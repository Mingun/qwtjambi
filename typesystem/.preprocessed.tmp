# 1 "builtins"
# 1 "qwt.h"






# 1 "/usr/share/qt4/include/QtCore/qabstractfileengine.h"












































# 1 "/usr/share/qt4/include/QtCore/qdir.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"












































# 1 "/usr/share/qt4/include/QtCore/qchar.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"















































# 48 "/usr/share/qt4/include/QtCore/qglobal.h"




# 52 "/usr/share/qt4/include/QtCore/qglobal.h"










# 1 "/usr/share/qt4/include/QtCore/qconfig.h"







# 8 "/usr/share/qt4/include/QtCore/qconfig.h"











# 19 "/usr/share/qt4/include/QtCore/qconfig.h"






# 25 "/usr/share/qt4/include/QtCore/qconfig.h"






































































































# 62 "/usr/share/qt4/include/QtCore/qglobal.h"







































































# 143 "/usr/share/qt4/include/QtCore/qglobal.h"


































































































































































































# 337 "/usr/share/qt4/include/QtCore/qglobal.h"



































# 372 "/usr/share/qt4/include/QtCore/qglobal.h"






























































































































































































































































































































































# 778 "/usr/share/qt4/include/QtCore/qglobal.h"






















































# 832 "/usr/share/qt4/include/QtCore/qglobal.h"









typedef signed char qint8; 
typedef unsigned char quint8; 
typedef short qint16; 
typedef unsigned short quint16; 
typedef int qint32; 
typedef unsigned int quint32; 








# 855 "/usr/share/qt4/include/QtCore/qglobal.h"
typedef long long qint64; 
typedef unsigned long long quint64; 


# 859 "/usr/share/qt4/include/QtCore/qglobal.h"
typedef qint64 qlonglong;
typedef quint64 qulonglong;














# 879 "/usr/share/qt4/include/QtCore/qglobal.h"






template <int> struct QIntegerForSize;
template <> struct QIntegerForSize<1> { typedef quint8 Unsigned; typedef qint8 Signed; };
template <> struct QIntegerForSize<2> { typedef quint16 Unsigned; typedef qint16 Signed; };
template <> struct QIntegerForSize<4> { typedef quint32 Unsigned; typedef qint32 Signed; };
template <> struct QIntegerForSize<8> { typedef quint64 Unsigned; typedef qint64 Signed; };
template <class T> struct QIntegerForSizeof: QIntegerForSize<sizeof(T)> { };
typedef QIntegerForSizeof<void*>::Unsigned quintptr;
typedef QIntegerForSizeof<void*>::Signed qptrdiff;






typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;






# 909 "/usr/share/qt4/include/QtCore/qglobal.h"





# 914 "/usr/share/qt4/include/QtCore/qglobal.h"














# 928 "/usr/share/qt4/include/QtCore/qglobal.h"









# 937 "/usr/share/qt4/include/QtCore/qglobal.h"












# 949 "/usr/share/qt4/include/QtCore/qglobal.h"













































































# 1026 "/usr/share/qt4/include/QtCore/qglobal.h"









































# 1067 "/usr/share/qt4/include/QtCore/qglobal.h"
typedef int QNoImplicitBoolCast;





# 1073 "/usr/share/qt4/include/QtCore/qglobal.h"






# 1079 "/usr/share/qt4/include/QtCore/qglobal.h"
typedef double qreal;


# 1082 "/usr/share/qt4/include/QtCore/qglobal.h"




template <typename T>
inline T qAbs(const T &t) { return t >= 0 ? t : -t; }

inline int qRound(qreal d)
{ return d >= 0.0 ? int(d + 0.5) : int(d - int(d-1) + 0.5) + int(d-1); }





# 1096 "/usr/share/qt4/include/QtCore/qglobal.h"
inline qint64 qRound64(qreal d)
{ return d >= 0.0 ? qint64(d + 0.5) : qint64(d - qreal(qint64(d-1)) + 0.5) + qint64(d-1); }


# 1100 "/usr/share/qt4/include/QtCore/qglobal.h"
template <typename T>
inline const T &qMin(const T &a, const T &b) { if (a < b) return a; return b; }
template <typename T>
inline const T &qMax(const T &a, const T &b) { if (a < b) return b; return a; }
template <typename T>
inline const T &qBound(const T &min, const T &val, const T &max)
{ return qMax(min, qMin(max, val)); }


























# 1133 "/usr/share/qt4/include/QtCore/qglobal.h"




class QDataStream;
























# 1 "/usr/share/qt4/include/QtCore/qfeatures.h"





























































































































































































































































































































# 318 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 323 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 328 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 333 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 338 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 343 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 348 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 353 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 358 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 363 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 368 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 373 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 378 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 383 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 388 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 393 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 398 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 403 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 408 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 413 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 418 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 423 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 428 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 433 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 438 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 443 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 448 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 453 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 458 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 463 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 468 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 473 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 478 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 483 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 488 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 493 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 498 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 503 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 508 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 513 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 518 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 523 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 528 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 533 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 538 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 543 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 548 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 553 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 558 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 563 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 568 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 573 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 578 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 583 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 588 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 593 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 598 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 603 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 608 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 613 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 618 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 623 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 628 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 633 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 638 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 643 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 648 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 653 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 658 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 663 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 668 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 673 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 678 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 683 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 688 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 693 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 698 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 703 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 708 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 713 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 718 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 723 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 728 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 733 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 738 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 743 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 748 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 753 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 758 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 763 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 768 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 773 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 778 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 783 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 788 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 793 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 798 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 803 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 808 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 813 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 818 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 823 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 828 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 833 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 838 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 843 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 848 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 853 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 858 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 863 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 868 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 873 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 1162 "/usr/share/qt4/include/QtCore/qglobal.h"






















# 1184 "/usr/share/qt4/include/QtCore/qglobal.h"





















































































































































# 1333 "/usr/share/qt4/include/QtCore/qglobal.h"
























# 1357 "/usr/share/qt4/include/QtCore/qglobal.h"















# 1372 "/usr/share/qt4/include/QtCore/qglobal.h"
inline void qt_noop() {}




























# 1401 "/usr/share/qt4/include/QtCore/qglobal.h"




class QString;
class  QSysInfo {
public:
enum Sizes {
WordSize = (sizeof(void *)<<3)
};









# 1420 "/usr/share/qt4/include/QtCore/qglobal.h"
enum Endian {
BigEndian,
LittleEndian




# 1427 "/usr/share/qt4/include/QtCore/qglobal.h"
, ByteOrder = BigEndian





# 1433 "/usr/share/qt4/include/QtCore/qglobal.h"
};

























































































# 1523 "/usr/share/qt4/include/QtCore/qglobal.h"
};

 const char *qVersion();
 bool qSharedBuild();




































# 1563 "/usr/share/qt4/include/QtCore/qglobal.h"












# 1575 "/usr/share/qt4/include/QtCore/qglobal.h"





















# 1596 "/usr/share/qt4/include/QtCore/qglobal.h"
 void qDebug(const char *, ...) 



# 1600 "/usr/share/qt4/include/QtCore/qglobal.h"
;

 void qWarning(const char *, ...) 



# 1606 "/usr/share/qt4/include/QtCore/qglobal.h"
;

class QString;
 QString qt_error_string(int errorCode = -1);
 void qCritical(const char *, ...) 



# 1614 "/usr/share/qt4/include/QtCore/qglobal.h"
;
 void qFatal(const char *, ...) 



# 1619 "/usr/share/qt4/include/QtCore/qglobal.h"
;




# 1624 "/usr/share/qt4/include/QtCore/qglobal.h"
 void qErrnoWarning(int code, const char *msg, ...);
 void qErrnoWarning(const char *msg, ...);





# 1631 "/usr/share/qt4/include/QtCore/qglobal.h"





class QDebug;
class QNoDebug;

# 1639 "/usr/share/qt4/include/QtCore/qglobal.h"
 inline QDebug qDebug();
 inline QDebug qWarning();
 inline QDebug qCritical();














# 1656 "/usr/share/qt4/include/QtCore/qglobal.h"
 void qt_assert(const char *assertion, const char *file, int line);













# 1670 "/usr/share/qt4/include/QtCore/qglobal.h"
 void qt_assert_x(const char *where, const char *what, const char *file, int line);









# 1680 "/usr/share/qt4/include/QtCore/qglobal.h"
 void qt_check_pointer(const char *, int);


# 1683 "/usr/share/qt4/include/QtCore/qglobal.h"
 void qBadAlloc();












# 1696 "/usr/share/qt4/include/QtCore/qglobal.h"
template <typename T>
inline T *q_check_ptr(T *p) { do { if (!(p)) qBadAlloc(); } while (0); return p; }














# 1712 "/usr/share/qt4/include/QtCore/qglobal.h"






# 1718 "/usr/share/qt4/include/QtCore/qglobal.h"








# 1726 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtMsgType { QtDebugMsg, QtWarningMsg, QtCriticalMsg, QtFatalMsg, QtSystemMsg = QtCriticalMsg };

 void qt_message_output(QtMsgType, const char *buf);

typedef void (*QtMsgHandler)(QtMsgType, const char *);
 QtMsgHandler qInstallMsgHandler(QtMsgHandler);

























# 1779 "/usr/share/qt4/include/QtCore/qglobal.h"

template <typename T> class QBasicAtomicPointer;


template <typename T>
class QGlobalStatic
{
public:
QBasicAtomicPointer<T> pointer;
bool destroyed;
};


template <typename T>
class QGlobalStaticDeleter
{
public:
QGlobalStatic<T> &globalStatic;
QGlobalStaticDeleter(QGlobalStatic<T> &_globalStatic)
: globalStatic(_globalStatic)
{ }

inline ~QGlobalStaticDeleter()
{
delete globalStatic.pointer;
globalStatic.pointer = 0;
globalStatic.destroyed = true;
}
};











# 1857 "/usr/share/qt4/include/QtCore/qglobal.h"
class QBool
{
bool b;

public:
inline explicit QBool(bool B) : b(B) {}
inline operator const void *() const
{ return b ? static_cast<const void *>(this) : static_cast<const void *>(0); }
};

inline bool operator==(QBool b1, bool b2) { return !b1 == !b2; }
inline bool operator==(bool b1, QBool b2) { return !b1 == !b2; }
inline bool operator==(QBool b1, QBool b2) { return !b1 == !b2; }
inline bool operator!=(QBool b1, bool b2) { return !b1 != !b2; }
inline bool operator!=(bool b1, QBool b2) { return !b1 != !b2; }
inline bool operator!=(QBool b1, QBool b2) { return !b1 != !b2; }

static inline bool qFuzzyCompare(double p1, double p2)
{
return (qAbs(p1 - p2) <= 0.000000000001 * qMin(qAbs(p1), qAbs(p2)));
}

static inline bool qFuzzyCompare(float p1, float p2)
{
return (qAbs(p1 - p2) <= 0.00001f * qMin(qAbs(p1), qAbs(p2)));
}




static inline bool qFuzzyIsNull(double d)
{
return qAbs(d) <= 0.000000000001;
}




static inline bool qFuzzyIsNull(float f)
{
return qAbs(f) <= 0.00001f;
}






static inline bool qIsNull(double d)
{
union U {
double d;
quint64 u;
};
U val;
val.d = d;
return val.u == quint64(0);
}






static inline bool qIsNull(float f)
{
union U {
float f;
quint32 u;
};
U val;
val.f = f;
return val.u == 0u;
}

















# 1952 "/usr/share/qt4/include/QtCore/qglobal.h"







# 1959 "/usr/share/qt4/include/QtCore/qglobal.h"




template <typename T> inline bool qIsDetached(T &) { return true; }

template <typename T>
class QTypeInfo
{
public:
enum {
isPointer = false,
isComplex = true,
isStatic = true,
isLarge = (sizeof(T)>sizeof(void*)),
isDummy = false
};
};

template <typename T>
class QTypeInfo<T*>
{
public:
enum {
isPointer = true,
isComplex = false,
isStatic = false,
isLarge = false,
isDummy = false
};
};























# 2013 "/usr/share/qt4/include/QtCore/qglobal.h"








enum { 
Q_COMPLEX_TYPE = 0,
Q_PRIMITIVE_TYPE = 0x1,
Q_STATIC_TYPE = 0,
Q_MOVABLE_TYPE = 0x2,
Q_DUMMY_TYPE = 0x4
};



# 2044 "/usr/share/qt4/include/QtCore/qglobal.h"
template <typename T>
inline void qSwap(T &value1, T &value2)
{
const T t = value1;
value1 = value2;
value2 = t;
}












# 2068 "/usr/share/qt4/include/QtCore/qglobal.h"



template <> class QTypeInfo<bool > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(bool)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "bool"; } };
template <> class QTypeInfo<char > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(char)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "char"; } };
template <> class QTypeInfo<signed char > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(signed char)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "signed char"; } };
template <> class QTypeInfo<uchar > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(uchar)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "uchar"; } };
template <> class QTypeInfo<short > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(short)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "short"; } };
template <> class QTypeInfo<ushort > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(ushort)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "ushort"; } };
template <> class QTypeInfo<int > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(int)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "int"; } };
template <> class QTypeInfo<uint > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(uint)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "uint"; } };
template <> class QTypeInfo<long > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(long)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "long"; } };
template <> class QTypeInfo<ulong > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(ulong)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "ulong"; } };
template <> class QTypeInfo<qint64 > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(qint64)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "qint64"; } };
template <> class QTypeInfo<quint64 > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(quint64)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "quint64"; } };
template <> class QTypeInfo<float > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(float)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "float"; } };
template <> class QTypeInfo<double > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(double)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "double"; } };

# 2086 "/usr/share/qt4/include/QtCore/qglobal.h"
template <> class QTypeInfo<long double > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(long double)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "long double"; } };


# 2089 "/usr/share/qt4/include/QtCore/qglobal.h"




 void *qMalloc(size_t size);
 void qFree(void *ptr);
 void *qRealloc(void *ptr, size_t size);
 void *qMallocAligned(size_t size, size_t alignment);
 void *qReallocAligned(void *ptr, size_t size, size_t oldsize, size_t alignment);
 void qFreeAligned(void *ptr);
 void *qMemCopy(void *dest, const void *src, size_t n);
 void *qMemSet(void *dest, int c, size_t n);








































# 2141 "/usr/share/qt4/include/QtCore/qglobal.h"
class  QFlag
{
int i;
public:
inline QFlag(int i);
inline operator int() const { return i; }
};

inline QFlag::QFlag(int ai) : i(ai) {}

class  QIncompatibleFlag
{
int i;
public:
inline explicit QIncompatibleFlag(int i);
inline operator int() const { return i; }
};

inline QIncompatibleFlag::QIncompatibleFlag(int ai) : i(ai) {}




# 2164 "/usr/share/qt4/include/QtCore/qglobal.h"
template<typename Enum>
class QFlags
{
typedef void **Zero;
int i;
public:
typedef Enum enum_type;
inline QFlags(const QFlags &f) : i(f.i) {}
inline QFlags(Enum f) : i(f) {}
inline QFlags(Zero = 0) : i(0) {}
inline QFlags(QFlag f) : i(f) {}

inline QFlags &operator=(const QFlags &f) { i = f.i; return *this; }
inline QFlags &operator&=(int mask) { i &= mask; return *this; }
inline QFlags &operator&=(uint mask) { i &= mask; return *this; }
inline QFlags &operator|=(QFlags f) { i |= f.i; return *this; }
inline QFlags &operator|=(Enum f) { i |= f; return *this; }
inline QFlags &operator^=(QFlags f) { i ^= f.i; return *this; }
inline QFlags &operator^=(Enum f) { i ^= f; return *this; }

inline operator int() const { return i; }

inline QFlags operator|(QFlags f) const { QFlags g; g.i = i | f.i; return g; }
inline QFlags operator|(Enum f) const { QFlags g; g.i = i | f; return g; }
inline QFlags operator^(QFlags f) const { QFlags g; g.i = i ^ f.i; return g; }
inline QFlags operator^(Enum f) const { QFlags g; g.i = i ^ f; return g; }
inline QFlags operator&(int mask) const { QFlags g; g.i = i & mask; return g; }
inline QFlags operator&(uint mask) const { QFlags g; g.i = i & mask; return g; }
inline QFlags operator&(Enum f) const { QFlags g; g.i = i & f; return g; }
inline QFlags operator~() const { QFlags g; g.i = ~i; return g; }

inline bool operator!() const { return !i; }

inline bool testFlag(Enum f) const { return (i & f) == f && (f != 0 || i == int(f) ); }
};


































# 2245 "/usr/share/qt4/include/QtCore/qglobal.h"
struct QForeachContainerBase {};

template <typename T>
class QForeachContainer : public QForeachContainerBase {
public:
inline QForeachContainer(const T& t): c(t), brk(0), i(c.begin()), e(c.end()){};
const T c;
mutable int brk;
mutable typename T::const_iterator i, e;
inline bool condition() const { return (!brk++ && i != e); }
};

template <typename T> inline T *qForeachPointer(const T &) { return 0; }

template <typename T> inline QForeachContainer<T> qForeachContainerNew(const T& t)
{ return QForeachContainer<T>(t); }

template <typename T>
inline const QForeachContainer<T> *qForeachContainer(const QForeachContainerBase *base, const T *)
{ return static_cast<const QForeachContainer<T> *>(base); }

































# 2320 "/usr/share/qt4/include/QtCore/qglobal.h"
template <typename T> static inline T *qGetPtrHelper(T *ptr) { return ptr; }
template <typename Wrapper> static inline typename Wrapper::pointer qGetPtrHelper(const Wrapper &p) { return p.data(); }



















# 2350 "/usr/share/qt4/include/QtCore/qglobal.h"



 QString qtTrId(const char *id, int n = -1);







# 2361 "/usr/share/qt4/include/QtCore/qglobal.h"













# 2374 "/usr/share/qt4/include/QtCore/qglobal.h"







# 2383 "/usr/share/qt4/include/QtCore/qglobal.h"
class QByteArray;
 QByteArray qgetenv(const char *varName);
 bool qputenv(const char *varName, const QByteArray& value);

inline int qIntCast(double f) { return int(f); }
inline int qIntCast(float f) { return int(f); }




 void qsrand(uint seed);
 int qrand();



























































# 2472 "/usr/share/qt4/include/QtCore/qglobal.h"



























# 2499 "/usr/share/qt4/include/QtCore/qglobal.h"










# 2540 "/usr/share/qt4/include/QtCore/qglobal.h"











# 2552 "/usr/share/qt4/include/QtCore/qglobal.h"




# 2556 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForCoreModule { LicensedCore = true };


# 2559 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForGuiModule { LicensedGui = true };


# 2562 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForNetworkModule { LicensedNetwork = true };


# 2565 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForOpenGLModule { LicensedOpenGL = true };


# 2568 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForOpenVGModule { LicensedOpenVG = true };


# 2571 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForSqlModule { LicensedSql = true };


# 2574 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForMultimediaModule { LicensedMultimedia = true };


# 2577 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForXmlModule { LicensedXml = true };


# 2580 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForXmlPatternsModule { LicensedXmlPatterns = true };


# 2583 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForHelpModule { LicensedHelp = true };


# 2586 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForScriptModule { LicensedScript = true };


# 2589 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForScriptToolsModule { LicensedScriptTools = true };


# 2592 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForQt3SupportLightModule { LicensedQt3SupportLight = true };


# 2595 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForQt3SupportModule { LicensedQt3Support = true };


# 2598 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForSvgModule { LicensedSvg = true };


# 2601 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForDeclarativeModule { LicensedDeclarative = true };


# 2604 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForActiveQtModule { LicensedActiveQt = true };


# 2607 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForTestModule { LicensedTest = true };


# 2610 "/usr/share/qt4/include/QtCore/qglobal.h"
enum QtValidLicenseForDBusModule { LicensedDBus = true };








# 2620 "/usr/share/qt4/include/QtCore/qglobal.h"






# 2626 "/usr/share/qt4/include/QtCore/qglobal.h"


















# 2644 "/usr/share/qt4/include/QtCore/qglobal.h"






# 45 "/usr/share/qt4/include/QtCore/qchar.h"


# 47 "/usr/share/qt4/include/QtCore/qchar.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QString;

struct QLatin1Char
{
public:
inline explicit QLatin1Char(char c) : ch(c) {}




# 63 "/usr/share/qt4/include/QtCore/qchar.h"
inline char toLatin1() const { return ch; }
inline ushort unicode() const { return ushort(uchar(ch)); }


# 67 "/usr/share/qt4/include/QtCore/qchar.h"
private:
char ch;
};


class  QChar {
public:
QChar();

# 76 "/usr/share/qt4/include/QtCore/qchar.h"
 QChar(char c);
 QChar(uchar c);

# 79 "/usr/share/qt4/include/QtCore/qchar.h"
QChar(QLatin1Char ch);
QChar(uchar c, uchar r);
inline QChar(ushort rc) : ucs(rc){}
QChar(short rc);
QChar(uint rc);
QChar(int rc);
enum SpecialCharacter {
Null = 0x0000,
Nbsp = 0x00a0,
ReplacementCharacter = 0xfffd,
ObjectReplacementCharacter = 0xfffc,
ByteOrderMark = 0xfeff,
ByteOrderSwapped = 0xfffe,







# 99 "/usr/share/qt4/include/QtCore/qchar.h"
ParagraphSeparator = 0x2029,
LineSeparator = 0x2028
};
QChar(SpecialCharacter sc);



enum Category
{
NoCategory,

Mark_NonSpacing, 
Mark_SpacingCombining, 
Mark_Enclosing, 

Number_DecimalDigit, 
Number_Letter, 
Number_Other, 

Separator_Space, 
Separator_Line, 
Separator_Paragraph, 

Other_Control, 
Other_Format, 
Other_Surrogate, 
Other_PrivateUse, 
Other_NotAssigned, 

Letter_Uppercase, 
Letter_Lowercase, 
Letter_Titlecase, 
Letter_Modifier, 
Letter_Other, 

Punctuation_Connector, 
Punctuation_Dash, 
Punctuation_Open, 
Punctuation_Close, 
Punctuation_InitialQuote, 
Punctuation_FinalQuote, 
Punctuation_Other, 

Symbol_Math, 
Symbol_Currency, 
Symbol_Modifier, 
Symbol_Other, 

Punctuation_Dask = Punctuation_Dash 
};

enum Direction
{
DirL, DirR, DirEN, DirES, DirET, DirAN, DirCS, DirB, DirS, DirWS, DirON,
DirLRE, DirLRO, DirAL, DirRLE, DirRLO, DirPDF, DirNSM, DirBN
};

enum Decomposition
{
NoDecomposition,
Canonical,
Font,
NoBreak,
Initial,
Medial,
Final,
Isolated,
Circle,
Super,
Sub,
Vertical,
Wide,
Narrow,
Small,
Square,
Compat,
Fraction




# 180 "/usr/share/qt4/include/QtCore/qchar.h"
};

enum Joining
{
OtherJoining, Dual, Right, Center
};

enum CombiningClass
{
Combining_BelowLeftAttached = 200,
Combining_BelowAttached = 202,
Combining_BelowRightAttached = 204,
Combining_LeftAttached = 208,
Combining_RightAttached = 210,
Combining_AboveLeftAttached = 212,
Combining_AboveAttached = 214,
Combining_AboveRightAttached = 216,

Combining_BelowLeft = 218,
Combining_Below = 220,
Combining_BelowRight = 222,
Combining_Left = 224,
Combining_Right = 226,
Combining_AboveLeft = 228,
Combining_Above = 230,
Combining_AboveRight = 232,

Combining_DoubleBelow = 233,
Combining_DoubleAbove = 234,
Combining_IotaSubscript = 240
};

enum UnicodeVersion {
Unicode_Unassigned,
Unicode_1_1,
Unicode_2_0,
Unicode_2_1_2,
Unicode_3_0,
Unicode_3_1,
Unicode_3_2,
Unicode_4_0,
Unicode_4_1,
Unicode_5_0
};


Category category() const;
Direction direction() const;
Joining joining() const;
bool hasMirrored() const;
unsigned char combiningClass() const;

QChar mirroredChar() const;
QString decomposition() const;
Decomposition decompositionTag() const;

int digitValue() const;
QChar toLower() const;
QChar toUpper() const;
QChar toTitleCase() const;
QChar toCaseFolded() const;

UnicodeVersion unicodeVersion() const;






# 249 "/usr/share/qt4/include/QtCore/qchar.h"
char toAscii() const;
inline char toLatin1() const;
inline ushort unicode() const { return ucs; }




# 256 "/usr/share/qt4/include/QtCore/qchar.h"
inline ushort &unicode() { return ucs; }


# 259 "/usr/share/qt4/include/QtCore/qchar.h"
static QChar fromAscii(char c);
static QChar fromLatin1(char c);

inline bool isNull() const { return ucs == 0; }
bool isPrint() const;
bool isPunct() const;
bool isSpace() const;
bool isMark() const;
bool isLetter() const;
bool isNumber() const;
bool isLetterOrNumber() const;
bool isDigit() const;
bool isSymbol() const;
inline bool isLower() const { return category() == Letter_Lowercase; }
inline bool isUpper() const { return category() == Letter_Uppercase; }
inline bool isTitleCase() const { return category() == Letter_Titlecase; }

inline bool isHighSurrogate() const {
return ((ucs & 0xfc00) == 0xd800);
}
inline bool isLowSurrogate() const {
return ((ucs & 0xfc00) == 0xdc00);
}

inline uchar cell() const { return uchar(ucs & 0xff); }
inline uchar row() const { return uchar((ucs>>8)&0xff); }
inline void setCell(uchar cell);
inline void setRow(uchar row);

static inline uint surrogateToUcs4(ushort high, ushort low) {
return (uint(high)<<10) + low - 0x35fdc00;
}
static inline uint surrogateToUcs4(QChar high, QChar low) {
return (uint(high.ucs)<<10) + low.ucs - 0x35fdc00;
}
static inline ushort highSurrogate(uint ucs4) {
return ushort((ucs4>>10) + 0xd7c0);
}
static inline ushort lowSurrogate(uint ucs4) {
return ushort(ucs4%0x400 + 0xdc00);
}

static Category  category(uint ucs4);
static Category  category(ushort ucs2);
static Direction  direction(uint ucs4);
static Direction  direction(ushort ucs2);
static Joining  joining(uint ucs4);
static Joining  joining(ushort ucs2);
static unsigned char  combiningClass(uint ucs4);
static unsigned char  combiningClass(ushort ucs2);

static uint  mirroredChar(uint ucs4);
static ushort  mirroredChar(ushort ucs2);
static Decomposition  decompositionTag(uint ucs4);

static int  digitValue(uint ucs4);
static int  digitValue(ushort ucs2);
static uint  toLower(uint ucs4);
static ushort  toLower(ushort ucs2);
static uint  toUpper(uint ucs4);
static ushort  toUpper(ushort ucs2);
static uint  toTitleCase(uint ucs4);
static ushort  toTitleCase(ushort ucs2);
static uint  toCaseFolded(uint ucs4);
static ushort  toCaseFolded(ushort ucs2);

static UnicodeVersion  unicodeVersion(uint ucs4);
static UnicodeVersion  unicodeVersion(ushort ucs2);

static QString  decomposition(uint ucs4);

















# 346 "/usr/share/qt4/include/QtCore/qchar.h"
private:




# 351 "/usr/share/qt4/include/QtCore/qchar.h"
ushort ucs;
}



# 356 "/usr/share/qt4/include/QtCore/qchar.h"
;

template <> class QTypeInfo<QChar > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QChar)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QChar"; } };

inline QChar::QChar() : ucs(0) {}




# 365 "/usr/share/qt4/include/QtCore/qchar.h"
inline char QChar::toLatin1() const { return ucs > 0xff ? '\0' : char(ucs); }

# 367 "/usr/share/qt4/include/QtCore/qchar.h"
inline QChar QChar::fromLatin1(char c) { return QChar(ushort(uchar(c))); }

inline QChar::QChar(uchar c, uchar r) : ucs(ushort((r << 8) | c)){}
inline QChar::QChar(short rc) : ucs(ushort(rc)){}
inline QChar::QChar(uint rc) : ucs(ushort(rc & 0xffff)){}
inline QChar::QChar(int rc) : ucs(ushort(rc & 0xffff)){}
inline QChar::QChar(SpecialCharacter s) : ucs(ushort(s)) {}
inline QChar::QChar(QLatin1Char ch) : ucs(ch.unicode()) {}

inline void QChar::setCell(uchar acell)
{ ucs = ushort((ucs & 0xff00) + acell); }
inline void QChar::setRow(uchar arow)
{ ucs = ushort((ushort(arow)<<8) + (ucs&0xff)); }

inline bool operator==(QChar c1, QChar c2) { return c1.unicode() == c2.unicode(); }
inline bool operator!=(QChar c1, QChar c2) { return c1.unicode() != c2.unicode(); }
inline bool operator<=(QChar c1, QChar c2) { return c1.unicode() <= c2.unicode(); }
inline bool operator>=(QChar c1, QChar c2) { return c1.unicode() >= c2.unicode(); }
inline bool operator<(QChar c1, QChar c2) { return c1.unicode() < c2.unicode(); }
inline bool operator>(QChar c1, QChar c2) { return c1.unicode() > c2.unicode(); }


# 389 "/usr/share/qt4/include/QtCore/qchar.h"
 QDataStream &operator<<(QDataStream &, const QChar &);
 QDataStream &operator>>(QDataStream &, QChar &);


# 393 "/usr/share/qt4/include/QtCore/qchar.h"





# 45 "/usr/share/qt4/include/QtCore/qstring.h"

# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"












































# 1 "/usr/share/qt4/include/QtCore/qatomic.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qatomic.h"

# 1 "/usr/share/qt4/include/QtCore/qbasicatomic.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qbasicatomic.h"


# 47 "/usr/share/qt4/include/QtCore/qbasicatomic.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class  QBasicAtomicInt
{
public:








# 64 "/usr/share/qt4/include/QtCore/qbasicatomic.h"
volatile int _q_value;


# 67 "/usr/share/qt4/include/QtCore/qbasicatomic.h"

inline bool operator==(int value) const
{
return _q_value == value;
}

inline bool operator!=(int value) const
{
return _q_value != value;
}

inline bool operator!() const
{
return _q_value == 0;
}

inline operator int() const
{
return _q_value;
}

inline QBasicAtomicInt &operator=(int value)
{



# 93 "/usr/share/qt4/include/QtCore/qbasicatomic.h"
_q_value = value;
return *this;
}



static bool isReferenceCountingNative();
static bool isReferenceCountingWaitFree();

bool ref();
bool deref();

static bool isTestAndSetNative();
static bool isTestAndSetWaitFree();

bool testAndSetRelaxed(int expectedValue, int newValue);
bool testAndSetAcquire(int expectedValue, int newValue);
bool testAndSetRelease(int expectedValue, int newValue);
bool testAndSetOrdered(int expectedValue, int newValue);

static bool isFetchAndStoreNative();
static bool isFetchAndStoreWaitFree();

int fetchAndStoreRelaxed(int newValue);
int fetchAndStoreAcquire(int newValue);
int fetchAndStoreRelease(int newValue);
int fetchAndStoreOrdered(int newValue);

static bool isFetchAndAddNative();
static bool isFetchAndAddWaitFree();

int fetchAndAddRelaxed(int valueToAdd);
int fetchAndAddAcquire(int valueToAdd);
int fetchAndAddRelease(int valueToAdd);
int fetchAndAddOrdered(int valueToAdd);
};

template <typename T>
class QBasicAtomicPointer
{
public:














# 148 "/usr/share/qt4/include/QtCore/qbasicatomic.h"
T * volatile _q_value;


# 151 "/usr/share/qt4/include/QtCore/qbasicatomic.h"

inline bool operator==(T *value) const
{
return _q_value == value;
}

inline bool operator!=(T *value) const
{
return !operator==(value);
}

inline bool operator!() const
{
return operator==(0);
}

inline operator T *() const
{
return _q_value;
}

inline T *operator->() const
{
return _q_value;
}

inline QBasicAtomicPointer<T> &operator=(T *value)
{



# 182 "/usr/share/qt4/include/QtCore/qbasicatomic.h"
_q_value = value;
return *this;
}



static bool isTestAndSetNative();
static bool isTestAndSetWaitFree();

bool testAndSetRelaxed(T *expectedValue, T *newValue);
bool testAndSetAcquire(T *expectedValue, T *newValue);
bool testAndSetRelease(T *expectedValue, T *newValue);
bool testAndSetOrdered(T *expectedValue, T *newValue);

static bool isFetchAndStoreNative();
static bool isFetchAndStoreWaitFree();

T *fetchAndStoreRelaxed(T *newValue);
T *fetchAndStoreAcquire(T *newValue);
T *fetchAndStoreRelease(T *newValue);
T *fetchAndStoreOrdered(T *newValue);

static bool isFetchAndAddNative();
static bool isFetchAndAddWaitFree();

T *fetchAndAddRelaxed(qptrdiff valueToAdd);
T *fetchAndAddAcquire(qptrdiff valueToAdd);
T *fetchAndAddRelease(qptrdiff valueToAdd);
T *fetchAndAddOrdered(qptrdiff valueToAdd);
};









# 221 "/usr/share/qt4/include/QtCore/qbasicatomic.h"






# 1 "/usr/share/qt4/include/QtCore/qatomic_arch.h"












































# 45 "/usr/share/qt4/include/QtCore/qatomic_arch.h"


# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qatomic_arch.h"





































# 1 "/usr/share/qt4/include/QtCore/qatomic_x86_64.h"












































# 45 "/usr/share/qt4/include/QtCore/qatomic_x86_64.h"







# 52 "/usr/share/qt4/include/QtCore/qatomic_x86_64.h"
inline bool QBasicAtomicInt::isReferenceCountingNative()
{ return true; }
inline bool QBasicAtomicInt::isReferenceCountingWaitFree()
{ return true; }




# 60 "/usr/share/qt4/include/QtCore/qatomic_x86_64.h"
inline bool QBasicAtomicInt::isTestAndSetNative()
{ return true; }
inline bool QBasicAtomicInt::isTestAndSetWaitFree()
{ return true; }




# 68 "/usr/share/qt4/include/QtCore/qatomic_x86_64.h"
inline bool QBasicAtomicInt::isFetchAndStoreNative()
{ return true; }
inline bool QBasicAtomicInt::isFetchAndStoreWaitFree()
{ return true; }




# 76 "/usr/share/qt4/include/QtCore/qatomic_x86_64.h"
inline bool QBasicAtomicInt::isFetchAndAddNative()
{ return true; }
inline bool QBasicAtomicInt::isFetchAndAddWaitFree()
{ return true; }




# 84 "/usr/share/qt4/include/QtCore/qatomic_x86_64.h"
template <typename T>
inline bool QBasicAtomicPointer<T>::isTestAndSetNative()
{ return true; }
template <typename T>
inline bool QBasicAtomicPointer<T>::isTestAndSetWaitFree()
{ return true; }




# 94 "/usr/share/qt4/include/QtCore/qatomic_x86_64.h"
template <typename T>
inline bool QBasicAtomicPointer<T>::isFetchAndStoreNative()
{ return true; }
template <typename T>
inline bool QBasicAtomicPointer<T>::isFetchAndStoreWaitFree()
{ return true; }




# 104 "/usr/share/qt4/include/QtCore/qatomic_x86_64.h"
template <typename T>
inline bool QBasicAtomicPointer<T>::isFetchAndAddNative()
{ return true; }
template <typename T>
inline bool QBasicAtomicPointer<T>::isFetchAndAddWaitFree()
{ return true; }






























































































# 204 "/usr/share/qt4/include/QtCore/qatomic_x86_64.h"
extern "C" {
 int q_atomic_test_and_set_int(volatile int *ptr, int expected, int newval);
 int q_atomic_test_and_set_ptr(volatile void *ptr, void *expected, void *newval);
 int q_atomic_increment(volatile int *ptr);
 int q_atomic_decrement(volatile int *ptr);
 int q_atomic_set_int(volatile int *ptr, int newval);
 void *q_atomic_set_ptr(volatile void *ptr, void *newval);
 int q_atomic_fetch_and_add_int(volatile int *ptr, int value);
 void *q_atomic_fetch_and_add_ptr(volatile void *ptr, qptrdiff value);
} 

inline bool QBasicAtomicInt::ref()
{
return q_atomic_increment(&_q_value) != 0;
}

inline bool QBasicAtomicInt::deref()
{
return q_atomic_decrement(&_q_value) != 0;
}

inline bool QBasicAtomicInt::testAndSetOrdered(int expected, int newval)
{
return q_atomic_test_and_set_int(&_q_value, expected, newval) != 0;
}

inline int QBasicAtomicInt::fetchAndStoreOrdered(int newval)
{
return q_atomic_set_int(&_q_value, newval);
}

inline int QBasicAtomicInt::fetchAndAddOrdered(int aValue)
{
return q_atomic_fetch_and_add_int(&_q_value, aValue);
}

template <typename T>
inline bool QBasicAtomicPointer<T>::testAndSetOrdered(T *expectedValue, T *newValue)
{
return q_atomic_test_and_set_ptr(&_q_value, expectedValue, newValue);
}

template <typename T>
inline T *QBasicAtomicPointer<T>::fetchAndStoreOrdered(T *newValue)
{
return reinterpret_cast<T *>(q_atomic_set_ptr(&_q_value, newValue));
}

template <typename T>
inline T *QBasicAtomicPointer<T>::fetchAndAddOrdered(qptrdiff valueToAdd)
{
return reinterpret_cast<T *>(q_atomic_fetch_and_add_ptr(&_q_value, valueToAdd * sizeof(T)));
}



# 260 "/usr/share/qt4/include/QtCore/qatomic_x86_64.h"
inline bool QBasicAtomicInt::testAndSetRelaxed(int expectedValue, int newValue)
{
return testAndSetOrdered(expectedValue, newValue);
}

inline bool QBasicAtomicInt::testAndSetAcquire(int expectedValue, int newValue)
{
return testAndSetOrdered(expectedValue, newValue);
}

inline bool QBasicAtomicInt::testAndSetRelease(int expectedValue, int newValue)
{
return testAndSetOrdered(expectedValue, newValue);
}

inline int QBasicAtomicInt::fetchAndStoreRelaxed(int newValue)
{
return fetchAndStoreOrdered(newValue);
}

inline int QBasicAtomicInt::fetchAndStoreAcquire(int newValue)
{
return fetchAndStoreOrdered(newValue);
}

inline int QBasicAtomicInt::fetchAndStoreRelease(int newValue)
{
return fetchAndStoreOrdered(newValue);
}

inline int QBasicAtomicInt::fetchAndAddRelaxed(int valueToAdd)
{
return fetchAndAddOrdered(valueToAdd);
}

inline int QBasicAtomicInt::fetchAndAddAcquire(int valueToAdd)
{
return fetchAndAddOrdered(valueToAdd);
}

inline int QBasicAtomicInt::fetchAndAddRelease(int valueToAdd)
{
return fetchAndAddOrdered(valueToAdd);
}

template <typename T>
inline bool QBasicAtomicPointer<T>::testAndSetRelaxed(T *expectedValue, T *newValue)
{
return testAndSetOrdered(expectedValue, newValue);
}

template <typename T>
inline bool QBasicAtomicPointer<T>::testAndSetAcquire(T *expectedValue, T *newValue)
{
return testAndSetOrdered(expectedValue, newValue);
}

template <typename T>
inline bool QBasicAtomicPointer<T>::testAndSetRelease(T *expectedValue, T *newValue)
{
return testAndSetOrdered(expectedValue, newValue);
}

template <typename T>
inline T *QBasicAtomicPointer<T>::fetchAndStoreRelaxed(T *newValue)
{
return fetchAndStoreOrdered(newValue);
}

template <typename T>
inline T *QBasicAtomicPointer<T>::fetchAndStoreAcquire(T *newValue)
{
return fetchAndStoreOrdered(newValue);
}

template <typename T>
inline T *QBasicAtomicPointer<T>::fetchAndStoreRelease(T *newValue)
{
return fetchAndStoreOrdered(newValue);
}

template <typename T>
inline T *QBasicAtomicPointer<T>::fetchAndAddRelaxed(qptrdiff valueToAdd)
{
return fetchAndAddOrdered(valueToAdd);
}

template <typename T>
inline T *QBasicAtomicPointer<T>::fetchAndAddAcquire(qptrdiff valueToAdd)
{
return fetchAndAddOrdered(valueToAdd);
}

template <typename T>
inline T *QBasicAtomicPointer<T>::fetchAndAddRelease(qptrdiff valueToAdd)
{
return fetchAndAddOrdered(valueToAdd);
}






# 84 "/usr/share/qt4/include/QtCore/qatomic_arch.h"











# 95 "/usr/share/qt4/include/QtCore/qatomic_arch.h"



# 227 "/usr/share/qt4/include/QtCore/qbasicatomic.h"




# 46 "/usr/share/qt4/include/QtCore/qatomic.h"


# 48 "/usr/share/qt4/include/QtCore/qatomic.h"




typedef QtValidLicenseForCoreModule QtCoreModule;


class  QAtomicInt : public QBasicAtomicInt
{
public:
inline QAtomicInt(int value = 0)
{



# 63 "/usr/share/qt4/include/QtCore/qatomic.h"
_q_value = value;
}
inline QAtomicInt(const QAtomicInt &other)
{



# 70 "/usr/share/qt4/include/QtCore/qatomic.h"
_q_value = other._q_value;
}

inline QAtomicInt &operator=(int value)
{
(void) QBasicAtomicInt::operator=(value);
return *this;
}

inline QAtomicInt &operator=(const QAtomicInt &other)
{
(void) QBasicAtomicInt::operator=(other);
return *this;
}





































# 121 "/usr/share/qt4/include/QtCore/qatomic.h"
};


template <typename T>
class QAtomicPointer : public QBasicAtomicPointer<T>
{
public:
inline QAtomicPointer(T *value = 0)
{



# 133 "/usr/share/qt4/include/QtCore/qatomic.h"
QBasicAtomicPointer<T>::_q_value = value;
}
inline QAtomicPointer(const QAtomicPointer<T> &other)
{



# 140 "/usr/share/qt4/include/QtCore/qatomic.h"
QBasicAtomicPointer<T>::_q_value = other._q_value;
}

inline QAtomicPointer<T> &operator=(T *value)
{
(void) QBasicAtomicPointer<T>::operator=(value);
return *this;
}

inline QAtomicPointer<T> &operator=(const QAtomicPointer<T> &other)
{
(void) QBasicAtomicPointer<T>::operator=(other);
return *this;
}
































# 186 "/usr/share/qt4/include/QtCore/qatomic.h"
};







template <typename T>
inline void qAtomicAssign(T *&d, T *x)
{
if (d == x)
return;
x->ref.ref();
if (!d->ref.deref())
delete d;
d = x;
}









template <typename T>
inline void qAtomicDetach(T *&d)
{
if (d->ref == 1)
return;
T *x = d;
d = new T(*d);
if (!x->ref.deref())
delete x;
}





# 45 "/usr/share/qt4/include/QtCore/qbytearray.h"

# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qnamespace.h"


# 47 "/usr/share/qt4/include/QtCore/qnamespace.h"




typedef QtValidLicenseForCoreModule QtCoreModule;


# 54 "/usr/share/qt4/include/QtCore/qnamespace.h"
namespace



# 58 "/usr/share/qt4/include/QtCore/qnamespace.h"
Qt {






# 65 "/usr/share/qt4/include/QtCore/qnamespace.h"

Q_ENUMS(ScrollBarPolicy FocusPolicy ContextMenuPolicy)
Q_ENUMS(ArrowType ToolButtonStyle PenStyle PenCapStyle PenJoinStyle BrushStyle)
Q_ENUMS(FillRule MaskMode BGMode ClipOperation SizeMode)
Q_ENUMS(BackgroundMode) 
Q_ENUMS(Axis Corner LayoutDirection SizeHint Orientation DropAction)


Q_ENUMS(DockWidgetArea ToolBarArea)
Q_ENUMS(TextFormat)
Q_ENUMS(TextElideMode)
Q_ENUMS(DateFormat TimeSpec DayOfWeek)
Q_ENUMS(CursorShape GlobalColor)
Q_ENUMS(AspectRatioMode TransformationMode)

Q_ENUMS(Key ShortcutContext)
Q_ENUMS(TextInteractionFlag)

Q_ENUMS(ItemSelectionMode)

Q_ENUMS(CheckState)
Q_ENUMS(SortOrder CaseSensitivity)


Q_ENUMS(WindowType WindowState WindowModality WidgetAttribute ApplicationAttribute)
Q_ENUMS(InputMethodHint)

Q_ENUMS(ConnectionType)






# 99 "/usr/share/qt4/include/QtCore/qnamespace.h"
enum GlobalColor {
color0,
color1,
black,
white,
darkGray,
gray,
lightGray,
red,
green,
blue,
cyan,
magenta,
yellow,
darkRed,
darkGreen,
darkBlue,
darkCyan,
darkMagenta,
darkYellow,
transparent
};

enum KeyboardModifier {
NoModifier = 0x00000000,
ShiftModifier = 0x02000000,
ControlModifier = 0x04000000,
AltModifier = 0x08000000,
MetaModifier = 0x10000000,
KeypadModifier = 0x20000000,
GroupSwitchModifier = 0x40000000,

KeyboardModifierMask = 0xfe000000
};
typedef QFlags<KeyboardModifier> KeyboardModifiers;


enum Modifier {
META = Qt::MetaModifier,
SHIFT = Qt::ShiftModifier,
CTRL = Qt::ControlModifier,
ALT = Qt::AltModifier,
MODIFIER_MASK = KeyboardModifierMask,
UNICODE_ACCEL = 0x00000000
};

enum MouseButton {
NoButton = 0x00000000,
LeftButton = 0x00000001,
RightButton = 0x00000002,
MidButton = 0x00000004,
XButton1 = 0x00000008,
XButton2 = 0x00000010,
MouseButtonMask = 0x000000ff
};
typedef QFlags<MouseButton> MouseButtons;













# 168 "/usr/share/qt4/include/QtCore/qnamespace.h"
enum Orientation {
Horizontal = 0x1,
Vertical = 0x2
};

typedef QFlags<Orientation> Orientations;

enum FocusPolicy {
NoFocus = 0,
TabFocus = 0x1,
ClickFocus = 0x2,
StrongFocus = TabFocus | ClickFocus | 0x8,
WheelFocus = StrongFocus | 0x4
};

enum SortOrder {
AscendingOrder,
DescendingOrder




# 190 "/usr/share/qt4/include/QtCore/qnamespace.h"
};

enum TileRule {
StretchTile,
RepeatTile,
RoundTile
};





enum AlignmentFlag {
AlignLeft = 0x0001,
AlignLeading = AlignLeft,
AlignRight = 0x0002,
AlignTrailing = AlignRight,
AlignHCenter = 0x0004,
AlignJustify = 0x0008,
AlignAbsolute = 0x0010,
AlignHorizontal_Mask = AlignLeft | AlignRight | AlignHCenter | AlignJustify | AlignAbsolute,

AlignTop = 0x0020,
AlignBottom = 0x0040,
AlignVCenter = 0x0080,
AlignVertical_Mask = AlignTop | AlignBottom | AlignVCenter,

AlignCenter = AlignVCenter | AlignHCenter



# 221 "/usr/share/qt4/include/QtCore/qnamespace.h"
};

typedef QFlags<AlignmentFlag> Alignment;

enum TextFlag {
TextSingleLine = 0x0100,
TextDontClip = 0x0200,
TextExpandTabs = 0x0400,
TextShowMnemonic = 0x0800,
TextWordWrap = 0x1000,
TextWrapAnywhere = 0x2000,
TextDontPrint = 0x4000,
TextIncludeTrailingSpaces = 0x08000000,
TextHideMnemonic = 0x8000,
TextJustificationForced = 0x10000,
TextForceLeftToRight = 0x20000,
TextForceRightToLeft = 0x40000,
TextLongestVariant = 0x80000












# 251 "/usr/share/qt4/include/QtCore/qnamespace.h"
};




# 256 "/usr/share/qt4/include/QtCore/qnamespace.h"
enum TextElideMode {
ElideLeft,
ElideRight,
ElideMiddle,
ElideNone
};

enum WindowType {
Widget = 0x00000000,
Window = 0x00000001,
Dialog = 0x00000002 | Window,
Sheet = 0x00000004 | Window,
Drawer = 0x00000006 | Window,
Popup = 0x00000008 | Window,
Tool = 0x0000000a | Window,
ToolTip = 0x0000000c | Window,
SplashScreen = 0x0000000e | Window,
Desktop = 0x00000010 | Window,
SubWindow = 0x00000012,

WindowType_Mask = 0x000000ff,
MSWindowsFixedSizeDialogHint = 0x00000100,
MSWindowsOwnDC = 0x00000200,
X11BypassWindowManagerHint = 0x00000400,
FramelessWindowHint = 0x00000800,
WindowTitleHint = 0x00001000,
WindowSystemMenuHint = 0x00002000,
WindowMinimizeButtonHint = 0x00004000,
WindowMaximizeButtonHint = 0x00008000,
WindowMinMaxButtonsHint = WindowMinimizeButtonHint | WindowMaximizeButtonHint,
WindowContextHelpButtonHint = 0x00010000,
WindowShadeButtonHint = 0x00020000,
WindowStaysOnTopHint = 0x00040000,







CustomizeWindowHint = 0x02000000,
WindowStaysOnBottomHint = 0x04000000,
WindowCloseButtonHint = 0x08000000,
MacWindowToolBarButtonHint = 0x10000000,
BypassGraphicsProxyWidget = 0x20000000,
WindowOkButtonHint = 0x00080000,
WindowCancelButtonHint = 0x00100000


















































# 353 "/usr/share/qt4/include/QtCore/qnamespace.h"
};

typedef QFlags<WindowType> WindowFlags;

enum WindowState {
WindowNoState = 0x00000000,
WindowMinimized = 0x00000001,
WindowMaximized = 0x00000002,
WindowFullScreen = 0x00000004,
WindowActive = 0x00000008
};

typedef QFlags<WindowState> WindowStates;

enum WidgetAttribute {
WA_Disabled = 0,
WA_UnderMouse = 1,
WA_MouseTracking = 2,
WA_ContentsPropagated = 3, 
WA_OpaquePaintEvent = 4,
WA_NoBackground = WA_OpaquePaintEvent, 
WA_StaticContents = 5,
WA_LaidOut = 7,
WA_PaintOnScreen = 8,
WA_NoSystemBackground = 9,
WA_UpdatesDisabled = 10,
WA_Mapped = 11,
WA_MacNoClickThrough = 12, 
WA_PaintOutsidePaintEvent = 13,
WA_InputMethodEnabled = 14,
WA_WState_Visible = 15,
WA_WState_Hidden = 16,

WA_ForceDisabled = 32,
WA_KeyCompression = 33,
WA_PendingMoveEvent = 34,
WA_PendingResizeEvent = 35,
WA_SetPalette = 36,
WA_SetFont = 37,
WA_SetCursor = 38,
WA_NoChildEventsFromChildren = 39,
WA_WindowModified = 41,
WA_Resized = 42,
WA_Moved = 43,
WA_PendingUpdate = 44,
WA_InvalidSize = 45,
WA_MacBrushedMetal = 46, 
WA_MacMetalStyle = WA_MacBrushedMetal, 
WA_CustomWhatsThis = 47,
WA_LayoutOnEntireRect = 48,
WA_OutsideWSRange = 49,
WA_GrabbedShortcut = 50,
WA_TransparentForMouseEvents = 51,
WA_PaintUnclipped = 52,
WA_SetWindowIcon = 53,
WA_NoMouseReplay = 54,
WA_DeleteOnClose = 55,
WA_RightToLeft = 56,
WA_SetLayoutDirection = 57,
WA_NoChildEventsForParent = 58,
WA_ForceUpdatesDisabled = 59,

WA_WState_Created = 60,
WA_WState_CompressKeys = 61,
WA_WState_InPaintEvent = 62,
WA_WState_Reparented = 63,
WA_WState_ConfigPending = 64,
WA_WState_Polished = 66,
WA_WState_DND = 67, 
WA_WState_OwnSizePolicy = 68,
WA_WState_ExplicitShowHide = 69,

WA_ShowModal = 70, 
WA_MouseNoMask = 71,
WA_GroupLeader = 72, 
WA_NoMousePropagation = 73, 
WA_Hover = 74,
WA_InputMethodTransparent = 75, 
WA_QuitOnClose = 76,

WA_KeyboardFocusChange = 77,

WA_AcceptDrops = 78,
WA_DropSiteRegistered = 79, 
WA_ForceAcceptDrops = WA_DropSiteRegistered, 

WA_WindowPropagation = 80,

WA_NoX11EventCompression = 81,
WA_TintedBackground = 82,
WA_X11OpenGLOverlay = 83,
WA_AlwaysShowToolTips = 84,
WA_MacOpaqueSizeGrip = 85,
WA_SetStyle = 86,

WA_SetLocale = 87,
WA_MacShowFocusRect = 88,

WA_MacNormalSize = 89, 
WA_MacSmallSize = 90, 
WA_MacMiniSize = 91, 

WA_LayoutUsesWidgetRect = 92,
WA_StyledBackground = 93, 
WA_MSWindowsUseDirect3D = 94, 
WA_CanHostQMdiSubWindowTitleBar = 95, 

WA_MacAlwaysShowToolWindow = 96, 

WA_StyleSheet = 97, 

WA_ShowWithoutActivating = 98,

WA_X11BypassTransientForHint = 99,

WA_NativeWindow = 100,
WA_DontCreateNativeAncestors = 101,

WA_MacVariableSize = 102, 

WA_DontShowOnScreen = 103,


WA_X11NetWmWindowTypeDesktop = 104,
WA_X11NetWmWindowTypeDock = 105,
WA_X11NetWmWindowTypeToolBar = 106,
WA_X11NetWmWindowTypeMenu = 107,
WA_X11NetWmWindowTypeUtility = 108,
WA_X11NetWmWindowTypeSplash = 109,
WA_X11NetWmWindowTypeDialog = 110,
WA_X11NetWmWindowTypeDropDownMenu = 111,
WA_X11NetWmWindowTypePopupMenu = 112,
WA_X11NetWmWindowTypeToolTip = 113,
WA_X11NetWmWindowTypeNotification = 114,
WA_X11NetWmWindowTypeCombo = 115,
WA_X11NetWmWindowTypeDND = 116,

WA_MacFrameworkScaled = 117,

WA_SetWindowModality = 118,
WA_WState_WindowOpacitySet = 119, 
WA_TranslucentBackground = 120,

WA_AcceptTouchEvents = 121,
WA_WState_AcceptedTouchBeginEvent = 122,
WA_TouchPadAcceptSingleTouchEvents = 123,

WA_MergeSoftkeys = 124,
WA_MergeSoftkeysRecursively = 125,


WA_AttributeCount
};

enum ApplicationAttribute
{
AA_ImmediateWidgetCreation = 0,
AA_MSWindowsUseDirect3DByDefault = 1, 
AA_DontShowIconsInMenus = 2,
AA_NativeWindows = 3,
AA_DontCreateNativeWidgetSiblings = 4,
AA_MacPluginApplication = 5,
AA_DontUseNativeMenuBar = 6,
AA_MacDontSwapCtrlAndMeta = 7,
AA_S60DontConstructApplicationPanes = 8,


AA_AttributeCount
};





enum ImageConversionFlag {
ColorMode_Mask = 0x00000003,
AutoColor = 0x00000000,
ColorOnly = 0x00000003,
MonoOnly = 0x00000002,


AlphaDither_Mask = 0x0000000c,
ThresholdAlphaDither = 0x00000000,
OrderedAlphaDither = 0x00000004,
DiffuseAlphaDither = 0x00000008,
NoAlpha = 0x0000000c, 

Dither_Mask = 0x00000030,
DiffuseDither = 0x00000000,
OrderedDither = 0x00000010,
ThresholdDither = 0x00000020,


DitherMode_Mask = 0x000000c0,
AutoDither = 0x00000000,
PreferDither = 0x00000040,
AvoidDither = 0x00000080,

NoOpaqueDetection = 0x00000100
};
typedef QFlags<ImageConversionFlag> ImageConversionFlags;

enum BGMode {
TransparentMode,
OpaqueMode
};




















# 579 "/usr/share/qt4/include/QtCore/qnamespace.h"
enum Key {
Key_Escape = 0x01000000, 
Key_Tab = 0x01000001,
Key_Backtab = 0x01000002,



# 586 "/usr/share/qt4/include/QtCore/qnamespace.h"
Key_Backspace = 0x01000003,



# 590 "/usr/share/qt4/include/QtCore/qnamespace.h"
Key_Return = 0x01000004,
Key_Enter = 0x01000005,
Key_Insert = 0x01000006,
Key_Delete = 0x01000007,
Key_Pause = 0x01000008,
Key_Print = 0x01000009,
Key_SysReq = 0x0100000a,
Key_Clear = 0x0100000b,
Key_Home = 0x01000010, 
Key_End = 0x01000011,
Key_Left = 0x01000012,
Key_Up = 0x01000013,
Key_Right = 0x01000014,
Key_Down = 0x01000015,
Key_PageUp = 0x01000016,



# 608 "/usr/share/qt4/include/QtCore/qnamespace.h"
Key_PageDown = 0x01000017,



# 612 "/usr/share/qt4/include/QtCore/qnamespace.h"
Key_Shift = 0x01000020, 
Key_Control = 0x01000021,
Key_Meta = 0x01000022,
Key_Alt = 0x01000023,
Key_CapsLock = 0x01000024,
Key_NumLock = 0x01000025,
Key_ScrollLock = 0x01000026,
Key_F1 = 0x01000030, 
Key_F2 = 0x01000031,
Key_F3 = 0x01000032,
Key_F4 = 0x01000033,
Key_F5 = 0x01000034,
Key_F6 = 0x01000035,
Key_F7 = 0x01000036,
Key_F8 = 0x01000037,
Key_F9 = 0x01000038,
Key_F10 = 0x01000039,
Key_F11 = 0x0100003a,
Key_F12 = 0x0100003b,
Key_F13 = 0x0100003c,
Key_F14 = 0x0100003d,
Key_F15 = 0x0100003e,
Key_F16 = 0x0100003f,
Key_F17 = 0x01000040,
Key_F18 = 0x01000041,
Key_F19 = 0x01000042,
Key_F20 = 0x01000043,
Key_F21 = 0x01000044,
Key_F22 = 0x01000045,
Key_F23 = 0x01000046,
Key_F24 = 0x01000047,
Key_F25 = 0x01000048, 
Key_F26 = 0x01000049,
Key_F27 = 0x0100004a,
Key_F28 = 0x0100004b,
Key_F29 = 0x0100004c,
Key_F30 = 0x0100004d,
Key_F31 = 0x0100004e,
Key_F32 = 0x0100004f,
Key_F33 = 0x01000050,
Key_F34 = 0x01000051,
Key_F35 = 0x01000052,
Key_Super_L = 0x01000053, 
Key_Super_R = 0x01000054,
Key_Menu = 0x01000055,
Key_Hyper_L = 0x01000056,
Key_Hyper_R = 0x01000057,
Key_Help = 0x01000058,
Key_Direction_L = 0x01000059,
Key_Direction_R = 0x01000060,
Key_Space = 0x20, 
Key_Any = Key_Space,
Key_Exclam = 0x21,
Key_QuoteDbl = 0x22,
Key_NumberSign = 0x23,
Key_Dollar = 0x24,
Key_Percent = 0x25,
Key_Ampersand = 0x26,
Key_Apostrophe = 0x27,
Key_ParenLeft = 0x28,
Key_ParenRight = 0x29,
Key_Asterisk = 0x2a,
Key_Plus = 0x2b,
Key_Comma = 0x2c,
Key_Minus = 0x2d,
Key_Period = 0x2e,
Key_Slash = 0x2f,
Key_0 = 0x30,
Key_1 = 0x31,
Key_2 = 0x32,
Key_3 = 0x33,
Key_4 = 0x34,
Key_5 = 0x35,
Key_6 = 0x36,
Key_7 = 0x37,
Key_8 = 0x38,
Key_9 = 0x39,
Key_Colon = 0x3a,
Key_Semicolon = 0x3b,
Key_Less = 0x3c,
Key_Equal = 0x3d,
Key_Greater = 0x3e,
Key_Question = 0x3f,
Key_At = 0x40,
Key_A = 0x41,
Key_B = 0x42,
Key_C = 0x43,
Key_D = 0x44,
Key_E = 0x45,
Key_F = 0x46,
Key_G = 0x47,
Key_H = 0x48,
Key_I = 0x49,
Key_J = 0x4a,
Key_K = 0x4b,
Key_L = 0x4c,
Key_M = 0x4d,
Key_N = 0x4e,
Key_O = 0x4f,
Key_P = 0x50,
Key_Q = 0x51,
Key_R = 0x52,
Key_S = 0x53,
Key_T = 0x54,
Key_U = 0x55,
Key_V = 0x56,
Key_W = 0x57,
Key_X = 0x58,
Key_Y = 0x59,
Key_Z = 0x5a,
Key_BracketLeft = 0x5b,
Key_Backslash = 0x5c,
Key_BracketRight = 0x5d,
Key_AsciiCircum = 0x5e,
Key_Underscore = 0x5f,
Key_QuoteLeft = 0x60,
Key_BraceLeft = 0x7b,
Key_Bar = 0x7c,
Key_BraceRight = 0x7d,
Key_AsciiTilde = 0x7e,

Key_nobreakspace = 0x0a0,
Key_exclamdown = 0x0a1,
Key_cent = 0x0a2,
Key_sterling = 0x0a3,
Key_currency = 0x0a4,
Key_yen = 0x0a5,
Key_brokenbar = 0x0a6,
Key_section = 0x0a7,
Key_diaeresis = 0x0a8,
Key_copyright = 0x0a9,
Key_ordfeminine = 0x0aa,
Key_guillemotleft = 0x0ab, 
Key_notsign = 0x0ac,
Key_hyphen = 0x0ad,
Key_registered = 0x0ae,
Key_macron = 0x0af,
Key_degree = 0x0b0,
Key_plusminus = 0x0b1,
Key_twosuperior = 0x0b2,
Key_threesuperior = 0x0b3,
Key_acute = 0x0b4,
Key_mu = 0x0b5,
Key_paragraph = 0x0b6,
Key_periodcentered = 0x0b7,
Key_cedilla = 0x0b8,
Key_onesuperior = 0x0b9,
Key_masculine = 0x0ba,
Key_guillemotright = 0x0bb, 
Key_onequarter = 0x0bc,
Key_onehalf = 0x0bd,
Key_threequarters = 0x0be,
Key_questiondown = 0x0bf,
Key_Agrave = 0x0c0,
Key_Aacute = 0x0c1,
Key_Acircumflex = 0x0c2,
Key_Atilde = 0x0c3,
Key_Adiaeresis = 0x0c4,
Key_Aring = 0x0c5,
Key_AE = 0x0c6,
Key_Ccedilla = 0x0c7,
Key_Egrave = 0x0c8,
Key_Eacute = 0x0c9,
Key_Ecircumflex = 0x0ca,
Key_Ediaeresis = 0x0cb,
Key_Igrave = 0x0cc,
Key_Iacute = 0x0cd,
Key_Icircumflex = 0x0ce,
Key_Idiaeresis = 0x0cf,
Key_ETH = 0x0d0,
Key_Ntilde = 0x0d1,
Key_Ograve = 0x0d2,
Key_Oacute = 0x0d3,
Key_Ocircumflex = 0x0d4,
Key_Otilde = 0x0d5,
Key_Odiaeresis = 0x0d6,
Key_multiply = 0x0d7,
Key_Ooblique = 0x0d8,
Key_Ugrave = 0x0d9,
Key_Uacute = 0x0da,
Key_Ucircumflex = 0x0db,
Key_Udiaeresis = 0x0dc,
Key_Yacute = 0x0dd,
Key_THORN = 0x0de,
Key_ssharp = 0x0df,

























# 822 "/usr/share/qt4/include/QtCore/qnamespace.h"
Key_division = 0x0f7,









# 832 "/usr/share/qt4/include/QtCore/qnamespace.h"
Key_ydiaeresis = 0x0ff,






Key_AltGr = 0x01001103,
Key_Multi_key = 0x01001120, 
Key_Codeinput = 0x01001137,
Key_SingleCandidate = 0x0100113c,
Key_MultipleCandidate = 0x0100113d,
Key_PreviousCandidate = 0x0100113e,


Key_Mode_switch = 0x0100117e, 



Key_Kanji = 0x01001121, 
Key_Muhenkan = 0x01001122, 

Key_Henkan = 0x01001123, 
Key_Romaji = 0x01001124, 
Key_Hiragana = 0x01001125, 
Key_Katakana = 0x01001126, 
Key_Hiragana_Katakana = 0x01001127, 
Key_Zenkaku = 0x01001128, 
Key_Hankaku = 0x01001129, 
Key_Zenkaku_Hankaku = 0x0100112a, 
Key_Touroku = 0x0100112b, 
Key_Massyo = 0x0100112c, 
Key_Kana_Lock = 0x0100112d, 
Key_Kana_Shift = 0x0100112e, 
Key_Eisu_Shift = 0x0100112f, 
Key_Eisu_toggle = 0x01001130, 









Key_Hangul = 0x01001131, 
Key_Hangul_Start = 0x01001132, 
Key_Hangul_End = 0x01001133, 
Key_Hangul_Hanja = 0x01001134, 
Key_Hangul_Jamo = 0x01001135, 
Key_Hangul_Romaja = 0x01001136, 

Key_Hangul_Jeonja = 0x01001138, 
Key_Hangul_Banja = 0x01001139, 
Key_Hangul_PreHanja = 0x0100113a, 
Key_Hangul_PostHanja = 0x0100113b, 



Key_Hangul_Special = 0x0100113f, 



Key_Dead_Grave = 0x01001250,
Key_Dead_Acute = 0x01001251,
Key_Dead_Circumflex = 0x01001252,
Key_Dead_Tilde = 0x01001253,
Key_Dead_Macron = 0x01001254,
Key_Dead_Breve = 0x01001255,
Key_Dead_Abovedot = 0x01001256,
Key_Dead_Diaeresis = 0x01001257,
Key_Dead_Abovering = 0x01001258,
Key_Dead_Doubleacute = 0x01001259,
Key_Dead_Caron = 0x0100125a,
Key_Dead_Cedilla = 0x0100125b,
Key_Dead_Ogonek = 0x0100125c,
Key_Dead_Iota = 0x0100125d,
Key_Dead_Voiced_Sound = 0x0100125e,
Key_Dead_Semivoiced_Sound = 0x0100125f,
Key_Dead_Belowdot = 0x01001260,
Key_Dead_Hook = 0x01001261,
Key_Dead_Horn = 0x01001262,


Key_Back = 0x01000061,
Key_Forward = 0x01000062,
Key_Stop = 0x01000063,
Key_Refresh = 0x01000064,
Key_VolumeDown = 0x01000070,
Key_VolumeMute = 0x01000071,
Key_VolumeUp = 0x01000072,
Key_BassBoost = 0x01000073,
Key_BassUp = 0x01000074,
Key_BassDown = 0x01000075,
Key_TrebleUp = 0x01000076,
Key_TrebleDown = 0x01000077,
Key_MediaPlay = 0x01000080,
Key_MediaStop = 0x01000081,
Key_MediaPrevious = 0x01000082,



# 934 "/usr/share/qt4/include/QtCore/qnamespace.h"
Key_MediaNext = 0x01000083,
Key_MediaRecord = 0x01000084,
Key_HomePage = 0x01000090,
Key_Favorites = 0x01000091,
Key_Search = 0x01000092,
Key_Standby = 0x01000093,
Key_OpenUrl = 0x01000094,
Key_LaunchMail = 0x010000a0,
Key_LaunchMedia = 0x010000a1,
Key_Launch0 = 0x010000a2,
Key_Launch1 = 0x010000a3,
Key_Launch2 = 0x010000a4,
Key_Launch3 = 0x010000a5,
Key_Launch4 = 0x010000a6,
Key_Launch5 = 0x010000a7,
Key_Launch6 = 0x010000a8,
Key_Launch7 = 0x010000a9,
Key_Launch8 = 0x010000aa,
Key_Launch9 = 0x010000ab,
Key_LaunchA = 0x010000ac,
Key_LaunchB = 0x010000ad,
Key_LaunchC = 0x010000ae,
Key_LaunchD = 0x010000af,
Key_LaunchE = 0x010000b0,
Key_LaunchF = 0x010000b1,
Key_MonBrightnessUp = 0x010000b2,
Key_MonBrightnessDown = 0x010000b3,
Key_KeyboardLightOnOff = 0x010000b4,
Key_KeyboardBrightnessUp = 0x010000b5,
Key_KeyboardBrightnessDown = 0x010000b6,
Key_PowerOff = 0x010000b7,
Key_WakeUp = 0x010000b8,
Key_Eject = 0x010000b9,
Key_ScreenSaver = 0x010000ba,
Key_WWW = 0x010000bb,
Key_Memo = 0x010000bc,
Key_LightBulb = 0x010000bd,
Key_Shop = 0x010000be,
Key_History = 0x010000bf,
Key_AddFavorite = 0x010000c0,
Key_HotLinks = 0x010000c1,
Key_BrightnessAdjust = 0x010000c2,
Key_Finance = 0x010000c3,
Key_Community = 0x010000c4,
Key_AudioRewind = 0x010000c5,
Key_BackForward = 0x010000c6,
Key_ApplicationLeft = 0x010000c7,
Key_ApplicationRight = 0x010000c8,
Key_Book = 0x010000c9,
Key_CD = 0x010000ca,
Key_Calculator = 0x010000cb,
Key_ToDoList = 0x010000cc,
Key_ClearGrab = 0x010000cd,
Key_Close = 0x010000ce,
Key_Copy = 0x010000cf,
Key_Cut = 0x010000d0,
Key_Display = 0x010000d1,
Key_DOS = 0x010000d2,
Key_Documents = 0x010000d3,
Key_Excel = 0x010000d4,
Key_Explorer = 0x010000d5,
Key_Game = 0x010000d6,
Key_Go = 0x010000d7,
Key_iTouch = 0x010000d8,
Key_LogOff = 0x010000d9,
Key_Market = 0x010000da,
Key_Meeting = 0x010000db,
Key_MenuKB = 0x010000dc,
Key_MenuPB = 0x010000dd,
Key_MySites = 0x010000de,
Key_News = 0x010000df,
Key_OfficeHome = 0x010000e0,
Key_Option = 0x010000e1,
Key_Paste = 0x010000e2,
Key_Phone = 0x010000e3,
Key_Calendar = 0x010000e4,
Key_Reply = 0x010000e5,
Key_Reload = 0x010000e6,
Key_RotateWindows = 0x010000e7,
Key_RotationPB = 0x010000e8,
Key_RotationKB = 0x010000e9,
Key_Save = 0x010000ea,
Key_Send = 0x010000eb,
Key_Spell = 0x010000ec,
Key_SplitScreen = 0x010000ed,
Key_Support = 0x010000ee,
Key_TaskPane = 0x010000ef,
Key_Terminal = 0x010000f0,
Key_Tools = 0x010000f1,
Key_Travel = 0x010000f2,
Key_Video = 0x010000f3,
Key_Word = 0x010000f4,
Key_Xfer = 0x010000f5,
Key_ZoomIn = 0x010000f6,
Key_ZoomOut = 0x010000f7,
Key_Away = 0x010000f8,
Key_Messenger = 0x010000f9,
Key_WebCam = 0x010000fa,
Key_MailForward = 0x010000fb,
Key_Pictures = 0x010000fc,
Key_Music = 0x010000fd,
Key_Battery = 0x010000fe,
Key_Bluetooth = 0x010000ff,
Key_WLAN = 0x01000100,
Key_UWB = 0x01000101,
Key_AudioForward = 0x01000102,
Key_AudioRepeat = 0x01000103,
Key_AudioRandomPlay = 0x01000104,
Key_Subtitle = 0x01000105,
Key_AudioCycleTrack = 0x01000106,
Key_Time = 0x01000107,
Key_Hibernate = 0x01000108,
Key_View = 0x01000109,
Key_TopMenu = 0x0100010a,
Key_PowerDown = 0x0100010b,
Key_Suspend = 0x0100010c,
Key_ContrastAdjust = 0x0100010d,

Key_MediaLast = 0x0100ffff,


Key_Select = 0x01010000,
Key_Yes = 0x01010001,
Key_No = 0x01010002,


Key_Cancel = 0x01020001,
Key_Printer = 0x01020002,
Key_Execute = 0x01020003,
Key_Sleep = 0x01020004,
Key_Play = 0x01020005, 
Key_Zoom = 0x01020006,





Key_Context1 = 0x01100000,
Key_Context2 = 0x01100001,
Key_Context3 = 0x01100002,
Key_Context4 = 0x01100003,
Key_Call = 0x01100004,
Key_Hangup = 0x01100005,
Key_Flip = 0x01100006,

Key_unknown = 0x01ffffff
};

enum ArrowType {
NoArrow,
UpArrow,
DownArrow,
LeftArrow,
RightArrow
};

enum PenStyle { 
NoPen,
SolidLine,
DashLine,
DotLine,
DashDotLine,
DashDotDotLine,
CustomDashLine

# 1099 "/usr/share/qt4/include/QtCore/qnamespace.h"
, MPenStyle = 0x0f

# 1101 "/usr/share/qt4/include/QtCore/qnamespace.h"
};

enum PenCapStyle { 
FlatCap = 0x00,
SquareCap = 0x10,
RoundCap = 0x20,
MPenCapStyle = 0x30
};

enum PenJoinStyle { 
MiterJoin = 0x00,
BevelJoin = 0x40,
RoundJoin = 0x80,
SvgMiterJoin = 0x100,
MPenJoinStyle = 0x1c0
};

enum BrushStyle { 
NoBrush,
SolidPattern,
Dense1Pattern,
Dense2Pattern,
Dense3Pattern,
Dense4Pattern,
Dense5Pattern,
Dense6Pattern,
Dense7Pattern,
HorPattern,
VerPattern,
CrossPattern,
BDiagPattern,
FDiagPattern,
DiagCrossPattern,
LinearGradientPattern,
RadialGradientPattern,
ConicalGradientPattern,
TexturePattern = 24



# 1141 "/usr/share/qt4/include/QtCore/qnamespace.h"
};

enum SizeMode {
AbsoluteSize,
RelativeSize
};





























































# 1208 "/usr/share/qt4/include/QtCore/qnamespace.h"
enum UIEffect {
UI_General,
UI_AnimateMenu,
UI_FadeMenu,
UI_AnimateCombo,
UI_AnimateTooltip,
UI_FadeTooltip,
UI_AnimateToolBox
};

enum CursorShape {
ArrowCursor,
UpArrowCursor,
CrossCursor,
WaitCursor,
IBeamCursor,
SizeVerCursor,
SizeHorCursor,
SizeBDiagCursor,
SizeFDiagCursor,
SizeAllCursor,
BlankCursor,
SplitVCursor,
SplitHCursor,
PointingHandCursor,
ForbiddenCursor,
WhatsThisCursor,
BusyCursor,
OpenHandCursor,
ClosedHandCursor,
LastCursor = ClosedHandCursor,
BitmapCursor = 24,
CustomCursor = 25




















# 1261 "/usr/share/qt4/include/QtCore/qnamespace.h"
};

enum TextFormat {
PlainText,
RichText,
AutoText,
LogText
};

enum AspectRatioMode {
IgnoreAspectRatio,
KeepAspectRatio,
KeepAspectRatioByExpanding





# 1279 "/usr/share/qt4/include/QtCore/qnamespace.h"
};




# 1284 "/usr/share/qt4/include/QtCore/qnamespace.h"

enum AnchorAttribute {
AnchorName,
AnchorHref
};

enum DockWidgetArea {
LeftDockWidgetArea = 0x1,
RightDockWidgetArea = 0x2,
TopDockWidgetArea = 0x4,
BottomDockWidgetArea = 0x8,

DockWidgetArea_Mask = 0xf,
AllDockWidgetAreas = DockWidgetArea_Mask,
NoDockWidgetArea = 0
};
enum DockWidgetAreaSizes {
NDockWidgetAreas = 4
};

typedef QFlags<DockWidgetArea> DockWidgetAreas;

enum ToolBarArea {
LeftToolBarArea = 0x1,
RightToolBarArea = 0x2,
TopToolBarArea = 0x4,
BottomToolBarArea = 0x8,

ToolBarArea_Mask = 0xf,
AllToolBarAreas = ToolBarArea_Mask,
NoToolBarArea = 0
};

enum ToolBarAreaSizes {
NToolBarAreas = 4
};

typedef QFlags<ToolBarArea> ToolBarAreas;























# 1345 "/usr/share/qt4/include/QtCore/qnamespace.h"
enum DateFormat {
TextDate, 
ISODate, 
SystemLocaleDate, 
LocalDate = SystemLocaleDate, 
LocaleDate, 
SystemLocaleShortDate,
SystemLocaleLongDate,
DefaultLocaleShortDate,
DefaultLocaleLongDate
};

enum TimeSpec {
LocalTime,
UTC,
OffsetFromUTC
};

enum DayOfWeek {
Monday = 1,
Tuesday = 2,
Wednesday = 3,
Thursday = 4,
Friday = 5,
Saturday = 6,
Sunday = 7
};

enum ScrollBarPolicy {
ScrollBarAsNeeded,
ScrollBarAlwaysOff,
ScrollBarAlwaysOn
};


























# 1404 "/usr/share/qt4/include/QtCore/qnamespace.h"
enum CaseSensitivity {
CaseInsensitive,
CaseSensitive
};

enum Corner {
TopLeftCorner = 0x00000,
TopRightCorner = 0x00001,
BottomLeftCorner = 0x00002,
BottomRightCorner = 0x00003






# 1420 "/usr/share/qt4/include/QtCore/qnamespace.h"
};

enum ConnectionType {
AutoConnection,
DirectConnection,
QueuedConnection,
AutoCompatConnection,
BlockingQueuedConnection,
UniqueConnection = 0x80
};

enum ShortcutContext {
WidgetShortcut,
WindowShortcut,
ApplicationShortcut,
WidgetWithChildrenShortcut
};

enum FillRule {
OddEvenFill,
WindingFill
};

enum MaskMode {
MaskInColor,
MaskOutColor
};

enum ClipOperation {
NoClip,
ReplaceClip,
IntersectClip,
UniteClip
};


enum ItemSelectionMode {
ContainsItemShape = 0x0,
IntersectsItemShape = 0x1,
ContainsItemBoundingRect = 0x2,
IntersectsItemBoundingRect = 0x3
};

enum TransformationMode {
FastTransformation,
SmoothTransformation
};

enum Axis {
XAxis,
YAxis,
ZAxis
};

enum FocusReason {
MouseFocusReason,
TabFocusReason,
BacktabFocusReason,
ActiveWindowFocusReason,
PopupFocusReason,
ShortcutFocusReason,
MenuBarFocusReason,
OtherFocusReason,
NoFocusReason
};

enum ContextMenuPolicy {
NoContextMenu,
DefaultContextMenu,
ActionsContextMenu,
CustomContextMenu,
PreventContextMenu
};

enum InputMethodQuery {
ImMicroFocus,
ImFont,
ImCursorPosition,
ImSurroundingText,
ImCurrentSelection,
ImMaximumTextLength,
ImAnchorPosition
};

enum InputMethodHint {
ImhNone = 0x0,
ImhHiddenText = 0x1,
ImhNoAutoUppercase = 0x2,
ImhPreferNumbers = 0x4,
ImhPreferUppercase = 0x8,
ImhPreferLowercase = 0x10,
ImhNoPredictiveText = 0x20,

ImhDigitsOnly = 0x10000,
ImhFormattedNumbersOnly = 0x20000,
ImhUppercaseOnly = 0x40000,
ImhLowercaseOnly = 0x80000,
ImhDialableCharactersOnly = 0x100000,
ImhEmailCharactersOnly = 0x200000,
ImhUrlCharactersOnly = 0x400000,

ImhExclusiveInputMask = 0xffff0000
};
typedef QFlags<InputMethodHint> InputMethodHints;

enum ToolButtonStyle {
ToolButtonIconOnly,
ToolButtonTextOnly,
ToolButtonTextBesideIcon,
ToolButtonTextUnderIcon,
ToolButtonFollowStyle
};

enum LayoutDirection {
LeftToRight,
RightToLeft
};

enum AnchorPoint {
AnchorLeft = 0,
AnchorHorizontalCenter,
AnchorRight,
AnchorTop,
AnchorVerticalCenter,
AnchorBottom
};



enum DropAction {
CopyAction = 0x1,
MoveAction = 0x2,
LinkAction = 0x4,
ActionMask = 0xff,
TargetMoveAction = 0x8002,
IgnoreAction = 0x0
};
typedef QFlags<DropAction> DropActions;

enum CheckState {
Unchecked,
PartiallyChecked,
Checked
};

enum ItemDataRole {
DisplayRole = 0,
DecorationRole = 1,
EditRole = 2,
ToolTipRole = 3,
StatusTipRole = 4,
WhatsThisRole = 5,

FontRole = 6,
TextAlignmentRole = 7,
BackgroundColorRole = 8,
BackgroundRole = 8,
TextColorRole = 9,
ForegroundRole = 9,
CheckStateRole = 10,

AccessibleTextRole = 11,
AccessibleDescriptionRole = 12,

SizeHintRole = 13,

DisplayPropertyRole = 27,
DecorationPropertyRole = 28,
ToolTipPropertyRole = 29,
StatusTipPropertyRole = 30,
WhatsThisPropertyRole = 31,

UserRole = 32
};

enum ItemFlag {
NoItemFlags = 0,
ItemIsSelectable = 1,
ItemIsEditable = 2,
ItemIsDragEnabled = 4,
ItemIsDropEnabled = 8,
ItemIsUserCheckable = 16,
ItemIsEnabled = 32,
ItemIsTristate = 64
};
typedef QFlags<ItemFlag> ItemFlags;

enum MatchFlag {
MatchExactly = 0,
MatchContains = 1,
MatchStartsWith = 2,
MatchEndsWith = 3,
MatchRegExp = 4,
MatchWildcard = 5,
MatchFixedString = 8,
MatchCaseSensitive = 16,
MatchWrap = 32,
MatchRecursive = 64
};
typedef QFlags<MatchFlag> MatchFlags;












# 1632 "/usr/share/qt4/include/QtCore/qnamespace.h"
typedef WindowFlags WFlags;

enum WindowModality {
NonModal,
WindowModal,
ApplicationModal
};

enum TextInteractionFlag {
NoTextInteraction = 0,
TextSelectableByMouse = 1,
TextSelectableByKeyboard = 2,
LinksAccessibleByMouse = 4,
LinksAccessibleByKeyboard = 8,
TextEditable = 16,

TextEditorInteraction = TextSelectableByMouse | TextSelectableByKeyboard | TextEditable,
TextBrowserInteraction = TextSelectableByMouse | LinksAccessibleByMouse | LinksAccessibleByKeyboard
};
typedef QFlags<TextInteractionFlag> TextInteractionFlags;

enum EventPriority {
HighEventPriority = 1,
NormalEventPriority = 0,
LowEventPriority = -1
};

enum SizeHint {
MinimumSize,
PreferredSize,
MaximumSize,
MinimumDescent,
NSizeHints
};

enum WindowFrameSection {
NoSection,
LeftSection, 
TopLeftSection,
TopSection,
TopRightSection,
RightSection,
BottomRightSection,
BottomSection,
BottomLeftSection,
TitleBarArea 
};

enum Initialization {
Uninitialized
};

enum CoordinateSystem {
DeviceCoordinates,
LogicalCoordinates
};

enum TouchPointState {
TouchPointPressed = 0x01,
TouchPointMoved = 0x02,
TouchPointStationary = 0x04,
TouchPointReleased = 0x08,
TouchPointStateMask = 0x0f,

TouchPointPrimary = 0x10
};
typedef QFlags<TouchPointState> TouchPointStates;

enum GestureState
{
NoGesture,
GestureStarted = 1,
GestureUpdated = 2,
GestureFinished = 3,
GestureCanceled = 4
};

enum GestureType
{
TapGesture = 1,
TapAndHoldGesture = 2,
PanGesture = 3,
PinchGesture = 4,
SwipeGesture = 5,

CustomGesture = 0x0100,

LastGestureType = ~0u
};

enum GestureFlag
{
DontStartGestureOnChildren = 0x01,
ReceivePartialGestures = 0x02
};
typedef QFlags<GestureFlag> GestureFlags;

enum NavigationMode
{
NavigationModeNone,
NavigationModeKeypadTabOrder,
NavigationModeKeypadDirectional,
NavigationModeCursorAuto,
NavigationModeCursorForceVisible
};
}




# 1742 "/usr/share/qt4/include/QtCore/qnamespace.h"
inline QFlags<Qt::MouseButtons::enum_type> operator|(Qt::MouseButtons::enum_type f1, Qt::MouseButtons::enum_type f2) { return QFlags<Qt::MouseButtons::enum_type>(f1) | f2; } inline QFlags<Qt::MouseButtons::enum_type> operator|(Qt::MouseButtons::enum_type f1, QFlags<Qt::MouseButtons::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::MouseButtons::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::Orientations::enum_type> operator|(Qt::Orientations::enum_type f1, Qt::Orientations::enum_type f2) { return QFlags<Qt::Orientations::enum_type>(f1) | f2; } inline QFlags<Qt::Orientations::enum_type> operator|(Qt::Orientations::enum_type f1, QFlags<Qt::Orientations::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::Orientations::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::KeyboardModifiers::enum_type> operator|(Qt::KeyboardModifiers::enum_type f1, Qt::KeyboardModifiers::enum_type f2) { return QFlags<Qt::KeyboardModifiers::enum_type>(f1) | f2; } inline QFlags<Qt::KeyboardModifiers::enum_type> operator|(Qt::KeyboardModifiers::enum_type f1, QFlags<Qt::KeyboardModifiers::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::KeyboardModifiers::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::WindowFlags::enum_type> operator|(Qt::WindowFlags::enum_type f1, Qt::WindowFlags::enum_type f2) { return QFlags<Qt::WindowFlags::enum_type>(f1) | f2; } inline QFlags<Qt::WindowFlags::enum_type> operator|(Qt::WindowFlags::enum_type f1, QFlags<Qt::WindowFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::WindowFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::Alignment::enum_type> operator|(Qt::Alignment::enum_type f1, Qt::Alignment::enum_type f2) { return QFlags<Qt::Alignment::enum_type>(f1) | f2; } inline QFlags<Qt::Alignment::enum_type> operator|(Qt::Alignment::enum_type f1, QFlags<Qt::Alignment::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::Alignment::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::ImageConversionFlags::enum_type> operator|(Qt::ImageConversionFlags::enum_type f1, Qt::ImageConversionFlags::enum_type f2) { return QFlags<Qt::ImageConversionFlags::enum_type>(f1) | f2; } inline QFlags<Qt::ImageConversionFlags::enum_type> operator|(Qt::ImageConversionFlags::enum_type f1, QFlags<Qt::ImageConversionFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::ImageConversionFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::DockWidgetAreas::enum_type> operator|(Qt::DockWidgetAreas::enum_type f1, Qt::DockWidgetAreas::enum_type f2) { return QFlags<Qt::DockWidgetAreas::enum_type>(f1) | f2; } inline QFlags<Qt::DockWidgetAreas::enum_type> operator|(Qt::DockWidgetAreas::enum_type f1, QFlags<Qt::DockWidgetAreas::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::DockWidgetAreas::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::ToolBarAreas::enum_type> operator|(Qt::ToolBarAreas::enum_type f1, Qt::ToolBarAreas::enum_type f2) { return QFlags<Qt::ToolBarAreas::enum_type>(f1) | f2; } inline QFlags<Qt::ToolBarAreas::enum_type> operator|(Qt::ToolBarAreas::enum_type f1, QFlags<Qt::ToolBarAreas::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::ToolBarAreas::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::WindowStates::enum_type> operator|(Qt::WindowStates::enum_type f1, Qt::WindowStates::enum_type f2) { return QFlags<Qt::WindowStates::enum_type>(f1) | f2; } inline QFlags<Qt::WindowStates::enum_type> operator|(Qt::WindowStates::enum_type f1, QFlags<Qt::WindowStates::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::WindowStates::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::DropActions::enum_type> operator|(Qt::DropActions::enum_type f1, Qt::DropActions::enum_type f2) { return QFlags<Qt::DropActions::enum_type>(f1) | f2; } inline QFlags<Qt::DropActions::enum_type> operator|(Qt::DropActions::enum_type f1, QFlags<Qt::DropActions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::DropActions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::ItemFlags::enum_type> operator|(Qt::ItemFlags::enum_type f1, Qt::ItemFlags::enum_type f2) { return QFlags<Qt::ItemFlags::enum_type>(f1) | f2; } inline QFlags<Qt::ItemFlags::enum_type> operator|(Qt::ItemFlags::enum_type f1, QFlags<Qt::ItemFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::ItemFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::MatchFlags::enum_type> operator|(Qt::MatchFlags::enum_type f1, Qt::MatchFlags::enum_type f2) { return QFlags<Qt::MatchFlags::enum_type>(f1) | f2; } inline QFlags<Qt::MatchFlags::enum_type> operator|(Qt::MatchFlags::enum_type f1, QFlags<Qt::MatchFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::MatchFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::TextInteractionFlags::enum_type> operator|(Qt::TextInteractionFlags::enum_type f1, Qt::TextInteractionFlags::enum_type f2) { return QFlags<Qt::TextInteractionFlags::enum_type>(f1) | f2; } inline QFlags<Qt::TextInteractionFlags::enum_type> operator|(Qt::TextInteractionFlags::enum_type f1, QFlags<Qt::TextInteractionFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::TextInteractionFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::InputMethodHints::enum_type> operator|(Qt::InputMethodHints::enum_type f1, Qt::InputMethodHints::enum_type f2) { return QFlags<Qt::InputMethodHints::enum_type>(f1) | f2; } inline QFlags<Qt::InputMethodHints::enum_type> operator|(Qt::InputMethodHints::enum_type f1, QFlags<Qt::InputMethodHints::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::InputMethodHints::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::TouchPointStates::enum_type> operator|(Qt::TouchPointStates::enum_type f1, Qt::TouchPointStates::enum_type f2) { return QFlags<Qt::TouchPointStates::enum_type>(f1) | f2; } inline QFlags<Qt::TouchPointStates::enum_type> operator|(Qt::TouchPointStates::enum_type f1, QFlags<Qt::TouchPointStates::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::TouchPointStates::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<Qt::GestureFlags::enum_type> operator|(Qt::GestureFlags::enum_type f1, Qt::GestureFlags::enum_type f2) { return QFlags<Qt::GestureFlags::enum_type>(f1) | f2; } inline QFlags<Qt::GestureFlags::enum_type> operator|(Qt::GestureFlags::enum_type f1, QFlags<Qt::GestureFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::GestureFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

typedef bool (*qInternalCallback)(void **);

class  QInternal {
public:
enum PaintDeviceFlags {
UnknownDevice = 0x00,
Widget = 0x01,
Pixmap = 0x02,
Image = 0x03,
Printer = 0x04,
Picture = 0x05,
Pbuffer = 0x06, 
FramebufferObject = 0x07, 
CustomRaster = 0x08,
MacQuartz = 0x09,
PaintBuffer = 0x0a,
OpenGL = 0x0b
};
enum RelayoutType {
RelayoutNormal,
RelayoutDragging,
RelayoutDropped
};


enum Callback {
ConnectCallback,
DisconnectCallback,
AdoptCurrentThread,
EventNotifyCallback,
LastCallback
};

enum InternalFunction {
CreateThreadForAdoption,
RefAdoptedThread,
DerefAdoptedThread,
SetCurrentThreadToMainThread,
SetQObjectSender,
GetQObjectSender,
ResetQObjectSender,
LastInternalFunction
};

enum DockPosition {
LeftDock,
RightDock,
TopDock,
BottomDock,
DockCount
};

static bool registerCallback(Callback, qInternalCallback);
static bool unregisterCallback(Callback, qInternalCallback);

static bool activateCallbacks(Callback, void **);
static bool callFunction(InternalFunction func, void **);
};









# 1826 "/usr/share/qt4/include/QtCore/qnamespace.h"





# 46 "/usr/share/qt4/include/QtCore/qbytearray.h"









# 55 "/usr/share/qt4/include/QtCore/qbytearray.h"




typedef QtValidLicenseForCoreModule QtCoreModule;





 char *qstrdup(const char *);

inline uint qstrlen(const char *str)
{ return str ? uint(strlen(str)) : 0; }

inline uint qstrnlen(const char *str, uint maxlen)
{
uint length = 0;
if (str) {
while (length < maxlen && *str++)
length++;
}
return length;
}

 char *qstrcpy(char *dst, const char *src);
 char *qstrncpy(char *dst, const char *src, uint len);

 int qstrcmp(const char *str1, const char *str2);
 int qstrcmp(const QByteArray &str1, const QByteArray &str2);
 int qstrcmp(const QByteArray &str1, const char *str2);
static inline int qstrcmp(const char *str1, const QByteArray &str2)
{ return -qstrcmp(str2, str1); }

inline int qstrncmp(const char *str1, const char *str2, uint len)
{
return (str1 && str2) ? strncmp(str1, str2, len)
: (str1 ? 1 : (str2 ? -1 : 0));
}
 int qstricmp(const char *, const char *);
 int qstrnicmp(const char *, const char *, uint len);


 int qvsnprintf(char *str, size_t n, const char *fmt, va_list ap);
 int qsnprintf(char *str, size_t n, const char *fmt, ...);














# 114 "/usr/share/qt4/include/QtCore/qbytearray.h"


 quint16 qChecksum(const char *s, uint len);

class QByteRef;
class QString;
class QDataStream;
template <typename T> class QList;

class  QByteArray
{
private:
struct Data {
QBasicAtomicInt ref;
int alloc, size;



char *data;
char array[1];
};

public:
inline QByteArray();
QByteArray(const char *);
QByteArray(const char *, int size);
QByteArray(int size, char c);
QByteArray(int size, Qt::Initialization);
inline QByteArray(const QByteArray &);
inline ~QByteArray();

QByteArray &operator=(const QByteArray &);
QByteArray &operator=(const char *str);

inline int size() const;
bool isEmpty() const;
void resize(int size);

QByteArray &fill(char c, int size = -1);

int capacity() const;
void reserve(int size);
void squeeze();


# 159 "/usr/share/qt4/include/QtCore/qbytearray.h"
operator const char *() const;
operator const void *() const;

# 162 "/usr/share/qt4/include/QtCore/qbytearray.h"
char *data();
const char *data() const;
inline const char *constData() const;
inline void detach();
bool isDetached() const;
void clear();






# 174 "/usr/share/qt4/include/QtCore/qbytearray.h"
char at(int i) const;
char operator[](int i) const;
char operator[](uint i) const;

# 178 "/usr/share/qt4/include/QtCore/qbytearray.h"
QByteRef operator[](int i);
QByteRef operator[](uint i);

int indexOf(char c, int from = 0) const;
int indexOf(const char *c, int from = 0) const;
int indexOf(const QByteArray &a, int from = 0) const;
int lastIndexOf(char c, int from = -1) const;
int lastIndexOf(const char *c, int from = -1) const;
int lastIndexOf(const QByteArray &a, int from = -1) const;

QBool contains(char c) const;
QBool contains(const char *a) const;
QBool contains(const QByteArray &a) const;
int count(char c) const;
int count(const char *a) const;
int count(const QByteArray &a) const;

QByteArray left(int len) const;
QByteArray right(int len) const;
QByteArray mid(int index, int len = -1) const;

bool startsWith(const QByteArray &a) const;
bool startsWith(char c) const;
bool startsWith(const char *c) const;

bool endsWith(const QByteArray &a) const;
bool endsWith(char c) const;
bool endsWith(const char *c) const;

void truncate(int pos);
void chop(int n);

QByteArray toLower() const;
QByteArray toUpper() const;

QByteArray trimmed() const;
QByteArray simplified() const;
QByteArray leftJustified(int width, char fill = ' ', bool truncate = false) const;
QByteArray rightJustified(int width, char fill = ' ', bool truncate = false) const;








# 225 "/usr/share/qt4/include/QtCore/qbytearray.h"
QByteArray &prepend(char c);
QByteArray &prepend(const char *s);
QByteArray &prepend(const char *s, int len);
QByteArray &prepend(const QByteArray &a);
QByteArray &append(char c);
QByteArray &append(const char *s);
QByteArray &append(const char *s, int len);
QByteArray &append(const QByteArray &a);
QByteArray &insert(int i, char c);
QByteArray &insert(int i, const char *s);
QByteArray &insert(int i, const char *s, int len);
QByteArray &insert(int i, const QByteArray &a);
QByteArray &remove(int index, int len);
QByteArray &replace(int index, int len, const char *s);
QByteArray &replace(int index, int len, const QByteArray &s);
QByteArray &replace(char before, const char *after);
QByteArray &replace(char before, const QByteArray &after);
QByteArray &replace(const char *before, const char *after);
QByteArray &replace(const char *before, int bsize, const char *after, int asize);
QByteArray &replace(const QByteArray &before, const QByteArray &after);
QByteArray &replace(const QByteArray &before, const char *after);
QByteArray &replace(const char *before, const QByteArray &after);
QByteArray &replace(char before, char after);
QByteArray &operator+=(char c);
QByteArray &operator+=(const char *s);
QByteArray &operator+=(const QByteArray &a);

QList<QByteArray> split(char sep) const;

QByteArray repeated(int times) const;


# 257 "/usr/share/qt4/include/QtCore/qbytearray.h"
 QByteArray &append(const QString &s);
 QByteArray &insert(int i, const QString &s);
 QByteArray &replace(const QString &before, const char *after);
 QByteArray &replace(char c, const QString &after);
 QByteArray &replace(const QString &before, const QByteArray &after);

 QByteArray &operator+=(const QString &s);
 int indexOf(const QString &s, int from = 0) const;
 int lastIndexOf(const QString &s, int from = -1) const;


# 268 "/usr/share/qt4/include/QtCore/qbytearray.h"
inline  bool operator==(const QString &s2) const;
inline  bool operator!=(const QString &s2) const;
inline  bool operator<(const QString &s2) const;
inline  bool operator>(const QString &s2) const;
inline  bool operator<=(const QString &s2) const;
inline  bool operator>=(const QString &s2) const;


# 276 "/usr/share/qt4/include/QtCore/qbytearray.h"
short toShort(bool *ok = 0, int base = 10) const;
ushort toUShort(bool *ok = 0, int base = 10) const;
int toInt(bool *ok = 0, int base = 10) const;
uint toUInt(bool *ok = 0, int base = 10) const;
long toLong(bool *ok = 0, int base = 10) const;
ulong toULong(bool *ok = 0, int base = 10) const;
qlonglong toLongLong(bool *ok = 0, int base = 10) const;
qulonglong toULongLong(bool *ok = 0, int base = 10) const;
float toFloat(bool *ok = 0) const;
double toDouble(bool *ok = 0) const;
QByteArray toBase64() const;
QByteArray toHex() const;
QByteArray toPercentEncoding(const QByteArray &exclude = QByteArray(),
const QByteArray &include = QByteArray(),
char percent = '%') const;

QByteArray &setNum(short, int base = 10);
QByteArray &setNum(ushort, int base = 10);
QByteArray &setNum(int, int base = 10);
QByteArray &setNum(uint, int base = 10);
QByteArray &setNum(qlonglong, int base = 10);
QByteArray &setNum(qulonglong, int base = 10);
QByteArray &setNum(float, char f = 'g', int prec = 6);
QByteArray &setNum(double, char f = 'g', int prec = 6);

static QByteArray number(int, int base = 10);
static QByteArray number(uint, int base = 10);
static QByteArray number(qlonglong, int base = 10);
static QByteArray number(qulonglong, int base = 10);
static QByteArray number(double, char f = 'g', int prec = 6);
static QByteArray fromRawData(const char *, int size);
static QByteArray fromBase64(const QByteArray &base64);
static QByteArray fromHex(const QByteArray &hexEncoded);
static QByteArray fromPercentEncoding(const QByteArray &pctEncoded, char percent = '%');


typedef char *iterator;
typedef const char *const_iterator;
typedef iterator Iterator;
typedef const_iterator ConstIterator;
iterator begin();
const_iterator begin() const;
const_iterator constBegin() const;
iterator end();
const_iterator end() const;
const_iterator constEnd() const;


typedef const char & const_reference;
typedef char & reference;
typedef char value_type;
void push_back(char c);
void push_back(const char *c);
void push_back(const QByteArray &a);
void push_front(char c);
void push_front(const char *c);
void push_front(const QByteArray &a);

inline int count() const { return d->size; }
int length() const { return d->size; }
bool isNull() const;


























# 363 "/usr/share/qt4/include/QtCore/qbytearray.h"
private:
operator QNoImplicitBoolCast() const;
static Data shared_null;
static Data shared_empty;
Data *d;
QByteArray(Data *dd, int , int ) : d(dd) {}
void realloc(int alloc);
void expand(int i);
QByteArray nulTerminated() const;

friend class QByteRef;
friend class QString;
friend  QByteArray qUncompress(const uchar *data, int nbytes);
public:
typedef Data * DataPtr;
inline DataPtr &data_ptr() { return d; }
};

inline QByteArray::QByteArray(): d(&shared_null) { d->ref.ref(); }
inline QByteArray::~QByteArray() { if (!d->ref.deref()) qFree(d); }
inline int QByteArray::size() const
{ return d->size; }









# 394 "/usr/share/qt4/include/QtCore/qbytearray.h"
inline char QByteArray::at(int i) const
{ qt_noop(); return d->data[i]; }
inline char QByteArray::operator[](int i) const
{ qt_noop(); return d->data[i]; }
inline char QByteArray::operator[](uint i) const
{ qt_noop(); return d->data[i]; }


# 402 "/usr/share/qt4/include/QtCore/qbytearray.h"
inline bool QByteArray::isEmpty() const
{ return d->size == 0; }

# 405 "/usr/share/qt4/include/QtCore/qbytearray.h"
inline QByteArray::operator const char *() const
{ return d->data; }
inline QByteArray::operator const void *() const
{ return d->data; }

# 410 "/usr/share/qt4/include/QtCore/qbytearray.h"
inline char *QByteArray::data()
{ detach(); return d->data; }
inline const char *QByteArray::data() const
{ return d->data; }
inline const char *QByteArray::constData() const
{ return d->data; }
inline void QByteArray::detach()
{ if (d->ref != 1 || d->data != d->array) realloc(d->size); }
inline bool QByteArray::isDetached() const
{ return d->ref == 1; }
inline QByteArray::QByteArray(const QByteArray &a) : d(a.d)
{ d->ref.ref(); }





# 427 "/usr/share/qt4/include/QtCore/qbytearray.h"
inline int QByteArray::capacity() const
{ return d->alloc; }

inline void QByteArray::reserve(int asize)
{ if (d->ref != 1 || asize > d->alloc) realloc(asize); }

inline void QByteArray::squeeze()
{ if (d->size < d->alloc) realloc(d->size); }

class  QByteRef {
QByteArray &a;
int i;
inline QByteRef(QByteArray &array, int idx)
: a(array),i(idx) {}
friend class QByteArray;
public:




# 447 "/usr/share/qt4/include/QtCore/qbytearray.h"
inline operator char() const
{ return i < a.d->size ? a.d->data[i] : char(0); }

# 450 "/usr/share/qt4/include/QtCore/qbytearray.h"
inline QByteRef &operator=(char c)
{ if (i >= a.d->size) a.expand(i); else a.detach();
a.d->data[i] = c; return *this; }
inline QByteRef &operator=(const QByteRef &c)
{ if (i >= a.d->size) a.expand(i); else a.detach();
a.d->data[i] = c.a.d->data[c.i]; return *this; }
inline bool operator==(char c) const
{ return a.d->data[i] == c; }
inline bool operator!=(char c) const
{ return a.d->data[i] != c; }
inline bool operator>(char c) const
{ return a.d->data[i] > c; }
inline bool operator>=(char c) const
{ return a.d->data[i] >= c; }
inline bool operator<(char c) const
{ return a.d->data[i] < c; }
inline bool operator<=(char c) const
{ return a.d->data[i] <= c; }
};

inline QByteRef QByteArray::operator[](int i)
{ qt_noop(); return QByteRef(*this, i); }
inline QByteRef QByteArray::operator[](uint i)
{ return QByteRef(*this, i); }
inline QByteArray::iterator QByteArray::begin()
{ detach(); return d->data; }
inline QByteArray::const_iterator QByteArray::begin() const
{ return d->data; }
inline QByteArray::const_iterator QByteArray::constBegin() const
{ return d->data; }
inline QByteArray::iterator QByteArray::end()
{ detach(); return d->data + d->size; }
inline QByteArray::const_iterator QByteArray::end() const
{ return d->data + d->size; }
inline QByteArray::const_iterator QByteArray::constEnd() const
{ return d->data + d->size; }
inline QByteArray &QByteArray::operator+=(char c)
{ return append(c); }
inline QByteArray &QByteArray::operator+=(const char *s)
{ return append(s); }
inline QByteArray &QByteArray::operator+=(const QByteArray &a)
{ return append(a); }
inline void QByteArray::push_back(char c)
{ append(c); }
inline void QByteArray::push_back(const char *c)
{ append(c); }
inline void QByteArray::push_back(const QByteArray &a)
{ append(a); }
inline void QByteArray::push_front(char c)
{ prepend(c); }
inline void QByteArray::push_front(const char *c)
{ prepend(c); }
inline void QByteArray::push_front(const QByteArray &a)
{ prepend(a); }
inline QBool QByteArray::contains(const QByteArray &a) const
{ return QBool(indexOf(a) != -1); }
inline QBool QByteArray::contains(char c) const
{ return QBool(indexOf(c) != -1); }
inline bool operator==(const QByteArray &a1, const QByteArray &a2)
{ return (a1.size() == a2.size()) && (memcmp(a1.constData(), a2.constData(), a1.size())==0); }
inline bool operator==(const QByteArray &a1, const char *a2)
{ return a2 ? qstrcmp(a1,a2) == 0 : a1.isEmpty(); }
inline bool operator==(const char *a1, const QByteArray &a2)
{ return a1 ? qstrcmp(a1,a2) == 0 : a2.isEmpty(); }
inline bool operator!=(const QByteArray &a1, const QByteArray &a2)
{ return !(a1==a2); }
inline bool operator!=(const QByteArray &a1, const char *a2)
{ return a2 ? qstrcmp(a1,a2) != 0 : !a1.isEmpty(); }
inline bool operator!=(const char *a1, const QByteArray &a2)
{ return a1 ? qstrcmp(a1,a2) != 0 : !a2.isEmpty(); }
inline bool operator<(const QByteArray &a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) < 0; }
inline bool operator<(const QByteArray &a1, const char *a2)
{ return qstrcmp(a1, a2) < 0; }
inline bool operator<(const char *a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) < 0; }
inline bool operator<=(const QByteArray &a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) <= 0; }
inline bool operator<=(const QByteArray &a1, const char *a2)
{ return qstrcmp(a1, a2) <= 0; }
inline bool operator<=(const char *a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) <= 0; }
inline bool operator>(const QByteArray &a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) > 0; }
inline bool operator>(const QByteArray &a1, const char *a2)
{ return qstrcmp(a1, a2) > 0; }
inline bool operator>(const char *a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) > 0; }
inline bool operator>=(const QByteArray &a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) >= 0; }
inline bool operator>=(const QByteArray &a1, const char *a2)
{ return qstrcmp(a1, a2) >= 0; }
inline bool operator>=(const char *a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) >= 0; }
inline const QByteArray operator+(const QByteArray &a1, const QByteArray &a2)
{ return QByteArray(a1) += a2; }
inline const QByteArray operator+(const QByteArray &a1, const char *a2)
{ return QByteArray(a1) += a2; }
inline const QByteArray operator+(const QByteArray &a1, char a2)
{ return QByteArray(a1) += a2; }
inline const QByteArray operator+(const char *a1, const QByteArray &a2)
{ return QByteArray(a1) += a2; }
inline const QByteArray operator+(char a1, const QByteArray &a2)
{ return QByteArray(&a1, 1) += a2; }
inline QBool QByteArray::contains(const char *c) const
{ return QBool(indexOf(c) != -1); }
inline QByteArray &QByteArray::replace(char before, const char *c)
{ return replace(&before, 1, c, qstrlen(c)); }
inline QByteArray &QByteArray::replace(const QByteArray &before, const char *c)
{ return replace(before.constData(), before.size(), c, qstrlen(c)); }
inline QByteArray &QByteArray::replace(const char *before, const char *after)
{ return replace(before, qstrlen(before), after, qstrlen(after)); }

inline QByteArray &QByteArray::setNum(short n, int base)
{ return setNum(qlonglong(n), base); }
inline QByteArray &QByteArray::setNum(ushort n, int base)
{ return setNum(qulonglong(n), base); }
inline QByteArray &QByteArray::setNum(int n, int base)
{ return setNum(qlonglong(n), base); }
inline QByteArray &QByteArray::setNum(uint n, int base)
{ return setNum(qulonglong(n), base); }
inline QByteArray &QByteArray::setNum(float n, char f, int prec)
{ return setNum(double(n),f,prec); }



# 576 "/usr/share/qt4/include/QtCore/qbytearray.h"
 QDataStream &operator<<(QDataStream &, const QByteArray &);
 QDataStream &operator>>(QDataStream &, QByteArray &);



# 581 "/usr/share/qt4/include/QtCore/qbytearray.h"
 QByteArray qCompress(const uchar* data, int nbytes, int compressionLevel = -1);
 QByteArray qUncompress(const uchar* data, int nbytes);
inline QByteArray qCompress(const QByteArray& data, int compressionLevel = -1)
{ return qCompress(reinterpret_cast<const uchar *>(data.constData()), data.size(), compressionLevel); }
inline QByteArray qUncompress(const QByteArray& data)
{ return qUncompress(reinterpret_cast<const uchar*>(data.constData()), data.size()); }


# 589 "/usr/share/qt4/include/QtCore/qbytearray.h"
template <> class QTypeInfo<QByteArray > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QByteArray)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QByteArray"; } };
template <> inline bool qIsDetached<QByteArray>(QByteArray &t) { return t.isDetached(); } template <> inline void qSwap<QByteArray>(QByteArray &value1, QByteArray &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }






# 46 "/usr/share/qt4/include/QtCore/qstring.h"

# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 47 "/usr/share/qt4/include/QtCore/qstring.h"

# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtCore/qstring.h"




























# 76 "/usr/share/qt4/include/QtCore/qstring.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QCharRef;
class QRegExp;
class QStringList;
class QTextCodec;
class QLatin1String;
class QStringRef;
template <typename T> class QVector;

class  QString
{
public:
inline QString();
QString(const QChar *unicode, int size);
QString(QChar c);
QString(int size, QChar c);
inline QString(const QLatin1String &latin1);
inline QString(const QString &);
inline ~QString();
QString &operator=(QChar c);
QString &operator=(const QString &);
inline QString &operator=(const QLatin1String &);

inline int size() const { return d->size; }
inline int count() const { return d->size; }
inline int length() const;
inline bool isEmpty() const;
void resize(int size);

QString &fill(QChar c, int size = -1);
void truncate(int pos);
void chop(int n);

int capacity() const;
inline void reserve(int size);
inline void squeeze() { if (d->size < d->alloc || d->ref != 1) realloc(); d->capacity = 0;}

inline const QChar *unicode() const;
inline QChar *data();
inline const QChar *data() const;
inline const QChar *constData() const;

inline void detach();
inline bool isDetached() const;
void clear();

inline const QChar at(int i) const;
const QChar operator[](int i) const;
QCharRef operator[](int i);
const QChar operator[](uint i) const;
QCharRef operator[](uint i);

QString arg(qlonglong a, int fieldwidth=0, int base=10,
const QChar &fillChar = QLatin1Char(' ')) const ;
QString arg(qulonglong a, int fieldwidth=0, int base=10,
const QChar &fillChar = QLatin1Char(' ')) const ;
QString arg(long a, int fieldwidth=0, int base=10,
const QChar &fillChar = QLatin1Char(' ')) const ;
QString arg(ulong a, int fieldwidth=0, int base=10,
const QChar &fillChar = QLatin1Char(' ')) const ;
QString arg(int a, int fieldWidth = 0, int base = 10,
const QChar &fillChar = QLatin1Char(' ')) const ;
QString arg(uint a, int fieldWidth = 0, int base = 10,
const QChar &fillChar = QLatin1Char(' ')) const ;
QString arg(short a, int fieldWidth = 0, int base = 10,
const QChar &fillChar = QLatin1Char(' ')) const ;
QString arg(ushort a, int fieldWidth = 0, int base = 10,
const QChar &fillChar = QLatin1Char(' ')) const ;
QString arg(double a, int fieldWidth = 0, char fmt = 'g', int prec = -1,
const QChar &fillChar = QLatin1Char(' ')) const ;
QString arg(char a, int fieldWidth = 0,
const QChar &fillChar = QLatin1Char(' ')) const ;
QString arg(QChar a, int fieldWidth = 0,
const QChar &fillChar = QLatin1Char(' ')) const ;
QString arg(const QString &a, int fieldWidth = 0,
const QChar &fillChar = QLatin1Char(' ')) const ;
QString arg(const QString &a1, const QString &a2) const ;
QString arg(const QString &a1, const QString &a2, const QString &a3) const ;
QString arg(const QString &a1, const QString &a2, const QString &a3,
const QString &a4) const ;
QString arg(const QString &a1, const QString &a2, const QString &a3,
const QString &a4, const QString &a5) const ;
QString arg(const QString &a1, const QString &a2, const QString &a3,
const QString &a4, const QString &a5, const QString &a6) const ;
QString arg(const QString &a1, const QString &a2, const QString &a3,
const QString &a4, const QString &a5, const QString &a6,
const QString &a7) const ;
QString arg(const QString &a1, const QString &a2, const QString &a3,
const QString &a4, const QString &a5, const QString &a6,
const QString &a7, const QString &a8) const ;
QString arg(const QString &a1, const QString &a2, const QString &a3,
const QString &a4, const QString &a5, const QString &a6,
const QString &a7, const QString &a8, const QString &a9) const ;

QString &vsprintf(const char *format, va_list ap)



# 179 "/usr/share/qt4/include/QtCore/qstring.h"
;
QString &sprintf(const char *format, ...)



# 184 "/usr/share/qt4/include/QtCore/qstring.h"
;

int indexOf(QChar c, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
int indexOf(const QString &s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
int indexOf(const QLatin1String &s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
int lastIndexOf(QChar c, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
int lastIndexOf(const QString &s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
int lastIndexOf(const QLatin1String &s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

inline QBool contains(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
inline QBool contains(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
int count(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
int count(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;


# 199 "/usr/share/qt4/include/QtCore/qstring.h"
int indexOf(const QRegExp &, int from = 0) const;
int lastIndexOf(const QRegExp &, int from = -1) const;
inline QBool contains(const QRegExp &rx) const { return QBool(indexOf(rx) != -1); }
int count(const QRegExp &) const;

int indexOf(QRegExp &, int from = 0) const;
int lastIndexOf(QRegExp &, int from = -1) const;
inline QBool contains(QRegExp &rx) const { return QBool(indexOf(rx) != -1); }


# 209 "/usr/share/qt4/include/QtCore/qstring.h"
enum SectionFlag {
SectionDefault = 0x00,
SectionSkipEmpty = 0x01,
SectionIncludeLeadingSep = 0x02,
SectionIncludeTrailingSep = 0x04,
SectionCaseInsensitiveSeps = 0x08
};
typedef QFlags<SectionFlag> SectionFlags;

QString section(QChar sep, int start, int end = -1, SectionFlags flags = SectionDefault) const;
QString section(const QString &in_sep, int start, int end = -1, SectionFlags flags = SectionDefault) const;

# 221 "/usr/share/qt4/include/QtCore/qstring.h"
QString section(const QRegExp &reg, int start, int end = -1, SectionFlags flags = SectionDefault) const;


# 224 "/usr/share/qt4/include/QtCore/qstring.h"
QString left(int n) const ;
QString right(int n) const ;
QString mid(int position, int n = -1) const ;
QStringRef leftRef(int n) const ;
QStringRef rightRef(int n) const ;
QStringRef midRef(int position, int n = -1) const ;

bool startsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
bool startsWith(const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
bool startsWith(const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
bool endsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
bool endsWith(const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
bool endsWith(const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

QString leftJustified(int width, QChar fill = QLatin1Char(' '), bool trunc = false) const ;
QString rightJustified(int width, QChar fill = QLatin1Char(' '), bool trunc = false) const ;

QString toLower() const ;
QString toUpper() const ;
QString toCaseFolded() const ;

QString trimmed() const ;
QString simplified() const ;

QString &insert(int i, QChar c);
QString &insert(int i, const QChar *uc, int len);
inline QString &insert(int i, const QString &s) { return insert(i, s.constData(), s.length()); }
QString &insert(int i, const QLatin1String &s);
QString &append(QChar c);
QString &append(const QString &s);
QString &append(const QStringRef &s);
QString &append(const QLatin1String &s);
inline QString &prepend(QChar c) { return insert(0, c); }
inline QString &prepend(const QString &s) { return insert(0, s); }
inline QString &prepend(const QLatin1String &s) { return insert(0, s); }

inline QString &operator+=(QChar c) {
if (d->ref != 1 || d->size + 1 > d->alloc)
realloc(grow(d->size + 1));
d->data[d->size++] = c.unicode();
d->data[d->size] = '\0';
return *this;
}

inline QString &operator+=(QChar::SpecialCharacter c) { return append(QChar(c)); }
inline QString &operator+=(const QString &s) { return append(s); }
inline QString &operator+=(const QStringRef &s) { return append(s); }
inline QString &operator+=(const QLatin1String &s) { return append(s); }

QString &remove(int i, int len);
QString &remove(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive);
QString &remove(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive);
QString &replace(int i, int len, QChar after);
QString &replace(int i, int len, const QChar *s, int slen);
QString &replace(int i, int len, const QString &after);
QString &replace(QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
QString &replace(const QChar *before, int blen, const QChar *after, int alen, Qt::CaseSensitivity cs = Qt::CaseSensitive);
QString &replace(const QLatin1String &before, const QLatin1String &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
QString &replace(const QLatin1String &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
QString &replace(const QString &before, const QLatin1String &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
QString &replace(const QString &before, const QString &after,
Qt::CaseSensitivity cs = Qt::CaseSensitive);
QString &replace(QChar c, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
QString &replace(QChar c, const QLatin1String &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);

# 289 "/usr/share/qt4/include/QtCore/qstring.h"
QString &replace(const QRegExp &rx, const QString &after);
inline QString &remove(const QRegExp &rx)
{ return replace(rx, QString()); }


# 294 "/usr/share/qt4/include/QtCore/qstring.h"
enum SplitBehavior { KeepEmptyParts, SkipEmptyParts };

QStringList split(const QString &sep, SplitBehavior behavior = KeepEmptyParts,
Qt::CaseSensitivity cs = Qt::CaseSensitive) const ;
QStringList split(const QChar &sep, SplitBehavior behavior = KeepEmptyParts,
Qt::CaseSensitivity cs = Qt::CaseSensitive) const ;

# 301 "/usr/share/qt4/include/QtCore/qstring.h"
QStringList split(const QRegExp &sep, SplitBehavior behavior = KeepEmptyParts) const ;


# 304 "/usr/share/qt4/include/QtCore/qstring.h"
enum NormalizationForm {
NormalizationForm_D,
NormalizationForm_C,
NormalizationForm_KD,
NormalizationForm_KC
};
QString normalized(NormalizationForm mode) const ;
QString normalized(NormalizationForm mode, QChar::UnicodeVersion version) const ;

QString repeated(int times) const;

const ushort *utf16() const;

QByteArray toAscii() const ;
QByteArray toLatin1() const ;
QByteArray toUtf8() const ;
QByteArray toLocal8Bit() const ;
QVector<uint> toUcs4() const ;

static QString fromAscii(const char *, int size = -1);
static QString fromLatin1(const char *, int size = -1);
static QString fromUtf8(const char *, int size = -1);
static QString fromLocal8Bit(const char *, int size = -1);
static QString fromUtf16(const ushort *, int size = -1);
static QString fromUcs4(const uint *, int size = -1);
static QString fromRawData(const QChar *, int size);

int toWCharArray(wchar_t *array) const;
static QString fromWCharArray(const wchar_t *, int size = -1);

QString &setUnicode(const QChar *unicode, int size);
inline QString &setUtf16(const ushort *utf16, int size);


int compare(const QString &s) const;
int compare(const QString &s, Qt::CaseSensitivity cs) const;

int compare(const QLatin1String &other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;


static inline int compare(const QString &s1, const QString &s2)
{ return s1.compare(s2); }
static inline int compare(const QString &s1, const QString &s2, Qt::CaseSensitivity cs)
{ return s1.compare(s2, cs); }

static inline int compare(const QString& s1, const QLatin1String &s2,
Qt::CaseSensitivity cs = Qt::CaseSensitive)
{ return s1.compare(s2, cs); }
static inline int compare(const QLatin1String& s1, const QString &s2,
Qt::CaseSensitivity cs = Qt::CaseSensitive)
{ return -s2.compare(s1, cs); }

int compare(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
static int compare(const QString &s1, const QStringRef &s2,
Qt::CaseSensitivity = Qt::CaseSensitive);

int localeAwareCompare(const QString& s) const;
static int localeAwareCompare(const QString& s1, const QString& s2)
{ return s1.localeAwareCompare(s2); }

int localeAwareCompare(const QStringRef &s) const;
static int localeAwareCompare(const QString& s1, const QStringRef& s2);

short toShort(bool *ok=0, int base=10) const;
ushort toUShort(bool *ok=0, int base=10) const;
int toInt(bool *ok=0, int base=10) const;
uint toUInt(bool *ok=0, int base=10) const;
long toLong(bool *ok=0, int base=10) const;
ulong toULong(bool *ok=0, int base=10) const;
qlonglong toLongLong(bool *ok=0, int base=10) const;
qulonglong toULongLong(bool *ok=0, int base=10) const;
float toFloat(bool *ok=0) const;
double toDouble(bool *ok=0) const;

QString &setNum(short, int base=10);
QString &setNum(ushort, int base=10);
QString &setNum(int, int base=10);
QString &setNum(uint, int base=10);
QString &setNum(long, int base=10);
QString &setNum(ulong, int base=10);
QString &setNum(qlonglong, int base=10);
QString &setNum(qulonglong, int base=10);
QString &setNum(float, char f='g', int prec=6);
QString &setNum(double, char f='g', int prec=6);

static QString number(int, int base=10);
static QString number(uint, int base=10);
static QString number(long, int base=10);
static QString number(ulong, int base=10);
static QString number(qlonglong, int base=10);
static QString number(qulonglong, int base=10);
static QString number(double, char f='g', int prec=6);

bool operator==(const QString &s) const;
bool operator<(const QString &s) const;
inline bool operator>(const QString &s) const { return s < *this; }
inline bool operator!=(const QString &s) const { return !operator==(s); }
inline bool operator<=(const QString &s) const { return !operator>(s); }
inline bool operator>=(const QString &s) const { return !operator<(s); }

bool operator==(const QLatin1String &s) const;
bool operator<(const QLatin1String &s) const;
bool operator>(const QLatin1String &s) const;
inline bool operator!=(const QLatin1String &s) const { return !operator==(s); }
inline bool operator<=(const QLatin1String &s) const { return !operator>(s); }
inline bool operator>=(const QLatin1String &s) const { return !operator<(s); }



# 413 "/usr/share/qt4/include/QtCore/qstring.h"
inline  QString(const char *ch) : d(fromAscii_helper(ch))
{}
inline  QString(const QByteArray &a)
: d(fromAscii_helper(a.constData(), qstrnlen(a.constData(), a.size())))
{}
inline  QString &operator=(const char *ch)
{ return (*this = fromAscii(ch)); }
inline  QString &operator=(const QByteArray &a)
{ return (*this = fromAscii(a.constData(), qstrnlen(a.constData(), a.size()))); }
inline  QString &operator=(char c)
{ return (*this = QChar::fromAscii(c)); }


inline  QString &prepend(const char *s)
{ return prepend(QString::fromAscii(s)); }
inline  QString &prepend(const QByteArray &s)
{ return prepend(QString::fromAscii(s.constData(), qstrnlen(s.constData(), s.size()))); }
inline  QString &append(const char *s)
{ return append(QString::fromAscii(s)); }
inline  QString &append(const QByteArray &s)
{ return append(QString::fromAscii(s.constData(), qstrnlen(s.constData(), s.size()))); }
inline  QString &operator+=(const char *s)
{ return append(QString::fromAscii(s)); }
inline  QString &operator+=(const QByteArray &s)
{ return append(QString::fromAscii(s.constData(), qstrnlen(s.constData(), s.size()))); }
inline  QString &operator+=(char c)
{ return append(QChar::fromAscii(c)); }

inline  bool operator==(const char *s) const;
inline  bool operator!=(const char *s) const;
inline  bool operator<(const char *s) const;
inline  bool operator<=(const char *s2) const;
inline  bool operator>(const char *s2) const;
inline  bool operator>=(const char *s2) const;

inline  bool operator==(const QByteArray &s) const;
inline  bool operator!=(const QByteArray &s) const;
inline  bool operator<(const QByteArray &s) const
{ return *this < QString::fromAscii(s.constData(), s.size()); }
inline  bool operator>(const QByteArray &s) const
{ return *this > QString::fromAscii(s.constData(), s.size()); }
inline  bool operator<=(const QByteArray &s) const
{ return *this <= QString::fromAscii(s.constData(), s.size()); }
inline  bool operator>=(const QByteArray &s) const
{ return *this >= QString::fromAscii(s.constData(), s.size()); }


# 460 "/usr/share/qt4/include/QtCore/qstring.h"
typedef QChar *iterator;
typedef const QChar *const_iterator;
typedef iterator Iterator;
typedef const_iterator ConstIterator;
iterator begin();
const_iterator begin() const;
const_iterator constBegin() const;
iterator end();
const_iterator end() const;
const_iterator constEnd() const;


inline void push_back(QChar c) { append(c); }
inline void push_back(const QString &s) { append(s); }
inline void push_front(QChar c) { prepend(c); }
inline void push_front(const QString &s) { prepend(s); }















# 491 "/usr/share/qt4/include/QtCore/qstring.h"

struct Null { };
static const Null null;
inline QString(const Null &): d(&shared_null) { d->ref.ref(); }
inline QString &operator=(const Null &) { *this = QString(); return *this; }
inline bool isNull() const { return d == &shared_null; }


















































































# 579 "/usr/share/qt4/include/QtCore/qstring.h"
bool isSimpleText() const { if (!d->clean) updateProperties(); return d->simpletext; }
bool isRightToLeft() const { if (!d->clean) updateProperties(); return d->righttoleft; }

QString(int size, Qt::Initialization);

private:









# 594 "/usr/share/qt4/include/QtCore/qstring.h"
struct Data {
QBasicAtomicInt ref;
int alloc, size;
ushort *data;
ushort clean : 1;
ushort simpletext : 1;
ushort righttoleft : 1;
ushort asciiCache : 1;
ushort capacity : 1;
ushort reserved : 11;
ushort array[1];
};
static Data shared_null;
static Data shared_empty;
Data *d;
QString(Data *dd, int ) : d(dd) {}

# 611 "/usr/share/qt4/include/QtCore/qstring.h"
static QTextCodec *codecForCStrings;

# 613 "/usr/share/qt4/include/QtCore/qstring.h"
static int grow(int);
static void free(Data *);
void realloc();
void realloc(int alloc);
void expand(int i);
void updateProperties() const;
QString multiArg(int numArgs, const QString **args) const;
static int compare_helper(const QChar *data1, int length1,
const QChar *data2, int length2,
Qt::CaseSensitivity cs = Qt::CaseSensitive);
static int compare_helper(const QChar *data1, int length1,
QLatin1String s2,
Qt::CaseSensitivity cs = Qt::CaseSensitive);
static int localeAwareCompare_helper(const QChar *data1, int length1,
const QChar *data2, int length2);
static Data *fromLatin1_helper(const char *str, int size = -1);
static Data *fromAscii_helper(const char *str, int size = -1);
void replace_helper(uint *indices, int nIndices, int blen, const QChar *after, int alen);
friend class QCharRef;
friend class QTextCodec;
friend class QStringRef;
friend struct QAbstractConcatenable;
friend inline bool qStringComparisonHelper(const QString &s1, const char *s2);
friend inline bool qStringComparisonHelper(const QStringRef &s1, const char *s2);
public:
typedef Data * DataPtr;
inline DataPtr &data_ptr() { return d; }
};


class  QLatin1String
{
public:
inline explicit QLatin1String(const char *s) : chars(s) {}
inline QLatin1String &operator=(const QLatin1String &other)
{ chars = other.chars; return *this; }

inline const char *latin1() const { return chars; }

inline bool operator==(const QString &s) const
{ return s == *this; }
inline bool operator!=(const QString &s) const
{ return s != *this; }
inline bool operator>(const QString &s) const
{ return s < *this; }
inline bool operator<(const QString &s) const
{ return s > *this; }
inline bool operator>=(const QString &s) const
{ return s <= *this; }
inline bool operator<=(const QString &s) const
{ return s >= *this; }

inline  bool operator==(const char *s) const
{ return QString::fromAscii(s) == *this; }
inline  bool operator!=(const char *s) const
{ return QString::fromAscii(s) != *this; }
inline  bool operator<(const char *s) const
{ return QString::fromAscii(s) > *this; }
inline  bool operator>(const char *s) const
{ return QString::fromAscii(s) < *this; }
inline  bool operator<=(const char *s) const
{ return QString::fromAscii(s) >= *this; }
inline  bool operator>=(const char *s) const
{ return QString::fromAscii(s) <= *this; }
private:
const char *chars;
};



inline QString::QString(const QLatin1String &aLatin1) : d(fromLatin1_helper(aLatin1.latin1()))
{ }
inline int QString::length() const
{ return d->size; }
inline const QChar QString::at(int i) const
{ qt_noop(); return d->data[i]; }
inline const QChar QString::operator[](int i) const
{ qt_noop(); return d->data[i]; }
inline const QChar QString::operator[](uint i) const
{ qt_noop(); return d->data[i]; }
inline bool QString::isEmpty() const
{ return d->size == 0; }
inline const QChar *QString::unicode() const
{ return reinterpret_cast<const QChar*>(d->data); }
inline const QChar *QString::data() const
{ return reinterpret_cast<const QChar*>(d->data); }
inline QChar *QString::data()
{ detach(); return reinterpret_cast<QChar*>(d->data); }
inline const QChar *QString::constData() const
{ return reinterpret_cast<const QChar*>(d->data); }
inline void QString::detach()
{ if (d->ref != 1 || d->data != d->array) realloc(); }
inline bool QString::isDetached() const
{ return d->ref == 1; }
inline QString &QString::operator=(const QLatin1String &s)
{
*this = fromLatin1(s.latin1());
return *this;
}
inline void QString::clear()
{ if (!isNull()) *this = QString(); }
inline QString::QString(const QString &other) : d(other.d)
{ qt_noop(); d->ref.ref(); }
inline int QString::capacity() const
{ return d->alloc; }
inline QString &QString::setNum(short n, int base)
{ return setNum(qlonglong(n), base); }
inline QString &QString::setNum(ushort n, int base)
{ return setNum(qulonglong(n), base); }
inline QString &QString::setNum(int n, int base)
{ return setNum(qlonglong(n), base); }
inline QString &QString::setNum(uint n, int base)
{ return setNum(qulonglong(n), base); }
inline QString &QString::setNum(long n, int base)
{ return setNum(qlonglong(n), base); }
inline QString &QString::setNum(ulong n, int base)
{ return setNum(qulonglong(n), base); }
inline QString &QString::setNum(float n, char f, int prec)
{ return setNum(double(n),f,prec); }
inline QString QString::arg(int a, int fieldWidth, int base, const QChar &fillChar) const
{ return arg(qlonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(uint a, int fieldWidth, int base, const QChar &fillChar) const
{ return arg(qulonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(long a, int fieldWidth, int base, const QChar &fillChar) const
{ return arg(qlonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(ulong a, int fieldWidth, int base, const QChar &fillChar) const
{ return arg(qulonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(short a, int fieldWidth, int base, const QChar &fillChar) const
{ return arg(qlonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(ushort a, int fieldWidth, int base, const QChar &fillChar) const
{ return arg(qulonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(const QString &a1, const QString &a2) const
{ const QString *args[2] = { &a1, &a2 }; return multiArg(2, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3) const
{ const QString *args[3] = { &a1, &a2, &a3 }; return multiArg(3, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3,
const QString &a4) const
{ const QString *args[4] = { &a1, &a2, &a3, &a4 }; return multiArg(4, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3,
const QString &a4, const QString &a5) const
{ const QString *args[5] = { &a1, &a2, &a3, &a4, &a5 }; return multiArg(5, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3,
const QString &a4, const QString &a5, const QString &a6) const
{ const QString *args[6] = { &a1, &a2, &a3, &a4, &a5, &a6 }; return multiArg(6, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3,
const QString &a4, const QString &a5, const QString &a6,
const QString &a7) const
{ const QString *args[7] = { &a1, &a2, &a3, &a4, &a5, &a6, &a7 }; return multiArg(7, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3,
const QString &a4, const QString &a5, const QString &a6,
const QString &a7, const QString &a8) const
{ const QString *args[8] = { &a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8 }; return multiArg(8, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3,
const QString &a4, const QString &a5, const QString &a6,
const QString &a7, const QString &a8, const QString &a9) const
{ const QString *args[9] = { &a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9 }; return multiArg(9, args); }

inline QString QString::section(QChar asep, int astart, int aend, SectionFlags aflags) const
{ return section(QString(asep), astart, aend, aflags); }


class  QCharRef {
QString &s;
int i;
inline QCharRef(QString &str, int idx)
: s(str),i(idx) {}
friend class QString;
public:




inline operator QChar() const
{ return i < s.d->size ? s.d->data[i] : 0; }
inline QCharRef &operator=(const QChar &c)
{ if (i >= s.d->size) s.expand(i); else s.detach();
s.d->data[i] = c.unicode(); return *this; }



# 793 "/usr/share/qt4/include/QtCore/qstring.h"
inline  QCharRef &operator=(char c)
{ return operator=(QChar::fromAscii(c)); }
inline  QCharRef &operator=(uchar c)
{ return operator=(QChar::fromAscii(c)); }

# 798 "/usr/share/qt4/include/QtCore/qstring.h"
inline QCharRef &operator=(const QCharRef &c) { return operator=(QChar(c)); }
inline QCharRef &operator=(ushort rc) { return operator=(QChar(rc)); }
inline QCharRef &operator=(short rc) { return operator=(QChar(rc)); }
inline QCharRef &operator=(uint rc) { return operator=(QChar(rc)); }
inline QCharRef &operator=(int rc) { return operator=(QChar(rc)); }


inline bool isNull() const { return QChar(*this).isNull(); }
inline bool isPrint() const { return QChar(*this).isPrint(); }
inline bool isPunct() const { return QChar(*this).isPunct(); }
inline bool isSpace() const { return QChar(*this).isSpace(); }
inline bool isMark() const { return QChar(*this).isMark(); }
inline bool isLetter() const { return QChar(*this).isLetter(); }
inline bool isNumber() const { return QChar(*this).isNumber(); }
inline bool isLetterOrNumber() { return QChar(*this).isLetterOrNumber(); }
inline bool isDigit() const { return QChar(*this).isDigit(); }
inline bool isLower() const { return QChar(*this).isLower(); }
inline bool isUpper() const { return QChar(*this).isUpper(); }
inline bool isTitleCase() const { return QChar(*this).isTitleCase(); }

inline int digitValue() const { return QChar(*this).digitValue(); }
QChar toLower() const { return QChar(*this).toLower(); }
QChar toUpper() const { return QChar(*this).toUpper(); }
QChar toTitleCase () const { return QChar(*this).toTitleCase(); }

QChar::Category category() const { return QChar(*this).category(); }
QChar::Direction direction() const { return QChar(*this).direction(); }
QChar::Joining joining() const { return QChar(*this).joining(); }
bool hasMirrored() const { return QChar(*this).hasMirrored(); }
QChar mirroredChar() const { return QChar(*this).mirroredChar(); }
QString decomposition() const { return QChar(*this).decomposition(); }
QChar::Decomposition decompositionTag() const { return QChar(*this).decompositionTag(); }
uchar combiningClass() const { return QChar(*this).combiningClass(); }

QChar::UnicodeVersion unicodeVersion() const { return QChar(*this).unicodeVersion(); }

inline uchar cell() const { return QChar(*this).cell(); }
inline uchar row() const { return QChar(*this).row(); }
inline void setCell(uchar cell);
inline void setRow(uchar row);






# 844 "/usr/share/qt4/include/QtCore/qstring.h"
char toAscii() const { return QChar(*this).toAscii(); }
char toLatin1() const { return QChar(*this).toLatin1(); }
ushort unicode() const { return QChar(*this).unicode(); }

# 848 "/usr/share/qt4/include/QtCore/qstring.h"
ushort& unicode() { return s.data()[i].unicode(); }













# 862 "/usr/share/qt4/include/QtCore/qstring.h"
};

inline void QCharRef::setRow(uchar arow) { QChar(*this).setRow(arow); }
inline void QCharRef::setCell(uchar acell) { QChar(*this).setCell(acell); }


inline QString::QString() : d(&shared_null) { d->ref.ref(); }
inline QString::~QString() { if (!d->ref.deref()) free(d); }
inline void QString::reserve(int asize) { if (d->ref != 1 || asize > d->alloc) realloc(asize); d->capacity = 1;}
inline QString &QString::setUtf16(const ushort *autf16, int asize)
{ return setUnicode(reinterpret_cast<const QChar *>(autf16), asize); }
inline QCharRef QString::operator[](int i)
{ qt_noop(); return QCharRef(*this, i); }
inline QCharRef QString::operator[](uint i)
{ return QCharRef(*this, i); }
inline QString::iterator QString::begin()
{ detach(); return reinterpret_cast<QChar*>(d->data); }
inline QString::const_iterator QString::begin() const
{ return reinterpret_cast<const QChar*>(d->data); }
inline QString::const_iterator QString::constBegin() const
{ return reinterpret_cast<const QChar*>(d->data); }
inline QString::iterator QString::end()
{ detach(); return reinterpret_cast<QChar*>(d->data + d->size); }
inline QString::const_iterator QString::end() const
{ return reinterpret_cast<const QChar*>(d->data + d->size); }
inline QString::const_iterator QString::constEnd() const
{ return reinterpret_cast<const QChar*>(d->data + d->size); }
inline QBool QString::contains(const QString &s, Qt::CaseSensitivity cs) const
{ return QBool(indexOf(s, 0, cs) != -1); }
inline QBool QString::contains(QChar c, Qt::CaseSensitivity cs) const
{ return QBool(indexOf(c, 0, cs) != -1); }


inline bool operator==(QString::Null, QString::Null) { return true; }
inline bool operator==(QString::Null, const QString &s) { return s.isNull(); }
inline bool operator==(const QString &s, QString::Null) { return s.isNull(); }
inline bool operator!=(QString::Null, QString::Null) { return false; }
inline bool operator!=(QString::Null, const QString &s) { return !s.isNull(); }
inline bool operator!=(const QString &s, QString::Null) { return !s.isNull(); }


# 903 "/usr/share/qt4/include/QtCore/qstring.h"
inline bool qStringComparisonHelper(const QString &s1, const char *s2)
{

# 906 "/usr/share/qt4/include/QtCore/qstring.h"
if (QString::codecForCStrings) return (s1 == QString::fromAscii(s2));

# 908 "/usr/share/qt4/include/QtCore/qstring.h"
return (s1 == QLatin1String(s2));
}
inline bool QString::operator==(const char *s) const
{ return qStringComparisonHelper(*this, s); }
inline bool QString::operator!=(const char *s) const
{ return !qStringComparisonHelper(*this, s); }
inline bool QString::operator<(const char *s) const
{ return *this < QString::fromAscii(s); }
inline bool QString::operator>(const char *s) const
{ return *this > QString::fromAscii(s); }
inline bool QString::operator<=(const char *s) const
{ return *this <= QString::fromAscii(s); }
inline bool QString::operator>=(const char *s) const
{ return *this >= QString::fromAscii(s); }

inline  bool operator==(const char *s1, const QString &s2)
{ return qStringComparisonHelper(s2, s1); }
inline  bool operator!=(const char *s1, const QString &s2)
{ return !qStringComparisonHelper(s2, s1); }
inline  bool operator<(const char *s1, const QString &s2)
{ return (QString::fromAscii(s1) < s2); }
inline  bool operator>(const char *s1, const QString &s2)
{ return (QString::fromAscii(s1) > s2); }
inline  bool operator<=(const char *s1, const QString &s2)
{ return (QString::fromAscii(s1) <= s2); }
inline  bool operator>=(const char *s1, const QString &s2)
{ return (QString::fromAscii(s1) >= s2); }

inline  bool operator==(const char *s1, const QLatin1String &s2)
{ return QString::fromAscii(s1) == s2; }
inline  bool operator!=(const char *s1, const QLatin1String &s2)
{ return QString::fromAscii(s1) != s2; }
inline  bool operator<(const char *s1, const QLatin1String &s2)
{ return (QString::fromAscii(s1) < s2); }
inline  bool operator>(const char *s1, const QLatin1String &s2)
{ return (QString::fromAscii(s1) > s2); }
inline  bool operator<=(const char *s1, const QLatin1String &s2)
{ return (QString::fromAscii(s1) <= s2); }
inline  bool operator>=(const char *s1, const QLatin1String &s2)
{ return (QString::fromAscii(s1) >= s2); }

inline bool operator==(const QLatin1String &s1, const QLatin1String &s2)
{ return (qstrcmp(s1.latin1(), s2.latin1()) == 0); }
inline bool operator!=(const QLatin1String &s1, const QLatin1String &s2)
{ return (qstrcmp(s1.latin1(), s2.latin1()) != 0); }
inline bool operator<(const QLatin1String &s1, const QLatin1String &s2)
{ return (qstrcmp(s1.latin1(), s2.latin1()) < 0); }
inline bool operator<=(const QLatin1String &s1, const QLatin1String &s2)
{ return (qstrcmp(s1.latin1(), s2.latin1()) <= 0); }
inline bool operator>(const QLatin1String &s1, const QLatin1String &s2)
{ return (qstrcmp(s1.latin1(), s2.latin1()) > 0); }
inline bool operator>=(const QLatin1String &s1, const QLatin1String &s2)
{ return (qstrcmp(s1.latin1(), s2.latin1()) >= 0); }


inline bool QString::operator==(const QByteArray &s) const
{ return qStringComparisonHelper(*this, s.constData()); }
inline bool QString::operator!=(const QByteArray &s) const
{ return !qStringComparisonHelper(*this, s.constData()); }

inline bool QByteArray::operator==(const QString &s) const
{ return qStringComparisonHelper(s, constData()); }
inline bool QByteArray::operator!=(const QString &s) const
{ return !qStringComparisonHelper(s, constData()); }
inline bool QByteArray::operator<(const QString &s) const
{ return QString::fromAscii(constData(), size()) < s; }
inline bool QByteArray::operator>(const QString &s) const
{ return QString::fromAscii(constData(), size()) > s; }
inline bool QByteArray::operator<=(const QString &s) const
{ return QString::fromAscii(constData(), size()) <= s; }
inline bool QByteArray::operator>=(const QString &s) const
{ return QString::fromAscii(constData(), size()) >= s; }



# 983 "/usr/share/qt4/include/QtCore/qstring.h"
inline QByteArray &QByteArray::append(const QString &s)
{ return append(s.toAscii()); }
inline QByteArray &QByteArray::insert(int i, const QString &s)
{ return insert(i, s.toAscii()); }
inline QByteArray &QByteArray::replace(char c, const QString &after)
{ return replace(c, after.toAscii()); }
inline QByteArray &QByteArray::replace(const QString &before, const char *after)
{ return replace(before.toAscii(), after); }
inline QByteArray &QByteArray::replace(const QString &before, const QByteArray &after)
{ return replace(before.toAscii(), after); }
inline QByteArray &QByteArray::operator+=(const QString &s)
{ return operator+=(s.toAscii()); }
inline int QByteArray::indexOf(const QString &s, int from) const
{ return indexOf(s.toAscii(), from); }
inline int QByteArray::lastIndexOf(const QString &s, int from) const
{ return lastIndexOf(s.toAscii(), from); }










# 1009 "/usr/share/qt4/include/QtCore/qstring.h"
inline const QString operator+(const QString &s1, const QString &s2)
{ QString t(s1); t += s2; return t; }
inline const QString operator+(const QString &s1, QChar s2)
{ QString t(s1); t += s2; return t; }
inline const QString operator+(QChar s1, const QString &s2)
{ QString t(s1); t += s2; return t; }

# 1016 "/usr/share/qt4/include/QtCore/qstring.h"
inline  const QString operator+(const QString &s1, const char *s2)
{ QString t(s1); t += QString::fromAscii(s2); return t; }
inline  const QString operator+(const char *s1, const QString &s2)
{ QString t = QString::fromAscii(s1); t += s2; return t; }
inline  const QString operator+(char c, const QString &s)
{ QString t = s; t.prepend(QChar::fromAscii(c)); return t; }
inline  const QString operator+(const QString &s, char c)
{ QString t = s; t += QChar::fromAscii(c); return t; }
inline  const QString operator+(const QByteArray &ba, const QString &s)
{ QString t = QString::fromAscii(ba.constData(), qstrnlen(ba.constData(), ba.size())); t += s; return t; }
inline  const QString operator+(const QString &s, const QByteArray &ba)
{ QString t(s); t += QString::fromAscii(ba.constData(), qstrnlen(ba.constData(), ba.size())); return t; }









































# 1069 "/usr/share/qt4/include/QtCore/qstring.h"
 QDataStream &operator<<(QDataStream &, const QString &);
 QDataStream &operator>>(QDataStream &, QString &);












# 1083 "/usr/share/qt4/include/QtCore/qstring.h"
template <> class QTypeInfo<QString > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QString)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QString"; } };
template <> inline bool qIsDetached<QString>(QString &t) { return t.isDetached(); } template <> inline void qSwap<QString>(QString &value1, QString &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }
inline QFlags<QString::SectionFlags::enum_type> operator|(QString::SectionFlags::enum_type f1, QString::SectionFlags::enum_type f2) { return QFlags<QString::SectionFlags::enum_type>(f1) | f2; } inline QFlags<QString::SectionFlags::enum_type> operator|(QString::SectionFlags::enum_type f1, QFlags<QString::SectionFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QString::SectionFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }








# 1094 "/usr/share/qt4/include/QtCore/qstring.h"
class  QStringRef {
const QString *m_string;
int m_position;
int m_size;
public:
inline QStringRef():m_string(0), m_position(0), m_size(0){}
inline QStringRef(const QString *string, int position, int size);
inline QStringRef(const QString *string);
inline QStringRef(const QStringRef &other)
:m_string(other.m_string), m_position(other.m_position), m_size(other.m_size)
{}

inline ~QStringRef(){}
inline const QString *string() const { return m_string; }
inline int position() const { return m_position; }
inline int size() const { return m_size; }
inline int count() const { return m_size; }
inline int length() const { return m_size; }

inline QStringRef &operator=(const QStringRef &other) {
m_string = other.m_string; m_position = other.m_position;
m_size = other.m_size; return *this;
}

inline QStringRef &operator=(const QString *string);

inline const QChar *unicode() const {
if (!m_string)
return reinterpret_cast<const QChar *>(QString::shared_null.data);
return m_string->unicode() + m_position;
}
inline const QChar *data() const { return unicode(); }
inline const QChar *constData() const { return unicode(); }

inline void clear() { m_string = 0; m_position = m_size = 0; }
QString toString() const;
inline bool isEmpty() const { return m_size == 0; }
inline bool isNull() const { return m_string == 0 || m_string->isNull(); }

QStringRef appendTo(QString *string) const;

inline const QChar at(int i) const
{ qt_noop(); return m_string->at(i + m_position); }

int compare(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
int compare(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
int compare(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
static int compare(const QStringRef &s1, const QString &s2,
Qt::CaseSensitivity = Qt::CaseSensitive);
static int compare(const QStringRef &s1, const QStringRef &s2,
Qt::CaseSensitivity = Qt::CaseSensitive);
static int compare(const QStringRef &s1, QLatin1String s2,
Qt::CaseSensitivity cs = Qt::CaseSensitive);

int localeAwareCompare(const QString &s) const;
int localeAwareCompare(const QStringRef &s) const;
static int localeAwareCompare(const QStringRef &s1, const QString &s2);
static int localeAwareCompare(const QStringRef &s1, const QStringRef &s2);
};

inline QStringRef &QStringRef::operator=(const QString *aString)
{ m_string = aString; m_position = 0; m_size = aString?aString->size():0; return *this; }

inline QStringRef::QStringRef(const QString *aString, int aPosition, int aSize)
:m_string(aString), m_position(aPosition), m_size(aSize){}

inline QStringRef::QStringRef(const QString *aString)
:m_string(aString), m_position(0), m_size(aString?aString->size() : 0){}

 bool operator==(const QStringRef &s1,const QStringRef &s2);
inline bool operator!=(const QStringRef &s1,const QStringRef &s2)
{ return !(s1 == s2); }
 bool operator==(const QString &s1,const QStringRef &s2);
inline bool operator!=(const QString &s1,const QStringRef &s2)
{ return !(s1 == s2); }
inline bool operator==(const QStringRef &s1,const QString &s2)
{ return s2 == s1; }
inline bool operator!=(const QStringRef &s1,const QString &s2)
{ return s2 != s1; }
 bool operator==(const QLatin1String &s1, const QStringRef &s2);
inline bool operator!=(const QLatin1String &s1,const QStringRef &s2)
{ return !(s1 == s2); }
inline bool operator==(const QStringRef &s1,const QLatin1String &s2)
{ return s2 == s1; }
inline bool operator!=(const QStringRef &s1,const QLatin1String &s2)
{ return s2 != s1; }

 bool operator<(const QStringRef &s1,const QStringRef &s2);
inline bool operator>(const QStringRef &s1, const QStringRef &s2)
{ return s2 < s1; }
inline bool operator<=(const QStringRef &s1, const QStringRef &s2)
{ return !(s1 > s2); }
inline bool operator>=(const QStringRef &s1, const QStringRef &s2)
{ return !(s1 < s2); }

inline bool qStringComparisonHelper(const QStringRef &s1, const char *s2)
{

# 1192 "/usr/share/qt4/include/QtCore/qstring.h"
if (QString::codecForCStrings) return (s1 == QString::fromAscii(s2));

# 1194 "/usr/share/qt4/include/QtCore/qstring.h"
return (s1 == QLatin1String(s2));
}

inline  bool operator==(const char *s1, const QStringRef &s2)
{ return qStringComparisonHelper(s2, s1); }
inline  bool operator==(const QStringRef &s1, const char *s2)
{ return qStringComparisonHelper(s1, s2); }
inline  bool operator!=(const char *s1, const QStringRef &s2)
{ return !qStringComparisonHelper(s2, s1); }
inline  bool operator!=(const QStringRef &s1, const char *s2)
{ return !qStringComparisonHelper(s1, s2); }

inline int QString::compare(const QStringRef &s, Qt::CaseSensitivity cs) const
{ return QString::compare_helper(constData(), length(), s.constData(), s.length(), cs); }
inline int QString::compare(const QString &s1, const QStringRef &s2, Qt::CaseSensitivity cs)
{ return QString::compare_helper(s1.constData(), s1.length(), s2.constData(), s2.length(), cs); }
inline int QStringRef::compare(const QString &s, Qt::CaseSensitivity cs) const
{ return QString::compare_helper(constData(), length(), s.constData(), s.length(), cs); }
inline int QStringRef::compare(const QStringRef &s, Qt::CaseSensitivity cs) const
{ return QString::compare_helper(constData(), length(), s.constData(), s.length(), cs); }
inline int QStringRef::compare(QLatin1String s, Qt::CaseSensitivity cs) const
{ return QString::compare_helper(constData(), length(), s, cs); }
inline int QStringRef::compare(const QStringRef &s1, const QString &s2, Qt::CaseSensitivity cs)
{ return QString::compare_helper(s1.constData(), s1.length(), s2.constData(), s2.length(), cs); }
inline int QStringRef::compare(const QStringRef &s1, const QStringRef &s2, Qt::CaseSensitivity cs)
{ return QString::compare_helper(s1.constData(), s1.length(), s2.constData(), s2.length(), cs); }
inline int QStringRef::compare(const QStringRef &s1, QLatin1String s2, Qt::CaseSensitivity cs)
{ return QString::compare_helper(s1.constData(), s1.length(), s2, cs); }

inline int QString::localeAwareCompare(const QStringRef &s) const
{ return localeAwareCompare_helper(constData(), length(), s.constData(), s.length()); }
inline int QString::localeAwareCompare(const QString& s1, const QStringRef& s2)
{ return localeAwareCompare_helper(s1.constData(), s1.length(), s2.constData(), s2.length()); }
inline int QStringRef::localeAwareCompare(const QString &s) const
{ return QString::localeAwareCompare_helper(constData(), length(), s.constData(), s.length()); }
inline int QStringRef::localeAwareCompare(const QStringRef &s) const
{ return QString::localeAwareCompare_helper(constData(), length(), s.constData(), s.length()); }
inline int QStringRef::localeAwareCompare(const QStringRef &s1, const QString &s2)
{ return QString::localeAwareCompare_helper(s1.constData(), s1.length(), s2.constData(), s2.length()); }
inline int QStringRef::localeAwareCompare(const QStringRef &s1, const QStringRef &s2)
{ return QString::localeAwareCompare_helper(s1.constData(), s1.length(), s2.constData(), s2.length()); }











# 45 "/usr/share/qt4/include/QtCore/qdir.h"

# 1 "/usr/share/qt4/include/QtCore/qfileinfo.h"












































# 1 "/usr/share/qt4/include/QtCore/qfile.h"












































# 1 "/usr/share/qt4/include/QtCore/qiodevice.h"













































# 1 "/usr/share/qt4/include/QtCore/qobject.h"














































# 1 "/usr/share/qt4/include/QtCore/qobjectdefs.h"































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qobject.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtCore/qobject.h"

# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtCore/qobject.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"












































# 1 "/usr/share/qt4/include/QtCore/qiterator.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qiterator.h"


# 47 "/usr/share/qt4/include/QtCore/qiterator.h"


namespace std {
struct bidirectional_iterator_tag;
struct random_access_iterator_tag;
}



typedef QtValidLicenseForCoreModule QtCoreModule;









# 198 "/usr/share/qt4/include/QtCore/qiterator.h"





# 45 "/usr/share/qt4/include/QtCore/qlist.h"

# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 46 "/usr/share/qt4/include/QtCore/qlist.h"

# 1 "/usr/share/qt4/include/QtCore/qalgorithms.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qalgorithms.h"


# 47 "/usr/share/qt4/include/QtCore/qalgorithms.h"




typedef QtValidLicenseForCoreModule QtCoreModule;





namespace QAlgorithmsPrivate {

template <typename RandomAccessIterator, typename T, typename LessThan>
 void qSortHelper(RandomAccessIterator start, RandomAccessIterator end, const T &t, LessThan lessThan);
template <typename RandomAccessIterator, typename T>
inline void qSortHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &dummy);

template <typename RandomAccessIterator, typename T, typename LessThan>
 void qStableSortHelper(RandomAccessIterator start, RandomAccessIterator end, const T &t, LessThan lessThan);
template <typename RandomAccessIterator, typename T>
inline void qStableSortHelper(RandomAccessIterator, RandomAccessIterator, const T &);

template <typename RandomAccessIterator, typename T, typename LessThan>
 RandomAccessIterator qLowerBoundHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan);
template <typename RandomAccessIterator, typename T, typename LessThan>
 RandomAccessIterator qUpperBoundHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan);
template <typename RandomAccessIterator, typename T, typename LessThan>
 RandomAccessIterator qBinaryFindHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan);

}

template <typename InputIterator, typename OutputIterator>
inline OutputIterator qCopy(InputIterator begin, InputIterator end, OutputIterator dest)
{
while (begin != end)
*dest++ = *begin++;
return dest;
}

template <typename BiIterator1, typename BiIterator2>
inline BiIterator2 qCopyBackward(BiIterator1 begin, BiIterator1 end, BiIterator2 dest)
{
while (begin != end)
*--dest = *--end;
return dest;
}

template <typename InputIterator1, typename InputIterator2>
inline bool qEqual(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
for (; first1 != last1; ++first1, ++first2)
if (!(*first1 == *first2))
return false;
return true;
}

template <typename ForwardIterator, typename T>
inline void qFill(ForwardIterator first, ForwardIterator last, const T &val)
{
for (; first != last; ++first)
*first = val;
}

template <typename Container, typename T>
inline void qFill(Container &container, const T &val)
{
qFill(container.begin(), container.end(), val);
}

template <typename InputIterator, typename T>
inline InputIterator qFind(InputIterator first, InputIterator last, const T &val)
{
while (first != last && !(*first == val))
++first;
return first;
}

template <typename Container, typename T>
inline typename Container::const_iterator qFind(const Container &container, const T &val)
{
return qFind(container.constBegin(), container.constEnd(), val);
}

template <typename InputIterator, typename T, typename Size>
inline void qCount(InputIterator first, InputIterator last, const T &value, Size &n)
{
for (; first != last; ++first)
if (*first == value)
++n;
}

template <typename Container, typename T, typename Size>
inline void qCount(const Container &container, const T &value, Size &n)
{
qCount(container.constBegin(), container.constEnd(), value, n);
}












# 155 "/usr/share/qt4/include/QtCore/qalgorithms.h"
template <typename T>
class qLess
{
public:
inline bool operator()(const T &t1, const T &t2) const
{
return (t1 < t2);
}
};

template <typename T>
class qGreater
{
public:
inline bool operator()(const T &t1, const T &t2) const
{
return (t2 < t1);
}
};


# 176 "/usr/share/qt4/include/QtCore/qalgorithms.h"
template <typename RandomAccessIterator>
inline void qSort(RandomAccessIterator start, RandomAccessIterator end)
{
if (start != end)
QAlgorithmsPrivate::qSortHelper(start, end, *start);
}

template <typename RandomAccessIterator, typename LessThan>
inline void qSort(RandomAccessIterator start, RandomAccessIterator end, LessThan lessThan)
{
if (start != end)
QAlgorithmsPrivate::qSortHelper(start, end, *start, lessThan);
}

template<typename Container>
inline void qSort(Container &c)
{




# 197 "/usr/share/qt4/include/QtCore/qalgorithms.h"
if (!c.empty())
QAlgorithmsPrivate::qSortHelper(c.begin(), c.end(), *c.begin());
}

template <typename RandomAccessIterator>
inline void qStableSort(RandomAccessIterator start, RandomAccessIterator end)
{
if (start != end)
QAlgorithmsPrivate::qStableSortHelper(start, end, *start);
}

template <typename RandomAccessIterator, typename LessThan>
inline void qStableSort(RandomAccessIterator start, RandomAccessIterator end, LessThan lessThan)
{
if (start != end)
QAlgorithmsPrivate::qStableSortHelper(start, end, *start, lessThan);
}

template<typename Container>
inline void qStableSort(Container &c)
{




# 222 "/usr/share/qt4/include/QtCore/qalgorithms.h"
if (!c.empty())
QAlgorithmsPrivate::qStableSortHelper(c.begin(), c.end(), *c.begin());
}

template <typename RandomAccessIterator, typename T>
 RandomAccessIterator qLowerBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
{



RandomAccessIterator middle;
int n = end - begin;
int half;

while (n > 0) {
half = n >> 1;
middle = begin + half;
if (*middle < value) {
begin = middle + 1;
n -= half + 1;
} else {
n = half;
}
}
return begin;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
 RandomAccessIterator qLowerBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan)
{
return QAlgorithmsPrivate::qLowerBoundHelper(begin, end, value, lessThan);
}

template <typename Container, typename T>
 typename Container::const_iterator qLowerBound(const Container &container, const T &value)
{
return QAlgorithmsPrivate::qLowerBoundHelper(container.constBegin(), container.constEnd(), value, qLess<T>());
}

template <typename RandomAccessIterator, typename T>
 RandomAccessIterator qUpperBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
{

RandomAccessIterator middle;
int n = end - begin;
int half;

while (n > 0) {
half = n >> 1;
middle = begin + half;
if (value < *middle) {
n = half;
} else {
begin = middle + 1;
n -= half + 1;
}
}
return begin;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
 RandomAccessIterator qUpperBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan)
{
return QAlgorithmsPrivate::qUpperBoundHelper(begin, end, value, lessThan);
}

template <typename Container, typename T>
 typename Container::const_iterator qUpperBound(const Container &container, const T &value)
{
return QAlgorithmsPrivate::qUpperBoundHelper(container.constBegin(), container.constEnd(), value, qLess<T>());
}

template <typename RandomAccessIterator, typename T>
 RandomAccessIterator qBinaryFind(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
{

RandomAccessIterator it = qLowerBound(begin, end, value);

if (it == end || value < *it)
return end;

return it;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
 RandomAccessIterator qBinaryFind(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan)
{
return QAlgorithmsPrivate::qBinaryFindHelper(begin, end, value, lessThan);
}

template <typename Container, typename T>
 typename Container::const_iterator qBinaryFind(const Container &container, const T &value)
{
return QAlgorithmsPrivate::qBinaryFindHelper(container.constBegin(), container.constEnd(), value, qLess<T>());
}

template <typename ForwardIterator>
 void qDeleteAll(ForwardIterator begin, ForwardIterator end)
{
while (begin != end) {
delete *begin;
++begin;
}
}

template <typename Container>
inline void qDeleteAll(const Container &c)
{
qDeleteAll(c.begin(), c.end());
}





namespace QAlgorithmsPrivate {

template <typename RandomAccessIterator, typename T, typename LessThan>
 void qSortHelper(RandomAccessIterator start, RandomAccessIterator end, const T &t, LessThan lessThan)
{
top:
int span = int(end - start);
if (span < 2)
return;

--end;
RandomAccessIterator low = start, high = end - 1;
RandomAccessIterator pivot = start + span / 2;

if (lessThan(*end, *start))
qSwap(*end, *start);
if (span == 2)
return;

if (lessThan(*pivot, *start))
qSwap(*pivot, *start);
if (lessThan(*end, *pivot))
qSwap(*end, *pivot);
if (span == 3)
return;

qSwap(*pivot, *end);

while (low < high) {
while (low < high && lessThan(*low, *end))
++low;

while (high > low && lessThan(*end, *high))
--high;

if (low < high) {
qSwap(*low, *high);
++low;
--high;
} else {
break;
}
}

if (lessThan(*low, *end))
++low;

qSwap(*end, *low);
qSortHelper(start, low, t, lessThan);

start = low + 1;
++end;
goto top;
}

template <typename RandomAccessIterator, typename T>
inline void qSortHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &dummy)
{
qSortHelper(begin, end, dummy, qLess<T>());
}

template <typename RandomAccessIterator>
 void qReverse(RandomAccessIterator begin, RandomAccessIterator end)
{
--end;
while (begin < end)
qSwap(*begin++, *end--);
}

template <typename RandomAccessIterator>
 void qRotate(RandomAccessIterator begin, RandomAccessIterator middle, RandomAccessIterator end)
{
qReverse(begin, middle);
qReverse(middle, end);
qReverse(begin, end);
}

template <typename RandomAccessIterator, typename T, typename LessThan>
 void qMerge(RandomAccessIterator begin, RandomAccessIterator pivot, RandomAccessIterator end, T &t, LessThan lessThan)
{
const int len1 = pivot - begin;
const int len2 = end - pivot;

if (len1 == 0 || len2 == 0)
return;

if (len1 + len2 == 2) {
if (lessThan(*(begin + 1), *(begin)))
qSwap(*begin, *(begin + 1));
return;
}

RandomAccessIterator firstCut;
RandomAccessIterator secondCut;
int len2Half;
if (len1 > len2) {
const int len1Half = len1 / 2;
firstCut = begin + len1Half;
secondCut = qLowerBound(pivot, end, *firstCut, lessThan);
len2Half = secondCut - pivot;
} else {
len2Half = len2 / 2;
secondCut = pivot + len2Half;
firstCut = qUpperBound(begin, pivot, *secondCut, lessThan);
}

qRotate(firstCut, pivot, secondCut);
const RandomAccessIterator newPivot = firstCut + len2Half;
qMerge(begin, firstCut, newPivot, t, lessThan);
qMerge(newPivot, secondCut, end, t, lessThan);
}

template <typename RandomAccessIterator, typename T, typename LessThan>
 void qStableSortHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &t, LessThan lessThan)
{
const int span = end - begin;
if (span < 2)
return;

const RandomAccessIterator middle = begin + span / 2;
qStableSortHelper(begin, middle, t, lessThan);
qStableSortHelper(middle, end, t, lessThan);
qMerge(begin, middle, end, t, lessThan);
}

template <typename RandomAccessIterator, typename T>
inline void qStableSortHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &dummy)
{
qStableSortHelper(begin, end, dummy, qLess<T>());
}

template <typename RandomAccessIterator, typename T, typename LessThan>
 RandomAccessIterator qLowerBoundHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan)
{
RandomAccessIterator middle;
int n = int(end - begin);
int half;

while (n > 0) {
half = n >> 1;
middle = begin + half;
if (lessThan(*middle, value)) {
begin = middle + 1;
n -= half + 1;
} else {
n = half;
}
}
return begin;
}


template <typename RandomAccessIterator, typename T, typename LessThan>
 RandomAccessIterator qUpperBoundHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan)
{
RandomAccessIterator middle;
int n = end - begin;
int half;

while (n > 0) {
half = n >> 1;
middle = begin + half;
if (lessThan(value, *middle)) {
n = half;
} else {
begin = middle + 1;
n -= half + 1;
}
}
return begin;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
 RandomAccessIterator qBinaryFindHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan)
{
RandomAccessIterator it = qLowerBoundHelper(begin, end, value, lessThan);

if (it == end || lessThan(value, *it))
return end;

return it;
}

} 






# 47 "/usr/share/qt4/include/QtCore/qlist.h"










# 57 "/usr/share/qt4/include/QtCore/qlist.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

template <typename T> class QVector;
template <typename T> class QSet;

struct  QListData {
struct Data {
QBasicAtomicInt ref;
int alloc, begin, end;
uint sharable : 1;
void *array[1];
};
enum { DataHeaderSize = sizeof(Data) - sizeof(void *) };

Data *detach(); 
Data *detach2(); 
Data *detach3();
void realloc(int alloc);
static Data shared_null;
Data *d;
void **erase(void **xi);
void **append();
void **append(const QListData &l);
void **append2(const QListData &l); 
void **prepend();
void **insert(int i);
void remove(int i);
void remove(int i, int n);
void move(int from, int to);
inline int size() const { return d->end - d->begin; }
inline bool isEmpty() const { return d->end == d->begin; }
inline void **at(int i) const { return d->array + d->begin + i; }
inline void **begin() const { return d->array + d->begin; }
inline void **end() const { return d->array + d->end; }
};

template <typename T>
class QList
{
struct Node { void *v;



# 104 "/usr/share/qt4/include/QtCore/qlist.h"
inline T &t()
{ return *reinterpret_cast<T*>(QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic
? v : this); }

# 108 "/usr/share/qt4/include/QtCore/qlist.h"
};

union { QListData p; QListData::Data *d; };

public:
inline QList() : d(&QListData::shared_null) { d->ref.ref(); }
inline QList(const QList<T> &l) : d(l.d) { d->ref.ref(); if (!d->sharable) detach_helper(); }
~QList();
QList<T> &operator=(const QList<T> &l);
bool operator==(const QList<T> &l) const;
inline bool operator!=(const QList<T> &l) const { return !(*this == l); }

inline int size() const { return p.size(); }

inline void detach() { if (d->ref != 1) detach_helper(); }

inline void detachShared()
{

if (d->ref != 1 && this->d != &QListData::shared_null)
detach_helper();
}

inline bool isDetached() const { return d->ref == 1; }
inline void setSharable(bool sharable) { if (!sharable) detach(); d->sharable = sharable; }

inline bool isEmpty() const { return p.isEmpty(); }

void clear();

const T &at(int i) const;
const T &operator[](int i) const;
T &operator[](int i);

void append(const T &t);
void append(const QList<T> &t);
void prepend(const T &t);
void insert(int i, const T &t);
void replace(int i, const T &t);
void removeAt(int i);
int removeAll(const T &t);
bool removeOne(const T &t);
T takeAt(int i);
T takeFirst();
T takeLast();
void move(int from, int to);
void swap(int i, int j);
int indexOf(const T &t, int from = 0) const;
int lastIndexOf(const T &t, int from = -1) const;
QBool contains(const T &t) const;
int count(const T &t) const;

class const_iterator;

class iterator {
public:
Node *i;
typedef std::random_access_iterator_tag iterator_category;
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef T *pointer;
typedef T &reference;

inline iterator() : i(0) {}
inline iterator(Node *n) : i(n) {}
inline iterator(const iterator &o): i(o.i){}
inline T &operator*() const { return i->t(); }
inline T *operator->() const { return &i->t(); }
inline T &operator[](int j) const { return i[j].t(); }
inline bool operator==(const iterator &o) const { return i == o.i; }
inline bool operator!=(const iterator &o) const { return i != o.i; }
inline bool operator<(const iterator& other) const { return i < other.i; }
inline bool operator<=(const iterator& other) const { return i <= other.i; }
inline bool operator>(const iterator& other) const { return i > other.i; }
inline bool operator>=(const iterator& other) const { return i >= other.i; }

# 184 "/usr/share/qt4/include/QtCore/qlist.h"
inline bool operator==(const const_iterator &o) const
{ return i == o.i; }
inline bool operator!=(const const_iterator &o) const
{ return i != o.i; }
inline bool operator<(const const_iterator& other) const
{ return i < other.i; }
inline bool operator<=(const const_iterator& other) const
{ return i <= other.i; }
inline bool operator>(const const_iterator& other) const
{ return i > other.i; }
inline bool operator>=(const const_iterator& other) const
{ return i >= other.i; }

# 197 "/usr/share/qt4/include/QtCore/qlist.h"
inline iterator &operator++() { ++i; return *this; }
inline iterator operator++(int) { Node *n = i; ++i; return n; }
inline iterator &operator--() { i--; return *this; }
inline iterator operator--(int) { Node *n = i; i--; return n; }
inline iterator &operator+=(int j) { i+=j; return *this; }
inline iterator &operator-=(int j) { i-=j; return *this; }
inline iterator operator+(int j) const { return iterator(i+j); }
inline iterator operator-(int j) const { return iterator(i-j); }
inline int operator-(iterator j) const { return int(i - j.i); }
};
friend class iterator;

class const_iterator {
public:
Node *i;
typedef std::random_access_iterator_tag iterator_category;
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef const T *pointer;
typedef const T &reference;

inline const_iterator() : i(0) {}
inline const_iterator(Node *n) : i(n) {}
inline const_iterator(const const_iterator &o): i(o.i) {}



# 224 "/usr/share/qt4/include/QtCore/qlist.h"
inline const_iterator(const iterator &o): i(o.i) {}

# 226 "/usr/share/qt4/include/QtCore/qlist.h"
inline const T &operator*() const { return i->t(); }
inline const T *operator->() const { return &i->t(); }
inline const T &operator[](int j) const { return i[j].t(); }
inline bool operator==(const const_iterator &o) const { return i == o.i; }
inline bool operator!=(const const_iterator &o) const { return i != o.i; }
inline bool operator<(const const_iterator& other) const { return i < other.i; }
inline bool operator<=(const const_iterator& other) const { return i <= other.i; }
inline bool operator>(const const_iterator& other) const { return i > other.i; }
inline bool operator>=(const const_iterator& other) const { return i >= other.i; }
inline const_iterator &operator++() { ++i; return *this; }
inline const_iterator operator++(int) { Node *n = i; ++i; return n; }
inline const_iterator &operator--() { i--; return *this; }
inline const_iterator operator--(int) { Node *n = i; i--; return n; }
inline const_iterator &operator+=(int j) { i+=j; return *this; }
inline const_iterator &operator-=(int j) { i-=j; return *this; }
inline const_iterator operator+(int j) const { return const_iterator(i+j); }
inline const_iterator operator-(int j) const { return const_iterator(i-j); }
inline int operator-(const_iterator j) const { return i - j.i; }
};
friend class const_iterator;


inline iterator begin() { detach(); return reinterpret_cast<Node *>(p.begin()); }
inline const_iterator begin() const { return reinterpret_cast<Node *>(p.begin()); }
inline const_iterator constBegin() const { return reinterpret_cast<Node *>(p.begin()); }
inline iterator end() { detach(); return reinterpret_cast<Node *>(p.end()); }
inline const_iterator end() const { return reinterpret_cast<Node *>(p.end()); }
inline const_iterator constEnd() const { return reinterpret_cast<Node *>(p.end()); }
iterator insert(iterator before, const T &t);
iterator erase(iterator pos);
iterator erase(iterator first, iterator last);


typedef iterator Iterator;
typedef const_iterator ConstIterator;
inline int count() const { return p.size(); }
inline int length() const { return p.size(); } 
inline T& first() { qt_noop(); return *begin(); }
inline const T& first() const { qt_noop(); return *begin(); }
T& last() { qt_noop(); return *(--end()); }
const T& last() const { qt_noop(); return *(--end()); }
inline void removeFirst() { qt_noop(); erase(begin()); }
inline void removeLast() { qt_noop(); erase(--end()); }
inline bool startsWith(const T &t) const { return !isEmpty() && first() == t; }
inline bool endsWith(const T &t) const { return !isEmpty() && last() == t; }
QList<T> mid(int pos, int length = -1) const;

T value(int i) const;
T value(int i, const T &defaultValue) const;


inline void push_back(const T &t) { append(t); }
inline void push_front(const T &t) { prepend(t); }
inline T& front() { return first(); }
inline const T& front() const { return first(); }
inline T& back() { return last(); }
inline const T& back() const { return last(); }
inline void pop_front() { removeFirst(); }
inline void pop_back() { removeLast(); }
inline bool empty() const { return isEmpty(); }
typedef int size_type;
typedef T value_type;
typedef value_type *pointer;
typedef const value_type *const_pointer;
typedef value_type &reference;
typedef const value_type &const_reference;
typedef ptrdiff_t difference_type;















# 308 "/usr/share/qt4/include/QtCore/qlist.h"

QList<T> &operator+=(const QList<T> &l);
inline QList<T> operator+(const QList<T> &l) const
{ QList n = *this; n += l; return n; }
inline QList<T> &operator+=(const T &t)
{ append(t); return *this; }
inline QList<T> &operator<< (const T &t)
{ append(t); return *this; }
inline QList<T> &operator<<(const QList<T> &l)
{ *this += l; return *this; }

QVector<T> toVector() const;
QSet<T> toSet() const;

static QList<T> fromVector(const QVector<T> &vector);
static QList<T> fromSet(const QSet<T> &set);








# 332 "/usr/share/qt4/include/QtCore/qlist.h"
private:
void detach_helper();
void free(QListData::Data *d);

void node_construct(Node *n, const T &t);
void node_destruct(Node *n);
void node_copy(Node *from, Node *to, Node *src);
void node_destruct(Node *from, Node *to);
};







# 348 "/usr/share/qt4/include/QtCore/qlist.h"
template <typename T>
inline void QList<T>::node_construct(Node *n, const T &t)
{
if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) n->v = new T(t);
else if (QTypeInfo<T>::isComplex) new (n) T(t);
else *reinterpret_cast<T*>(n) = t;
}

template <typename T>
inline void QList<T>::node_destruct(Node *n)
{
if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) delete reinterpret_cast<T*>(n->v);
else if (QTypeInfo<T>::isComplex) reinterpret_cast<T*>(n)->~T();
}

template <typename T>
inline void QList<T>::node_copy(Node *from, Node *to, Node *src)
{
Node *current = from;
if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
try {
while(current != to) {
current->v = new T(*reinterpret_cast<T*>(src->v));
++current;
++src;
}
} catch (...) {
while (current-- != from)
delete reinterpret_cast<T*>(current->v);
throw;
}

} else if (QTypeInfo<T>::isComplex) {
try {
while(current != to) {
new (current) T(*reinterpret_cast<T*>(src));
++current;
++src;
}
} catch (...) {
while (current-- != from)
(reinterpret_cast<T*>(current))->~T();
throw;
}
} else {
if (src != from && to - from > 0)
memcpy(from, src, (to - from) * sizeof(Node *));
}
}

template <typename T>
inline void QList<T>::node_destruct(Node *from, Node *to)
{
if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic)
while(from != to) --to, delete reinterpret_cast<T*>(to->v);
else if (QTypeInfo<T>::isComplex)
while (from != to) --to, reinterpret_cast<T*>(to)->~T();
}

template <typename T>
inline QList<T> &QList<T>::operator=(const QList<T> &l)
{
if (d != l.d) {
l.d->ref.ref();
if (!d->ref.deref())
free(d);
d = l.d;
if (!d->sharable)
detach_helper();
}
return *this;
}
template <typename T>
inline typename QList<T>::iterator QList<T>::insert(iterator before, const T &t)
{
int iBefore = int(before.i - reinterpret_cast<Node *>(p.begin()));
Node *n = reinterpret_cast<Node *>(p.insert(iBefore));
try {
node_construct(n, t);
} catch (...) {
p.remove(iBefore);
throw;
}
return n;
}
template <typename T>
inline typename QList<T>::iterator QList<T>::erase(iterator it)
{ node_destruct(it.i);
return reinterpret_cast<Node *>(p.erase(reinterpret_cast<void**>(it.i))); }
template <typename T>
inline const T &QList<T>::at(int i) const
{ qt_noop();
return reinterpret_cast<Node *>(p.at(i))->t(); }
template <typename T>
inline const T &QList<T>::operator[](int i) const
{ qt_noop();
return reinterpret_cast<Node *>(p.at(i))->t(); }
template <typename T>
inline T &QList<T>::operator[](int i)
{ qt_noop();
detach(); return reinterpret_cast<Node *>(p.at(i))->t(); }
template <typename T>
inline void QList<T>::removeAt(int i)
{ if(i >= 0 && i < p.size()) { detach();
node_destruct(reinterpret_cast<Node *>(p.at(i))); p.remove(i); } }
template <typename T>
inline T QList<T>::takeAt(int i)
{ qt_noop();
detach(); Node *n = reinterpret_cast<Node *>(p.at(i)); T t = n->t(); node_destruct(n);
p.remove(i); return t; }
template <typename T>
inline T QList<T>::takeFirst()
{ T t = first(); removeFirst(); return t; }
template <typename T>
inline T QList<T>::takeLast()
{ T t = last(); removeLast(); return t; }

template <typename T>
 void QList<T>::append(const T &t)
{
detach();
if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
Node *n = reinterpret_cast<Node *>(p.append());
try {
node_construct(n, t);
} catch (...) {
--d->end;
throw;
}
} else {
const T cpy(t);
Node *n = reinterpret_cast<Node *>(p.append());
try {
node_construct(n, cpy);
} catch (...) {
--d->end;
throw;
}
}
}

template <typename T>
inline void QList<T>::prepend(const T &t)
{
detach();
if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
Node *n = reinterpret_cast<Node *>(p.prepend());
try {
node_construct(n, t);
} catch (...) {
++d->begin;
throw;
}
} else {
const T cpy(t);
Node *n = reinterpret_cast<Node *>(p.prepend());
try {
node_construct(n, cpy);
} catch (...) {
++d->begin;
throw;
}
}
}

template <typename T>
inline void QList<T>::insert(int i, const T &t)
{
detach();
if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
Node *n = reinterpret_cast<Node *>(p.insert(i));
try {
node_construct(n, t);
} catch (...) {
p.remove(i);
throw;
}
} else {
const T cpy(t);
Node *n = reinterpret_cast<Node *>(p.insert(i));
try {
node_construct(n, cpy);
} catch (...) {
p.remove(i);
throw;
}
}
}

template <typename T>
inline void QList<T>::replace(int i, const T &t)
{
qt_noop();
detach();
if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
reinterpret_cast<Node *>(p.at(i))->t() = t;
} else {
const T cpy(t);
reinterpret_cast<Node *>(p.at(i))->t() = cpy;
}
}

template <typename T>
inline void QList<T>::swap(int i, int j)
{
qt_noop();
detach();
void *t = d->array[d->begin + i];
d->array[d->begin + i] = d->array[d->begin + j];
d->array[d->begin + j] = t;
}

template <typename T>
inline void QList<T>::move(int from, int to)
{
qt_noop();
detach();
p.move(from, to);
}

template<typename T>
 QList<T> QList<T>::mid(int pos, int alength) const
{
if (alength < 0)
alength = size() - pos;
if (pos == 0 && alength == size())
return *this;
QList<T> cpy;
if (pos + alength > size())
alength = size() - pos;
for (int i = pos; i < pos + alength; ++i)
cpy += at(i);
return cpy;
}

template<typename T>
 T QList<T>::value(int i) const
{
if (i < 0 || i >= p.size()) {
return T();
}
return reinterpret_cast<Node *>(p.at(i))->t();
}

template<typename T>
 T QList<T>::value(int i, const T& defaultValue) const
{
return ((i < 0 || i >= p.size()) ? defaultValue : reinterpret_cast<Node *>(p.at(i))->t());
}

template <typename T>
 void QList<T>::detach_helper()
{
Node *n = reinterpret_cast<Node *>(p.begin());
QListData::Data *x = p.detach3();
try {
node_copy(reinterpret_cast<Node *>(p.begin()), reinterpret_cast<Node *>(p.end()), n);
} catch (...) {
qFree(d);
d = x;
throw;
}

if (!x->ref.deref())
free(x);
}

template <typename T>
 QList<T>::~QList()
{
if (d && !d->ref.deref())
free(d);
}

template <typename T>
 bool QList<T>::operator==(const QList<T> &l) const
{
if (p.size() != l.p.size())
return false;
if (d == l.d)
return true;
Node *i = reinterpret_cast<Node *>(p.end());
Node *b = reinterpret_cast<Node *>(p.begin());
Node *li = reinterpret_cast<Node *>(l.p.end());
while (i != b) {
--i; --li;
if (!(i->t() == li->t()))
return false;
}
return true;
}


template <typename T>
 void QList<T>::free(QListData::Data *data)
{
node_destruct(reinterpret_cast<Node *>(data->array + data->begin),
reinterpret_cast<Node *>(data->array + data->end));
if (data->ref == 0)
qFree(data);
}


template <typename T>
 void QList<T>::clear()
{
*this = QList<T>();
}

template <typename T>
 int QList<T>::removeAll(const T &_t)
{
detachShared();
const T t = _t;
int removedCount=0, i=0;
Node *n;
while (i < p.size())
if ((n = reinterpret_cast<Node *>(p.at(i)))->t() == t) {
node_destruct(n);
p.remove(i);
++removedCount;
} else {
++i;
}
return removedCount;
}

template <typename T>
 bool QList<T>::removeOne(const T &_t)
{
detachShared();
int index = indexOf(_t);
if (index != -1) {
removeAt(index);
return true;
}
return false;
}

template <typename T>
 typename QList<T>::iterator QList<T>::erase(typename QList<T>::iterator afirst,
typename QList<T>::iterator alast)
{
for (Node *n = afirst.i; n < alast.i; ++n)
node_destruct(n);
int idx = afirst - begin();
p.remove(idx, alast - afirst);
return begin() + idx;
}

template <typename T>
 QList<T> &QList<T>::operator+=(const QList<T> &l)
{
detach();
Node *n = reinterpret_cast<Node *>(p.append2(l.p));
try{
node_copy(n, reinterpret_cast<Node *>(p.end()), reinterpret_cast<Node *>(l.p.begin()));
} catch (...) {

d->end -= int(reinterpret_cast<Node *>(p.end()) - n);
throw;
}
return *this;
}

template <typename T>
inline void QList<T>::append(const QList<T> &t)
{
*this += t;
}

template <typename T>
 int QList<T>::indexOf(const T &t, int from) const
{
if (from < 0)
from = qMax(from + p.size(), 0);
if (from < p.size()) {
Node *n = reinterpret_cast<Node *>(p.at(from -1));
Node *e = reinterpret_cast<Node *>(p.end());
while (++n != e)
if (n->t() == t)
return int(n - reinterpret_cast<Node *>(p.begin()));
}
return -1;
}

template <typename T>
 int QList<T>::lastIndexOf(const T &t, int from) const
{
if (from < 0)
from += p.size();
else if (from >= p.size())
from = p.size()-1;
if (from >= 0) {
Node *b = reinterpret_cast<Node *>(p.begin());
Node *n = reinterpret_cast<Node *>(p.at(from + 1));
while (n-- != b) {
if (n->t() == t)
return n - b;
}
}
return -1;
}

template <typename T>
 QBool QList<T>::contains(const T &t) const
{
Node *b = reinterpret_cast<Node *>(p.begin());
Node *i = reinterpret_cast<Node *>(p.end());
while (i-- != b)
if (i->t() == t)
return QBool(true);
return QBool(false);
}

template <typename T>
 int QList<T>::count(const T &t) const
{
int c = 0;
Node *b = reinterpret_cast<Node *>(p.begin());
Node *i = reinterpret_cast<Node *>(p.end());
while (i-- != b)
if (i->t() == t)
++c;
return c;
}

template <class T> class QListIterator { typedef typename QList<T>::const_iterator const_iterator; QList<T> c; const_iterator i; public: inline QListIterator(const QList<T> &container) : c(container), i(c.constBegin()) {} inline QListIterator &operator=(const QList<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };
template <class T> class QMutableListIterator { typedef typename QList<T>::iterator iterator; typedef typename QList<T>::const_iterator const_iterator; QList<T> *c; iterator i, n; inline bool item_exists() const { return const_iterator(n) != c->constEnd(); } public: inline QMutableListIterator(QList<T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableListIterator() { c->setSharable(true); } inline QMutableListIterator &operator=(QList<T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = i; } inline bool hasNext() const { return c->constEnd() != const_iterator(i); } inline T &next() { n = i++; return *n; } inline T &peekNext() const { return *i; } inline bool hasPrevious() const { return c->constBegin() != const_iterator(i); } inline T &previous() { n = --i; return *n; } inline T &peekPrevious() const { iterator p = i; return *--p; } inline void remove() { if (c->constEnd() != const_iterator(n)) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) const { if (c->constEnd() != const_iterator(n)) *n = t; } inline T &value() { qt_noop(); return *n; } inline const T &value() const { qt_noop(); return *n; } inline void insert(const T &t) { n = i = c->insert(i, t); ++i; } inline bool findNext(const T &t) { while (c->constEnd() != const_iterator(n = i)) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (c->constBegin() != const_iterator(i)) if (*(n = --i) == t) return true; n = c->end(); return false; } };






# 50 "/usr/share/qt4/include/QtCore/qobject.h"




# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qscopedpointer.h"


# 47 "/usr/share/qt4/include/QtCore/qscopedpointer.h"


typedef QtValidLicenseForCoreModule QtCoreModule;

template <typename T>
struct QScopedPointerDeleter
{
static inline void cleanup(T *pointer)
{



typedef char IsIncompleteType[ sizeof(T) ? 1 : -1 ];
(void) sizeof(IsIncompleteType);

delete pointer;
}
};

template <typename T>
struct QScopedPointerArrayDeleter
{
static inline void cleanup(T *pointer)
{



typedef char IsIncompleteType[ sizeof(T) ? 1 : -1 ];
(void) sizeof(IsIncompleteType);

delete [] pointer;
}
};

struct QScopedPointerPodDeleter
{
static inline void cleanup(void *pointer) { if (pointer) qFree(pointer); }
};

template <typename T, typename Cleanup = QScopedPointerDeleter<T> >
class QScopedPointer
{

# 90 "/usr/share/qt4/include/QtCore/qscopedpointer.h"
typedef T *QScopedPointer:: *RestrictedBool;

# 92 "/usr/share/qt4/include/QtCore/qscopedpointer.h"
public:
explicit inline QScopedPointer(T *p = 0) : d(p)
{
}

inline ~QScopedPointer()
{
T *oldD = this->d;
Cleanup::cleanup(oldD);
this->d = 0;
}

inline T &operator*() const
{
qt_noop();
return *d;
}

inline T *operator->() const
{
qt_noop();
return d;
}

inline bool operator!() const
{
return !d;
}







# 127 "/usr/share/qt4/include/QtCore/qscopedpointer.h"
inline operator RestrictedBool() const
{
return isNull() ? 0 : &QScopedPointer::d;
}


# 133 "/usr/share/qt4/include/QtCore/qscopedpointer.h"
inline T *data() const
{
return d;
}

inline bool isNull() const
{
return !d;
}

inline void reset(T *other = 0)
{
if (d == other)
return;
T *oldD = d;
d = other;
Cleanup::cleanup(oldD);
}

inline T *take()
{
T *oldD = d;
d = 0;
return oldD;
}

inline void swap(QScopedPointer<T, Cleanup> &other)
{
qSwap(d, other.d);
}

typedef T *pointer;

protected:
T *d;

private:
QScopedPointer(const QScopedPointer &); QScopedPointer &operator=(const QScopedPointer &);
};

template <class T, class Cleanup>
inline bool operator==(const QScopedPointer<T, Cleanup> &lhs, const QScopedPointer<T, Cleanup> &rhs)
{
return lhs.data() == rhs.data();
}

template <class T, class Cleanup>
inline bool operator!=(const QScopedPointer<T, Cleanup> &lhs, const QScopedPointer<T, Cleanup> &rhs)
{
return lhs.data() != rhs.data();
}

template <class T, class Cleanup>
inline void qSwap(QScopedPointer<T, Cleanup> &p1, QScopedPointer<T, Cleanup> &p2)
{ p1.swap(p2); }

template <typename T, typename Cleanup = QScopedPointerArrayDeleter<T> >
class QScopedArrayPointer : public QScopedPointer<T, Cleanup>
{
public:
explicit inline QScopedArrayPointer(T *p = 0)
: QScopedPointer<T, Cleanup>(p)
{
}

inline T &operator[](int i)
{
return this->d[i];
}

inline const T &operator[](int i) const
{
return this->d[i];
}

private:
QScopedArrayPointer(const QScopedArrayPointer &); QScopedArrayPointer &operator=(const QScopedArrayPointer &);
};





# 54 "/usr/share/qt4/include/QtCore/qobject.h"


# 56 "/usr/share/qt4/include/QtCore/qobject.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QEvent;
class QTimerEvent;
class QChildEvent;
struct QMetaObject;
class QVariant;
class QObjectPrivate;
class QObject;
class QThread;
class QWidget;

# 72 "/usr/share/qt4/include/QtCore/qobject.h"
class QRegExp;


# 75 "/usr/share/qt4/include/QtCore/qobject.h"
class QObjectUserData;


# 78 "/usr/share/qt4/include/QtCore/qobject.h"
typedef QList<QObject*> QObjectList;








# 87 "/usr/share/qt4/include/QtCore/qobject.h"
template<typename T> inline T qFindChild(const QObject *, const QString & = QString());
template<typename T> inline QList<T> qFindChildren(const QObject *, const QString & = QString());

# 90 "/usr/share/qt4/include/QtCore/qobject.h"
template<typename T> inline QList<T> qFindChildren(const QObject *, const QRegExp &);



# 94 "/usr/share/qt4/include/QtCore/qobject.h"
class



# 98 "/usr/share/qt4/include/QtCore/qobject.h"
QObjectData {
public:
virtual ~QObjectData() = 0;
QObject *q_ptr;
QObject *parent;
QObjectList children;

uint isWidget : 1;
uint pendTimer : 1;
uint blockSig : 1;
uint wasDeleted : 1;
uint ownObjectName : 1;
uint sendChildEvents : 1;
uint receiveChildEvents : 1;
uint inEventHandler : 1;
uint inThreadChangeEvent : 1;
uint hasGuards : 1; 
uint unused : 22;
int postedEvents;
QMetaObject *metaObject; 
};


class  QObject
{
Q_OBJECT
Q_PROPERTY(QString objectName READ objectName WRITE setObjectName)
inline QObjectPrivate* d_func() { return reinterpret_cast<QObjectPrivate *>(qGetPtrHelper(d_ptr)); } inline const QObjectPrivate* d_func() const { return reinterpret_cast<const QObjectPrivate *>(qGetPtrHelper(d_ptr)); } friend class QObjectPrivate;

public:
Q_INVOKABLE explicit QObject(QObject *parent=0);
virtual ~QObject();

virtual bool event(QEvent *);
virtual bool eventFilter(QObject *, QEvent *);




















# 153 "/usr/share/qt4/include/QtCore/qobject.h"
QString objectName() const;
void setObjectName(const QString &name);

inline bool isWidgetType() const { return d_ptr->isWidget; }

inline bool signalsBlocked() const { return d_ptr->blockSig; }
bool blockSignals(bool b);

QThread *thread() const;
void moveToThread(QThread *thread);

int startTimer(int interval);
void killTimer(int id);


# 168 "/usr/share/qt4/include/QtCore/qobject.h"
template<typename T>
inline T findChild(const QString &aName = QString()) const
{ return qFindChild<T>(this, aName); }

template<typename T>
inline QList<T> findChildren(const QString &aName = QString()) const
{ return qFindChildren<T>(this, aName); }


# 177 "/usr/share/qt4/include/QtCore/qobject.h"
template<typename T>
inline QList<T> findChildren(const QRegExp &re) const
{ return qFindChildren<T>(this, re); }











# 191 "/usr/share/qt4/include/QtCore/qobject.h"
inline const QObjectList &children() const { return d_ptr->children; }

void setParent(QObject *);
void installEventFilter(QObject *);
void removeEventFilter(QObject *);


static bool connect(const QObject *sender, const char *signal,
const QObject *receiver, const char *member, Qt::ConnectionType =






# 206 "/usr/share/qt4/include/QtCore/qobject.h"
Qt::AutoConnection


# 209 "/usr/share/qt4/include/QtCore/qobject.h"
);
inline bool connect(const QObject *sender, const char *signal,
const char *member, Qt::ConnectionType type =






# 218 "/usr/share/qt4/include/QtCore/qobject.h"
Qt::AutoConnection


# 221 "/usr/share/qt4/include/QtCore/qobject.h"
) const;

static bool disconnect(const QObject *sender, const char *signal,
const QObject *receiver, const char *member);
inline bool disconnect(const char *signal = 0,
const QObject *receiver = 0, const char *member = 0)
{ return disconnect(this, signal, receiver, member); }
inline bool disconnect(const QObject *receiver, const char *member = 0)
{ return disconnect(this, 0, receiver, member); }

void dumpObjectTree();
void dumpObjectInfo();


# 235 "/usr/share/qt4/include/QtCore/qobject.h"
bool setProperty(const char *name, const QVariant &value);
QVariant property(const char *name) const;
QList<QByteArray> dynamicPropertyNames() const;



# 241 "/usr/share/qt4/include/QtCore/qobject.h"
static uint registerUserData();
void setUserData(uint id, QObjectUserData* data);
QObjectUserData* userData(uint id) const;


# 246 "/usr/share/qt4/include/QtCore/qobject.h"
signals:
void destroyed(QObject * = 0);

public:
inline QObject *parent() const { return d_ptr->parent; }

inline bool inherits(const char *classname) const
{ return const_cast<QObject *>(this)->qt_metacast(classname) != 0; }

public slots:
void deleteLater();

protected:
QObject *sender() const;
int receivers(const char* signal) const;

virtual void timerEvent(QTimerEvent *);
virtual void childEvent(QChildEvent *);
virtual void customEvent(QEvent *);

virtual void connectNotify(const char *signal);
virtual void disconnectNotify(const char *signal);
























# 292 "/usr/share/qt4/include/QtCore/qobject.h"
protected:
QObject(QObjectPrivate &dd, QObject *parent = 0);

protected:
QScopedPointer<QObjectData> d_ptr;

static const QMetaObject staticQtMetaObject;

friend struct QMetaObject;
friend class QApplication;
friend class QApplicationPrivate;
friend class QCoreApplication;
friend class QCoreApplicationPrivate;
friend class QWidget;
friend class QThreadData;

private:
QObject(const QObject &); QObject &operator=(const QObject &);

};

inline bool QObject::connect(const QObject *asender, const char *asignal,
const char *amember, Qt::ConnectionType atype) const
{ return connect(asender, asignal, this, amember, atype); }


# 318 "/usr/share/qt4/include/QtCore/qobject.h"
class  QObjectUserData {
public:
virtual ~QObjectUserData();
};


# 324 "/usr/share/qt4/include/QtCore/qobject.h"
 void qt_qFindChildren_helper(const QObject *parent, const QString &name, const QRegExp *re,
const QMetaObject &mo, QList<void *> *list);
 QObject *qt_qFindChild_helper(const QObject *parent, const QString &name, const QMetaObject &mo);




















































































# 417 "/usr/share/qt4/include/QtCore/qobject.h"
template<typename T>
inline T qFindChild(const QObject *o, const QString &name)
{ return static_cast<T>(qt_qFindChild_helper(o, name, reinterpret_cast<T>(0)->staticMetaObject)); }

template<typename T>
inline QList<T> qFindChildren(const QObject *o, const QString &name)
{
QList<T> list;
union {
QList<T> *typedList;
QList<void *> *voidList;
} u;
u.typedList = &list;
qt_qFindChildren_helper(o, name, 0, reinterpret_cast<T>(0)->staticMetaObject, u.voidList);
return list;
}


# 435 "/usr/share/qt4/include/QtCore/qobject.h"
template<typename T>
inline QList<T> qFindChildren(const QObject *o, const QRegExp &re)
{
QList<T> list;
union {
QList<T> *typedList;
QList<void *> *voidList;
} u;
u.typedList = &list;
qt_qFindChildren_helper(o, QString(), &re, reinterpret_cast<T>(0)->staticMetaObject, u.voidList);
return list;
}


# 449 "/usr/share/qt4/include/QtCore/qobject.h"
template <class T>
inline T qobject_cast(QObject *object)
{

# 453 "/usr/share/qt4/include/QtCore/qobject.h"
reinterpret_cast<T>(0)->qt_check_for_QOBJECT_macro(*reinterpret_cast<T>(object));

# 455 "/usr/share/qt4/include/QtCore/qobject.h"
return static_cast<T>(reinterpret_cast<T>(0)->staticMetaObject.cast(object));
}

template <class T>
inline T qobject_cast(const QObject *object)
{

register T ptr = static_cast<T>(object);
(void)ptr;;


# 466 "/usr/share/qt4/include/QtCore/qobject.h"
reinterpret_cast<T>(0)->qt_check_for_QOBJECT_macro(*reinterpret_cast<T>(const_cast<QObject *>(object)));

# 468 "/usr/share/qt4/include/QtCore/qobject.h"
return static_cast<T>(const_cast<QObject *>(reinterpret_cast<T>(0)->staticMetaObject.cast(const_cast<QObject *>(object))));
}


template <class T> inline const char * qobject_interface_iid()
{ return 0; }








# 488 "/usr/share/qt4/include/QtCore/qobject.h"
 QDebug operator<<(QDebug, const QObject *);


# 491 "/usr/share/qt4/include/QtCore/qobject.h"







# 46 "/usr/share/qt4/include/QtCore/qiodevice.h"





# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 51 "/usr/share/qt4/include/QtCore/qiodevice.h"






# 57 "/usr/share/qt4/include/QtCore/qiodevice.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QByteArray;
class QIODevicePrivate;

class  QIODevice

# 68 "/usr/share/qt4/include/QtCore/qiodevice.h"
: public QObject

# 70 "/usr/share/qt4/include/QtCore/qiodevice.h"
{

# 72 "/usr/share/qt4/include/QtCore/qiodevice.h"
Q_OBJECT

# 74 "/usr/share/qt4/include/QtCore/qiodevice.h"
public:
enum OpenModeFlag {
NotOpen = 0x0000,
ReadOnly = 0x0001,
WriteOnly = 0x0002,
ReadWrite = ReadOnly | WriteOnly,
Append = 0x0004,
Truncate = 0x0008,
Text = 0x0010,
Unbuffered = 0x0020
};
typedef QFlags<OpenModeFlag> OpenMode;

QIODevice();

# 89 "/usr/share/qt4/include/QtCore/qiodevice.h"
explicit QIODevice(QObject *parent);

# 91 "/usr/share/qt4/include/QtCore/qiodevice.h"
virtual ~QIODevice();

OpenMode openMode() const;

void setTextModeEnabled(bool enabled);
bool isTextModeEnabled() const;

bool isOpen() const;
bool isReadable() const;
bool isWritable() const;
virtual bool isSequential() const;

virtual bool open(OpenMode mode);
virtual void close();



virtual qint64 pos() const;
virtual qint64 size() const;
virtual bool seek(qint64 pos);
virtual bool atEnd() const;
virtual bool reset();

virtual qint64 bytesAvailable() const;
virtual qint64 bytesToWrite() const;

qint64 read(char *data, qint64 maxlen);
QByteArray read(qint64 maxlen);
QByteArray readAll();
qint64 readLine(char *data, qint64 maxlen);
QByteArray readLine(qint64 maxlen = 0);
virtual bool canReadLine() const;

qint64 write(const char *data, qint64 len);
qint64 write(const char *data);
inline qint64 write(const QByteArray &data)
{ return write(data.constData(), data.size()); }

qint64 peek(char *data, qint64 maxlen);
QByteArray peek(qint64 maxlen);

virtual bool waitForReadyRead(int msecs);
virtual bool waitForBytesWritten(int msecs);

void ungetChar(char c);
bool putChar(char c);
bool getChar(char *c);

QString errorString() const;


# 142 "/usr/share/qt4/include/QtCore/qiodevice.h"
signals:
void readyRead();
void bytesWritten(qint64 bytes);
void aboutToClose();
void readChannelFinished();


# 149 "/usr/share/qt4/include/QtCore/qiodevice.h"
protected:



# 153 "/usr/share/qt4/include/QtCore/qiodevice.h"
QIODevice(QIODevicePrivate &dd, QObject *parent = 0);

# 155 "/usr/share/qt4/include/QtCore/qiodevice.h"
virtual qint64 readData(char *data, qint64 maxlen) = 0;
virtual qint64 readLineData(char *data, qint64 maxlen);
virtual qint64 writeData(const char *data, qint64 len) = 0;

void setOpenMode(OpenMode openMode);

void setErrorString(const QString &errorString);





# 167 "/usr/share/qt4/include/QtCore/qiodevice.h"
private:
inline QIODevicePrivate* d_func() { return reinterpret_cast<QIODevicePrivate *>(qGetPtrHelper(d_ptr)); } inline const QIODevicePrivate* d_func() const { return reinterpret_cast<const QIODevicePrivate *>(qGetPtrHelper(d_ptr)); } friend class QIODevicePrivate;
QIODevice(const QIODevice &); QIODevice &operator=(const QIODevice &);


































# 204 "/usr/share/qt4/include/QtCore/qiodevice.h"
};

inline QFlags<QIODevice::OpenMode::enum_type> operator|(QIODevice::OpenMode::enum_type f1, QIODevice::OpenMode::enum_type f2) { return QFlags<QIODevice::OpenMode::enum_type>(f1) | f2; } inline QFlags<QIODevice::OpenMode::enum_type> operator|(QIODevice::OpenMode::enum_type f1, QFlags<QIODevice::OpenMode::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QIODevice::OpenMode::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }







































# 246 "/usr/share/qt4/include/QtCore/qiodevice.h"
class QDebug;
 QDebug operator<<(QDebug debug, QIODevice::OpenMode modes);


# 250 "/usr/share/qt4/include/QtCore/qiodevice.h"





# 45 "/usr/share/qt4/include/QtCore/qfile.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qfile.h"







# 53 "/usr/share/qt4/include/QtCore/qfile.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QAbstractFileEngine;
class QFilePrivate;

class  QFile : public QIODevice
{

# 65 "/usr/share/qt4/include/QtCore/qfile.h"
Q_OBJECT

# 67 "/usr/share/qt4/include/QtCore/qfile.h"
inline QFilePrivate* d_func() { return reinterpret_cast<QFilePrivate *>(qGetPtrHelper(d_ptr)); } inline const QFilePrivate* d_func() const { return reinterpret_cast<const QFilePrivate *>(qGetPtrHelper(d_ptr)); } friend class QFilePrivate;

public:

enum FileError {
NoError = 0,
ReadError = 1,
WriteError = 2,
FatalError = 3,
ResourceError = 4,
OpenError = 5,
AbortError = 6,
TimeOutError = 7,
UnspecifiedError = 8,
RemoveError = 9,
RenameError = 10,
PositionError = 11,
ResizeError = 12,
PermissionsError = 13,
CopyError = 14



# 90 "/usr/share/qt4/include/QtCore/qfile.h"
};

enum Permission {
ReadOwner = 0x4000, WriteOwner = 0x2000, ExeOwner = 0x1000,
ReadUser = 0x0400, WriteUser = 0x0200, ExeUser = 0x0100,
ReadGroup = 0x0040, WriteGroup = 0x0020, ExeGroup = 0x0010,
ReadOther = 0x0004, WriteOther = 0x0002, ExeOther = 0x0001
};
typedef QFlags<Permission> Permissions;

QFile();
QFile(const QString &name);

# 103 "/usr/share/qt4/include/QtCore/qfile.h"
explicit QFile(QObject *parent);
QFile(const QString &name, QObject *parent);

# 106 "/usr/share/qt4/include/QtCore/qfile.h"
~QFile();

FileError error() const;
void unsetError();

QString fileName() const;
void setFileName(const QString &name);

typedef QByteArray (*EncoderFn)(const QString &fileName);
typedef QString (*DecoderFn)(const QByteArray &localfileName);
static QByteArray encodeName(const QString &fileName);
static QString decodeName(const QByteArray &localFileName);
inline static QString decodeName(const char *localFileName)
{ return decodeName(QByteArray(localFileName)); }
static void setEncodingFunction(EncoderFn);
static void setDecodingFunction(DecoderFn);

bool exists() const;
static bool exists(const QString &fileName);

QString readLink() const;
static QString readLink(const QString &fileName);
inline QString symLinkTarget() const { return readLink(); }
inline static QString symLinkTarget(const QString &fileName) { return readLink(fileName); }

bool remove();
static bool remove(const QString &fileName);

bool rename(const QString &newName);
static bool rename(const QString &oldName, const QString &newName);

bool link(const QString &newName);
static bool link(const QString &oldname, const QString &newName);

bool copy(const QString &newName);
static bool copy(const QString &fileName, const QString &newName);

bool isSequential() const;

bool open(OpenMode flags);
bool open(FILE *f, OpenMode flags);
bool open(int fd, OpenMode flags);
virtual void close();

qint64 size() const;
qint64 pos() const;
bool seek(qint64 offset);
bool atEnd() const;
bool flush();

bool resize(qint64 sz);
static bool resize(const QString &filename, qint64 sz);

Permissions permissions() const;
static Permissions permissions(const QString &filename);
bool setPermissions(Permissions permissionSpec);
static bool setPermissions(const QString &filename, Permissions permissionSpec);

int handle() const;

enum MemoryMapFlags {
NoOptions = 0
};

uchar *map(qint64 offset, qint64 size, MemoryMapFlags flags = NoOptions);
bool unmap(uchar *address);

virtual QAbstractFileEngine *fileEngine() const;









# 183 "/usr/share/qt4/include/QtCore/qfile.h"
protected:



# 187 "/usr/share/qt4/include/QtCore/qfile.h"
QFile(QFilePrivate &dd, QObject *parent = 0);


# 190 "/usr/share/qt4/include/QtCore/qfile.h"
qint64 readData(char *data, qint64 maxlen);
qint64 writeData(const char *data, qint64 len);
qint64 readLineData(char *data, qint64 maxlen);

private:
QFile(const QFile &); QFile &operator=(const QFile &);
};

inline QFlags<QFile::Permissions::enum_type> operator|(QFile::Permissions::enum_type f1, QFile::Permissions::enum_type f2) { return QFlags<QFile::Permissions::enum_type>(f1) | f2; } inline QFlags<QFile::Permissions::enum_type> operator|(QFile::Permissions::enum_type f1, QFlags<QFile::Permissions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QFile::Permissions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }






# 45 "/usr/share/qt4/include/QtCore/qfileinfo.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qfileinfo.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 47 "/usr/share/qt4/include/QtCore/qfileinfo.h"


# 49 "/usr/share/qt4/include/QtCore/qfileinfo.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QDir;
class QDateTime;
class QFileInfoPrivate;

class  QFileInfo
{
public:
QFileInfo();
QFileInfo(const QString &file);
QFileInfo(const QFile &file);
QFileInfo(const QDir &dir, const QString &file);
QFileInfo(const QFileInfo &fileinfo);
~QFileInfo();

QFileInfo &operator=(const QFileInfo &fileinfo);
bool operator==(const QFileInfo &fileinfo); 
bool operator==(const QFileInfo &fileinfo) const;
inline bool operator!=(const QFileInfo &fileinfo) { return !(operator==(fileinfo)); } 
inline bool operator!=(const QFileInfo &fileinfo) const { return !(operator==(fileinfo)); }

void setFile(const QString &file);
void setFile(const QFile &file);
void setFile(const QDir &dir, const QString &file);
bool exists() const;
void refresh();

QString filePath() const;
QString absoluteFilePath() const;
QString canonicalFilePath() const;
QString fileName() const;
QString baseName() const;
QString completeBaseName() const;
QString suffix() const;
QString bundleName() const;
QString completeSuffix() const;

QString path() const;
QString absolutePath() const;
QString canonicalPath() const;
QDir dir() const;
QDir absoluteDir() const;

bool isReadable() const;
bool isWritable() const;
bool isExecutable() const;
bool isHidden() const;

bool isRelative() const;
inline bool isAbsolute() const { return !isRelative(); }
bool makeAbsolute();

bool isFile() const;
bool isDir() const;
bool isSymLink() const;
bool isRoot() const;
bool isBundle() const;

QString readLink() const;
inline QString symLinkTarget() const { return readLink(); }

QString owner() const;
uint ownerId() const;
QString group() const;
uint groupId() const;

bool permission(QFile::Permissions permissions) const;
QFile::Permissions permissions() const;

qint64 size() const;

QDateTime created() const;
QDateTime lastModified() const;
QDateTime lastRead() const;

void detach();

bool caching() const;
void setCaching(bool on);



































# 168 "/usr/share/qt4/include/QtCore/qfileinfo.h"
protected:
QScopedPointer<QFileInfoPrivate> d_ptr;
private:
inline QFileInfoPrivate* d_func() { return reinterpret_cast<QFileInfoPrivate *>(qGetPtrHelper(d_ptr)); } inline const QFileInfoPrivate* d_func() const { return reinterpret_cast<const QFileInfoPrivate *>(qGetPtrHelper(d_ptr)); } friend class QFileInfoPrivate;
};
template <> class QTypeInfo<QFileInfo > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QFileInfo)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QFileInfo"; } };





# 179 "/usr/share/qt4/include/QtCore/qfileinfo.h"
typedef QList<QFileInfo> QFileInfoList;




# 184 "/usr/share/qt4/include/QtCore/qfileinfo.h"





# 46 "/usr/share/qt4/include/QtCore/qdir.h"

# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"












































# 1 "/usr/share/qt4/include/QtCore/qalgorithms.h"








































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qstringlist.h"

# 1 "/usr/share/qt4/include/QtCore/qdatastream.h"












































# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 45 "/usr/share/qt4/include/QtCore/qdatastream.h"

# 1 "/usr/share/qt4/include/QtCore/qiodevice.h"






























































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qdatastream.h"

# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qdatastream.h"






# 53 "/usr/share/qt4/include/QtCore/qdatastream.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QByteArray;
class QIODevice;

template <typename T> class QList;
template <typename T> class QLinkedList;
template <typename T> class QVector;
template <typename T> class QSet;
template <class Key, class T> class QHash;
template <class Key, class T> class QMap;


# 70 "/usr/share/qt4/include/QtCore/qdatastream.h"
class QDataStreamPrivate;
class  QDataStream
{
public:
enum Version {
Qt_1_0 = 1,
Qt_2_0 = 2,
Qt_2_1 = 3,
Qt_3_0 = 4,
Qt_3_1 = 5,
Qt_3_3 = 6,
Qt_4_0 = 7,
Qt_4_1 = Qt_4_0,
Qt_4_2 = 8,
Qt_4_3 = 9,
Qt_4_4 = 10,
Qt_4_5 = 11,
Qt_4_6 = 12




# 92 "/usr/share/qt4/include/QtCore/qdatastream.h"
};

enum ByteOrder {
BigEndian = QSysInfo::BigEndian,
LittleEndian = QSysInfo::LittleEndian
};

enum Status {
Ok,
ReadPastEnd,
ReadCorruptData
};

enum FloatingPointPrecision {
SinglePrecision,
DoublePrecision
};

QDataStream();
explicit QDataStream(QIODevice *);



# 115 "/usr/share/qt4/include/QtCore/qdatastream.h"
QDataStream(QByteArray *, QIODevice::OpenMode flags);
QDataStream(const QByteArray &);
virtual ~QDataStream();

QIODevice *device() const;
void setDevice(QIODevice *);
void unsetDevice();

bool atEnd() const;




# 128 "/usr/share/qt4/include/QtCore/qdatastream.h"
Status status() const;
void setStatus(Status status);
void resetStatus();

FloatingPointPrecision floatingPointPrecision() const;
void setFloatingPointPrecision(FloatingPointPrecision precision);

ByteOrder byteOrder() const;
void setByteOrder(ByteOrder);

int version() const;
void setVersion(int);

QDataStream &operator>>(qint8 &i);
QDataStream &operator>>(quint8 &i);
QDataStream &operator>>(qint16 &i);
QDataStream &operator>>(quint16 &i);
QDataStream &operator>>(qint32 &i);
QDataStream &operator>>(quint32 &i);
QDataStream &operator>>(qint64 &i);
QDataStream &operator>>(quint64 &i);

QDataStream &operator>>(bool &i);
QDataStream &operator>>(float &f);
QDataStream &operator>>(double &f);
QDataStream &operator>>(char *&str);

QDataStream &operator<<(qint8 i);
QDataStream &operator<<(quint8 i);
QDataStream &operator<<(qint16 i);
QDataStream &operator<<(quint16 i);
QDataStream &operator<<(qint32 i);
QDataStream &operator<<(quint32 i);
QDataStream &operator<<(qint64 i);
QDataStream &operator<<(quint64 i);
QDataStream &operator<<(bool i);
QDataStream &operator<<(float f);
QDataStream &operator<<(double f);
QDataStream &operator<<(const char *str);

QDataStream &readBytes(char *&, uint &len);
int readRawData(char *, int len);

QDataStream &writeBytes(const char *, uint len);
int writeRawData(const char *, int len);

int skipRawData(int len);










# 185 "/usr/share/qt4/include/QtCore/qdatastream.h"
private:
QDataStream(const QDataStream &); QDataStream &operator=(const QDataStream &);

QScopedPointer<QDataStreamPrivate> d;

QIODevice *dev;
bool owndev;
bool noswap;
ByteOrder byteorder;
int ver;
Status q_status;
};






inline QIODevice *QDataStream::device() const
{ return dev; }

inline QDataStream::ByteOrder QDataStream::byteOrder() const
{ return byteorder; }

inline int QDataStream::version() const
{ return ver; }

inline void QDataStream::setVersion(int v)
{ ver = v; }

inline QDataStream &QDataStream::operator>>(quint8 &i)
{ return *this >> reinterpret_cast<qint8&>(i); }

inline QDataStream &QDataStream::operator>>(quint16 &i)
{ return *this >> reinterpret_cast<qint16&>(i); }

inline QDataStream &QDataStream::operator>>(quint32 &i)
{ return *this >> reinterpret_cast<qint32&>(i); }

inline QDataStream &QDataStream::operator>>(quint64 &i)
{ return *this >> reinterpret_cast<qint64&>(i); }

inline QDataStream &QDataStream::operator<<(quint8 i)
{ return *this << qint8(i); }

inline QDataStream &QDataStream::operator<<(quint16 i)
{ return *this << qint16(i); }

inline QDataStream &QDataStream::operator<<(quint32 i)
{ return *this << qint32(i); }

inline QDataStream &QDataStream::operator<<(quint64 i)
{ return *this << qint64(i); }

template <typename T>
QDataStream& operator>>(QDataStream& s, QList<T>& l)
{
l.clear();
quint32 c;
s >> c;
for(quint32 i = 0; i < c; ++i)
{
T t;
s >> t;
l.append(t);
if (s.atEnd())
break;
}
return s;
}

template <typename T>
QDataStream& operator<<(QDataStream& s, const QList<T>& l)
{
s << quint32(l.size());
for (int i = 0; i < l.size(); ++i)
s << l.at(i);
return s;
}

template <typename T>
QDataStream& operator>>(QDataStream& s, QLinkedList<T>& l)
{
l.clear();
quint32 c;
s >> c;
for(quint32 i = 0; i < c; ++i)
{
T t;
s >> t;
l.append(t);
if (s.atEnd())
break;
}
return s;
}

template <typename T>
QDataStream& operator<<(QDataStream& s, const QLinkedList<T>& l)
{
s << quint32(l.size());
typename QLinkedList<T>::ConstIterator it = l.constBegin();
for(; it != l.constEnd(); ++it)
s << *it;
return s;
}

template<typename T>
QDataStream& operator>>(QDataStream& s, QVector<T>& v)
{
v.clear();
quint32 c;
s >> c;
v.resize(c);
for(quint32 i = 0; i < c; ++i) {
T t;
s >> t;
v[i] = t;
}
return s;
}

template<typename T>
QDataStream& operator<<(QDataStream& s, const QVector<T>& v)
{
s << quint32(v.size());
for (typename QVector<T>::const_iterator it = v.begin(); it != v.end(); ++it)
s << *it;
return s;
}

template <typename T>
QDataStream &operator>>(QDataStream &in, QSet<T> &set)
{
set.clear();
quint32 c;
in >> c;
for (quint32 i = 0; i < c; ++i) {
T t;
in >> t;
set << t;
if (in.atEnd())
break;
}
return in;
}

template <typename T>
QDataStream& operator<<(QDataStream &out, const QSet<T> &set)
{
out << quint32(set.size());
typename QSet<T>::const_iterator i = set.constBegin();
while (i != set.constEnd()) {
out << *i;
++i;
}
return out;
}

template <class Key, class T>
 QDataStream &operator>>(QDataStream &in, QHash<Key, T> &hash)
{
QDataStream::Status oldStatus = in.status();
in.resetStatus();
hash.clear();

quint32 n;
in >> n;

for (quint32 i = 0; i < n; ++i) {
if (in.status() != QDataStream::Ok)
break;

Key k;
T t;
in >> k >> t;
hash.insertMulti(k, t);
}

if (in.status() != QDataStream::Ok)
hash.clear();
if (oldStatus != QDataStream::Ok)
in.setStatus(oldStatus);
return in;
}

template <class Key, class T>
 QDataStream &operator<<(QDataStream &out, const QHash<Key, T>& hash)
{
out << quint32(hash.size());
typename QHash<Key, T>::ConstIterator it = hash.end();
typename QHash<Key, T>::ConstIterator begin = hash.begin();
while (it != begin) {
--it;
out << it.key() << it.value();
}
return out;
}




# 387 "/usr/share/qt4/include/QtCore/qdatastream.h"
template <class aKey, class aT>
 QDataStream &operator>>(QDataStream &in, QMap<aKey, aT> &map)

# 390 "/usr/share/qt4/include/QtCore/qdatastream.h"
{
QDataStream::Status oldStatus = in.status();
in.resetStatus();
map.clear();

quint32 n;
in >> n;

map.detach();
map.setInsertInOrder(true);
for (quint32 i = 0; i < n; ++i) {
if (in.status() != QDataStream::Ok)
break;

aKey key;
aT value;
in >> key >> value;
map.insertMulti(key, value);
}
map.setInsertInOrder(false);
if (in.status() != QDataStream::Ok)
map.clear();
if (oldStatus != QDataStream::Ok)
in.setStatus(oldStatus);
return in;
}

template <class Key, class T>
 QDataStream &operator<<(QDataStream &out, const QMap<Key, T> &map)
{
out << quint32(map.size());
typename QMap<Key, T>::ConstIterator it = map.end();
typename QMap<Key, T>::ConstIterator begin = map.begin();
while (it != begin) {
--it;
out << it.key() << it.value();
}
return out;
}



# 432 "/usr/share/qt4/include/QtCore/qdatastream.h"





# 46 "/usr/share/qt4/include/QtCore/qstringlist.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qstringlist.h"

# 1 "/usr/share/qt4/include/QtCore/qregexp.h"














































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qregexp.h"





# 52 "/usr/share/qt4/include/QtCore/qregexp.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

struct QRegExpPrivate;
class QStringList;

class  QRegExp
{
public:
enum PatternSyntax {
RegExp,
Wildcard,
FixedString,
RegExp2,
WildcardUnix,
W3CXmlSchema11 };
enum CaretMode { CaretAtZero, CaretAtOffset, CaretWontMatch };

QRegExp();
explicit QRegExp(const QString &pattern, Qt::CaseSensitivity cs = Qt::CaseSensitive,
PatternSyntax syntax = RegExp);
QRegExp(const QRegExp &rx);
~QRegExp();
QRegExp &operator=(const QRegExp &rx);

bool operator==(const QRegExp &rx) const;
inline bool operator!=(const QRegExp &rx) const { return !operator==(rx); }

bool isEmpty() const;
bool isValid() const;
QString pattern() const;
void setPattern(const QString &pattern);
Qt::CaseSensitivity caseSensitivity() const;
void setCaseSensitivity(Qt::CaseSensitivity cs);





# 94 "/usr/share/qt4/include/QtCore/qregexp.h"
PatternSyntax patternSyntax() const;
void setPatternSyntax(PatternSyntax syntax);






# 102 "/usr/share/qt4/include/QtCore/qregexp.h"
bool isMinimal() const;
void setMinimal(bool minimal);




# 108 "/usr/share/qt4/include/QtCore/qregexp.h"
bool exactMatch(const QString &str) const;

int indexIn(const QString &str, int offset = 0, CaretMode caretMode = CaretAtZero) const;
int lastIndexIn(const QString &str, int offset = -1, CaretMode caretMode = CaretAtZero) const;








# 120 "/usr/share/qt4/include/QtCore/qregexp.h"
int matchedLength() const;


# 123 "/usr/share/qt4/include/QtCore/qregexp.h"
 int numCaptures() const;

# 125 "/usr/share/qt4/include/QtCore/qregexp.h"
int captureCount() const;
QStringList capturedTexts() const;
QStringList capturedTexts();
QString cap(int nth = 0) const;
QString cap(int nth = 0);
int pos(int nth = 0) const;
int pos(int nth = 0);
QString errorString() const;
QString errorString();


# 136 "/usr/share/qt4/include/QtCore/qregexp.h"
static QString escape(const QString &str);










# 147 "/usr/share/qt4/include/QtCore/qregexp.h"
private:
QRegExpPrivate *priv;
};

template <> class QTypeInfo<QRegExp > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QRegExp)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QRegExp"; } };


# 154 "/usr/share/qt4/include/QtCore/qregexp.h"
 QDataStream &operator<<(QDataStream &out, const QRegExp &regExp);
 QDataStream &operator>>(QDataStream &in, QRegExp &regExp);


# 158 "/usr/share/qt4/include/QtCore/qregexp.h"







# 48 "/usr/share/qt4/include/QtCore/qstringlist.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtCore/qstringlist.h"

# 1 "/usr/share/qt4/include/QtCore/qstringmatcher.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qstringmatcher.h"


# 47 "/usr/share/qt4/include/QtCore/qstringmatcher.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QStringMatcherPrivate;

class  QStringMatcher
{
public:
QStringMatcher();
QStringMatcher(const QString &pattern,
Qt::CaseSensitivity cs = Qt::CaseSensitive);
QStringMatcher(const QChar *uc, int len,
Qt::CaseSensitivity cs = Qt::CaseSensitive);
QStringMatcher(const QStringMatcher &other);
~QStringMatcher();

QStringMatcher &operator=(const QStringMatcher &other);

void setPattern(const QString &pattern);
void setCaseSensitivity(Qt::CaseSensitivity cs);

int indexIn(const QString &str, int from = 0) const;
int indexIn(const QChar *str, int length, int from = 0) const;
QString pattern() const;
inline Qt::CaseSensitivity caseSensitivity() const { return q_cs; }

private:
QStringMatcherPrivate *d_ptr;
QString q_pattern;
Qt::CaseSensitivity q_cs;





# 85 "/usr/share/qt4/include/QtCore/qstringmatcher.h"
struct Data {
uchar q_skiptable[256];
const QChar *uc;
int len;
};
union {
uint q_data[256];
Data p;
};



# 97 "/usr/share/qt4/include/QtCore/qstringmatcher.h"
};






# 50 "/usr/share/qt4/include/QtCore/qstringlist.h"





# 55 "/usr/share/qt4/include/QtCore/qstringlist.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QRegExp;

typedef QListIterator<QString> QStringListIterator;
typedef QMutableListIterator<QString> QMutableStringListIterator;

class QStringList : public QList<QString>
{
public:
inline QStringList() { }
inline explicit QStringList(const QString &i) { append(i); }
inline QStringList(const QStringList &l) : QList<QString>(l) { }
inline QStringList(const QList<QString> &l) : QList<QString>(l) { }

inline void sort();
inline int removeDuplicates();

inline QString join(const QString &sep) const;

inline QStringList filter(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
inline QBool contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

inline QStringList &replaceInStrings(const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);

inline QStringList operator+(const QStringList &other) const
{ QStringList n = *this; n += other; return n; }
inline QStringList &operator<<(const QString &str)
{ append(str); return *this; }
inline QStringList &operator<<(const QStringList &l)
{ *this += l; return *this; }


# 92 "/usr/share/qt4/include/QtCore/qstringlist.h"
inline QStringList filter(const QRegExp &rx) const;
inline QStringList &replaceInStrings(const QRegExp &rx, const QString &after);
inline int indexOf(const QRegExp &rx, int from = 0) const;
inline int lastIndexOf(const QRegExp &rx, int from = -1) const;
inline int indexOf(QRegExp &rx, int from = 0) const;
inline int lastIndexOf(QRegExp &rx, int from = -1) const;





# 103 "/usr/share/qt4/include/QtCore/qstringlist.h"
inline int indexOf(const QString &str, int from = 0) const
{ return QList<QString>::indexOf(str, from); }
inline int lastIndexOf(const QString &str, int from = -1) const
{ return QList<QString>::lastIndexOf(str, from); }



















# 126 "/usr/share/qt4/include/QtCore/qstringlist.h"
};

namespace QtPrivate {
void  QStringList_sort(QStringList *that);
int  QStringList_removeDuplicates(QStringList *that);
QString  QStringList_join(const QStringList *that, const QString &sep);
QStringList  QStringList_filter(const QStringList *that, const QString &str,
Qt::CaseSensitivity cs);

QBool  QStringList_contains(const QStringList *that, const QString &str, Qt::CaseSensitivity cs);
void  QStringList_replaceInStrings(QStringList *that, const QString &before, const QString &after,
Qt::CaseSensitivity cs);


# 140 "/usr/share/qt4/include/QtCore/qstringlist.h"
void  QStringList_replaceInStrings(QStringList *that, const QRegExp &rx, const QString &after);
QStringList  QStringList_filter(const QStringList *that, const QRegExp &re);
int  QStringList_indexOf(const QStringList *that, const QRegExp &rx, int from);
int  QStringList_lastIndexOf(const QStringList *that, const QRegExp &rx, int from);
int  QStringList_indexOf(const QStringList *that, QRegExp &rx, int from);
int  QStringList_lastIndexOf(const QStringList *that, QRegExp &rx, int from);

# 147 "/usr/share/qt4/include/QtCore/qstringlist.h"
}

inline void QStringList::sort()
{
QtPrivate::QStringList_sort(this);
}

inline int QStringList::removeDuplicates()
{
return QtPrivate::QStringList_removeDuplicates(this);
}

inline QString QStringList::join(const QString &sep) const
{
return QtPrivate::QStringList_join(this, sep);
}

inline QStringList QStringList::filter(const QString &str, Qt::CaseSensitivity cs) const
{
return QtPrivate::QStringList_filter(this, str, cs);
}

inline QBool QStringList::contains(const QString &str, Qt::CaseSensitivity cs) const
{
return QtPrivate::QStringList_contains(this, str, cs);
}

inline QStringList &QStringList::replaceInStrings(const QString &before, const QString &after, Qt::CaseSensitivity cs)
{
QtPrivate::QStringList_replaceInStrings(this, before, after, cs);
return *this;
}


# 181 "/usr/share/qt4/include/QtCore/qstringlist.h"
inline QStringList &QStringList::replaceInStrings(const QRegExp &rx, const QString &after)
{
QtPrivate::QStringList_replaceInStrings(this, rx, after);
return *this;
}

inline QStringList QStringList::filter(const QRegExp &rx) const
{
return QtPrivate::QStringList_filter(this, rx);
}

inline int QStringList::indexOf(const QRegExp &rx, int from) const
{
return QtPrivate::QStringList_indexOf(this, rx, from);
}

inline int QStringList::lastIndexOf(const QRegExp &rx, int from) const
{
return QtPrivate::QStringList_lastIndexOf(this, rx, from);
}

inline int QStringList::indexOf(QRegExp &rx, int from) const
{
return QtPrivate::QStringList_indexOf(this, rx, from);
}

inline int QStringList::lastIndexOf(QRegExp &rx, int from) const
{
return QtPrivate::QStringList_lastIndexOf(this, rx, from);
}


































# 245 "/usr/share/qt4/include/QtCore/qstringlist.h"
inline QDataStream &operator>>(QDataStream &in, QStringList &list)
{
return operator>>(in, static_cast<QList<QString> &>(list));
}
inline QDataStream &operator<<(QDataStream &out, const QStringList &list)
{
return operator<<(out, static_cast<const QList<QString> &>(list));
}


# 255 "/usr/share/qt4/include/QtCore/qstringlist.h"





# 47 "/usr/share/qt4/include/QtCore/qdir.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 48 "/usr/share/qt4/include/QtCore/qdir.h"


# 50 "/usr/share/qt4/include/QtCore/qdir.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QDirPrivate;

class  QDir
{
protected:
QScopedPointer<QDirPrivate> d_ptr;
private:
inline QDirPrivate* d_func() { return reinterpret_cast<QDirPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDirPrivate* d_func() const { return reinterpret_cast<const QDirPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDirPrivate;
public:
enum Filter { Dirs = 0x001,
Files = 0x002,
Drives = 0x004,
NoSymLinks = 0x008,
AllEntries = Dirs | Files | Drives,
TypeMask = 0x00f,




# 75 "/usr/share/qt4/include/QtCore/qdir.h"
Readable = 0x010,
Writable = 0x020,
Executable = 0x040,
PermissionMask = 0x070,




# 83 "/usr/share/qt4/include/QtCore/qdir.h"
Modified = 0x080,
Hidden = 0x100,
System = 0x200,

AccessMask = 0x3F0,

AllDirs = 0x400,
CaseSensitive = 0x800,
NoDotAndDotDot = 0x1000,

NoFilter = -1



# 97 "/usr/share/qt4/include/QtCore/qdir.h"
};
typedef QFlags<Filter> Filters;




# 103 "/usr/share/qt4/include/QtCore/qdir.h"
enum SortFlag { Name = 0x00,
Time = 0x01,
Size = 0x02,
Unsorted = 0x03,
SortByMask = 0x03,

DirsFirst = 0x04,
Reversed = 0x08,
IgnoreCase = 0x10,
DirsLast = 0x20,
LocaleAware = 0x40, 
Type = 0x80,
NoSort = -1



# 119 "/usr/share/qt4/include/QtCore/qdir.h"
};
typedef QFlags<SortFlag> SortFlags;

QDir(const QDir &);
QDir(const QString &path = QString());
QDir(const QString &path, const QString &nameFilter,
SortFlags sort = SortFlags(Name | IgnoreCase), Filters filter = AllEntries);
~QDir();

QDir &operator=(const QDir &);
QDir &operator=(const QString &path);

void setPath(const QString &path);
QString path() const;
QString absolutePath() const;
QString canonicalPath() const;

static void addResourceSearchPath(const QString &path);

static void setSearchPaths(const QString &prefix, const QStringList &searchPaths);
static void addSearchPath(const QString &prefix, const QString &path);
static QStringList searchPaths(const QString &prefix);

QString dirName() const;
QString filePath(const QString &fileName) const;
QString absoluteFilePath(const QString &fileName) const;
QString relativeFilePath(const QString &fileName) const;


# 148 "/usr/share/qt4/include/QtCore/qdir.h"
 static QString convertSeparators(const QString &pathName);

# 150 "/usr/share/qt4/include/QtCore/qdir.h"
static QString toNativeSeparators(const QString &pathName);
static QString fromNativeSeparators(const QString &pathName);

bool cd(const QString &dirName);
bool cdUp();

QStringList nameFilters() const;
void setNameFilters(const QStringList &nameFilters);

Filters filter() const;
void setFilter(Filters filter);
SortFlags sorting() const;
void setSorting(SortFlags sort);

uint count() const;
QString operator[](int) const;

static QStringList nameFiltersFromString(const QString &nameFilter);

QStringList entryList(Filters filters = NoFilter, SortFlags sort = NoSort) const;
QStringList entryList(const QStringList &nameFilters, Filters filters = NoFilter,
SortFlags sort = NoSort) const;

QFileInfoList entryInfoList(Filters filters = NoFilter, SortFlags sort = NoSort) const;
QFileInfoList entryInfoList(const QStringList &nameFilters, Filters filters = NoFilter,
SortFlags sort = NoSort) const;

bool mkdir(const QString &dirName) const;
bool rmdir(const QString &dirName) const;
bool mkpath(const QString &dirPath) const;
bool rmpath(const QString &dirPath) const;

bool isReadable() const;
bool exists() const;
bool isRoot() const;

static bool isRelativePath(const QString &path);
inline static bool isAbsolutePath(const QString &path) { return !isRelativePath(path); }
bool isRelative() const;
inline bool isAbsolute() const { return !isRelative(); }
bool makeAbsolute();

bool operator==(const QDir &dir) const;
inline bool operator!=(const QDir &dir) const { return !operator==(dir); }

bool remove(const QString &fileName);
bool rename(const QString &oldName, const QString &newName);
bool exists(const QString &name) const;

static QFileInfoList drives();

static QChar separator();

static bool setCurrent(const QString &path);
static inline QDir current() { return QDir(currentPath()); }
static QString currentPath();

static inline QDir home() { return QDir(homePath()); }
static QString homePath();
static inline QDir root() { return QDir(rootPath()); }
static QString rootPath();
static inline QDir temp() { return QDir(tempPath()); }
static QString tempPath();


# 215 "/usr/share/qt4/include/QtCore/qdir.h"
static bool match(const QStringList &filters, const QString &fileName);
static bool match(const QString &filter, const QString &fileName);

# 218 "/usr/share/qt4/include/QtCore/qdir.h"
static QString cleanPath(const QString &path);
void refresh() const;






























# 250 "/usr/share/qt4/include/QtCore/qdir.h"
};

inline QFlags<QDir::Filters::enum_type> operator|(QDir::Filters::enum_type f1, QDir::Filters::enum_type f2) { return QFlags<QDir::Filters::enum_type>(f1) | f2; } inline QFlags<QDir::Filters::enum_type> operator|(QDir::Filters::enum_type f1, QFlags<QDir::Filters::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QDir::Filters::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<QDir::SortFlags::enum_type> operator|(QDir::SortFlags::enum_type f1, QDir::SortFlags::enum_type f2) { return QFlags<QDir::SortFlags::enum_type>(f1) | f2; } inline QFlags<QDir::SortFlags::enum_type> operator|(QDir::SortFlags::enum_type f1, QFlags<QDir::SortFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QDir::SortFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 256 "/usr/share/qt4/include/QtCore/qdir.h"
class QDebug;
 QDebug operator<<(QDebug debug, QDir::Filters filters);
 QDebug operator<<(QDebug debug, const QDir &dir);


# 261 "/usr/share/qt4/include/QtCore/qdir.h"





# 45 "/usr/share/qt4/include/QtCore/qabstractfileengine.h"






# 51 "/usr/share/qt4/include/QtCore/qabstractfileengine.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QFileExtension;
class QFileExtensionResult;
class QVariant;
class QAbstractFileEngineIterator;
class QAbstractFileEnginePrivate;

class  QAbstractFileEngine
{
public:
enum FileFlag {

ReadOwnerPerm = 0x4000, WriteOwnerPerm = 0x2000, ExeOwnerPerm = 0x1000,
ReadUserPerm = 0x0400, WriteUserPerm = 0x0200, ExeUserPerm = 0x0100,
ReadGroupPerm = 0x0040, WriteGroupPerm = 0x0020, ExeGroupPerm = 0x0010,
ReadOtherPerm = 0x0004, WriteOtherPerm = 0x0002, ExeOtherPerm = 0x0001,


LinkType = 0x10000,
FileType = 0x20000,
DirectoryType = 0x40000,
BundleType = 0x80000,


HiddenFlag = 0x0100000,
LocalDiskFlag = 0x0200000,
ExistsFlag = 0x0400000,
RootFlag = 0x0800000,
Refresh = 0x1000000,


PermsMask = 0x0000FFFF,
TypesMask = 0x000F0000,
FlagsMask = 0x0FF00000,
FileInfoAll = FlagsMask | PermsMask | TypesMask
};
typedef QFlags<FileFlag> FileFlags;

enum FileName {
DefaultName,
BaseName,
PathName,
AbsoluteName,
AbsolutePathName,
LinkName,
CanonicalName,
CanonicalPathName,
BundleName,
NFileNames = 9
};
enum FileOwner {
OwnerUser,
OwnerGroup
};
enum FileTime {
CreationTime,
ModificationTime,
AccessTime
};

virtual ~QAbstractFileEngine();

virtual bool open(QIODevice::OpenMode openMode);
virtual bool close();
virtual bool flush();
virtual qint64 size() const;
virtual qint64 pos() const;
virtual bool seek(qint64 pos);
virtual bool isSequential() const;
virtual bool remove();
virtual bool copy(const QString &newName);
virtual bool rename(const QString &newName);
virtual bool link(const QString &newName);
virtual bool mkdir(const QString &dirName, bool createParentDirectories) const;
virtual bool rmdir(const QString &dirName, bool recurseParentDirectories) const;
virtual bool setSize(qint64 size);
virtual bool caseSensitive() const;
virtual bool isRelativePath() const;
virtual QStringList entryList(QDir::Filters filters, const QStringList &filterNames) const;
virtual FileFlags fileFlags(FileFlags type=FileInfoAll) const;
virtual bool setPermissions(uint perms);
virtual QString fileName(FileName file=DefaultName) const;
virtual uint ownerId(FileOwner) const;
virtual QString owner(FileOwner) const;
virtual QDateTime fileTime(FileTime time) const;
virtual void setFileName(const QString &file);
virtual int handle() const;
bool atEnd() const;
uchar *map(qint64 offset, qint64 size, QFile::MemoryMapFlags flags);
bool unmap(uchar *ptr);

typedef QAbstractFileEngineIterator Iterator;
virtual Iterator *beginEntryList(QDir::Filters filters, const QStringList &filterNames);
virtual Iterator *endEntryList();

virtual qint64 read(char *data, qint64 maxlen);
virtual qint64 readLine(char *data, qint64 maxlen);
virtual qint64 write(const char *data, qint64 len);

QFile::FileError error() const;
QString errorString() const;

enum Extension {
AtEndExtension,
FastReadLineExtension,
MapExtension,
UnMapExtension
};
class ExtensionOption
{};
class ExtensionReturn
{};

class MapExtensionOption : public ExtensionOption {
public:
qint64 offset;
qint64 size;
QFile::MemoryMapFlags flags;
};
class MapExtensionReturn : public ExtensionReturn {
public:
uchar *address;
};

class UnMapExtensionOption : public ExtensionOption {
public:
uchar *address;
};

virtual bool extension(Extension extension, const ExtensionOption *option = 0, ExtensionReturn *output = 0);
virtual bool supportsExtension(Extension extension) const;


static QAbstractFileEngine *create(const QString &fileName);

protected:
void setError(QFile::FileError error, const QString &str);

QAbstractFileEngine();
QAbstractFileEngine(QAbstractFileEnginePrivate &);

QScopedPointer<QAbstractFileEnginePrivate> d_ptr;
private:
inline QAbstractFileEnginePrivate* d_func() { return reinterpret_cast<QAbstractFileEnginePrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractFileEnginePrivate* d_func() const { return reinterpret_cast<const QAbstractFileEnginePrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractFileEnginePrivate;
QAbstractFileEngine(const QAbstractFileEngine &); QAbstractFileEngine &operator=(const QAbstractFileEngine &);
};

inline QFlags<QAbstractFileEngine::FileFlags::enum_type> operator|(QAbstractFileEngine::FileFlags::enum_type f1, QAbstractFileEngine::FileFlags::enum_type f2) { return QFlags<QAbstractFileEngine::FileFlags::enum_type>(f1) | f2; } inline QFlags<QAbstractFileEngine::FileFlags::enum_type> operator|(QAbstractFileEngine::FileFlags::enum_type f1, QFlags<QAbstractFileEngine::FileFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QAbstractFileEngine::FileFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class  QAbstractFileEngineHandler
{
public:
QAbstractFileEngineHandler();
virtual ~QAbstractFileEngineHandler();
virtual QAbstractFileEngine *create(const QString &fileName) const = 0;
};

class QAbstractFileEngineIteratorPrivate;
class  QAbstractFileEngineIterator
{
public:
QAbstractFileEngineIterator(QDir::Filters filters, const QStringList &nameFilters);
virtual ~QAbstractFileEngineIterator();

virtual QString next() = 0;
virtual bool hasNext() const = 0;

QString path() const;
QStringList nameFilters() const;
QDir::Filters filters() const;

virtual QString currentFileName() const = 0;
virtual QFileInfo currentFileInfo() const;
QString currentFilePath() const;

protected:
enum EntryInfoType {
};
virtual QVariant entryInfo(EntryInfoType type) const;

private:
QAbstractFileEngineIterator(const QAbstractFileEngineIterator &); QAbstractFileEngineIterator &operator=(const QAbstractFileEngineIterator &);
friend class QDirIterator;
friend class QDirIteratorPrivate;
void setPath(const QString &path);
QScopedPointer<QAbstractFileEngineIteratorPrivate> d;
};






# 3 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qbuffer.h"












































# 1 "/usr/share/qt4/include/QtCore/qiodevice.h"






























































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qbuffer.h"

# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qbuffer.h"


# 48 "/usr/share/qt4/include/QtCore/qbuffer.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QObject;
class QBufferPrivate;

class  QBuffer : public QIODevice
{

# 60 "/usr/share/qt4/include/QtCore/qbuffer.h"
Q_OBJECT


# 63 "/usr/share/qt4/include/QtCore/qbuffer.h"
public:

# 65 "/usr/share/qt4/include/QtCore/qbuffer.h"
explicit QBuffer(QObject *parent = 0);
QBuffer(QByteArray *buf, QObject *parent = 0);




# 71 "/usr/share/qt4/include/QtCore/qbuffer.h"
~QBuffer();

QByteArray &buffer();
const QByteArray &buffer() const;
void setBuffer(QByteArray *a);

void setData(const QByteArray &data);
inline void setData(const char *data, int len);
const QByteArray &data() const;

bool open(OpenMode openMode);

void close();
qint64 size() const;
qint64 pos() const;
bool seek(qint64 off);
bool atEnd() const;
bool canReadLine() const;

protected:

# 92 "/usr/share/qt4/include/QtCore/qbuffer.h"
void connectNotify(const char*);
void disconnectNotify(const char*);

# 95 "/usr/share/qt4/include/QtCore/qbuffer.h"
qint64 readData(char *data, qint64 maxlen);
qint64 writeData(const char *data, qint64 len);

private:
inline QBufferPrivate* d_func() { return reinterpret_cast<QBufferPrivate *>(qGetPtrHelper(d_ptr)); } inline const QBufferPrivate* d_func() const { return reinterpret_cast<const QBufferPrivate *>(qGetPtrHelper(d_ptr)); } friend class QBufferPrivate;
QBuffer(const QBuffer &); QBuffer &operator=(const QBuffer &);


};

inline void QBuffer::setData(const char *adata, int alen)
{ setData(QByteArray(adata, alen)); }






# 4 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qdatastream.h"


















































































































































































































































































































































































































































# 5 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qdebug.h"












































# 1 "/usr/share/qt4/include/QtCore/qalgorithms.h"








































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qdebug.h"

# 1 "/usr/share/qt4/include/QtCore/qhash.h"












































# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 45 "/usr/share/qt4/include/QtCore/qhash.h"

# 1 "/usr/share/qt4/include/QtCore/qchar.h"













































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qhash.h"

# 1 "/usr/share/qt4/include/QtCore/qiterator.h"






































































# 47 "/usr/share/qt4/include/QtCore/qhash.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtCore/qhash.h"

# 1 "/usr/share/qt4/include/QtCore/qpair.h"












































# 1 "/usr/share/qt4/include/QtCore/qdatastream.h"


















































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qpair.h"


# 47 "/usr/share/qt4/include/QtCore/qpair.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

template <class T1, class T2>
struct QPair
{
typedef T1 first_type;
typedef T2 second_type;

QPair() : first(T1()), second(T2()) {}
QPair(const T1 &t1, const T2 &t2) : first(t1), second(t2) {}

QPair<T1, T2> &operator=(const QPair<T1, T2> &other)
{ first = other.first; second = other.second; return *this; }

T1 first;
T2 second;
};

template <class T1, class T2>
inline bool operator==(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{ return p1.first == p2.first && p1.second == p2.second; }

template <class T1, class T2>
inline bool operator!=(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{ return !(p1 == p2); }

template <class T1, class T2>
inline bool operator<(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{
return p1.first < p2.first || (!(p2.first < p1.first) && p1.second < p2.second);
}

template <class T1, class T2>
inline bool operator>(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{
return p2 < p1;
}

template <class T1, class T2>
inline bool operator<=(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{
return !(p2 < p1);
}

template <class T1, class T2>
inline bool operator>=(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{
return !(p1 < p2);
}

template <class T1, class T2>
 QPair<T1, T2> qMakePair(const T1 &x, const T2 &y)
{
return QPair<T1, T2>(x, y);
}


# 108 "/usr/share/qt4/include/QtCore/qpair.h"
template <class T1, class T2>
inline QDataStream& operator>>(QDataStream& s, QPair<T1, T2>& p)
{
s >> p.first >> p.second;
return s;
}

template <class T1, class T2>
inline QDataStream& operator<<(QDataStream& s, const QPair<T1, T2>& p)
{
s << p.first << p.second;
return s;
}


# 123 "/usr/share/qt4/include/QtCore/qpair.h"





# 49 "/usr/share/qt4/include/QtCore/qhash.h"


# 51 "/usr/share/qt4/include/QtCore/qhash.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QBitArray;
class QByteArray;
class QString;
class QStringRef;

inline uint qHash(char key) { return uint(key); }
inline uint qHash(uchar key) { return uint(key); }
inline uint qHash(signed char key) { return uint(key); }
inline uint qHash(ushort key) { return uint(key); }
inline uint qHash(short key) { return uint(key); }
inline uint qHash(uint key) { return key; }
inline uint qHash(int key) { return uint(key); }
inline uint qHash(ulong key)
{
if (sizeof(ulong) > sizeof(uint)) {
return uint(((key >> (8 * sizeof(uint) - 1)) ^ key) & (~0U));
} else {
return uint(key & (~0U));
}
}
inline uint qHash(long key) { return qHash(ulong(key)); }
inline uint qHash(quint64 key)
{
if (sizeof(quint64) > sizeof(uint)) {
return uint(((key >> (8 * sizeof(uint) - 1)) ^ key) & (~0U));
} else {
return uint(key & (~0U));
}
}
inline uint qHash(qint64 key) { return qHash(quint64(key)); }
inline uint qHash(QChar key) { return qHash(key.unicode()); }
 uint qHash(const QByteArray &key);
 uint qHash(const QString &key);
 uint qHash(const QStringRef &key);
 uint qHash(const QBitArray &key);





# 97 "/usr/share/qt4/include/QtCore/qhash.h"
template <class T> inline uint qHash(const T *key)
{
return qHash(reinterpret_cast<quintptr>(key));
}




# 105 "/usr/share/qt4/include/QtCore/qhash.h"
template <typename T1, typename T2> inline uint qHash(const QPair<T1, T2> &key)
{
uint h1 = qHash(key.first);
uint h2 = qHash(key.second);
return ((h1 << 16) | (h1 >> 16)) ^ h2;
}

struct  QHashData
{
struct Node {
Node *next;
uint h;
};

Node *fakeNext;
Node **buckets;
QBasicAtomicInt ref;
int size;
int nodeSize;
short userNumBits;
short numBits;
int numBuckets;
uint sharable : 1;
uint strictAlignment : 1;
uint reserved : 30;

void *allocateNode(); 
void *allocateNode(int nodeAlign);
void freeNode(void *node);
QHashData *detach_helper(void (*node_duplicate)(Node *, void *), int nodeSize); 
QHashData *detach_helper2(void (*node_duplicate)(Node *, void *), void (*node_delete)(Node *),
int nodeSize, int nodeAlign);
void mightGrow();
bool willGrow();
void hasShrunk();
void rehash(int hint);
void free_helper(void (*node_delete)(Node *));
void destroyAndFree(); 
Node *firstNode();




# 148 "/usr/share/qt4/include/QtCore/qhash.h"
static Node *nextNode(Node *node);
static Node *previousNode(Node *node);

static QHashData shared_null;
};

inline void QHashData::mightGrow() 
{
if (size >= numBuckets)
rehash(numBits + 1);
}

inline bool QHashData::willGrow()
{
if (size >= numBuckets) {
rehash(numBits + 1);
return true;
} else {
return false;
}
}

inline void QHashData::hasShrunk()
{
if (size <= (numBuckets >> 3) && numBits > userNumBits) {
try {
rehash(qMax(int(numBits) - 2, int(userNumBits)));
} catch (const std::bad_alloc &) {

}
}
}

inline QHashData::Node *QHashData::firstNode()
{
Node *e = reinterpret_cast<Node *>(this);
Node **bucket = buckets;
int n = numBuckets;
while (n--) {
if (*bucket != e)
return *bucket;
++bucket;
}
return e;
}

struct QHashDummyValue
{
};

inline bool operator==(const QHashDummyValue & , const QHashDummyValue & )
{
return true;
}

template <> class QTypeInfo<QHashDummyValue > { public: enum { isComplex = (((Q_MOVABLE_TYPE | Q_DUMMY_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE | Q_DUMMY_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QHashDummyValue)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE | Q_DUMMY_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QHashDummyValue"; } };

template <class Key, class T>
struct QHashDummyNode
{
QHashDummyNode *next;
uint h;
Key key;

inline QHashDummyNode(const Key &key0) : key(key0) {}
};

template <class Key, class T>
struct QHashNode
{
QHashNode *next;
uint h;
Key key;
T value;

inline QHashNode(const Key &key0) : key(key0) {} 
inline QHashNode(const Key &key0, const T &value0) : key(key0), value(value0) {}
inline bool same_key(uint h0, const Key &key0) { return h0 == h && key0 == key; }
};





# 250 "/usr/share/qt4/include/QtCore/qhash.h"
template <class T> struct QHashDummyNode<short, T> { QHashDummyNode *next; union { uint h; short key; }; inline QHashDummyNode(short ) {} }; template <class T> struct QHashNode<short, T> { QHashNode *next; union { uint h; short key; }; T value; inline QHashNode(short ) {} inline QHashNode(short , const T &value0) : value(value0) {} inline bool same_key(uint h0, short) { return h0 == h; } };
template <class T> struct QHashDummyNode<ushort, T> { QHashDummyNode *next; union { uint h; ushort key; }; inline QHashDummyNode(ushort ) {} }; template <class T> struct QHashNode<ushort, T> { QHashNode *next; union { uint h; ushort key; }; T value; inline QHashNode(ushort ) {} inline QHashNode(ushort , const T &value0) : value(value0) {} inline bool same_key(uint h0, ushort) { return h0 == h; } };

# 253 "/usr/share/qt4/include/QtCore/qhash.h"
template <class T> struct QHashDummyNode<int, T> { QHashDummyNode *next; union { uint h; int key; }; inline QHashDummyNode(int ) {} }; template <class T> struct QHashNode<int, T> { QHashNode *next; union { uint h; int key; }; T value; inline QHashNode(int ) {} inline QHashNode(int , const T &value0) : value(value0) {} inline bool same_key(uint h0, int) { return h0 == h; } };
template <class T> struct QHashDummyNode<uint, T> { QHashDummyNode *next; union { uint h; uint key; }; inline QHashDummyNode(uint ) {} }; template <class T> struct QHashNode<uint, T> { QHashNode *next; union { uint h; uint key; }; T value; inline QHashNode(uint ) {} inline QHashNode(uint , const T &value0) : value(value0) {} inline bool same_key(uint h0, uint) { return h0 == h; } };



# 258 "/usr/share/qt4/include/QtCore/qhash.h"
template <class Key, class T>
class QHash
{
typedef QHashDummyNode<Key, T> DummyNode;
typedef QHashNode<Key, T> Node;

union {
QHashData *d;
QHashNode<Key, T> *e;
};

static inline Node *concrete(QHashData::Node *node) {
return reinterpret_cast<Node *>(node);
}





# 277 "/usr/share/qt4/include/QtCore/qhash.h"
static inline int alignOfNode() { return 0; }
static inline int alignOfDummyNode() { return 0; }


# 281 "/usr/share/qt4/include/QtCore/qhash.h"
public:
inline QHash() : d(&QHashData::shared_null) { d->ref.ref(); }
inline QHash(const QHash<Key, T> &other) : d(other.d) { d->ref.ref(); if (!d->sharable) detach(); }
inline ~QHash() { if (!d->ref.deref()) freeData(d); }

QHash<Key, T> &operator=(const QHash<Key, T> &other);

bool operator==(const QHash<Key, T> &other) const;
inline bool operator!=(const QHash<Key, T> &other) const { return !(*this == other); }

inline int size() const { return d->size; }

inline bool isEmpty() const { return d->size == 0; }

inline int capacity() const { return d->numBuckets; }
void reserve(int size);
inline void squeeze() { reserve(1); }

inline void detach() { if (d->ref != 1) detach_helper(); }
inline bool isDetached() const { return d->ref == 1; }
inline void setSharable(bool sharable) { if (!sharable) detach(); d->sharable = sharable; }

void clear();

int remove(const Key &key);
T take(const Key &key);

bool contains(const Key &key) const;
const Key key(const T &value) const;
const Key key(const T &value, const Key &defaultKey) const;
const T value(const Key &key) const;
const T value(const Key &key, const T &defaultValue) const;
T &operator[](const Key &key);
const T operator[](const Key &key) const;

QList<Key> uniqueKeys() const;
QList<Key> keys() const;
QList<Key> keys(const T &value) const;
QList<T> values() const;
QList<T> values(const Key &key) const;
int count(const Key &key) const;

class const_iterator;

class iterator
{
friend class const_iterator;
QHashData::Node *i;

public:
typedef std::bidirectional_iterator_tag iterator_category;
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef T *pointer;
typedef T &reference;


inline operator Node *() const { return concrete(i); }
inline iterator() : i(0) { }
explicit inline iterator(void *node) : i(reinterpret_cast<QHashData::Node *>(node)) { }

inline const Key &key() const { return concrete(i)->key; }
inline T &value() const { return concrete(i)->value; }
inline T &operator*() const { return concrete(i)->value; }
inline T *operator->() const { return &concrete(i)->value; }
inline bool operator==(const iterator &o) const { return i == o.i; }
inline bool operator!=(const iterator &o) const { return i != o.i; }

inline iterator &operator++() {
i = QHashData::nextNode(i);
return *this;
}
inline iterator operator++(int) {
iterator r = *this;
i = QHashData::nextNode(i);
return r;
}
inline iterator &operator--() {
i = QHashData::previousNode(i);
return *this;
}
inline iterator operator--(int) {
iterator r = *this;
i = QHashData::previousNode(i);
return r;
}
inline iterator operator+(int j) const
{ iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; }
inline iterator operator-(int j) const { return operator+(-j); }
inline iterator &operator+=(int j) { return *this = *this + j; }
inline iterator &operator-=(int j) { return *this = *this - j; }





# 377 "/usr/share/qt4/include/QtCore/qhash.h"
public:

# 379 "/usr/share/qt4/include/QtCore/qhash.h"
inline bool operator==(const const_iterator &o) const
{ return i == o.i; }
inline bool operator!=(const const_iterator &o) const
{ return i != o.i; }

private:

inline operator bool() const { return false; }
};
friend class iterator;

class const_iterator
{
friend class iterator;
QHashData::Node *i;

public:
typedef std::bidirectional_iterator_tag iterator_category;
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef const T *pointer;
typedef const T &reference;


inline operator Node *() const { return concrete(i); }
inline const_iterator() : i(0) { }
explicit inline const_iterator(void *node)
: i(reinterpret_cast<QHashData::Node *>(node)) { }



# 410 "/usr/share/qt4/include/QtCore/qhash.h"
inline const_iterator(const iterator &o)

# 412 "/usr/share/qt4/include/QtCore/qhash.h"
{ i = o.i; }

inline const Key &key() const { return concrete(i)->key; }
inline const T &value() const { return concrete(i)->value; }
inline const T &operator*() const { return concrete(i)->value; }
inline const T *operator->() const { return &concrete(i)->value; }
inline bool operator==(const const_iterator &o) const { return i == o.i; }
inline bool operator!=(const const_iterator &o) const { return i != o.i; }

inline const_iterator &operator++() {
i = QHashData::nextNode(i);
return *this;
}
inline const_iterator operator++(int) {
const_iterator r = *this;
i = QHashData::nextNode(i);
return r;
}
inline const_iterator &operator--() {
i = QHashData::previousNode(i);
return *this;
}
inline const_iterator operator--(int) {
const_iterator r = *this;
i = QHashData::previousNode(i);
return r;
}
inline const_iterator operator+(int j) const
{ const_iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; }
inline const_iterator operator-(int j) const { return operator+(-j); }
inline const_iterator &operator+=(int j) { return *this = *this + j; }
inline const_iterator &operator-=(int j) { return *this = *this - j; }








# 452 "/usr/share/qt4/include/QtCore/qhash.h"
private:

inline operator bool() const { return false; }
};
friend class const_iterator;


inline iterator begin() { detach(); return iterator(d->firstNode()); }
inline const_iterator begin() const { return const_iterator(d->firstNode()); }
inline const_iterator constBegin() const { return const_iterator(d->firstNode()); }
inline iterator end() { detach(); return iterator(e); }
inline const_iterator end() const { return const_iterator(e); }
inline const_iterator constEnd() const { return const_iterator(e); }
iterator erase(iterator it);


typedef iterator Iterator;
typedef const_iterator ConstIterator;
inline int count() const { return d->size; }
iterator find(const Key &key);
const_iterator find(const Key &key) const;
const_iterator constFind(const Key &key) const;
iterator insert(const Key &key, const T &value);
iterator insertMulti(const Key &key, const T &value);
QHash<Key, T> &unite(const QHash<Key, T> &other);


typedef T mapped_type;
typedef Key key_type;
typedef ptrdiff_t difference_type;
typedef int size_type;

inline bool empty() const { return isEmpty(); }






# 491 "/usr/share/qt4/include/QtCore/qhash.h"
private:
void detach_helper();
void freeData(QHashData *d);
Node **findNode(const Key &key, uint *hp = 0) const;
Node *createNode(uint h, const Key &key, const T &value, Node **nextNode);
void deleteNode(Node *node);
static void deleteNode2(QHashData::Node *node);

static void duplicateNode(QHashData::Node *originalNode, void *newNode);
};


template <class Key, class T>
inline void QHash<Key, T>::deleteNode(Node *node)
{
deleteNode2(reinterpret_cast<QHashData::Node*>(node));
d->freeNode(node);
}

template <class Key, class T>
inline void QHash<Key, T>::deleteNode2(QHashData::Node *node)
{





# 518 "/usr/share/qt4/include/QtCore/qhash.h"
concrete(node)->~Node();

# 520 "/usr/share/qt4/include/QtCore/qhash.h"
}

template <class Key, class T>
void QHash<Key, T>::duplicateNode(QHashData::Node *node, void *newNode)
{
Node *concreteNode = concrete(node);
if (QTypeInfo<T>::isDummy) {
(void) new (newNode) DummyNode(concreteNode->key);
} else {
(void) new (newNode) Node(concreteNode->key, concreteNode->value);
}
}

template <class Key, class T>
inline typename QHash<Key, T>::Node *
QHash<Key, T>::createNode(uint ah, const Key &akey, const T &avalue, Node **anextNode)
{
Node *node;

if (QTypeInfo<T>::isDummy) {
node = reinterpret_cast<Node *>(new (d->allocateNode(alignOfDummyNode())) DummyNode(akey));
} else {
node = new (d->allocateNode(alignOfNode())) Node(akey, avalue);
}

node->h = ah;
node->next = *anextNode;
*anextNode = node;
++d->size;
return node;
}

template <class Key, class T>
inline QHash<Key, T> &QHash<Key, T>::unite(const QHash<Key, T> &other)
{
QHash<Key, T> copy(other);
const_iterator it = copy.constEnd();
while (it != copy.constBegin()) {
--it;
insertMulti(it.key(), it.value());
}
return *this;
}

template <class Key, class T>
 void QHash<Key, T>::freeData(QHashData *x)
{
x->free_helper(deleteNode2);
}

template <class Key, class T>
inline void QHash<Key, T>::clear()
{
*this = QHash<Key,T>();
}

template <class Key, class T>
 void QHash<Key, T>::detach_helper()
{
QHashData *x = d->detach_helper2(duplicateNode, deleteNode2,
QTypeInfo<T>::isDummy ? sizeof(DummyNode) : sizeof(Node),
QTypeInfo<T>::isDummy ? alignOfDummyNode() : alignOfNode());
if (!d->ref.deref())
freeData(d);
d = x;
}

template <class Key, class T>
inline QHash<Key, T> &QHash<Key, T>::operator=(const QHash<Key, T> &other)
{
if (d != other.d) {
other.d->ref.ref();
if (!d->ref.deref())
freeData(d);
d = other.d;
if (!d->sharable)
detach_helper();
}
return *this;
}

template <class Key, class T>
inline const T QHash<Key, T>::value(const Key &akey) const
{
Node *node;
if (d->size == 0 || (node = *findNode(akey)) == e) {
return T();
} else {
return node->value;
}
}

template <class Key, class T>
inline const T QHash<Key, T>::value(const Key &akey, const T &adefaultValue) const
{
Node *node;
if (d->size == 0 || (node = *findNode(akey)) == e) {
return adefaultValue;
} else {
return node->value;
}
}

template <class Key, class T>
 QList<Key> QHash<Key, T>::uniqueKeys() const
{
QList<Key> res;
const_iterator i = begin();
if (i != end()) {
for (;;) {
const Key &aKey = i.key();
res.append(aKey);
do {
if (++i == end())
goto break_out_of_outer_loop;
} while (aKey == i.key());
}
}
break_out_of_outer_loop:
return res;
}

template <class Key, class T>
 QList<Key> QHash<Key, T>::keys() const
{
QList<Key> res;
const_iterator i = begin();
while (i != end()) {
res.append(i.key());
++i;
}
return res;
}

template <class Key, class T>
 QList<Key> QHash<Key, T>::keys(const T &avalue) const
{
QList<Key> res;
const_iterator i = begin();
while (i != end()) {
if (i.value() == avalue)
res.append(i.key());
++i;
}
return res;
}

template <class Key, class T>
 const Key QHash<Key, T>::key(const T &avalue) const
{
return key(avalue, Key());
}

template <class Key, class T>
 const Key QHash<Key, T>::key(const T &avalue, const Key &defaultValue) const
{
const_iterator i = begin();
while (i != end()) {
if (i.value() == avalue)
return i.key();
++i;
}

return defaultValue;
}

template <class Key, class T>
 QList<T> QHash<Key, T>::values() const
{
QList<T> res;
const_iterator i = begin();
while (i != end()) {
res.append(i.value());
++i;
}
return res;
}

template <class Key, class T>
 QList<T> QHash<Key, T>::values(const Key &akey) const
{
QList<T> res;
Node *node = *findNode(akey);
if (node != e) {
do {
res.append(node->value);
} while ((node = node->next) != e && node->key == akey);
}
return res;
}

template <class Key, class T>
 int QHash<Key, T>::count(const Key &akey) const
{
int cnt = 0;
Node *node = *findNode(akey);
if (node != e) {
do {
++cnt;
} while ((node = node->next) != e && node->key == akey);
}
return cnt;
}

template <class Key, class T>
inline const T QHash<Key, T>::operator[](const Key &akey) const
{
return value(akey);
}

template <class Key, class T>
inline T &QHash<Key, T>::operator[](const Key &akey)
{
detach();

uint h;
Node **node = findNode(akey, &h);
if (*node == e) {
if (d->willGrow())
node = findNode(akey, &h);
return createNode(h, akey, T(), node)->value;
}
return (*node)->value;
}

template <class Key, class T>
inline typename QHash<Key, T>::iterator QHash<Key, T>::insert(const Key &akey,
const T &avalue)
{
detach();

uint h;
Node **node = findNode(akey, &h);
if (*node == e) {
if (d->willGrow())
node = findNode(akey, &h);
return iterator(createNode(h, akey, avalue, node));
}

if (!QTypeInfo<T>::isDummy)
(*node)->value = avalue;
return iterator(*node);
}

template <class Key, class T>
inline typename QHash<Key, T>::iterator QHash<Key, T>::insertMulti(const Key &akey,
const T &avalue)
{
detach();
d->willGrow();

uint h;
Node **nextNode = findNode(akey, &h);
return iterator(createNode(h, akey, avalue, nextNode));
}

template <class Key, class T>
 int QHash<Key, T>::remove(const Key &akey)
{
if (isEmpty()) 
return 0;
detach();

int oldSize = d->size;
Node **node = findNode(akey);
if (*node != e) {
bool deleteNext = true;
do {
Node *next = (*node)->next;
deleteNext = (next != e && next->key == (*node)->key);
deleteNode(*node);
*node = next;
--d->size;
} while (deleteNext);
d->hasShrunk();
}
return oldSize - d->size;
}

template <class Key, class T>
 T QHash<Key, T>::take(const Key &akey)
{
if (isEmpty()) 
return T();
detach();

Node **node = findNode(akey);
if (*node != e) {
T t = (*node)->value;
Node *next = (*node)->next;
deleteNode(*node);
*node = next;
--d->size;
d->hasShrunk();
return t;
}
return T();
}

template <class Key, class T>
 typename QHash<Key, T>::iterator QHash<Key, T>::erase(iterator it)
{
if (it == iterator(e))
return it;

iterator ret = it;
++ret;

Node *node = it;
Node **node_ptr = reinterpret_cast<Node **>(&d->buckets[node->h % d->numBuckets]);
while (*node_ptr != node)
node_ptr = &(*node_ptr)->next;
*node_ptr = node->next;
deleteNode(node);
--d->size;
return ret;
}

template <class Key, class T>
inline void QHash<Key, T>::reserve(int asize)
{
detach();
d->rehash(-qMax(asize, 1));
}

template <class Key, class T>
inline typename QHash<Key, T>::const_iterator QHash<Key, T>::find(const Key &akey) const
{
return const_iterator(*findNode(akey));
}

template <class Key, class T>
inline typename QHash<Key, T>::const_iterator QHash<Key, T>::constFind(const Key &akey) const
{
return const_iterator(*findNode(akey));
}

template <class Key, class T>
inline typename QHash<Key, T>::iterator QHash<Key, T>::find(const Key &akey)
{
detach();
return iterator(*findNode(akey));
}

template <class Key, class T>
inline bool QHash<Key, T>::contains(const Key &akey) const
{
return *findNode(akey) != e;
}

template <class Key, class T>
 typename QHash<Key, T>::Node **QHash<Key, T>::findNode(const Key &akey,
uint *ahp) const
{
Node **node;
uint h = qHash(akey);

if (d->numBuckets) {
node = reinterpret_cast<Node **>(&d->buckets[h % d->numBuckets]);
qt_noop();
while (*node != e && !(*node)->same_key(h, akey))
node = &(*node)->next;
} else {
node = const_cast<Node **>(reinterpret_cast<const Node * const *>(&e));
}
if (ahp)
*ahp = h;
return node;
}

template <class Key, class T>
 bool QHash<Key, T>::operator==(const QHash<Key, T> &other) const
{
if (size() != other.size())
return false;
if (d == other.d)
return true;

const_iterator it = begin();

while (it != end()) {
const Key &akey = it.key();

const_iterator it2 = other.find(akey);
do {
if (it2 == other.end() || !(it2.key() == akey))
return false;
if (!QTypeInfo<T>::isDummy && !(it.value() == it2.value()))
return false;
++it;
++it2;
} while (it != end() && it.key() == akey);
}
return true;
}

template <class Key, class T>
class QMultiHash : public QHash<Key, T>
{
public:
QMultiHash() {}
QMultiHash(const QHash<Key, T> &other) : QHash<Key, T>(other) {}

inline typename QHash<Key, T>::iterator replace(const Key &key, const T &value)
{ return QHash<Key, T>::insert(key, value); }

inline typename QHash<Key, T>::iterator insert(const Key &key, const T &value)
{ return QHash<Key, T>::insertMulti(key, value); }

inline QMultiHash &operator+=(const QMultiHash &other)
{ unite(other); return *this; }
inline QMultiHash operator+(const QMultiHash &other) const
{ QMultiHash result = *this; result += other; return result; }









# 942 "/usr/share/qt4/include/QtCore/qhash.h"
inline bool contains(const Key &key) const
{ return QHash<Key, T>::contains(key); }
inline int remove(const Key &key)
{ return QHash<Key, T>::remove(key); }
inline int count(const Key &key) const
{ return QHash<Key, T>::count(key); }
inline int count() const
{ return QHash<Key, T>::count(); }
inline typename QHash<Key, T>::iterator find(const Key &key)
{ return QHash<Key, T>::find(key); }
inline typename QHash<Key, T>::const_iterator find(const Key &key) const
{ return QHash<Key, T>::find(key); }
inline typename QHash<Key, T>::const_iterator constFind(const Key &key) const
{ return QHash<Key, T>::constFind(key); }


# 958 "/usr/share/qt4/include/QtCore/qhash.h"
bool contains(const Key &key, const T &value) const;

int remove(const Key &key, const T &value);

int count(const Key &key, const T &value) const;

typename QHash<Key, T>::iterator find(const Key &key, const T &value) {
typename QHash<Key, T>::iterator i(find(key));
typename QHash<Key, T>::iterator end(this->end());
while (i != end && i.key() == key) {
if (i.value() == value)
return i;
++i;
}
return end;
}
typename QHash<Key, T>::const_iterator find(const Key &key, const T &value) const {
typename QHash<Key, T>::const_iterator i(constFind(key));
typename QHash<Key, T>::const_iterator end(QHash<Key, T>::constEnd());
while (i != end && i.key() == key) {
if (i.value() == value)
return i;
++i;
}
return end;
}
typename QHash<Key, T>::const_iterator constFind(const Key &key, const T &value) const
{ return find(key, value); }
private:
T &operator[](const Key &key);
const T operator[](const Key &key) const;
};

template <class Key, class T>
inline bool QMultiHash<Key, T>::contains(const Key &key, const T &value) const
{
return constFind(key, value) != QHash<Key, T>::constEnd();
}

template <class Key, class T>
inline int QMultiHash<Key, T>::remove(const Key &key, const T &value)
{
int n = 0;
typename QHash<Key, T>::iterator i(find(key));
typename QHash<Key, T>::iterator end(QHash<Key, T>::end());
while (i != end && i.key() == key) {
if (i.value() == value) {




# 1009 "/usr/share/qt4/include/QtCore/qhash.h"
i = erase(i);

# 1011 "/usr/share/qt4/include/QtCore/qhash.h"
++n;
} else {
++i;
}
}
return n;
}

template <class Key, class T>
inline int QMultiHash<Key, T>::count(const Key &key, const T &value) const
{
int n = 0;
typename QHash<Key, T>::const_iterator i(constFind(key));
typename QHash<Key, T>::const_iterator end(QHash<Key, T>::constEnd());
while (i != end && i.key() == key) {
if (i.value() == value)
++n;
++i;
}
return n;
}

template <class Key, class T> class QHashIterator { typedef typename QHash<Key,T>::const_iterator const_iterator; typedef const_iterator Item; QHash<Key,T> c; const_iterator i, n; inline bool item_exists() const { return n != c.constEnd(); } public: inline QHashIterator(const QHash<Key,T> &container) : c(container), i(c.constBegin()), n(c.constEnd()) {} inline QHashIterator &operator=(const QHash<Key,T> &container) { c = container; i = c.constBegin(); n = c.constEnd(); return *this; } inline void toFront() { i = c.constBegin(); n = c.constEnd(); } inline void toBack() { i = c.constEnd(); n = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline Item next() { n = i++; return n; } inline Item peekNext() const { return i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline Item previous() { n = --i; return n; } inline Item peekPrevious() const { const_iterator p = i; return --p; } inline const T &value() const { qt_noop(); return *n; } inline const Key &key() const { qt_noop(); return n.key(); } inline bool findNext(const T &t) { while ((n = i) != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(n = --i) == t) return true; n = c.constEnd(); return false; } };
template <class Key, class T> class QMutableHashIterator { typedef typename QHash<Key,T>::iterator iterator; typedef typename QHash<Key,T>::const_iterator const_iterator; typedef iterator Item; QHash<Key,T> *c; iterator i, n; inline bool item_exists() const { return const_iterator(n) != c->constEnd(); } public: inline QMutableHashIterator(QHash<Key,T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableHashIterator() { c->setSharable(true); } inline QMutableHashIterator &operator=(QHash<Key,T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = c->end(); } inline bool hasNext() const { return const_iterator(i) != c->constEnd(); } inline Item next() { n = i++; return n; } inline Item peekNext() const { return i; } inline bool hasPrevious() const { return const_iterator(i) != c->constBegin(); } inline Item previous() { n = --i; return n; } inline Item peekPrevious() const { iterator p = i; return --p; } inline void remove() { if (const_iterator(n) != c->constEnd()) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) { if (const_iterator(n) != c->constEnd()) *n = t; } inline T &value() { qt_noop(); return *n; } inline const T &value() const { qt_noop(); return *n; } inline const Key &key() const { qt_noop(); return n.key(); } inline bool findNext(const T &t) { while (const_iterator(n = i) != c->constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (const_iterator(i) != c->constBegin()) if (*(n = --i) == t) return true; n = c->end(); return false; } };






# 46 "/usr/share/qt4/include/QtCore/qdebug.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qdebug.h"

# 1 "/usr/share/qt4/include/QtCore/qmap.h"












































# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 45 "/usr/share/qt4/include/QtCore/qmap.h"

# 1 "/usr/share/qt4/include/QtCore/qiterator.h"






































































# 46 "/usr/share/qt4/include/QtCore/qmap.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qmap.h"








# 55 "/usr/share/qt4/include/QtCore/qmap.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

struct  QMapData
{
struct Node {
Node *backward;
Node *forward[1];
};
enum { LastLevel = 11, Sparseness = 3 };

QMapData *backward;
QMapData *forward[QMapData::LastLevel + 1];
QBasicAtomicInt ref;
int topLevel;
int size;
uint randomBits;
uint insertInOrder : 1;
uint sharable : 1;
uint strictAlignment : 1;
uint reserved : 29;

static QMapData *createData(); 
static QMapData *createData(int alignment);
void continueFreeData(int offset);
Node *node_create(Node *update[], int offset); 
Node *node_create(Node *update[], int offset, int alignment);
void node_delete(Node *update[], int offset, Node *node);





# 91 "/usr/share/qt4/include/QtCore/qmap.h"
static QMapData shared_null;
};












template <class Key> inline bool qMapLessThanKey(const Key &key1, const Key &key2)
{
return key1 < key2;
}


# 111 "/usr/share/qt4/include/QtCore/qmap.h"
template <class Ptr> inline bool qMapLessThanKey(Ptr *key1, Ptr *key2)
{
qt_noop();
return quintptr(key1) < quintptr(key2);
}

template <class Ptr> inline bool qMapLessThanKey(const Ptr *key1, const Ptr *key2)
{
qt_noop();
return quintptr(key1) < quintptr(key2);
}


# 124 "/usr/share/qt4/include/QtCore/qmap.h"
template <class Key, class T>
struct QMapNode {
Key key;
T value;
QMapData::Node *backward;
QMapData::Node *forward[1];
};

template <class Key, class T>
struct QMapPayloadNode
{
Key key;
T value;
QMapData::Node *backward;
};

template <class Key, class T>
class QMap
{
typedef QMapNode<Key, T> Node;
typedef QMapPayloadNode<Key, T> PayloadNode;

union {
QMapData *d;
QMapData::Node *e;
};

static inline int payload() { return sizeof(PayloadNode) - sizeof(QMapData::Node *); }
static inline int alignment() {



# 156 "/usr/share/qt4/include/QtCore/qmap.h"
return 0;

# 158 "/usr/share/qt4/include/QtCore/qmap.h"
}
static inline Node *concrete(QMapData::Node *node) {
return reinterpret_cast<Node *>(reinterpret_cast<char *>(node) - payload());
}

public:
inline QMap() : d(&QMapData::shared_null) { d->ref.ref(); }
inline QMap(const QMap<Key, T> &other) : d(other.d)
{ d->ref.ref(); if (!d->sharable) detach(); }
inline ~QMap() { if (!d) return; if (!d->ref.deref()) freeData(d); }

QMap<Key, T> &operator=(const QMap<Key, T> &other);





# 175 "/usr/share/qt4/include/QtCore/qmap.h"
bool operator==(const QMap<Key, T> &other) const;
inline bool operator!=(const QMap<Key, T> &other) const { return !(*this == other); }

inline int size() const { return d->size; }

inline bool isEmpty() const { return d->size == 0; }

inline void detach() { if (d->ref != 1) detach_helper(); }
inline bool isDetached() const { return d->ref == 1; }
inline void setSharable(bool sharable) { if (!sharable) detach(); d->sharable = sharable; }
inline void setInsertInOrder(bool ordered) { d->insertInOrder = ordered; }

void clear();

int remove(const Key &key);
T take(const Key &key);

bool contains(const Key &key) const;
const Key key(const T &value) const;
const Key key(const T &value, const Key &defaultKey) const;
const T value(const Key &key) const;
const T value(const Key &key, const T &defaultValue) const;
T &operator[](const Key &key);
const T operator[](const Key &key) const;

QList<Key> uniqueKeys() const;
QList<Key> keys() const;
QList<Key> keys(const T &value) const;
QList<T> values() const;
QList<T> values(const Key &key) const;
int count(const Key &key) const;

class const_iterator;

class iterator
{
friend class const_iterator;
QMapData::Node *i;

public:
typedef std::bidirectional_iterator_tag iterator_category;
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef T *pointer;
typedef T &reference;


inline operator QMapData::Node *() const { return i; }
inline iterator() : i(0) { }
inline iterator(QMapData::Node *node) : i(node) { }

inline const Key &key() const { return concrete(i)->key; }
inline T &value() const { return concrete(i)->value; }



# 231 "/usr/share/qt4/include/QtCore/qmap.h"
inline T &operator*() const { return concrete(i)->value; }
inline T *operator->() const { return &concrete(i)->value; }
inline bool operator==(const iterator &o) const { return i == o.i; }
inline bool operator!=(const iterator &o) const { return i != o.i; }

inline iterator &operator++() {
i = i->forward[0];
return *this;
}
inline iterator operator++(int) {
iterator r = *this;
i = i->forward[0];
return r;
}
inline iterator &operator--() {
i = i->backward;
return *this;
}
inline iterator operator--(int) {
iterator r = *this;
i = i->backward;
return r;
}
inline iterator operator+(int j) const
{ iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; }
inline iterator operator-(int j) const { return operator+(-j); }
inline iterator &operator+=(int j) { return *this = *this + j; }
inline iterator &operator-=(int j) { return *this = *this - j; }





# 264 "/usr/share/qt4/include/QtCore/qmap.h"
public:

# 266 "/usr/share/qt4/include/QtCore/qmap.h"
inline bool operator==(const const_iterator &o) const
{ return i == o.i; }
inline bool operator!=(const const_iterator &o) const
{ return i != o.i; }

private:

inline operator bool() const { return false; }
};
friend class iterator;

class const_iterator
{
friend class iterator;
QMapData::Node *i;

public:
typedef std::bidirectional_iterator_tag iterator_category;
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef const T *pointer;
typedef const T &reference;


inline operator QMapData::Node *() const { return i; }
inline const_iterator() : i(0) { }
inline const_iterator(QMapData::Node *node) : i(node) { }



# 296 "/usr/share/qt4/include/QtCore/qmap.h"
inline const_iterator(const iterator &o)

# 298 "/usr/share/qt4/include/QtCore/qmap.h"
{ i = o.i; }

inline const Key &key() const { return concrete(i)->key; }
inline const T &value() const { return concrete(i)->value; }



# 305 "/usr/share/qt4/include/QtCore/qmap.h"
inline const T &operator*() const { return concrete(i)->value; }
inline const T *operator->() const { return &concrete(i)->value; }
inline bool operator==(const const_iterator &o) const { return i == o.i; }
inline bool operator!=(const const_iterator &o) const { return i != o.i; }

inline const_iterator &operator++() {
i = i->forward[0];
return *this;
}
inline const_iterator operator++(int) {
const_iterator r = *this;
i = i->forward[0];
return r;
}
inline const_iterator &operator--() {
i = i->backward;
return *this;
}
inline const_iterator operator--(int) {
const_iterator r = *this;
i = i->backward;
return r;
}
inline const_iterator operator+(int j) const
{ const_iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; }
inline const_iterator operator-(int j) const { return operator+(-j); }
inline const_iterator &operator+=(int j) { return *this = *this + j; }
inline const_iterator &operator-=(int j) { return *this = *this - j; }








# 341 "/usr/share/qt4/include/QtCore/qmap.h"
private:

inline operator bool() const { return false; }
};
friend class const_iterator;


inline iterator begin() { detach(); return iterator(e->forward[0]); }
inline const_iterator begin() const { return const_iterator(e->forward[0]); }
inline const_iterator constBegin() const { return const_iterator(e->forward[0]); }
inline iterator end() {
detach();
return iterator(e);
}
inline const_iterator end() const { return const_iterator(e); }
inline const_iterator constEnd() const { return const_iterator(e); }
iterator erase(iterator it);





# 363 "/usr/share/qt4/include/QtCore/qmap.h"

typedef iterator Iterator;
typedef const_iterator ConstIterator;
inline int count() const { return d->size; }
iterator find(const Key &key);
const_iterator find(const Key &key) const;
const_iterator constFind(const Key &key) const;
iterator lowerBound(const Key &key);
const_iterator lowerBound(const Key &key) const;
iterator upperBound(const Key &key);
const_iterator upperBound(const Key &key) const;
iterator insert(const Key &key, const T &value);



# 378 "/usr/share/qt4/include/QtCore/qmap.h"
iterator insertMulti(const Key &key, const T &value);



# 382 "/usr/share/qt4/include/QtCore/qmap.h"
QMap<Key, T> &unite(const QMap<Key, T> &other);


typedef Key key_type;
typedef T mapped_type;
typedef ptrdiff_t difference_type;
typedef int size_type;
inline bool empty() const { return isEmpty(); }





# 395 "/usr/share/qt4/include/QtCore/qmap.h"
private:
void detach_helper();
void freeData(QMapData *d);
QMapData::Node *findNode(const Key &key) const;
QMapData::Node *mutableFindNode(QMapData::Node *update[], const Key &key) const;
QMapData::Node *node_create(QMapData *d, QMapData::Node *update[], const Key &key,
const T &value);
};

template <class Key, class T>
inline QMap<Key, T> &QMap<Key, T>::operator=(const QMap<Key, T> &other)
{
if (d != other.d) {
other.d->ref.ref();
if (!d->ref.deref())
freeData(d);
d = other.d;
if (!d->sharable)
detach_helper();
}
return *this;
}

template <class Key, class T>
inline void QMap<Key, T>::clear()
{
*this = QMap<Key, T>();
}

template <class Key, class T>
inline typename QMapData::Node *
QMap<Key, T>::node_create(QMapData *adt, QMapData::Node *aupdate[], const Key &akey, const T &avalue)
{
QMapData::Node *abstractNode = adt->node_create(aupdate, payload(), alignment());
try {
Node *concreteNode = concrete(abstractNode);
new (&concreteNode->key) Key(akey);
try {
new (&concreteNode->value) T(avalue);
} catch (...) {
concreteNode->key.~Key();
throw;
}
} catch (...) {
adt->node_delete(aupdate, payload(), abstractNode);
throw;
}










return abstractNode;
}

template <class Key, class T>
inline QMapData::Node *QMap<Key, T>::findNode(const Key &akey) const
{
QMapData::Node *cur = e;
QMapData::Node *next = e;

for (int i = d->topLevel; i >= 0; i--) {
while ((next = cur->forward[i]) != e && qMapLessThanKey<Key>(concrete(next)->key, akey))
cur = next;
}

if (next != e && !qMapLessThanKey<Key>(akey, concrete(next)->key)) {
return next;
} else {
return e;
}
}

template <class Key, class T>
inline const T QMap<Key, T>::value(const Key &akey) const
{
QMapData::Node *node;
if (d->size == 0 || (node = findNode(akey)) == e) {
return T();
} else {
return concrete(node)->value;
}
}

template <class Key, class T>
inline const T QMap<Key, T>::value(const Key &akey, const T &adefaultValue) const
{
QMapData::Node *node;
if (d->size == 0 || (node = findNode(akey)) == e) {
return adefaultValue;
} else {
return concrete(node)->value;
}
}

template <class Key, class T>
inline const T QMap<Key, T>::operator[](const Key &akey) const
{
return value(akey);
}

template <class Key, class T>
inline T &QMap<Key, T>::operator[](const Key &akey)
{
detach();

QMapData::Node *update[QMapData::LastLevel + 1];
QMapData::Node *node = mutableFindNode(update, akey);
if (node == e)
node = node_create(d, update, akey, T());
return concrete(node)->value;
}

template <class Key, class T>
inline int QMap<Key, T>::count(const Key &akey) const
{
int cnt = 0;
QMapData::Node *node = findNode(akey);
if (node != e) {
do {
++cnt;
node = node->forward[0];
} while (node != e && !qMapLessThanKey<Key>(akey, concrete(node)->key));
}
return cnt;
}

template <class Key, class T>
inline bool QMap<Key, T>::contains(const Key &akey) const
{
return findNode(akey) != e;
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::insert(const Key &akey,
const T &avalue)
{
detach();

QMapData::Node *update[QMapData::LastLevel + 1];
QMapData::Node *node = mutableFindNode(update, akey);
if (node == e) {
node = node_create(d, update, akey, avalue);
} else {
concrete(node)->value = avalue;
}
return iterator(node);
}





















# 569 "/usr/share/qt4/include/QtCore/qmap.h"
template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::insertMulti(const Key &akey,
const T &avalue)
{
detach();

QMapData::Node *update[QMapData::LastLevel + 1];
mutableFindNode(update, akey);
return iterator(node_create(d, update, akey, avalue));
}

template <class Key, class T>
inline typename QMap<Key, T>::const_iterator QMap<Key, T>::find(const Key &akey) const
{
return const_iterator(findNode(akey));
}

template <class Key, class T>
inline typename QMap<Key, T>::const_iterator QMap<Key, T>::constFind(const Key &akey) const
{
return const_iterator(findNode(akey));
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::find(const Key &akey)
{
detach();
return iterator(findNode(akey));
}

template <class Key, class T>
inline QMap<Key, T> &QMap<Key, T>::unite(const QMap<Key, T> &other)
{
QMap<Key, T> copy(other);
const_iterator it = copy.constEnd();
const const_iterator b = copy.constBegin();
while (it != b) {
--it;
insertMulti(it.key(), it.value());
}
return *this;
}

template <class Key, class T>
 void QMap<Key, T>::freeData(QMapData *x)
{
if (QTypeInfo<Key>::isComplex || QTypeInfo<T>::isComplex) {
QMapData *cur = x;
QMapData *next = cur->forward[0];
while (next != x) {
cur = next;
next = cur->forward[0];



# 624 "/usr/share/qt4/include/QtCore/qmap.h"
Node *concreteNode = concrete(reinterpret_cast<QMapData::Node *>(cur));
concreteNode->key.~Key();
concreteNode->value.~T();



# 630 "/usr/share/qt4/include/QtCore/qmap.h"
}
}
x->continueFreeData(payload());
}

template <class Key, class T>
 int QMap<Key, T>::remove(const Key &akey)
{
detach();

QMapData::Node *update[QMapData::LastLevel + 1];
QMapData::Node *cur = e;
QMapData::Node *next = e;
int oldSize = d->size;

for (int i = d->topLevel; i >= 0; i--) {
while ((next = cur->forward[i]) != e && qMapLessThanKey<Key>(concrete(next)->key, akey))
cur = next;
update[i] = cur;
}

if (next != e && !qMapLessThanKey<Key>(akey, concrete(next)->key)) {
bool deleteNext = true;
do {
cur = next;
next = cur->forward[0];
deleteNext = (next != e && !qMapLessThanKey<Key>(concrete(cur)->key, concrete(next)->key));
concrete(cur)->key.~Key();
concrete(cur)->value.~T();
d->node_delete(update, payload(), cur);
} while (deleteNext);
}
return oldSize - d->size;
}

template <class Key, class T>
 T QMap<Key, T>::take(const Key &akey)
{
detach();

QMapData::Node *update[QMapData::LastLevel + 1];
QMapData::Node *cur = e;
QMapData::Node *next = e;

for (int i = d->topLevel; i >= 0; i--) {
while ((next = cur->forward[i]) != e && qMapLessThanKey<Key>(concrete(next)->key, akey))
cur = next;
update[i] = cur;
}

if (next != e && !qMapLessThanKey<Key>(akey, concrete(next)->key)) {
T t = concrete(next)->value;
concrete(next)->key.~Key();
concrete(next)->value.~T();
d->node_delete(update, payload(), next);
return t;
}
return T();
}

template <class Key, class T>
 typename QMap<Key, T>::iterator QMap<Key, T>::erase(iterator it)
{
QMapData::Node *update[QMapData::LastLevel + 1];
QMapData::Node *cur = e;
QMapData::Node *next = e;

if (it == iterator(e))
return it;

for (int i = d->topLevel; i >= 0; i--) {
while ((next = cur->forward[i]) != e && qMapLessThanKey<Key>(concrete(next)->key, it.key()))
cur = next;
update[i] = cur;
}

while (next != e) {
cur = next;
next = cur->forward[0];
if (cur == it) {
concrete(cur)->key.~Key();
concrete(cur)->value.~T();
d->node_delete(update, payload(), cur);
return iterator(next);
}

for (int i = 0; i <= d->topLevel; ++i) {
if (update[i]->forward[i] != cur)
break;
update[i] = cur;
}
}
return end();
}

template <class Key, class T>
 void QMap<Key, T>::detach_helper()
{
union { QMapData *d; QMapData::Node *e; } x;
x.d = QMapData::createData(alignment());
if (d->size) {
x.d->insertInOrder = true;
QMapData::Node *update[QMapData::LastLevel + 1];
QMapData::Node *cur = e->forward[0];
update[0] = x.e;
while (cur != e) {
try {
Node *concreteNode = concrete(cur);
node_create(x.d, update, concreteNode->key, concreteNode->value);
} catch (...) {
freeData(x.d);
throw;
}
cur = cur->forward[0];
}
x.d->insertInOrder = false;
}
if (!d->ref.deref())
freeData(d);
d = x.d;
}

template <class Key, class T>
 QMapData::Node *QMap<Key, T>::mutableFindNode(QMapData::Node *aupdate[],
const Key &akey) const
{
QMapData::Node *cur = e;
QMapData::Node *next = e;

for (int i = d->topLevel; i >= 0; i--) {
while ((next = cur->forward[i]) != e && qMapLessThanKey<Key>(concrete(next)->key, akey))
cur = next;
aupdate[i] = cur;
}
if (next != e && !qMapLessThanKey<Key>(akey, concrete(next)->key)) {
return next;
} else {
return e;
}
}

template <class Key, class T>
 QList<Key> QMap<Key, T>::uniqueKeys() const
{
QList<Key> res;
const_iterator i = begin();
if (i != end()) {
for (;;) {
const Key &aKey = i.key();
res.append(aKey);
do {
if (++i == end())
goto break_out_of_outer_loop;
} while (!(aKey < i.key())); 
}
}
break_out_of_outer_loop:
return res;
}

template <class Key, class T>
 QList<Key> QMap<Key, T>::keys() const
{
QList<Key> res;
const_iterator i = begin();
while (i != end()) {
res.append(i.key());
++i;
}
return res;
}

template <class Key, class T>
 QList<Key> QMap<Key, T>::keys(const T &avalue) const
{
QList<Key> res;
const_iterator i = begin();
while (i != end()) {
if (i.value() == avalue)
res.append(i.key());
++i;
}
return res;
}

template <class Key, class T>
 const Key QMap<Key, T>::key(const T &avalue) const
{
return key(avalue, Key());
}

template <class Key, class T>
 const Key QMap<Key, T>::key(const T &avalue, const Key &defaultKey) const
{
const_iterator i = begin();
while (i != end()) {
if (i.value() == avalue)
return i.key();
++i;
}

return defaultKey;
}

template <class Key, class T>
 QList<T> QMap<Key, T>::values() const
{
QList<T> res;
const_iterator i = begin();
while (i != end()) {
res.append(i.value());
++i;
}
return res;
}

template <class Key, class T>
 QList<T> QMap<Key, T>::values(const Key &akey) const
{
QList<T> res;
QMapData::Node *node = findNode(akey);
if (node != e) {
do {
res.append(concrete(node)->value);
node = node->forward[0];
} while (node != e && !qMapLessThanKey<Key>(akey, concrete(node)->key));
}
return res;
}

template <class Key, class T>
inline typename QMap<Key, T>::const_iterator
QMap<Key, T>::lowerBound(const Key &akey) const
{
QMapData::Node *update[QMapData::LastLevel + 1];
mutableFindNode(update, akey);
return const_iterator(update[0]->forward[0]);
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::lowerBound(const Key &akey)
{
detach();
return static_cast<QMapData::Node *>(const_cast<const QMap *>(this)->lowerBound(akey));
}

template <class Key, class T>
inline typename QMap<Key, T>::const_iterator
QMap<Key, T>::upperBound(const Key &akey) const
{
QMapData::Node *update[QMapData::LastLevel + 1];
mutableFindNode(update, akey);
QMapData::Node *node = update[0]->forward[0];
while (node != e && !qMapLessThanKey<Key>(akey, concrete(node)->key))
node = node->forward[0];
return const_iterator(node);
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::upperBound(const Key &akey)
{
detach();
return static_cast<QMapData::Node *>(const_cast<const QMap *>(this)->upperBound(akey));
}

template <class Key, class T>
 bool QMap<Key, T>::operator==(const QMap<Key, T> &other) const
{
if (size() != other.size())
return false;
if (d == other.d)
return true;

const_iterator it1 = begin();
const_iterator it2 = other.begin();

while (it1 != end()) {
if (!(it1.value() == it2.value()) || qMapLessThanKey(it1.key(), it2.key()) || qMapLessThanKey(it2.key(), it1.key()))
return false;
++it2;
++it1;
}
return true;
}





























# 943 "/usr/share/qt4/include/QtCore/qmap.h"
template <class Key, class T>
class QMultiMap : public QMap<Key, T>
{
public:
QMultiMap() {}
QMultiMap(const QMap<Key, T> &other) : QMap<Key, T>(other) {}

inline typename QMap<Key, T>::iterator replace(const Key &key, const T &value)
{ return QMap<Key, T>::insert(key, value); }
inline typename QMap<Key, T>::iterator insert(const Key &key, const T &value)
{ return QMap<Key, T>::insertMulti(key, value); }

inline QMultiMap &operator+=(const QMultiMap &other)
{ unite(other); return *this; }
inline QMultiMap operator+(const QMultiMap &other) const
{ QMultiMap result = *this; result += other; return result; }









# 968 "/usr/share/qt4/include/QtCore/qmap.h"
inline bool contains(const Key &key) const
{ return QMap<Key, T>::contains(key); }
inline int remove(const Key &key)
{ return QMap<Key, T>::remove(key); }
inline int count(const Key &key) const
{ return QMap<Key, T>::count(key); }
inline int count() const
{ return QMap<Key, T>::count(); }
inline typename QMap<Key, T>::iterator find(const Key &key)
{ return QMap<Key, T>::find(key); }
inline typename QMap<Key, T>::const_iterator find(const Key &key) const
{ return QMap<Key, T>::find(key); }
inline typename QMap<Key, T>::const_iterator constFind(const Key &key) const
{ return QMap<Key, T>::constFind(key); }


# 984 "/usr/share/qt4/include/QtCore/qmap.h"
bool contains(const Key &key, const T &value) const;

int remove(const Key &key, const T &value);

int count(const Key &key, const T &value) const;

typename QMap<Key, T>::iterator find(const Key &key, const T &value) {
typename QMap<Key, T>::iterator i(find(key));
typename QMap<Key, T>::iterator end(this->end());
while (i != end && !qMapLessThanKey<Key>(key, i.key())) {
if (i.value() == value)
return i;
++i;
}
return end;
}
typename QMap<Key, T>::const_iterator find(const Key &key, const T &value) const {
typename QMap<Key, T>::const_iterator i(constFind(key));
typename QMap<Key, T>::const_iterator end(QMap<Key, T>::constEnd());
while (i != end && !qMapLessThanKey<Key>(key, i.key())) {
if (i.value() == value)
return i;
++i;
}
return end;
}
typename QMap<Key, T>::const_iterator constFind(const Key &key, const T &value) const
{ return find(key, value); }
private:
T &operator[](const Key &key);
const T operator[](const Key &key) const;
};

template <class Key, class T>
inline bool QMultiMap<Key, T>::contains(const Key &key, const T &value) const
{
return constFind(key, value) != QMap<Key, T>::constEnd();
}

template <class Key, class T>
inline int QMultiMap<Key, T>::remove(const Key &key, const T &value)
{
int n = 0;
typename QMap<Key, T>::iterator i(find(key));
typename QMap<Key, T>::iterator end(QMap<Key, T>::end());
while (i != end && !qMapLessThanKey<Key>(key, i.key())) {
if (i.value() == value) {




# 1035 "/usr/share/qt4/include/QtCore/qmap.h"
i = erase(i);

# 1037 "/usr/share/qt4/include/QtCore/qmap.h"
++n;
} else {
++i;
}
}
return n;
}

template <class Key, class T>
inline int QMultiMap<Key, T>::count(const Key &key, const T &value) const
{
int n = 0;
typename QMap<Key, T>::const_iterator i(constFind(key));
typename QMap<Key, T>::const_iterator end(QMap<Key, T>::constEnd());
while (i != end && !qMapLessThanKey<Key>(key, i.key())) {
if (i.value() == value)
++n;
++i;
}
return n;
}

template <class Key, class T> class QMapIterator { typedef typename QMap<Key,T>::const_iterator const_iterator; typedef const_iterator Item; QMap<Key,T> c; const_iterator i, n; inline bool item_exists() const { return n != c.constEnd(); } public: inline QMapIterator(const QMap<Key,T> &container) : c(container), i(c.constBegin()), n(c.constEnd()) {} inline QMapIterator &operator=(const QMap<Key,T> &container) { c = container; i = c.constBegin(); n = c.constEnd(); return *this; } inline void toFront() { i = c.constBegin(); n = c.constEnd(); } inline void toBack() { i = c.constEnd(); n = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline Item next() { n = i++; return n; } inline Item peekNext() const { return i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline Item previous() { n = --i; return n; } inline Item peekPrevious() const { const_iterator p = i; return --p; } inline const T &value() const { qt_noop(); return *n; } inline const Key &key() const { qt_noop(); return n.key(); } inline bool findNext(const T &t) { while ((n = i) != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(n = --i) == t) return true; n = c.constEnd(); return false; } };
template <class Key, class T> class QMutableMapIterator { typedef typename QMap<Key,T>::iterator iterator; typedef typename QMap<Key,T>::const_iterator const_iterator; typedef iterator Item; QMap<Key,T> *c; iterator i, n; inline bool item_exists() const { return const_iterator(n) != c->constEnd(); } public: inline QMutableMapIterator(QMap<Key,T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableMapIterator() { c->setSharable(true); } inline QMutableMapIterator &operator=(QMap<Key,T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = c->end(); } inline bool hasNext() const { return const_iterator(i) != c->constEnd(); } inline Item next() { n = i++; return n; } inline Item peekNext() const { return i; } inline bool hasPrevious() const { return const_iterator(i) != c->constBegin(); } inline Item previous() { n = --i; return n; } inline Item peekPrevious() const { iterator p = i; return --p; } inline void remove() { if (const_iterator(n) != c->constEnd()) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) { if (const_iterator(n) != c->constEnd()) *n = t; } inline T &value() { qt_noop(); return *n; } inline const T &value() const { qt_noop(); return *n; } inline const Key &key() const { qt_noop(); return n.key(); } inline bool findNext(const T &t) { while (const_iterator(n = i) != c->constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (const_iterator(i) != c->constBegin()) if (*(n = --i) == t) return true; n = c->end(); return false; } };






# 48 "/usr/share/qt4/include/QtCore/qdebug.h"

# 1 "/usr/share/qt4/include/QtCore/qpair.h"































































































































# 49 "/usr/share/qt4/include/QtCore/qdebug.h"

# 1 "/usr/share/qt4/include/QtCore/qtextstream.h"












































# 1 "/usr/share/qt4/include/QtCore/qiodevice.h"






























































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtextstream.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qtextstream.h"

# 1 "/usr/share/qt4/include/QtCore/qchar.h"













































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qtextstream.h"

# 1 "/usr/share/qt4/include/QtCore/qlocale.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qlocale.h"

# 1 "/usr/share/qt4/include/QtCore/qobjectdefs.h"































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qlocale.h"


# 48 "/usr/share/qt4/include/QtCore/qlocale.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QDataStream;
class QDate;
class QDateTime;
class QTime;
class QVariant;
class QTextStream;
class QTextStreamPrivate;

class QLocale;


# 65 "/usr/share/qt4/include/QtCore/qlocale.h"
class  QSystemLocale
{
public:
QSystemLocale();
virtual ~QSystemLocale();

enum QueryType {
LanguageId, 
CountryId, 
DecimalPoint, 
GroupSeparator, 
ZeroDigit, 
NegativeSign, 
DateFormatLong, 
DateFormatShort, 
TimeFormatLong, 
TimeFormatShort, 
DayNameLong, 
DayNameShort, 
MonthNameLong, 
MonthNameShort, 
DateToStringLong, 
DateToStringShort, 
TimeToStringLong, 
TimeToStringShort, 
DateTimeFormatLong, 
DateTimeFormatShort, 
DateTimeToStringLong, 
DateTimeToStringShort, 
MeasurementSystem, 
PositiveSign, 
AMText, 
PMText 
};
virtual QVariant query(QueryType type, QVariant in) const;
virtual QLocale fallbackLocale() const;

private:
QSystemLocale(bool);
friend QSystemLocale *QSystemLocale_globalSystemLocale();
};


# 108 "/usr/share/qt4/include/QtCore/qlocale.h"
struct QLocalePrivate;
class  QLocale
{

Q_ENUMS(Language)
Q_ENUMS(Country)
friend class QString;
friend class QByteArray;
friend class QIntValidator;
friend class QDoubleValidator;
friend class QTextStream;
friend class QTextStreamPrivate;

public:
enum Language {
C = 1,
Abkhazian = 2,
Afan = 3,
Afar = 4,
Afrikaans = 5,
Albanian = 6,
Amharic = 7,
Arabic = 8,
Armenian = 9,
Assamese = 10,
Aymara = 11,
Azerbaijani = 12,
Bashkir = 13,
Basque = 14,
Bengali = 15,
Bhutani = 16,
Bihari = 17,
Bislama = 18,
Breton = 19,
Bulgarian = 20,
Burmese = 21,
Byelorussian = 22,
Cambodian = 23,
Catalan = 24,
Chinese = 25,
Corsican = 26,
Croatian = 27,
Czech = 28,
Danish = 29,
Dutch = 30,
English = 31,
Esperanto = 32,
Estonian = 33,
Faroese = 34,
FijiLanguage = 35,
Finnish = 36,
French = 37,
Frisian = 38,
Gaelic = 39,
Galician = 40,
Georgian = 41,
German = 42,
Greek = 43,
Greenlandic = 44,
Guarani = 45,
Gujarati = 46,
Hausa = 47,
Hebrew = 48,
Hindi = 49,
Hungarian = 50,
Icelandic = 51,
Indonesian = 52,
Interlingua = 53,
Interlingue = 54,
Inuktitut = 55,
Inupiak = 56,
Irish = 57,
Italian = 58,
Japanese = 59,
Javanese = 60,
Kannada = 61,
Kashmiri = 62,
Kazakh = 63,
Kinyarwanda = 64,
Kirghiz = 65,
Korean = 66,
Kurdish = 67,
Kurundi = 68,
Laothian = 69,
Latin = 70,
Latvian = 71,
Lingala = 72,
Lithuanian = 73,
Macedonian = 74,
Malagasy = 75,
Malay = 76,
Malayalam = 77,
Maltese = 78,
Maori = 79,
Marathi = 80,
Moldavian = 81,
Mongolian = 82,
NauruLanguage = 83,
Nepali = 84,
Norwegian = 85,
NorwegianBokmal = Norwegian,
Occitan = 86,
Oriya = 87,
Pashto = 88,
Persian = 89,
Polish = 90,
Portuguese = 91,
Punjabi = 92,
Quechua = 93,
RhaetoRomance = 94,
Romanian = 95,
Russian = 96,
Samoan = 97,
Sangho = 98,
Sanskrit = 99,
Serbian = 100,
SerboCroatian = 101,
Sesotho = 102,
Setswana = 103,
Shona = 104,
Sindhi = 105,
Singhalese = 106,
Siswati = 107,
Slovak = 108,
Slovenian = 109,
Somali = 110,
Spanish = 111,
Sundanese = 112,
Swahili = 113,
Swedish = 114,
Tagalog = 115,
Tajik = 116,
Tamil = 117,
Tatar = 118,
Telugu = 119,
Thai = 120,
Tibetan = 121,
Tigrinya = 122,
TongaLanguage = 123,
Tsonga = 124,
Turkish = 125,
Turkmen = 126,
Twi = 127,
Uigur = 128,
Ukrainian = 129,
Urdu = 130,
Uzbek = 131,
Vietnamese = 132,
Volapuk = 133,
Welsh = 134,
Wolof = 135,
Xhosa = 136,
Yiddish = 137,
Yoruba = 138,
Zhuang = 139,
Zulu = 140,
NorwegianNynorsk = 141,
Nynorsk = NorwegianNynorsk, 
Bosnian = 142,
Divehi = 143,
Manx = 144,
Cornish = 145,
Akan = 146,
Konkani = 147,
Ga = 148,
Igbo = 149,
Kamba = 150,
Syriac = 151,
Blin = 152,
Geez = 153,
Koro = 154,
Sidamo = 155,
Atsam = 156,
Tigre = 157,
Jju = 158,
Friulian = 159,
Venda = 160,
Ewe = 161,
Walamo = 162,
Hawaiian = 163,
Tyap = 164,
Chewa = 165,
LastLanguage = Chewa
};

enum Country {
AnyCountry = 0,
Afghanistan = 1,
Albania = 2,
Algeria = 3,
AmericanSamoa = 4,
Andorra = 5,
Angola = 6,
Anguilla = 7,
Antarctica = 8,
AntiguaAndBarbuda = 9,
Argentina = 10,
Armenia = 11,
Aruba = 12,
Australia = 13,
Austria = 14,
Azerbaijan = 15,
Bahamas = 16,
Bahrain = 17,
Bangladesh = 18,
Barbados = 19,
Belarus = 20,
Belgium = 21,
Belize = 22,
Benin = 23,
Bermuda = 24,
Bhutan = 25,
Bolivia = 26,
BosniaAndHerzegowina = 27,
Botswana = 28,
BouvetIsland = 29,
Brazil = 30,
BritishIndianOceanTerritory = 31,
BruneiDarussalam = 32,
Bulgaria = 33,
BurkinaFaso = 34,
Burundi = 35,
Cambodia = 36,
Cameroon = 37,
Canada = 38,
CapeVerde = 39,
CaymanIslands = 40,
CentralAfricanRepublic = 41,
Chad = 42,
Chile = 43,
China = 44,
ChristmasIsland = 45,
CocosIslands = 46,
Colombia = 47,
Comoros = 48,
DemocraticRepublicOfCongo = 49,
PeoplesRepublicOfCongo = 50,
CookIslands = 51,
CostaRica = 52,
IvoryCoast = 53,
Croatia = 54,
Cuba = 55,
Cyprus = 56,
CzechRepublic = 57,
Denmark = 58,
Djibouti = 59,
Dominica = 60,
DominicanRepublic = 61,
EastTimor = 62,
Ecuador = 63,
Egypt = 64,
ElSalvador = 65,
EquatorialGuinea = 66,
Eritrea = 67,
Estonia = 68,
Ethiopia = 69,
FalklandIslands = 70,
FaroeIslands = 71,
FijiCountry = 72,
Finland = 73,
France = 74,
MetropolitanFrance = 75,
FrenchGuiana = 76,
FrenchPolynesia = 77,
FrenchSouthernTerritories = 78,
Gabon = 79,
Gambia = 80,
Georgia = 81,
Germany = 82,
Ghana = 83,
Gibraltar = 84,
Greece = 85,
Greenland = 86,
Grenada = 87,
Guadeloupe = 88,
Guam = 89,
Guatemala = 90,
Guinea = 91,
GuineaBissau = 92,
Guyana = 93,
Haiti = 94,
HeardAndMcDonaldIslands = 95,
Honduras = 96,
HongKong = 97,
Hungary = 98,
Iceland = 99,
India = 100,
Indonesia = 101,
Iran = 102,
Iraq = 103,
Ireland = 104,
Israel = 105,
Italy = 106,
Jamaica = 107,
Japan = 108,
Jordan = 109,
Kazakhstan = 110,
Kenya = 111,
Kiribati = 112,
DemocraticRepublicOfKorea = 113,
RepublicOfKorea = 114,
Kuwait = 115,
Kyrgyzstan = 116,
Lao = 117,
Latvia = 118,
Lebanon = 119,
Lesotho = 120,
Liberia = 121,
LibyanArabJamahiriya = 122,
Liechtenstein = 123,
Lithuania = 124,
Luxembourg = 125,
Macau = 126,
Macedonia = 127,
Madagascar = 128,
Malawi = 129,
Malaysia = 130,
Maldives = 131,
Mali = 132,
Malta = 133,
MarshallIslands = 134,
Martinique = 135,
Mauritania = 136,
Mauritius = 137,
Mayotte = 138,
Mexico = 139,
Micronesia = 140,
Moldova = 141,
Monaco = 142,
Mongolia = 143,
Montserrat = 144,
Morocco = 145,
Mozambique = 146,
Myanmar = 147,
Namibia = 148,
NauruCountry = 149,
Nepal = 150,
Netherlands = 151,
NetherlandsAntilles = 152,
NewCaledonia = 153,
NewZealand = 154,
Nicaragua = 155,
Niger = 156,
Nigeria = 157,
Niue = 158,
NorfolkIsland = 159,
NorthernMarianaIslands = 160,
Norway = 161,
Oman = 162,
Pakistan = 163,
Palau = 164,
PalestinianTerritory = 165,
Panama = 166,
PapuaNewGuinea = 167,
Paraguay = 168,
Peru = 169,
Philippines = 170,
Pitcairn = 171,
Poland = 172,
Portugal = 173,
PuertoRico = 174,
Qatar = 175,
Reunion = 176,
Romania = 177,
RussianFederation = 178,
Rwanda = 179,
SaintKittsAndNevis = 180,
StLucia = 181,
StVincentAndTheGrenadines = 182,
Samoa = 183,
SanMarino = 184,
SaoTomeAndPrincipe = 185,
SaudiArabia = 186,
Senegal = 187,
Seychelles = 188,
SierraLeone = 189,
Singapore = 190,
Slovakia = 191,
Slovenia = 192,
SolomonIslands = 193,
Somalia = 194,
SouthAfrica = 195,
SouthGeorgiaAndTheSouthSandwichIslands = 196,
Spain = 197,
SriLanka = 198,
StHelena = 199,
StPierreAndMiquelon = 200,
Sudan = 201,
Suriname = 202,
SvalbardAndJanMayenIslands = 203,
Swaziland = 204,
Sweden = 205,
Switzerland = 206,
SyrianArabRepublic = 207,
Taiwan = 208,
Tajikistan = 209,
Tanzania = 210,
Thailand = 211,
Togo = 212,
Tokelau = 213,
TongaCountry = 214,
TrinidadAndTobago = 215,
Tunisia = 216,
Turkey = 217,
Turkmenistan = 218,
TurksAndCaicosIslands = 219,
Tuvalu = 220,
Uganda = 221,
Ukraine = 222,
UnitedArabEmirates = 223,
UnitedKingdom = 224,
UnitedStates = 225,
UnitedStatesMinorOutlyingIslands = 226,
Uruguay = 227,
Uzbekistan = 228,
Vanuatu = 229,
VaticanCityState = 230,
Venezuela = 231,
VietNam = 232,
BritishVirginIslands = 233,
USVirginIslands = 234,
WallisAndFutunaIslands = 235,
WesternSahara = 236,
Yemen = 237,
Yugoslavia = 238,
Zambia = 239,
Zimbabwe = 240,
SerbiaAndMontenegro = 241,
LastCountry = SerbiaAndMontenegro
};

enum MeasurementSystem { MetricSystem, ImperialSystem };

enum FormatType { LongFormat, ShortFormat, NarrowFormat };
enum NumberOption {
OmitGroupSeparator = 0x01,
RejectGroupSeparator = 0x02
};
typedef QFlags<NumberOption> NumberOptions;

QLocale();
QLocale(const QString &name);
QLocale(Language language, Country country = AnyCountry);
QLocale(const QLocale &other);

QLocale &operator=(const QLocale &other);

Language language() const;
Country country() const;
QString name() const;

short toShort(const QString &s, bool *ok = 0, int base = 0) const;
ushort toUShort(const QString &s, bool *ok = 0, int base = 0) const;
int toInt(const QString &s, bool *ok = 0, int base = 0) const;
uint toUInt(const QString &s, bool *ok = 0, int base = 0) const;
qlonglong toLongLong(const QString &s, bool *ok = 0, int base = 0) const;
qlonglong toULongLong(const QString &s, bool *ok = 0, int base = 0) const;
float toFloat(const QString &s, bool *ok = 0) const;
double toDouble(const QString &s, bool *ok = 0) const;

QString toString(qlonglong i) const;
QString toString(qulonglong i) const;
inline QString toString(short i) const;
inline QString toString(ushort i) const;
inline QString toString(int i) const;
inline QString toString(uint i) const;
QString toString(double i, char f = 'g', int prec = 6) const;
inline QString toString(float i, char f = 'g', int prec = 6) const;
QString toString(const QDate &date, const QString &formatStr) const;
QString toString(const QDate &date, FormatType format = LongFormat) const;
QString toString(const QTime &time, const QString &formatStr) const;
QString toString(const QTime &time, FormatType format = LongFormat) const;
QString toString(const QDateTime &dateTime, FormatType format = LongFormat) const;
QString toString(const QDateTime &dateTime, const QString &format) const;

QString dateFormat(FormatType format = LongFormat) const;
QString timeFormat(FormatType format = LongFormat) const;
QString dateTimeFormat(FormatType format = LongFormat) const;

# 587 "/usr/share/qt4/include/QtCore/qlocale.h"
QDate toDate(const QString &string, FormatType = LongFormat) const;
QTime toTime(const QString &string, FormatType = LongFormat) const;
QDateTime toDateTime(const QString &string, FormatType format = LongFormat) const;
QDate toDate(const QString &string, const QString &format) const;
QTime toTime(const QString &string, const QString &format) const;
QDateTime toDateTime(const QString &string, const QString &format) const;


# 595 "/usr/share/qt4/include/QtCore/qlocale.h"


QChar decimalPoint() const;
QChar groupSeparator() const;
QChar percent() const;
QChar zeroDigit() const;
QChar negativeSign() const;
QChar positiveSign() const;
QChar exponential() const;

QString monthName(int, FormatType format = LongFormat) const;
QString standaloneMonthName(int, FormatType format = LongFormat) const;
QString dayName(int, FormatType format = LongFormat) const;
QString standaloneDayName(int, FormatType format = LongFormat) const;

QString amText() const;
QString pmText() const;

MeasurementSystem measurementSystem() const;

inline bool operator==(const QLocale &other) const;
inline bool operator!=(const QLocale &other) const;

static QString languageToString(Language language);
static QString countryToString(Country country);
static void setDefault(const QLocale &locale);

static QLocale c() { return QLocale(C); }
static QLocale system();

static QList<Country> countriesForLanguage(Language lang);

void setNumberOptions(NumberOptions options);
NumberOptions numberOptions() const;


struct Data {
quint16 index;
quint16 numberOptions;
}



# 638 "/usr/share/qt4/include/QtCore/qlocale.h"
;
private:
friend struct QLocalePrivate;


union {
void *v;
Data p;
};
const QLocalePrivate *d() const;
};
template <> class QTypeInfo<QLocale > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QLocale)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QLocale"; } };
inline QFlags<QLocale::NumberOptions::enum_type> operator|(QLocale::NumberOptions::enum_type f1, QLocale::NumberOptions::enum_type f2) { return QFlags<QLocale::NumberOptions::enum_type>(f1) | f2; } inline QFlags<QLocale::NumberOptions::enum_type> operator|(QLocale::NumberOptions::enum_type f1, QFlags<QLocale::NumberOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QLocale::NumberOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

inline QString QLocale::toString(short i) const
{ return toString(qlonglong(i)); }
inline QString QLocale::toString(ushort i) const
{ return toString(qulonglong(i)); }
inline QString QLocale::toString(int i) const
{ return toString(qlonglong(i)); }
inline QString QLocale::toString(uint i) const
{ return toString(qulonglong(i)); }
inline QString QLocale::toString(float i, char f, int prec) const
{ return toString(double(i), f, prec); }
inline bool QLocale::operator==(const QLocale &other) const
{ return d() == other.d() && numberOptions() == other.numberOptions(); }
inline bool QLocale::operator!=(const QLocale &other) const
{ return d() != other.d() || numberOptions() != other.numberOptions(); }


# 668 "/usr/share/qt4/include/QtCore/qlocale.h"
 QDataStream &operator<<(QDataStream &, const QLocale &);
 QDataStream &operator>>(QDataStream &, QLocale &);


# 672 "/usr/share/qt4/include/QtCore/qlocale.h"





# 48 "/usr/share/qt4/include/QtCore/qtextstream.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 49 "/usr/share/qt4/include/QtCore/qtextstream.h"














# 63 "/usr/share/qt4/include/QtCore/qtextstream.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QTextCodec;
class QTextDecoder;

class QTextStreamPrivate;
class  QTextStream 
{
inline QTextStreamPrivate* d_func() { return reinterpret_cast<QTextStreamPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTextStreamPrivate* d_func() const { return reinterpret_cast<const QTextStreamPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTextStreamPrivate;

public:
enum RealNumberNotation {
SmartNotation,
FixedNotation,
ScientificNotation
};
enum FieldAlignment {
AlignLeft,
AlignRight,
AlignCenter,
AlignAccountingStyle
};
enum Status {
Ok,
ReadPastEnd,
ReadCorruptData
};
enum NumberFlag {
ShowBase = 0x1,
ForcePoint = 0x2,
ForceSign = 0x4,
UppercaseBase = 0x8,
UppercaseDigits = 0x10
};
typedef QFlags<NumberFlag> NumberFlags;

QTextStream();
explicit QTextStream(QIODevice *device);
explicit QTextStream(FILE *fileHandle, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
explicit QTextStream(QString *string, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
explicit QTextStream(QByteArray *array, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
explicit QTextStream(const QByteArray &array, QIODevice::OpenMode openMode = QIODevice::ReadOnly);
virtual ~QTextStream();


# 112 "/usr/share/qt4/include/QtCore/qtextstream.h"
void setCodec(QTextCodec *codec);
void setCodec(const char *codecName);
QTextCodec *codec() const;
void setAutoDetectUnicode(bool enabled);
bool autoDetectUnicode() const;
void setGenerateByteOrderMark(bool generate);
bool generateByteOrderMark() const;


# 121 "/usr/share/qt4/include/QtCore/qtextstream.h"
void setLocale(const QLocale &locale);
QLocale locale() const;

void setDevice(QIODevice *device);
QIODevice *device() const;

void setString(QString *string, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
QString *string() const;

Status status() const;
void setStatus(Status status);
void resetStatus();

bool atEnd() const;
void reset();
void flush();
bool seek(qint64 pos);
qint64 pos() const;

void skipWhiteSpace();

QString readLine(qint64 maxlen = 0);
QString readAll();
QString read(qint64 maxlen);

void setFieldAlignment(FieldAlignment alignment);
FieldAlignment fieldAlignment() const;

void setPadChar(QChar ch);
QChar padChar() const;

void setFieldWidth(int width);
int fieldWidth() const;

void setNumberFlags(NumberFlags flags);
NumberFlags numberFlags() const;

void setIntegerBase(int base);
int integerBase() const;

void setRealNumberNotation(RealNumberNotation notation);
RealNumberNotation realNumberNotation() const;

void setRealNumberPrecision(int precision);
int realNumberPrecision() const;

QTextStream &operator>>(QChar &ch);
QTextStream &operator>>(char &ch);
QTextStream &operator>>(signed short &i);
QTextStream &operator>>(unsigned short &i);
QTextStream &operator>>(signed int &i);
QTextStream &operator>>(unsigned int &i);
QTextStream &operator>>(signed long &i);
QTextStream &operator>>(unsigned long &i);
QTextStream &operator>>(qlonglong &i);
QTextStream &operator>>(qulonglong &i);
QTextStream &operator>>(float &f);
QTextStream &operator>>(double &f);
QTextStream &operator>>(QString &s);
QTextStream &operator>>(QByteArray &array);
QTextStream &operator>>(char *c);

QTextStream &operator<<(QBool b);
QTextStream &operator<<(QChar ch);
QTextStream &operator<<(char ch);
QTextStream &operator<<(signed short i);
QTextStream &operator<<(unsigned short i);
QTextStream &operator<<(signed int i);
QTextStream &operator<<(unsigned int i);
QTextStream &operator<<(signed long i);
QTextStream &operator<<(unsigned long i);
QTextStream &operator<<(qlonglong i);
QTextStream &operator<<(qulonglong i);
QTextStream &operator<<(float f);
QTextStream &operator<<(double f);
QTextStream &operator<<(const QString &s);
QTextStream &operator<<(const QByteArray &array);
QTextStream &operator<<(const char *c);
QTextStream &operator<<(const void *ptr);




















































# 252 "/usr/share/qt4/include/QtCore/qtextstream.h"
private:





# 258 "/usr/share/qt4/include/QtCore/qtextstream.h"
QTextStream(const QTextStream &); QTextStream &operator=(const QTextStream &);

QScopedPointer<QTextStreamPrivate> d_ptr;
};

inline QFlags<QTextStream::NumberFlags::enum_type> operator|(QTextStream::NumberFlags::enum_type f1, QTextStream::NumberFlags::enum_type f2) { return QFlags<QTextStream::NumberFlags::enum_type>(f1) | f2; } inline QFlags<QTextStream::NumberFlags::enum_type> operator|(QTextStream::NumberFlags::enum_type f1, QFlags<QTextStream::NumberFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTextStream::NumberFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }





typedef QTextStream & (*QTextStreamFunction)(QTextStream &);
typedef void (QTextStream::*QTSMFI)(int); 
typedef void (QTextStream::*QTSMFC)(QChar); 

class  QTextStreamManipulator
{
public:
QTextStreamManipulator(QTSMFI m, int a) { mf = m; mc = 0; arg = a; }
QTextStreamManipulator(QTSMFC m, QChar c) { mf = 0; mc = m; ch = c; arg = -1; }
void exec(QTextStream &s) { if (mf) { (s.*mf)(arg); } else { (s.*mc)(ch); } }

private:
QTSMFI mf; 
QTSMFC mc; 
int arg; 
QChar ch;
};

inline QTextStream &operator>>(QTextStream &s, QTextStreamFunction f)
{ return (*f)(s); }

inline QTextStream &operator<<(QTextStream &s, QTextStreamFunction f)
{ return (*f)(s); }

inline QTextStream &operator<<(QTextStream &s, QTextStreamManipulator m)
{ m.exec(s); return s; }

 QTextStream &bin(QTextStream &s);
 QTextStream &oct(QTextStream &s);
 QTextStream &dec(QTextStream &s);
 QTextStream &hex(QTextStream &s);

 QTextStream &showbase(QTextStream &s);
 QTextStream &forcesign(QTextStream &s);
 QTextStream &forcepoint(QTextStream &s);
 QTextStream &noshowbase(QTextStream &s);
 QTextStream &noforcesign(QTextStream &s);
 QTextStream &noforcepoint(QTextStream &s);

 QTextStream &uppercasebase(QTextStream &s);
 QTextStream &uppercasedigits(QTextStream &s);
 QTextStream &lowercasebase(QTextStream &s);
 QTextStream &lowercasedigits(QTextStream &s);

 QTextStream &fixed(QTextStream &s);
 QTextStream &scientific(QTextStream &s);

 QTextStream &left(QTextStream &s);
 QTextStream &right(QTextStream &s);
 QTextStream &center(QTextStream &s);

 QTextStream &endl(QTextStream &s);
 QTextStream &flush(QTextStream &s);
 QTextStream &reset(QTextStream &s);

 QTextStream &bom(QTextStream &s);

 QTextStream &ws(QTextStream &s);

inline QTextStreamManipulator qSetFieldWidth(int width)
{
QTSMFI func = &QTextStream::setFieldWidth;
return QTextStreamManipulator(func,width);
}

inline QTextStreamManipulator qSetPadChar(QChar ch)
{
QTSMFC func = &QTextStream::setPadChar;
return QTextStreamManipulator(func, ch);
}

inline QTextStreamManipulator qSetRealNumberPrecision(int precision)
{
QTSMFI func = &QTextStream::setRealNumberPrecision;
return QTextStreamManipulator(func, precision);
}



























# 372 "/usr/share/qt4/include/QtCore/qtextstream.h"





# 50 "/usr/share/qt4/include/QtCore/qdebug.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 51 "/usr/share/qt4/include/QtCore/qdebug.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"












































# 1 "/usr/share/qt4/include/QtCore/qiterator.h"






































































# 45 "/usr/share/qt4/include/QtCore/qvector.h"

# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 46 "/usr/share/qt4/include/QtCore/qvector.h"

# 1 "/usr/share/qt4/include/QtCore/qalgorithms.h"








































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qvector.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtCore/qvector.h"









# 57 "/usr/share/qt4/include/QtCore/qvector.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

struct  QVectorData
{
QBasicAtomicInt ref;
int alloc;
int size;






# 74 "/usr/share/qt4/include/QtCore/qvector.h"
uint sharable : 1;
uint capacity : 1;
uint reserved : 30;


# 79 "/usr/share/qt4/include/QtCore/qvector.h"
static QVectorData shared_null;



static QVectorData *malloc(int sizeofTypedData, int size, int sizeofT, QVectorData *init);
static QVectorData *allocate(int size, int alignment);
static QVectorData *reallocate(QVectorData *old, int newsize, int oldsize, int alignment);
static void free(QVectorData *data, int alignment);
static int grow(int sizeofTypedData, int size, int sizeofT, bool excessive);
};

template <typename T>
struct QVectorTypedData : private QVectorData
{ 

T array[1];

static inline void free(QVectorTypedData<T> *x, int alignment) { QVectorData::free(static_cast<QVectorData *>(x), alignment); }
};

class QRegion;

template <typename T>
class QVector
{
typedef QVectorTypedData<T> Data;
union {
QVectorData *d;



# 110 "/usr/share/qt4/include/QtCore/qvector.h"
Data *p;

# 112 "/usr/share/qt4/include/QtCore/qvector.h"
};

public:
inline QVector() : d(&QVectorData::shared_null) { d->ref.ref(); }
explicit QVector(int size);
QVector(int size, const T &t);
inline QVector(const QVector<T> &v) : d(v.d) { d->ref.ref(); if (!d->sharable) detach_helper(); }
inline ~QVector() { if (!d) return; if (!d->ref.deref()) free(p); }
QVector<T> &operator=(const QVector<T> &v);
bool operator==(const QVector<T> &v) const;
inline bool operator!=(const QVector<T> &v) const { return !(*this == v); }

inline int size() const { return d->size; }

inline bool isEmpty() const { return d->size == 0; }

void resize(int size);

inline int capacity() const { return d->alloc; }
void reserve(int size);
inline void squeeze() { realloc(d->size, d->size); d->capacity = 0; }

inline void detach() { if (d->ref != 1) detach_helper(); }
inline bool isDetached() const { return d->ref == 1; }
inline void setSharable(bool sharable) { if (!sharable) detach(); d->sharable = sharable; }

inline T *data() { detach(); return p->array; }
inline const T *data() const { return p->array; }
inline const T *constData() const { return p->array; }
void clear();

const T &at(int i) const;
T &operator[](int i);
const T &operator[](int i) const;
void append(const T &t);
void prepend(const T &t);
void insert(int i, const T &t);
void insert(int i, int n, const T &t);
void replace(int i, const T &t);
void remove(int i);
void remove(int i, int n);

QVector<T> &fill(const T &t, int size = -1);

int indexOf(const T &t, int from = 0) const;
int lastIndexOf(const T &t, int from = -1) const;
bool contains(const T &t) const;
int count(const T &t) const;





































































# 229 "/usr/share/qt4/include/QtCore/qvector.h"

typedef T* iterator;
typedef const T* const_iterator;

# 233 "/usr/share/qt4/include/QtCore/qvector.h"
inline iterator begin() { detach(); return p->array; }
inline const_iterator begin() const { return p->array; }
inline const_iterator constBegin() const { return p->array; }
inline iterator end() { detach(); return p->array + d->size; }
inline const_iterator end() const { return p->array + d->size; }
inline const_iterator constEnd() const { return p->array + d->size; }
iterator insert(iterator before, int n, const T &x);
inline iterator insert(iterator before, const T &x) { return insert(before, 1, x); }
iterator erase(iterator begin, iterator end);
inline iterator erase(iterator pos) { return erase(pos, pos+1); }


inline int count() const { return d->size; }
inline T& first() { qt_noop(); return *begin(); }
inline const T &first() const { qt_noop(); return *begin(); }
inline T& last() { qt_noop(); return *(end()-1); }
inline const T &last() const { qt_noop(); return *(end()-1); }
inline bool startsWith(const T &t) const { return !isEmpty() && first() == t; }
inline bool endsWith(const T &t) const { return !isEmpty() && last() == t; }
QVector<T> mid(int pos, int length = -1) const;

T value(int i) const;
T value(int i, const T &defaultValue) const;


typedef T value_type;
typedef value_type* pointer;
typedef const value_type* const_pointer;
typedef value_type& reference;
typedef const value_type& const_reference;
typedef ptrdiff_t difference_type;
typedef iterator Iterator;
typedef const_iterator ConstIterator;
typedef int size_type;
inline void push_back(const T &t) { append(t); }
inline void push_front(const T &t) { prepend(t); }
void pop_back() { qt_noop(); erase(end()-1); }
void pop_front() { qt_noop(); erase(begin()); }
inline bool empty() const
{ return d->size == 0; }
inline T& front() { return first(); }
inline const_reference front() const { return first(); }
inline reference back() { return last(); }
inline const_reference back() const { return last(); }


QVector<T> &operator+=(const QVector<T> &l);
inline QVector<T> operator+(const QVector<T> &l) const
{ QVector n = *this; n += l; return n; }
inline QVector<T> &operator+=(const T &t)
{ append(t); return *this; }
inline QVector<T> &operator<< (const T &t)
{ append(t); return *this; }
inline QVector<T> &operator<<(const QVector<T> &l)
{ *this += l; return *this; }

QList<T> toList() const;

static QVector<T> fromList(const QList<T> &list);








# 300 "/usr/share/qt4/include/QtCore/qvector.h"
private:
friend class QRegion; 

void detach_helper();
QVectorData *malloc(int alloc);
void realloc(int size, int alloc);
void free(Data *d);
int sizeOfTypedData() {


return reinterpret_cast<const char *>(&(reinterpret_cast<const Data *>(this))->array[1]) - reinterpret_cast<const char *>(this);
}
inline int alignOfTypedData() const
{



# 317 "/usr/share/qt4/include/QtCore/qvector.h"
return 0;

# 319 "/usr/share/qt4/include/QtCore/qvector.h"
}
};

template <typename T>
void QVector<T>::detach_helper()
{ realloc(d->size, d->alloc); }
template <typename T>
void QVector<T>::reserve(int asize)
{ if (asize > d->alloc) realloc(d->size, asize); if (d->ref == 1) d->capacity = 1; }
template <typename T>
void QVector<T>::resize(int asize)
{ realloc(asize, (asize > d->alloc || (!d->capacity && asize < d->size && asize < (d->alloc >> 1))) ?
QVectorData::grow(sizeOfTypedData(), asize, sizeof(T), QTypeInfo<T>::isStatic)
: d->alloc); }
template <typename T>
inline void QVector<T>::clear()
{ *this = QVector<T>(); }
template <typename T>
inline const T &QVector<T>::at(int i) const
{ qt_noop();
return p->array[i]; }
template <typename T>
inline const T &QVector<T>::operator[](int i) const
{ qt_noop();
return p->array[i]; }
template <typename T>
inline T &QVector<T>::operator[](int i)
{ qt_noop();
return data()[i]; }
template <typename T>
inline void QVector<T>::insert(int i, const T &t)
{ qt_noop();
insert(begin() + i, 1, t); }
template <typename T>
inline void QVector<T>::insert(int i, int n, const T &t)
{ qt_noop();
insert(begin() + i, n, t); }
template <typename T>
inline void QVector<T>::remove(int i, int n)
{ qt_noop();
erase(begin() + i, begin() + i + n); }
template <typename T>
inline void QVector<T>::remove(int i)
{ qt_noop();
erase(begin() + i, begin() + i + 1); }
template <typename T>
inline void QVector<T>::prepend(const T &t)
{ insert(begin(), 1, t); }

template <typename T>
inline void QVector<T>::replace(int i, const T &t)
{
qt_noop();
const T copy(t);
data()[i] = copy;
}

template <typename T>
QVector<T> &QVector<T>::operator=(const QVector<T> &v)
{
v.d->ref.ref();
if (!d->ref.deref())
free(p);
d = v.d;
if (!d->sharable)
detach_helper();
return *this;
}

template <typename T>
inline QVectorData *QVector<T>::malloc(int aalloc)
{
QVectorData *vectordata = QVectorData::allocate(sizeOfTypedData() + (aalloc - 1) * sizeof(T), alignOfTypedData());
do { if (!(vectordata)) qBadAlloc(); } while (0);
return vectordata;
}

template <typename T>
QVector<T>::QVector(int asize)
{
d = malloc(asize);
d->ref = 1;
d->alloc = d->size = asize;
d->sharable = true;
d->capacity = false;
if (QTypeInfo<T>::isComplex) {
T* b = p->array;
T* i = p->array + d->size;
while (i != b)
new (--i) T;
} else {
qMemSet(p->array, 0, asize * sizeof(T));
}
}

template <typename T>
QVector<T>::QVector(int asize, const T &t)
{
d = malloc(asize);
d->ref = 1;
d->alloc = d->size = asize;
d->sharable = true;
d->capacity = false;
T* i = p->array + d->size;
while (i != p->array)
new (--i) T(t);
}

template <typename T>
void QVector<T>::free(Data *x)
{
if (QTypeInfo<T>::isComplex) {
T* b = x->array;
union { QVectorData *d; Data *p; } u;
u.p = x;
T* i = b + u.d->size;
while (i-- != b)
i->~T();
}
x->free(x, alignOfTypedData());
}

template <typename T>
void QVector<T>::realloc(int asize, int aalloc)
{
qt_noop();
T *pOld;
T *pNew;
union { QVectorData *d; Data *p; } x;
x.d = d;

if (QTypeInfo<T>::isComplex && asize < d->size && d->ref == 1 ) {


pOld = p->array + d->size;
pNew = p->array + asize;
while (asize < d->size) {
(--pOld)->~T();
d->size--;
}
}

if (aalloc != d->alloc || d->ref != 1) {

if (QTypeInfo<T>::isStatic) {
x.d = malloc(aalloc);
do { if (!(x.p)) qBadAlloc(); } while (0);
x.d->size = 0;
} else if (d->ref != 1) {
x.d = malloc(aalloc);
do { if (!(x.p)) qBadAlloc(); } while (0);
if (QTypeInfo<T>::isComplex) {
x.d->size = 0;
} else {
::memcpy(x.p, p, sizeOfTypedData() + (qMin(aalloc, d->alloc) - 1) * sizeof(T));
x.d->size = d->size;
}
} else {
try {
QVectorData *mem = QVectorData::reallocate(d, sizeOfTypedData() + (aalloc - 1) * sizeof(T),
sizeOfTypedData() + (d->alloc - 1) * sizeof(T), alignOfTypedData());
do { if (!(mem)) qBadAlloc(); } while (0);
x.d = d = mem;
x.d->size = d->size;
} catch (const std::bad_alloc &) {
if (aalloc > d->alloc) 
throw;
}
}
x.d->ref = 1;
x.d->alloc = aalloc;
x.d->sharable = true;
x.d->capacity = d->capacity;
x.d->reserved = 0;
}

if (QTypeInfo<T>::isComplex) {
try {
pOld = p->array + x.d->size;
pNew = x.p->array + x.d->size;

const int toMove = qMin(asize, d->size);
while (x.d->size < toMove) {
new (pNew++) T(*pOld++);
x.d->size++;
}

while (x.d->size < asize) {
new (pNew++) T;
x.d->size++;
}
} catch (...) {
free(x.p);
throw;
}

} else if (asize > x.d->size) {

qMemSet(x.p->array + x.d->size, 0, (asize - x.d->size) * sizeof(T));
}
x.d->size = asize;

if (d != x.d) {
if (!d->ref.deref())
free(p);
d = x.d;
}
}

template<typename T>
 T QVector<T>::value(int i) const
{
if (i < 0 || i >= d->size) {
return T();
}
return p->array[i];
}
template<typename T>
 T QVector<T>::value(int i, const T &defaultValue) const
{
return ((i < 0 || i >= d->size) ? defaultValue : p->array[i]);
}

template <typename T>
void QVector<T>::append(const T &t)
{
if (d->ref != 1 || d->size + 1 > d->alloc) {
const T copy(t);
realloc(d->size, QVectorData::grow(sizeOfTypedData(), d->size + 1, sizeof(T),
QTypeInfo<T>::isStatic));
if (QTypeInfo<T>::isComplex)
new (p->array + d->size) T(copy);
else
p->array[d->size] = copy;
} else {
if (QTypeInfo<T>::isComplex)
new (p->array + d->size) T(t);
else
p->array[d->size] = t;
}
++d->size;
}

template <typename T>
typename QVector<T>::iterator QVector<T>::insert(iterator before, size_type n, const T &t)
{
int offset = int(before - p->array);
if (n != 0) {
const T copy(t);
if (d->ref != 1 || d->size + n > d->alloc)
realloc(d->size, QVectorData::grow(sizeOfTypedData(), d->size + n, sizeof(T),
QTypeInfo<T>::isStatic));
if (QTypeInfo<T>::isStatic) {
T *b = p->array + d->size;
T *i = p->array + d->size + n;
while (i != b)
new (--i) T;
i = p->array + d->size;
T *j = i + n;
b = p->array + offset;
while (i != b)
*--j = *--i;
i = b+n;
while (i != b)
*--i = copy;
} else {
T *b = p->array + offset;
T *i = b + n;
memmove(i, b, (d->size - offset) * sizeof(T));
while (i != b)
new (--i) T(copy);
}
d->size += n;
}
return p->array + offset;
}

template <typename T>
typename QVector<T>::iterator QVector<T>::erase(iterator abegin, iterator aend)
{
int f = int(abegin - p->array);
int l = int(aend - p->array);
int n = l - f;
detach();
if (QTypeInfo<T>::isComplex) {
qCopy(p->array+l, p->array+d->size, p->array+f);
T *i = p->array+d->size;
T* b = p->array+d->size-n;
while (i != b) {
--i;
i->~T();
}
} else {
memmove(p->array + f, p->array + l, (d->size-l)*sizeof(T));
}
d->size -= n;
return p->array + f;
}

template <typename T>
bool QVector<T>::operator==(const QVector<T> &v) const
{
if (d->size != v.d->size)
return false;
if (d == v.d)
return true;
T* b = p->array;
T* i = b + d->size;
T* j = v.p->array + d->size;
while (i != b)
if (!(*--i == *--j))
return false;
return true;
}

template <typename T>
QVector<T> &QVector<T>::fill(const T &from, int asize)
{
const T copy(from);
resize(asize < 0 ? d->size : asize);
if (d->size) {
T *i = p->array + d->size;
T *b = p->array;
while (i != b)
*--i = copy;
}
return *this;
}

template <typename T>
QVector<T> &QVector<T>::operator+=(const QVector &l)
{
int newSize = d->size + l.d->size;
realloc(d->size, newSize);

T *w = p->array + newSize;
T *i = l.p->array + l.d->size;
T *b = l.p->array;
while (i != b) {
if (QTypeInfo<T>::isComplex)
new (--w) T(*--i);
else
*--w = *--i;
}
d->size = newSize;
return *this;
}

template <typename T>
int QVector<T>::indexOf(const T &t, int from) const
{
if (from < 0)
from = qMax(from + d->size, 0);
if (from < d->size) {
T* n = p->array + from - 1;
T* e = p->array + d->size;
while (++n != e)
if (*n == t)
return n - p->array;
}
return -1;
}

template <typename T>
int QVector<T>::lastIndexOf(const T &t, int from) const
{
if (from < 0)
from += d->size;
else if (from >= d->size)
from = d->size-1;
if (from >= 0) {
T* b = p->array;
T* n = p->array + from + 1;
while (n != b) {
if (*--n == t)
return n - b;
}
}
return -1;
}

template <typename T>
bool QVector<T>::contains(const T &t) const
{
T* b = p->array;
T* i = p->array + d->size;
while (i != b)
if (*--i == t)
return true;
return false;
}

template <typename T>
int QVector<T>::count(const T &t) const
{
int c = 0;
T* b = p->array;
T* i = p->array + d->size;
while (i != b)
if (*--i == t)
++c;
return c;
}

template <typename T>
 QVector<T> QVector<T>::mid(int pos, int length) const
{
if (length < 0)
length = size() - pos;
if (pos == 0 && length == size())
return *this;
QVector<T> copy;
if (pos + length > size())
length = size() - pos;
for (int i = pos; i < pos + length; ++i)
copy += at(i);
return copy;
}

template <typename T>
 QList<T> QVector<T>::toList() const
{
QList<T> result;
for (int i = 0; i < size(); ++i)
result.append(at(i));
return result;
}

template <typename T>
 QVector<T> QList<T>::toVector() const
{
QVector<T> result(size());
for (int i = 0; i < size(); ++i)
result[i] = at(i);
return result;
}

template <typename T>
QVector<T> QVector<T>::fromList(const QList<T> &list)
{
return list.toVector();
}

template <typename T>
QList<T> QList<T>::fromVector(const QVector<T> &vector)
{
return vector.toList();
}

template <class T> class QVectorIterator { typedef typename QVector<T>::const_iterator const_iterator; QVector<T> c; const_iterator i; public: inline QVectorIterator(const QVector<T> &container) : c(container), i(c.constBegin()) {} inline QVectorIterator &operator=(const QVector<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };
template <class T> class QMutableVectorIterator { typedef typename QVector<T>::iterator iterator; typedef typename QVector<T>::const_iterator const_iterator; QVector<T> *c; iterator i, n; inline bool item_exists() const { return const_iterator(n) != c->constEnd(); } public: inline QMutableVectorIterator(QVector<T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableVectorIterator() { c->setSharable(true); } inline QMutableVectorIterator &operator=(QVector<T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = i; } inline bool hasNext() const { return c->constEnd() != const_iterator(i); } inline T &next() { n = i++; return *n; } inline T &peekNext() const { return *i; } inline bool hasPrevious() const { return c->constBegin() != const_iterator(i); } inline T &previous() { n = --i; return *n; } inline T &peekPrevious() const { iterator p = i; return *--p; } inline void remove() { if (c->constEnd() != const_iterator(n)) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) const { if (c->constEnd() != const_iterator(n)) *n = t; } inline T &value() { qt_noop(); return *n; } inline const T &value() const { qt_noop(); return *n; } inline void insert(const T &t) { n = i = c->insert(i, t); ++i; } inline bool findNext(const T &t) { while (c->constEnd() != const_iterator(n = i)) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (c->constBegin() != const_iterator(i)) if (*(n = --i) == t) return true; n = c->end(); return false; } };


























# 796 "/usr/share/qt4/include/QtCore/qvector.h"





# 52 "/usr/share/qt4/include/QtCore/qdebug.h"

# 1 "/usr/share/qt4/include/QtCore/qset.h"












































# 1 "/usr/share/qt4/include/QtCore/qhash.h"






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qset.h"


# 47 "/usr/share/qt4/include/QtCore/qset.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

template <class T>
class QSet
{
typedef QHash<T, QHashDummyValue> Hash;

public:
inline QSet() {}
inline QSet(const QSet<T> &other) : q_hash(other.q_hash) {}

inline QSet<T> &operator=(const QSet<T> &other)
{ q_hash = other.q_hash; return *this; }

inline bool operator==(const QSet<T> &other) const
{ return q_hash == other.q_hash; }
inline bool operator!=(const QSet<T> &other) const
{ return q_hash != other.q_hash; }

inline int size() const { return q_hash.size(); }

inline bool isEmpty() const { return q_hash.isEmpty(); }

inline int capacity() const { return q_hash.capacity(); }
inline void reserve(int size);
inline void squeeze() { q_hash.squeeze(); }

inline void detach() { q_hash.detach(); }
inline bool isDetached() const { return q_hash.isDetached(); }
inline void setSharable(bool sharable) { q_hash.setSharable(sharable); }

inline void clear() { q_hash.clear(); }

inline bool remove(const T &value) { return q_hash.remove(value) != 0; }

inline bool contains(const T &value) const { return q_hash.contains(value); }

bool contains(const QSet<T> &set) const;

class const_iterator;

class iterator
{
typedef QHash<T, QHashDummyValue> Hash;
typename Hash::iterator i;
friend class const_iterator;

public:
typedef std::bidirectional_iterator_tag iterator_category;
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef const T *pointer;
typedef const T &reference;

inline iterator() {}
inline iterator(typename Hash::iterator o) : i(o) {}
inline iterator(const iterator &o) : i(o.i) {}
inline iterator &operator=(const iterator &o) { i = o.i; return *this; }
inline const T &operator*() const { return i.key(); }
inline const T *operator->() const { return &i.key(); }
inline bool operator==(const iterator &o) const { return i == o.i; }
inline bool operator!=(const iterator &o) const { return i != o.i; }
inline bool operator==(const const_iterator &o) const
{ return i == o.i; }
inline bool operator!=(const const_iterator &o) const
{ return i != o.i; }
inline iterator &operator++() { ++i; return *this; }
inline iterator operator++(int) { iterator r = *this; ++i; return r; }
inline iterator &operator--() { --i; return *this; }
inline iterator operator--(int) { iterator r = *this; --i; return r; }
inline iterator operator+(int j) const { return i + j; }
inline iterator operator-(int j) const { return i - j; }
inline iterator &operator+=(int j) { i += j; return *this; }
inline iterator &operator-=(int j) { i -= j; return *this; }
};

class const_iterator
{
typedef QHash<T, QHashDummyValue> Hash;
typename Hash::const_iterator i;
friend class iterator;

public:
typedef std::bidirectional_iterator_tag iterator_category;
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef const T *pointer;
typedef const T &reference;

inline const_iterator() {}
inline const_iterator(typename Hash::const_iterator o) : i(o) {}
inline const_iterator(const const_iterator &o) : i(o.i) {}
inline const_iterator(const iterator &o)
: i(o.i) {}
inline const_iterator &operator=(const const_iterator &o) { i = o.i; return *this; }
inline const T &operator*() const { return i.key(); }
inline const T *operator->() const { return &i.key(); }
inline bool operator==(const const_iterator &o) const { return i == o.i; }
inline bool operator!=(const const_iterator &o) const { return i != o.i; }
inline const_iterator &operator++() { ++i; return *this; }
inline const_iterator operator++(int) { const_iterator r = *this; ++i; return r; }
inline const_iterator &operator--() { --i; return *this; }
inline const_iterator operator--(int) { const_iterator r = *this; --i; return r; }
inline const_iterator operator+(int j) const { return i + j; }
inline const_iterator operator-(int j) const { return i - j; }
inline const_iterator &operator+=(int j) { i += j; return *this; }
inline const_iterator &operator-=(int j) { i -= j; return *this; }
};


inline iterator begin() { return q_hash.begin(); }
inline const_iterator begin() const { return q_hash.begin(); }
inline const_iterator constBegin() const { return q_hash.constBegin(); }
inline iterator end() { return q_hash.end(); }
inline const_iterator end() const { return q_hash.end(); }
inline const_iterator constEnd() const { return q_hash.constEnd(); }
iterator erase(iterator i)
{ return q_hash.erase(reinterpret_cast<typename Hash::iterator &>(i)); }


typedef iterator Iterator;
typedef const_iterator ConstIterator;
inline int count() const { return q_hash.count(); }
inline const_iterator insert(const T &value) 
{ return static_cast<typename Hash::const_iterator>(q_hash.insert(value,
QHashDummyValue())); }
iterator find(const T &value) { return q_hash.find(value); }
const_iterator find(const T &value) const { return q_hash.find(value); }
inline const_iterator constFind(const T &value) const { return find(value); }
QSet<T> &unite(const QSet<T> &other);
QSet<T> &intersect(const QSet<T> &other);
QSet<T> &subtract(const QSet<T> &other);


typedef T key_type;
typedef T value_type;
typedef value_type *pointer;
typedef const value_type *const_pointer;
typedef value_type &reference;
typedef const value_type &const_reference;
typedef ptrdiff_t difference_type;
typedef int size_type;

inline bool empty() const { return isEmpty(); }


inline QSet<T> &operator<<(const T &value) { insert(value); return *this; }
inline QSet<T> &operator|=(const QSet<T> &other) { unite(other); return *this; }
inline QSet<T> &operator|=(const T &value) { insert(value); return *this; }
inline QSet<T> &operator&=(const QSet<T> &other) { intersect(other); return *this; }
inline QSet<T> &operator&=(const T &value)
{ QSet<T> result; if (contains(value)) result.insert(value); return (*this = result); }
inline QSet<T> &operator+=(const QSet<T> &other) { unite(other); return *this; }
inline QSet<T> &operator+=(const T &value) { insert(value); return *this; }
inline QSet<T> &operator-=(const QSet<T> &other) { subtract(other); return *this; }
inline QSet<T> &operator-=(const T &value) { remove(value); return *this; }
inline QSet<T> operator|(const QSet<T> &other) const
{ QSet<T> result = *this; result |= other; return result; }
inline QSet<T> operator&(const QSet<T> &other) const
{ QSet<T> result = *this; result &= other; return result; }
inline QSet<T> operator+(const QSet<T> &other) const
{ QSet<T> result = *this; result += other; return result; }
inline QSet<T> operator-(const QSet<T> &other) const
{ QSet<T> result = *this; result -= other; return result; }

# 216 "/usr/share/qt4/include/QtCore/qset.h"

inline QSet<T> operator|(const QSet<T> &other)
{ QSet<T> result = *this; result |= other; return result; }
inline QSet<T> operator&(const QSet<T> &other)
{ QSet<T> result = *this; result &= other; return result; }
inline QSet<T> operator+(const QSet<T> &other)
{ QSet<T> result = *this; result += other; return result; }
inline QSet<T> operator-(const QSet<T> &other)
{ QSet<T> result = *this; result -= other; return result; }


# 227 "/usr/share/qt4/include/QtCore/qset.h"
QList<T> toList() const;
inline QList<T> values() const { return toList(); }

static QSet<T> fromList(const QList<T> &list);

private:
Hash q_hash;
};

template <class T>
inline void QSet<T>::reserve(int asize) { q_hash.reserve(asize); }

template <class T>
inline QSet<T> &QSet<T>::unite(const QSet<T> &other)
{
QSet<T> copy(other);
typename QSet<T>::const_iterator i = copy.constEnd();
while (i != copy.constBegin()) {
--i;
insert(*i);
}
return *this;
}

template <class T>
inline QSet<T> &QSet<T>::intersect(const QSet<T> &other)
{
QSet<T> copy1(*this);
QSet<T> copy2(other);
typename QSet<T>::const_iterator i = copy1.constEnd();
while (i != copy1.constBegin()) {
--i;
if (!copy2.contains(*i))
remove(*i);
}
return *this;
}

template <class T>
inline QSet<T> &QSet<T>::subtract(const QSet<T> &other)
{
QSet<T> copy1(*this);
QSet<T> copy2(other);
typename QSet<T>::const_iterator i = copy1.constEnd();
while (i != copy1.constBegin()) {
--i;
if (copy2.contains(*i))
remove(*i);
}
return *this;
}

template <class T>
inline bool QSet<T>::contains(const QSet<T> &other) const
{
typename QSet<T>::const_iterator i = other.constBegin();
while (i != other.constEnd()) {
if (!contains(*i))
return false;
++i;
}
return true;
}

template <typename T>
 QList<T> QSet<T>::toList() const
{
QList<T> result;
typename QSet<T>::const_iterator i = constBegin();
while (i != constEnd()) {
result.append(*i);
++i;
}
return result;
}

template <typename T>
 QSet<T> QList<T>::toSet() const
{
QSet<T> result;
result.reserve(size());
for (int i = 0; i < size(); ++i)
result.insert(at(i));
return result;
}

template <typename T>
QSet<T> QSet<T>::fromList(const QList<T> &list)
{
return list.toSet();
}

template <typename T>
QList<T> QList<T>::fromSet(const QSet<T> &set)
{
return set.toList();
}

template <class T> class QSetIterator { typedef typename QSet<T>::const_iterator const_iterator; QSet<T> c; const_iterator i; public: inline QSetIterator(const QSet<T> &container) : c(container), i(c.constBegin()) {} inline QSetIterator &operator=(const QSet<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };

template <typename T>
class QMutableSetIterator
{
typedef typename QSet<T>::iterator iterator;
QSet<T> *c;
iterator i, n;
inline bool item_exists() const { return n != c->constEnd(); }

public:
inline QMutableSetIterator(QSet<T> &container)
: c(&container)
{ c->setSharable(false); i = c->begin(); n = c->end(); }
inline ~QMutableSetIterator()
{ c->setSharable(true); }
inline QMutableSetIterator &operator=(QSet<T> &container)
{ c->setSharable(true); c = &container; c->setSharable(false);
i = c->begin(); n = c->end(); return *this; }
inline void toFront() { i = c->begin(); n = c->end(); }
inline void toBack() { i = c->end(); n = i; }
inline bool hasNext() const { return c->constEnd() != i; }
inline const T &next() { n = i++; return *n; }
inline const T &peekNext() const { return *i; }
inline bool hasPrevious() const { return c->constBegin() != i; }
inline const T &previous() { n = --i; return *n; }
inline const T &peekPrevious() const { iterator p = i; return *--p; }
inline void remove()
{ if (c->constEnd() != n) { i = c->erase(n); n = c->end(); } }
inline const T &value() const { qt_noop(); return *n; }
inline bool findNext(const T &t)
{ while (c->constEnd() != (n = i)) if (*i++ == t) return true; return false; }
inline bool findPrevious(const T &t)
{ while (c->constBegin() != i) if (*(n = --i) == t) return true;
n = c->end(); return false; }
};






# 53 "/usr/share/qt4/include/QtCore/qdebug.h"

# 1 "/usr/share/qt4/include/QtCore/qcontiguouscache.h"












































# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 45 "/usr/share/qt4/include/QtCore/qcontiguouscache.h"




# 49 "/usr/share/qt4/include/QtCore/qcontiguouscache.h"





# 54 "/usr/share/qt4/include/QtCore/qcontiguouscache.h"
typedef QtValidLicenseForCoreModule QtCoreModule;


struct  QContiguousCacheData
{
QBasicAtomicInt ref;
int alloc;
int count;
int start;
int offset;
uint sharable : 1;
uint reserved : 31;






static QContiguousCacheData *allocate(int size, int alignment);
static void free(QContiguousCacheData *data);




# 78 "/usr/share/qt4/include/QtCore/qcontiguouscache.h"
};

template <typename T>
struct QContiguousCacheTypedData: private QContiguousCacheData
{

T array[1];

static inline void free(QContiguousCacheTypedData *data) { QContiguousCacheData::free(data); }
};

template<typename T>
class QContiguousCache {
typedef QContiguousCacheTypedData<T> Data;
union { QContiguousCacheData *d; QContiguousCacheTypedData<T> *p; };
public:

typedef T value_type;
typedef value_type* pointer;
typedef const value_type* const_pointer;
typedef value_type& reference;
typedef const value_type& const_reference;
typedef ptrdiff_t difference_type;
typedef int size_type;

explicit QContiguousCache(int capacity = 0);
QContiguousCache(const QContiguousCache<T> &v) : d(v.d) { d->ref.ref(); if (!d->sharable) detach_helper(); }

inline ~QContiguousCache() { if (!d) return; if (!d->ref.deref()) free(p); }

inline void detach() { if (d->ref != 1) detach_helper(); }
inline bool isDetached() const { return d->ref == 1; }
inline void setSharable(bool sharable) { if (!sharable) detach(); d->sharable = sharable; }

QContiguousCache<T> &operator=(const QContiguousCache<T> &other);
bool operator==(const QContiguousCache<T> &other) const;
inline bool operator!=(const QContiguousCache<T> &other) const { return !(*this == other); }

inline int capacity() const {return d->alloc; }
inline int count() const { return d->count; }
inline int size() const { return d->count; }

inline bool isEmpty() const { return d->count == 0; }
inline bool isFull() const { return d->count == d->alloc; }
inline int available() const { return d->alloc - d->count; }

void clear();
void setCapacity(int size);

const T &at(int pos) const;
T &operator[](int i);
const T &operator[](int i) const;

void append(const T &value);
void prepend(const T &value);
void insert(int pos, const T &value);

inline bool containsIndex(int pos) const { return pos >= d->offset && pos - d->offset < d->count; }
inline int firstIndex() const { return d->offset; }
inline int lastIndex() const { return d->offset + d->count - 1; }

inline const T &first() const { qt_noop(); return p->array[d->start]; }
inline const T &last() const { qt_noop(); return p->array[(d->start + d->count -1) % d->alloc]; }
inline T &first() { qt_noop(); detach(); return p->array[d->start]; }
inline T &last() { qt_noop(); detach(); return p->array[(d->start + d->count -1) % d->alloc]; }

void removeFirst();
T takeFirst();
void removeLast();
T takeLast();

inline bool areIndexesValid() const
{ return d->offset >= 0 && d->offset < INT_MAX - d->count && (d->offset % d->alloc) == d->start; }

inline void normalizeIndexes() { d->offset = d->start; }




# 157 "/usr/share/qt4/include/QtCore/qcontiguouscache.h"
private:
void detach_helper();

QContiguousCacheData *malloc(int aalloc);
void free(Data *x);
int sizeOfTypedData() {


return reinterpret_cast<const char *>(&(reinterpret_cast<const Data *>(this))->array[1]) - reinterpret_cast<const char *>(this);
}
int alignOfTypedData() const
{



# 172 "/usr/share/qt4/include/QtCore/qcontiguouscache.h"
return 0;

# 174 "/usr/share/qt4/include/QtCore/qcontiguouscache.h"
}
};

template <typename T>
void QContiguousCache<T>::detach_helper()
{
union { QContiguousCacheData *d; QContiguousCacheTypedData<T> *p; } x;

x.d = malloc(d->alloc);
x.d->ref = 1;
x.d->count = d->count;
x.d->start = d->start;
x.d->offset = d->offset;
x.d->alloc = d->alloc;
x.d->sharable = true;
x.d->reserved = 0;

T *dest = x.p->array + x.d->start;
T *src = p->array + d->start;
int oldcount = x.d->count;
while (oldcount--) {
if (QTypeInfo<T>::isComplex) {
new (dest) T(*src);
} else {
*dest = *src;
}
dest++;
if (dest == x.p->array + x.d->alloc)
dest = x.p->array;
src++;
if (src == p->array + d->alloc)
src = p->array;
}

if (!d->ref.deref())
free(p);
d = x.d;
}

template <typename T>
void QContiguousCache<T>::setCapacity(int asize)
{
if (asize == d->alloc)
return;
detach();
union { QContiguousCacheData *d; QContiguousCacheTypedData<T> *p; } x;
x.d = malloc(asize);
x.d->alloc = asize;
x.d->count = qMin(d->count, asize);
x.d->offset = d->offset + d->count - x.d->count;
x.d->start = x.d->offset % x.d->alloc;
T *dest = x.p->array + (x.d->start + x.d->count-1) % x.d->alloc;
T *src = p->array + (d->start + d->count-1) % d->alloc;
int oldcount = x.d->count;
while (oldcount--) {
if (QTypeInfo<T>::isComplex) {
new (dest) T(*src);
} else {
*dest = *src;
}
if (dest == x.p->array)
dest = x.p->array + x.d->alloc;
dest--;
if (src == p->array)
src = p->array + d->alloc;
src--;
}

free(p);
d = x.d;
}

template <typename T>
void QContiguousCache<T>::clear()
{
if (d->ref == 1) {
if (QTypeInfo<T>::isComplex) {
int oldcount = d->count;
T * i = p->array + d->start;
T * e = p->array + d->alloc;
while (oldcount--) {
i->~T();
i++;
if (i == e)
i = p->array;
}
}
d->count = d->start = d->offset = 0;
} else {
union { QContiguousCacheData *d; QContiguousCacheTypedData<T> *p; } x;
x.d = malloc(d->alloc);
x.d->ref = 1;
x.d->alloc = d->alloc;
x.d->count = x.d->start = x.d->offset = 0;
x.d->sharable = true;
if (!d->ref.deref()) free(p);
d = x.d;
}
}

template <typename T>
inline QContiguousCacheData *QContiguousCache<T>::malloc(int aalloc)
{
return QContiguousCacheData::allocate(sizeOfTypedData() + (aalloc - 1) * sizeof(T), alignOfTypedData());
}

template <typename T>
QContiguousCache<T>::QContiguousCache(int cap)
{
d = malloc(cap);
d->ref = 1;
d->alloc = cap;
d->count = d->start = d->offset = 0;
d->sharable = true;
}

template <typename T>
QContiguousCache<T> &QContiguousCache<T>::operator=(const QContiguousCache<T> &other)
{
other.d->ref.ref();
if (!d->ref.deref())
free(d);
d = other.d;
if (!d->sharable)
detach_helper();
return *this;
}

template <typename T>
bool QContiguousCache<T>::operator==(const QContiguousCache<T> &other) const
{
if (other.d == d)
return true;
if (other.d->start != d->start
|| other.d->count != d->count
|| other.d->offset != d->offset
|| other.d->alloc != d->alloc)
return false;
for (int i = firstIndex(); i <= lastIndex(); ++i)
if (!(at(i) == other.at(i)))
return false;
return true;
}

template <typename T>
void QContiguousCache<T>::free(Data *x)
{
if (QTypeInfo<T>::isComplex) {
int oldcount = d->count;
T * i = p->array + d->start;
T * e = p->array + d->alloc;
while (oldcount--) {
i->~T();
i++;
if (i == e)
i = p->array;
}
}
x->free(x);
}
template <typename T>
void QContiguousCache<T>::append(const T &value)
{
detach();
if (QTypeInfo<T>::isComplex) {
if (d->count == d->alloc)
(p->array + (d->start+d->count) % d->alloc)->~T();
new (p->array + (d->start+d->count) % d->alloc) T(value);
} else {
p->array[(d->start+d->count) % d->alloc] = value;
}

if (d->count == d->alloc) {
d->start++;
d->start %= d->alloc;
d->offset++;
} else {
d->count++;
}
}

template<typename T>
void QContiguousCache<T>::prepend(const T &value)
{
detach();
if (d->start)
d->start--;
else
d->start = d->alloc-1;
d->offset--;

if (d->count != d->alloc)
d->count++;
else
if (d->count == d->alloc)
(p->array + d->start)->~T();

if (QTypeInfo<T>::isComplex)
new (p->array + d->start) T(value);
else
p->array[d->start] = value;
}

template<typename T>
void QContiguousCache<T>::insert(int pos, const T &value)
{
qt_noop();
detach();
if (containsIndex(pos)) {
if(QTypeInfo<T>::isComplex)
new (p->array + pos % d->alloc) T(value);
else
p->array[pos % d->alloc] = value;
} else if (pos == d->offset-1)
prepend(value);
else if (pos == d->offset+d->count)
append(value);
else {

clear();
d->offset = pos;
d->start = pos % d->alloc;
d->count = 1;
if (QTypeInfo<T>::isComplex)
new (p->array + d->start) T(value);
else
p->array[d->start] = value;
}
}

template <typename T>
inline const T &QContiguousCache<T>::at(int pos) const
{ qt_noop(); return p->array[pos % d->alloc]; }
template <typename T>
inline const T &QContiguousCache<T>::operator[](int pos) const
{ qt_noop(); return p->array[pos % d->alloc]; }

template <typename T>
inline T &QContiguousCache<T>::operator[](int pos)
{
detach();
if (!containsIndex(pos))
insert(pos, T());
return p->array[pos % d->alloc];
}

template <typename T>
inline void QContiguousCache<T>::removeFirst()
{
qt_noop();
detach();
d->count--;
if (QTypeInfo<T>::isComplex)
(p->array + d->start)->~T();
d->start = (d->start + 1) % d->alloc;
d->offset++;
}

template <typename T>
inline void QContiguousCache<T>::removeLast()
{
qt_noop();
detach();
d->count--;
if (QTypeInfo<T>::isComplex)
(p->array + (d->start + d->count) % d->alloc)->~T();
}

template <typename T>
inline T QContiguousCache<T>::takeFirst()
{ T t = first(); removeFirst(); return t; }

template <typename T>
inline T QContiguousCache<T>::takeLast()
{ T t = last(); removeLast(); return t; }






# 54 "/usr/share/qt4/include/QtCore/qdebug.h"


# 56 "/usr/share/qt4/include/QtCore/qdebug.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class  QDebug
{
struct Stream {
Stream(QIODevice *device) : ts(device), ref(1), type(QtDebugMsg), space(true), message_output(false) {}
Stream(QString *string) : ts(string, QIODevice::WriteOnly), ref(1), type(QtDebugMsg), space(true), message_output(false) {}
Stream(QtMsgType t) : ts(&buffer, QIODevice::WriteOnly), ref(1), type(t), space(true), message_output(true) {}
QTextStream ts;
QString buffer;
int ref;
QtMsgType type;
bool space;
bool message_output;
} *stream;
public:
inline QDebug(QIODevice *device) : stream(new Stream(device)) {}
inline QDebug(QString *string) : stream(new Stream(string)) {}
inline QDebug(QtMsgType t) : stream(new Stream(t)) {}
inline QDebug(const QDebug &o):stream(o.stream) { ++stream->ref; }
inline QDebug &operator=(const QDebug &other);
inline ~QDebug() {
if (!--stream->ref) {
if(stream->message_output) {
try {
qt_message_output(stream->type, stream->buffer.toLocal8Bit().data());
} catch (std::bad_alloc&) {  }
}
delete stream;
}
}
inline QDebug &space() { stream->space = true; stream->ts << ' '; return *this; }
inline QDebug &nospace() { stream->space = false; return *this; }
inline QDebug &maybeSpace() { if (stream->space) stream->ts << ' '; return *this; }

inline QDebug &operator<<(QChar t) { stream->ts << '\'' << t << '\''; return maybeSpace(); }
inline QDebug &operator<<(QBool t) { stream->ts << (bool(t != 0) ? "true" : "false"); return maybeSpace(); }
inline QDebug &operator<<(bool t) { stream->ts << (t ? "true" : "false"); return maybeSpace(); }
inline QDebug &operator<<(char t) { stream->ts << t; return maybeSpace(); }
inline QDebug &operator<<(signed short t) { stream->ts << t; return maybeSpace(); }
inline QDebug &operator<<(unsigned short t) { stream->ts << t; return maybeSpace(); }
inline QDebug &operator<<(signed int t) { stream->ts << t; return maybeSpace(); }
inline QDebug &operator<<(unsigned int t) { stream->ts << t; return maybeSpace(); }
inline QDebug &operator<<(signed long t) { stream->ts << t; return maybeSpace(); }
inline QDebug &operator<<(unsigned long t) { stream->ts << t; return maybeSpace(); }
inline QDebug &operator<<(qint64 t)
{ stream->ts << QString::number(t); return maybeSpace(); }
inline QDebug &operator<<(quint64 t)
{ stream->ts << QString::number(t); return maybeSpace(); }
inline QDebug &operator<<(float t) { stream->ts << t; return maybeSpace(); }
inline QDebug &operator<<(double t) { stream->ts << t; return maybeSpace(); }
inline QDebug &operator<<(const char* t) { stream->ts << QString::fromAscii(t); return maybeSpace(); }
inline QDebug &operator<<(const QString & t) { stream->ts << '\"' << t << '\"'; return maybeSpace(); }
inline QDebug &operator<<(const QStringRef & t) { return operator<<(t.toString()); }
inline QDebug &operator<<(const QLatin1String &t) { stream->ts << '\"' << t.latin1() << '\"'; return maybeSpace(); }
inline QDebug &operator<<(const QByteArray & t) { stream->ts << '\"' << t << '\"'; return maybeSpace(); }
inline QDebug &operator<<(const void * t) { stream->ts << t; return maybeSpace(); }
inline QDebug &operator<<(QTextStreamFunction f) {
stream->ts << f;
return *this;
}

inline QDebug &operator<<(QTextStreamManipulator m)
{ stream->ts << m; return *this; }
};

class QNoDebug
{
public:
inline QNoDebug(){}
inline QNoDebug(const QDebug &){}
inline ~QNoDebug(){}

# 133 "/usr/share/qt4/include/QtCore/qdebug.h"
inline QNoDebug &operator<<(QTextStreamFunction) { return *this; }
inline QNoDebug &operator<<(QTextStreamManipulator) { return *this; }

# 136 "/usr/share/qt4/include/QtCore/qdebug.h"
inline QNoDebug &space() { return *this; }
inline QNoDebug &nospace() { return *this; }
inline QNoDebug &maybeSpace() { return *this; }


# 141 "/usr/share/qt4/include/QtCore/qdebug.h"
template<typename T>
inline QNoDebug &operator<<(const T &) { return *this; }

# 144 "/usr/share/qt4/include/QtCore/qdebug.h"
};

 inline QDebug qCritical() { return QDebug(QtCriticalMsg); }

inline QDebug &QDebug::operator=(const QDebug &other)
{
if (this != &other) {
QDebug copy(other);
qSwap(stream, copy.stream);
}
return *this;
}





# 161 "/usr/share/qt4/include/QtCore/qdebug.h"
template <class T>
inline QDebug operator<<(QDebug debug, const QList<T> &list)

# 164 "/usr/share/qt4/include/QtCore/qdebug.h"
{
debug.nospace() << '(';
for (typename QList<T>::size_type i = 0; i < list.count(); ++i) {
if (i)
debug << ", ";
debug << list.at(i);
}
debug << ')';
return debug.space();
}





# 179 "/usr/share/qt4/include/QtCore/qdebug.h"
template <typename T>
inline QDebug operator<<(QDebug debug, const QVector<T> &vec)

# 182 "/usr/share/qt4/include/QtCore/qdebug.h"
{
debug.nospace() << "QVector";
return operator<<(debug, vec.toList());
}





# 191 "/usr/share/qt4/include/QtCore/qdebug.h"
template <class aKey, class aT>
inline QDebug operator<<(QDebug debug, const QMap<aKey, aT> &map)

# 194 "/usr/share/qt4/include/QtCore/qdebug.h"
{
debug.nospace() << "QMap(";
for (typename QMap<aKey, aT>::const_iterator it = map.constBegin();
it != map.constEnd(); ++it) {
debug << '(' << it.key() << ", " << it.value() << ')';
}
debug << ')';
return debug.space();
}





# 208 "/usr/share/qt4/include/QtCore/qdebug.h"
template <class aKey, class aT>
inline QDebug operator<<(QDebug debug, const QHash<aKey, aT> &hash)

# 211 "/usr/share/qt4/include/QtCore/qdebug.h"
{
debug.nospace() << "QHash(";
for (typename QHash<aKey, aT>::const_iterator it = hash.constBegin();
it != hash.constEnd(); ++it)
debug << '(' << it.key() << ", " << it.value() << ')';
debug << ')';
return debug.space();
}





# 224 "/usr/share/qt4/include/QtCore/qdebug.h"
template <class T1, class T2>
inline QDebug operator<<(QDebug debug, const QPair<T1, T2> &pair)

# 227 "/usr/share/qt4/include/QtCore/qdebug.h"
{
debug.nospace() << "QPair(" << pair.first << ',' << pair.second << ')';
return debug.space();
}

template <typename T>
inline QDebug operator<<(QDebug debug, const QSet<T> &set)
{
debug.nospace() << "QSet";
return operator<<(debug, set.toList());
}





# 243 "/usr/share/qt4/include/QtCore/qdebug.h"
template <class T>
inline QDebug operator<<(QDebug debug, const QContiguousCache<T> &cache)

# 246 "/usr/share/qt4/include/QtCore/qdebug.h"
{
debug.nospace() << "QContiguousCache(";
for (int i = cache.firstIndex(); i <= cache.lastIndex(); ++i) {
debug << cache[i];
if (i != cache.lastIndex())
debug << ", ";
}
debug << ')';
return debug.space();
}


# 258 "/usr/share/qt4/include/QtCore/qdebug.h"
 inline QDebug qDebug() { return QDebug(QtDebugMsg); }














# 273 "/usr/share/qt4/include/QtCore/qdebug.h"
 inline QDebug qWarning() { return QDebug(QtWarningMsg); }






# 280 "/usr/share/qt4/include/QtCore/qdebug.h"





# 6 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qdir.h"









































































































































































































































































# 7 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qdiriterator.h"












































# 1 "/usr/share/qt4/include/QtCore/qdir.h"









































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qdiriterator.h"


# 47 "/usr/share/qt4/include/QtCore/qdiriterator.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QDirIteratorPrivate;
class  QDirIterator {
public:
enum IteratorFlag {
NoIteratorFlags = 0x0,
FollowSymlinks = 0x1,
Subdirectories = 0x2
};
typedef QFlags<IteratorFlag> IteratorFlags;

QDirIterator(const QDir &dir, IteratorFlags flags = NoIteratorFlags);
QDirIterator(const QString &path,
IteratorFlags flags = NoIteratorFlags);
QDirIterator(const QString &path,
QDir::Filters filter,
IteratorFlags flags = NoIteratorFlags);
QDirIterator(const QString &path,
const QStringList &nameFilters,
QDir::Filters filters = QDir::NoFilter,
IteratorFlags flags = NoIteratorFlags);

virtual ~QDirIterator();

QString next();
bool hasNext() const;

QString fileName() const;
QString filePath() const;
QFileInfo fileInfo() const;
QString path() const;

private:
QDirIterator(const QDirIterator &); QDirIterator &operator=(const QDirIterator &);

QScopedPointer<QDirIteratorPrivate> d;
friend class QDir;
};

inline QFlags<QDirIterator::IteratorFlags::enum_type> operator|(QDirIterator::IteratorFlags::enum_type f1, QDirIterator::IteratorFlags::enum_type f2) { return QFlags<QDirIterator::IteratorFlags::enum_type>(f1) | f2; } inline QFlags<QDirIterator::IteratorFlags::enum_type> operator|(QDirIterator::IteratorFlags::enum_type f1, QFlags<QDirIterator::IteratorFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QDirIterator::IteratorFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }






# 8 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qfile.h"












































































































































































































# 9 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qfileinfo.h"




























































































































































































# 10 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qfilesystemwatcher.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qfilesystemwatcher.h"




# 49 "/usr/share/qt4/include/QtCore/qfilesystemwatcher.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QFileSystemWatcherPrivate;

class  QFileSystemWatcher : public QObject
{
Q_OBJECT
inline QFileSystemWatcherPrivate* d_func() { return reinterpret_cast<QFileSystemWatcherPrivate *>(qGetPtrHelper(d_ptr)); } inline const QFileSystemWatcherPrivate* d_func() const { return reinterpret_cast<const QFileSystemWatcherPrivate *>(qGetPtrHelper(d_ptr)); } friend class QFileSystemWatcherPrivate;

public:
QFileSystemWatcher(QObject *parent = 0);
QFileSystemWatcher(const QStringList &paths, QObject *parent = 0);
~QFileSystemWatcher();

void addPath(const QString &file);
void addPaths(const QStringList &files);
void removePath(const QString &file);
void removePaths(const QStringList &files);

QStringList files() const;
QStringList directories() const;

signals:
void fileChanged(const QString &path);
void directoryChanged(const QString &path);

private:


};







# 11 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qfsfileengine.h"












































# 1 "/usr/share/qt4/include/QtCore/qabstractfileengine.h"
























































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qfsfileengine.h"




# 49 "/usr/share/qt4/include/QtCore/qfsfileengine.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QFSFileEnginePrivate;

class  QFSFileEngine : public QAbstractFileEngine
{
inline QFSFileEnginePrivate* d_func() { return reinterpret_cast<QFSFileEnginePrivate *>(qGetPtrHelper(d_ptr)); } inline const QFSFileEnginePrivate* d_func() const { return reinterpret_cast<const QFSFileEnginePrivate *>(qGetPtrHelper(d_ptr)); } friend class QFSFileEnginePrivate;
public:
QFSFileEngine();
explicit QFSFileEngine(const QString &file);
~QFSFileEngine();

bool open(QIODevice::OpenMode openMode);
bool open(QIODevice::OpenMode flags, FILE *fh);
bool close();
bool flush();
qint64 size() const;
qint64 pos() const;
bool seek(qint64);
bool isSequential() const;
bool remove();
bool copy(const QString &newName);
bool rename(const QString &newName);
bool link(const QString &newName);
bool mkdir(const QString &dirName, bool createParentDirectories) const;
bool rmdir(const QString &dirName, bool recurseParentDirectories) const;
bool setSize(qint64 size);
bool caseSensitive() const;
bool isRelativePath() const;
QStringList entryList(QDir::Filters filters, const QStringList &filterNames) const;
FileFlags fileFlags(FileFlags type) const;
bool setPermissions(uint perms);
QString fileName(FileName file) const;
uint ownerId(FileOwner) const;
QString owner(FileOwner) const;
QDateTime fileTime(FileTime time) const;
void setFileName(const QString &file);
int handle() const;

Iterator *beginEntryList(QDir::Filters filters, const QStringList &filterNames);
Iterator *endEntryList();

qint64 read(char *data, qint64 maxlen);
qint64 readLine(char *data, qint64 maxlen);
qint64 write(const char *data, qint64 len);

bool extension(Extension extension, const ExtensionOption *option = 0, ExtensionReturn *output = 0);
bool supportsExtension(Extension extension) const;


bool open(QIODevice::OpenMode flags, int fd);
static bool setCurrentPath(const QString &path);
static QString currentPath(const QString &path = QString());
static QString homePath();
static QString rootPath();
static QString tempPath();
static QFileInfoList drives();

protected:
QFSFileEngine(QFSFileEnginePrivate &dd);
};








# 12 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qiodevice.h"






























































































































































































































































# 13 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qprocess.h"












































# 1 "/usr/share/qt4/include/QtCore/qiodevice.h"






























































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qprocess.h"

# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"



































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qprocess.h"

# 1 "/usr/share/qt4/include/QtCore/qshareddata.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qshareddata.h"

# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 46 "/usr/share/qt4/include/QtCore/qshareddata.h"


# 48 "/usr/share/qt4/include/QtCore/qshareddata.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

template <class T> class QSharedDataPointer;

class  QSharedData
{
public:
mutable QAtomicInt ref;

inline QSharedData() : ref(0) { }
inline QSharedData(const QSharedData &) : ref(0) { }

private:

QSharedData &operator=(const QSharedData &);
};

template <class T> class QSharedDataPointer
{
public:
typedef T Type;
typedef T *pointer;

inline void detach() { if (d && d->ref != 1) detach_helper(); }
inline T &operator*() { detach(); return *d; }
inline const T &operator*() const { return *d; }
inline T *operator->() { detach(); return d; }
inline const T *operator->() const { return d; }
inline operator T *() { detach(); return d; }
inline operator const T *() const { return d; }
inline T *data() { detach(); return d; }
inline const T *data() const { return d; }
inline const T *constData() const { return d; }

inline bool operator==(const QSharedDataPointer<T> &other) const { return d == other.d; }
inline bool operator!=(const QSharedDataPointer<T> &other) const { return d != other.d; }

inline QSharedDataPointer() { d = 0; }
inline ~QSharedDataPointer() { if (d && !d->ref.deref()) delete d; }

explicit QSharedDataPointer(T *data);
inline QSharedDataPointer(const QSharedDataPointer<T> &o) : d(o.d) { if (d) d->ref.ref(); }
inline QSharedDataPointer<T> & operator=(const QSharedDataPointer<T> &o) {
if (o.d != d) {
if (o.d)
o.d->ref.ref();
if (d && !d->ref.deref())
delete d;
d = o.d;
}
return *this;
}
inline QSharedDataPointer &operator=(T *o) {
if (o != d) {
if (o)
o->ref.ref();
if (d && !d->ref.deref())
delete d;
d = o;
}
return *this;
}

inline bool operator!() const { return !d; }

inline void swap(QSharedDataPointer &other)
{ qSwap(d, other.d); }

protected:
T *clone();

private:
void detach_helper();

T *d;
};

template <class T> class QExplicitlySharedDataPointer
{
public:
typedef T Type;
typedef T *pointer;

inline T &operator*() const { return *d; }
inline T *operator->() { return d; }
inline T *operator->() const { return d; }
inline T *data() const { return d; }
inline const T *constData() const { return d; }

inline void detach() { if (d && d->ref != 1) detach_helper(); }

inline void reset()
{
if(d && !d->ref.deref())
delete d;

d = 0;
}

inline operator bool () const { return d != 0; }

inline bool operator==(const QExplicitlySharedDataPointer<T> &other) const { return d == other.d; }
inline bool operator!=(const QExplicitlySharedDataPointer<T> &other) const { return d != other.d; }
inline bool operator==(const T *ptr) const { return d == ptr; }
inline bool operator!=(const T *ptr) const { return d != ptr; }

inline QExplicitlySharedDataPointer() { d = 0; }
inline ~QExplicitlySharedDataPointer() { if (d && !d->ref.deref()) delete d; }

explicit QExplicitlySharedDataPointer(T *data);
inline QExplicitlySharedDataPointer(const QExplicitlySharedDataPointer<T> &o) : d(o.d) { if (d) d->ref.ref(); }


# 165 "/usr/share/qt4/include/QtCore/qshareddata.h"
template<class X>
inline QExplicitlySharedDataPointer(const QExplicitlySharedDataPointer<X> &o) : d(static_cast<T *>(o.data()))
{
if(d)
d->ref.ref();
}


# 173 "/usr/share/qt4/include/QtCore/qshareddata.h"
inline QExplicitlySharedDataPointer<T> & operator=(const QExplicitlySharedDataPointer<T> &o) {
if (o.d != d) {
if (o.d)
o.d->ref.ref();
if (d && !d->ref.deref())
delete d;
d = o.d;
}
return *this;
}
inline QExplicitlySharedDataPointer &operator=(T *o) {
if (o != d) {
if (o)
o->ref.ref();
if (d && !d->ref.deref())
delete d;
d = o;
}
return *this;
}

inline bool operator!() const { return !d; }

inline void swap(QExplicitlySharedDataPointer &other)
{ qSwap(d, other.d); }

protected:
T *clone();

private:
void detach_helper();

T *d;
};

template <class T>
inline QSharedDataPointer<T>::QSharedDataPointer(T *adata) : d(adata)
{ if (d) d->ref.ref(); }

template <class T>
inline T *QSharedDataPointer<T>::clone()
{
return new T(*d);
}

template <class T>
 void QSharedDataPointer<T>::detach_helper()
{
T *x = clone();
x->ref.ref();
if (!d->ref.deref())
delete d;
d = x;
}

template <class T>
inline T *QExplicitlySharedDataPointer<T>::clone()
{
return new T(*d);
}

template <class T>
 void QExplicitlySharedDataPointer<T>::detach_helper()
{
T *x = clone();
x->ref.ref();
if (!d->ref.deref())
delete d;
d = x;
}

template <class T>
inline QExplicitlySharedDataPointer<T>::QExplicitlySharedDataPointer(T *adata) : d(adata)
{ if (d) d->ref.ref(); }

template <class T>
inline void qSwap(QSharedDataPointer<T> &p1, QSharedDataPointer<T> &p2)
{ p1.swap(p2); }

template <class T>
inline void qSwap(QExplicitlySharedDataPointer<T> &p1, QExplicitlySharedDataPointer<T> &p2)
{ p1.swap(p2); }






# 47 "/usr/share/qt4/include/QtCore/qprocess.h"


# 49 "/usr/share/qt4/include/QtCore/qprocess.h"




typedef QtValidLicenseForCoreModule QtCoreModule;




# 58 "/usr/share/qt4/include/QtCore/qprocess.h"
typedef qint64 Q_PID;






# 65 "/usr/share/qt4/include/QtCore/qprocess.h"
class QProcessPrivate;
class QProcessEnvironmentPrivate;

class  QProcessEnvironment
{
public:
QProcessEnvironment();
QProcessEnvironment(const QProcessEnvironment &other);
~QProcessEnvironment();
QProcessEnvironment &operator=(const QProcessEnvironment &other);

bool operator==(const QProcessEnvironment &other) const;
inline bool operator!=(const QProcessEnvironment &other) const
{ return !(*this == other); }

bool isEmpty() const;
void clear();

bool contains(const QString &name) const;
void insert(const QString &name, const QString &value);
void remove(const QString &name);
QString value(const QString &name, const QString &defaultValue = QString()) const;

QStringList toStringList() const;

static QProcessEnvironment systemEnvironment();

private:
friend class QProcessPrivate;
friend class QProcessEnvironmentPrivate;
QSharedDataPointer<QProcessEnvironmentPrivate> d;
};

class  QProcess : public QIODevice
{
Q_OBJECT
public:
enum ProcessError {
FailedToStart, 
Crashed,
Timedout,
ReadError,
WriteError,
UnknownError
};
enum ProcessState {
NotRunning,
Starting,
Running
};
enum ProcessChannel {
StandardOutput,
StandardError
};
enum ProcessChannelMode {
SeparateChannels,
MergedChannels,
ForwardedChannels
};
enum ExitStatus {
NormalExit,
CrashExit
};

explicit QProcess(QObject *parent = 0);
virtual ~QProcess();

void start(const QString &program, const QStringList &arguments, OpenMode mode = ReadWrite);
void start(const QString &program, OpenMode mode = ReadWrite);

ProcessChannelMode readChannelMode() const;
void setReadChannelMode(ProcessChannelMode mode);
ProcessChannelMode processChannelMode() const;
void setProcessChannelMode(ProcessChannelMode mode);

ProcessChannel readChannel() const;
void setReadChannel(ProcessChannel channel);

void closeReadChannel(ProcessChannel channel);
void closeWriteChannel();

void setStandardInputFile(const QString &fileName);
void setStandardOutputFile(const QString &fileName, OpenMode mode = Truncate);
void setStandardErrorFile(const QString &fileName, OpenMode mode = Truncate);
void setStandardOutputProcess(QProcess *destination);

QString workingDirectory() const;
void setWorkingDirectory(const QString &dir);

void setEnvironment(const QStringList &environment);
QStringList environment() const;
void setProcessEnvironment(const QProcessEnvironment &environment);
QProcessEnvironment processEnvironment() const;

QProcess::ProcessError error() const;
QProcess::ProcessState state() const;


Q_PID pid() const;

bool waitForStarted(int msecs = 30000);
bool waitForReadyRead(int msecs = 30000);
bool waitForBytesWritten(int msecs = 30000);
bool waitForFinished(int msecs = 30000);

QByteArray readAllStandardOutput();
QByteArray readAllStandardError();

int exitCode() const;
QProcess::ExitStatus exitStatus() const;


qint64 bytesAvailable() const;
qint64 bytesToWrite() const;
bool isSequential() const;
bool canReadLine() const;
void close();
bool atEnd() const;

static int execute(const QString &program, const QStringList &arguments);
static int execute(const QString &program);

static bool startDetached(const QString &program, const QStringList &arguments, const QString &workingDirectory,
qint64 *pid = 0);
static bool startDetached(const QString &program, const QStringList &arguments);
static bool startDetached(const QString &program);

static QStringList systemEnvironment();

public slots:
void terminate();
void kill();

signals:
void started();
void finished(int exitCode);
void finished(int exitCode, QProcess::ExitStatus exitStatus);
void error(QProcess::ProcessError error);
void stateChanged(QProcess::ProcessState state);

void readyReadStandardOutput();
void readyReadStandardError();

protected:
void setProcessState(ProcessState state);

virtual void setupChildProcess();


qint64 readData(char *data, qint64 maxlen);
qint64 writeData(const char *data, qint64 len);

private:
inline QProcessPrivate* d_func() { return reinterpret_cast<QProcessPrivate *>(qGetPtrHelper(d_ptr)); } inline const QProcessPrivate* d_func() const { return reinterpret_cast<const QProcessPrivate *>(qGetPtrHelper(d_ptr)); } friend class QProcessPrivate;
QProcess(const QProcess &); QProcess &operator=(const QProcess &);







friend class QProcessManager;
};



# 232 "/usr/share/qt4/include/QtCore/qprocess.h"





# 14 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qresource.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qresource.h"

# 1 "/usr/share/qt4/include/QtCore/qlocale.h"




































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qresource.h"

# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"



































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qresource.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtCore/qresource.h"


# 50 "/usr/share/qt4/include/QtCore/qresource.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QResourcePrivate;

class  QResource
{
public:
QResource(const QString &file=QString(), const QLocale &locale=QLocale());
~QResource();

void setFileName(const QString &file);
QString fileName() const;
QString absoluteFilePath() const;

void setLocale(const QLocale &locale);
QLocale locale() const;

bool isValid() const;

bool isCompressed() const;
qint64 size() const;
const uchar *data() const;

static void addSearchPath(const QString &path);
static QStringList searchPaths();

static bool registerResource(const QString &rccFilename, const QString &resourceRoot=QString());
static bool unregisterResource(const QString &rccFilename, const QString &resourceRoot=QString());

static bool registerResource(const uchar *rccData, const QString &resourceRoot=QString());
static bool unregisterResource(const uchar *rccData, const QString &resourceRoot=QString());

protected:
friend class QResourceFileEngine;
friend class QResourceFileEngineIterator;
bool isDir() const;
inline bool isFile() const { return !isDir(); }
QStringList children() const;

protected:
QScopedPointer<QResourcePrivate> d_ptr;

private:
inline QResourcePrivate* d_func() { return reinterpret_cast<QResourcePrivate *>(qGetPtrHelper(d_ptr)); } inline const QResourcePrivate* d_func() const { return reinterpret_cast<const QResourcePrivate *>(qGetPtrHelper(d_ptr)); } friend class QResourcePrivate;
};






# 15 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qsettings.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qsettings.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"












































# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 45 "/usr/share/qt4/include/QtCore/qvariant.h"

# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qvariant.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qvariant.h"

# 1 "/usr/share/qt4/include/QtCore/qmetatype.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qmetatype.h"

# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 46 "/usr/share/qt4/include/QtCore/qmetatype.h"



# 1 "/usr/share/qt4/include/QtCore/qdatastream.h"


















































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtCore/qmetatype.h"







# 56 "/usr/share/qt4/include/QtCore/qmetatype.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class  QMetaType {
public:
enum Type {

Void = 0, Bool = 1, Int = 2, UInt = 3, LongLong = 4, ULongLong = 5,
Double = 6, QChar = 7, QVariantMap = 8, QVariantList = 9,
QString = 10, QStringList = 11, QByteArray = 12,
QBitArray = 13, QDate = 14, QTime = 15, QDateTime = 16, QUrl = 17,
QLocale = 18, QRect = 19, QRectF = 20, QSize = 21, QSizeF = 22,
QLine = 23, QLineF = 24, QPoint = 25, QPointF = 26, QRegExp = 27,
QVariantHash = 28, LastCoreType = 28 ,

FirstGuiType = 63 ,



# 78 "/usr/share/qt4/include/QtCore/qmetatype.h"
QFont = 64, QPixmap = 65, QBrush = 66, QColor = 67, QPalette = 68,
QIcon = 69, QImage = 70, QPolygon = 71, QRegion = 72, QBitmap = 73,
QCursor = 74, QSizePolicy = 75, QKeySequence = 76, QPen = 77,
QTextLength = 78, QTextFormat = 79, QMatrix = 80, QTransform = 81,
QMatrix4x4 = 82, QVector2D = 83, QVector3D = 84, QVector4D = 85,
QQuaternion = 86,
LastGuiType = 86 ,

FirstCoreExtType = 128 ,
VoidStar = 128, Long = 129, Short = 130, Char = 131, ULong = 132,
UShort = 133, UChar = 134, Float = 135, QObjectStar = 136, QWidgetStar = 137,
LastCoreExtType = 137 ,







# 97 "/usr/share/qt4/include/QtCore/qmetatype.h"
QReal = Double,


# 100 "/usr/share/qt4/include/QtCore/qmetatype.h"
User = 256
};

typedef void (*Destructor)(void *);
typedef void *(*Constructor)(const void *);


# 107 "/usr/share/qt4/include/QtCore/qmetatype.h"
typedef void (*SaveOperator)(QDataStream &, const void *);
typedef void (*LoadOperator)(QDataStream &, void *);
static void registerStreamOperators(const char *typeName, SaveOperator saveOp,
LoadOperator loadOp);

# 112 "/usr/share/qt4/include/QtCore/qmetatype.h"
static int registerType(const char *typeName, Destructor destructor,
Constructor constructor);
static int type(const char *typeName);
static const char *typeName(int type);
static bool isRegistered(int type);
static void *construct(int type, const void *copy = 0);
static void destroy(int type, void *data);
static void unregisterType(const char *typeName);


# 122 "/usr/share/qt4/include/QtCore/qmetatype.h"
static bool save(QDataStream &stream, int type, const void *data);
static bool load(QDataStream &stream, int type, void *data);

# 125 "/usr/share/qt4/include/QtCore/qmetatype.h"
};

template <typename T>
void qMetaTypeDeleteHelper(T *t)
{
delete t;
}

template <typename T>
void *qMetaTypeConstructHelper(const T *t)
{
if (!t)
return new T;
return new T(*static_cast<const T*>(t));
}


# 142 "/usr/share/qt4/include/QtCore/qmetatype.h"
template <typename T>
void qMetaTypeSaveHelper(QDataStream &stream, const T *t)
{
stream << *t;
}

template <typename T>
void qMetaTypeLoadHelper(QDataStream &stream, T *t)
{
stream >> *t;
}


# 155 "/usr/share/qt4/include/QtCore/qmetatype.h"
template <typename T>
int qRegisterMetaType(const char *typeName

# 158 "/usr/share/qt4/include/QtCore/qmetatype.h"
, T *  = 0

# 160 "/usr/share/qt4/include/QtCore/qmetatype.h"
)
{
typedef void*(*ConstructPtr)(const T*);
ConstructPtr cptr = qMetaTypeConstructHelper<T>;
typedef void(*DeletePtr)(T*);
DeletePtr dptr = qMetaTypeDeleteHelper<T>;

return QMetaType::registerType(typeName, reinterpret_cast<QMetaType::Destructor>(dptr),
reinterpret_cast<QMetaType::Constructor>(cptr));
}


# 172 "/usr/share/qt4/include/QtCore/qmetatype.h"
template <typename T>
void qRegisterMetaTypeStreamOperators(const char *typeName

# 175 "/usr/share/qt4/include/QtCore/qmetatype.h"
, T *  = 0

# 177 "/usr/share/qt4/include/QtCore/qmetatype.h"
)
{
typedef void(*SavePtr)(QDataStream &, const T *);
typedef void(*LoadPtr)(QDataStream &, T *);
SavePtr sptr = qMetaTypeSaveHelper<T>;
LoadPtr lptr = qMetaTypeLoadHelper<T>;

qRegisterMetaType<T>(typeName);
QMetaType::registerStreamOperators(typeName, reinterpret_cast<QMetaType::SaveOperator>(sptr),
reinterpret_cast<QMetaType::LoadOperator>(lptr));
}


# 190 "/usr/share/qt4/include/QtCore/qmetatype.h"
template <typename T>
struct QMetaTypeId
{
enum { Defined = 0 };
};

template <typename T>
struct QMetaTypeId2
{
enum { Defined = QMetaTypeId<T>::Defined };
static inline int qt_metatype_id() { return QMetaTypeId<T>::qt_metatype_id(); }
};

template <typename T>
inline int qMetaTypeId(

# 206 "/usr/share/qt4/include/QtCore/qmetatype.h"
T *  = 0

# 208 "/usr/share/qt4/include/QtCore/qmetatype.h"
)
{
return QMetaTypeId2<T>::qt_metatype_id();
}

template <typename T>
inline int qRegisterMetaType(

# 216 "/usr/share/qt4/include/QtCore/qmetatype.h"
T * dummy = 0

# 218 "/usr/share/qt4/include/QtCore/qmetatype.h"
)
{



# 223 "/usr/share/qt4/include/QtCore/qmetatype.h"
return qMetaTypeId(dummy);

# 225 "/usr/share/qt4/include/QtCore/qmetatype.h"
}





# 252 "/usr/share/qt4/include/QtCore/qmetatype.h"
class QString;
class QByteArray;
class QChar;
class QStringList;
class QBitArray;
class QDate;
class QTime;
class QDateTime;
class QUrl;
class QLocale;
class QRect;
class QRectF;
class QSize;
class QSizeF;
class QLine;
class QLineF;
class QPoint;
class QPointF;

# 271 "/usr/share/qt4/include/QtCore/qmetatype.h"
class QRegExp;

# 273 "/usr/share/qt4/include/QtCore/qmetatype.h"
class QWidget;
class QObject;




# 279 "/usr/share/qt4/include/QtCore/qmetatype.h"
class QFont;
class QPixmap;
class QBrush;
class QColor;
class QPalette;
class QIcon;
class QImage;
class QPolygon;
class QRegion;
class QBitmap;
class QCursor;
class QSizePolicy;
class QKeySequence;
class QPen;
class QTextLength;
class QTextFormat;
class QMatrix;
class QTransform;
class QMatrix4x4;
class QVector2D;
class QVector3D;
class QVector4D;
class QQuaternion;



 template<> struct QMetaTypeId2<QString> { enum { Defined = 1, MetaType = QMetaType::QString }; static inline int qt_metatype_id() { return QMetaType::QString; } }; 
 template<> struct QMetaTypeId2<int> { enum { Defined = 1, MetaType = QMetaType::Int }; static inline int qt_metatype_id() { return QMetaType::Int; } }; 
 template<> struct QMetaTypeId2<uint> { enum { Defined = 1, MetaType = QMetaType::UInt }; static inline int qt_metatype_id() { return QMetaType::UInt; } }; 
 template<> struct QMetaTypeId2<bool> { enum { Defined = 1, MetaType = QMetaType::Bool }; static inline int qt_metatype_id() { return QMetaType::Bool; } }; 
 template<> struct QMetaTypeId2<double> { enum { Defined = 1, MetaType = QMetaType::Double }; static inline int qt_metatype_id() { return QMetaType::Double; } }; 
 template<> struct QMetaTypeId2<QByteArray> { enum { Defined = 1, MetaType = QMetaType::QByteArray }; static inline int qt_metatype_id() { return QMetaType::QByteArray; } }; 
 template<> struct QMetaTypeId2<QChar> { enum { Defined = 1, MetaType = QMetaType::QChar }; static inline int qt_metatype_id() { return QMetaType::QChar; } }; 
 template<> struct QMetaTypeId2<long> { enum { Defined = 1, MetaType = QMetaType::Long }; static inline int qt_metatype_id() { return QMetaType::Long; } }; 
 template<> struct QMetaTypeId2<short> { enum { Defined = 1, MetaType = QMetaType::Short }; static inline int qt_metatype_id() { return QMetaType::Short; } }; 
 template<> struct QMetaTypeId2<char> { enum { Defined = 1, MetaType = QMetaType::Char }; static inline int qt_metatype_id() { return QMetaType::Char; } }; 
 template<> struct QMetaTypeId2<ulong> { enum { Defined = 1, MetaType = QMetaType::ULong }; static inline int qt_metatype_id() { return QMetaType::ULong; } }; 
 template<> struct QMetaTypeId2<ushort> { enum { Defined = 1, MetaType = QMetaType::UShort }; static inline int qt_metatype_id() { return QMetaType::UShort; } }; 
 template<> struct QMetaTypeId2<uchar> { enum { Defined = 1, MetaType = QMetaType::UChar }; static inline int qt_metatype_id() { return QMetaType::UChar; } }; 
 template<> struct QMetaTypeId2<float> { enum { Defined = 1, MetaType = QMetaType::Float }; static inline int qt_metatype_id() { return QMetaType::Float; } }; 
 template<> struct QMetaTypeId2<QObject *> { enum { Defined = 1, MetaType = QMetaType::QObjectStar }; static inline int qt_metatype_id() { return QMetaType::QObjectStar; } }; 
 template<> struct QMetaTypeId2<QWidget *> { enum { Defined = 1, MetaType = QMetaType::QWidgetStar }; static inline int qt_metatype_id() { return QMetaType::QWidgetStar; } }; 
 template<> struct QMetaTypeId2<void *> { enum { Defined = 1, MetaType = QMetaType::VoidStar }; static inline int qt_metatype_id() { return QMetaType::VoidStar; } }; 
 template<> struct QMetaTypeId2<qlonglong> { enum { Defined = 1, MetaType = QMetaType::LongLong }; static inline int qt_metatype_id() { return QMetaType::LongLong; } }; 
 template<> struct QMetaTypeId2<qulonglong> { enum { Defined = 1, MetaType = QMetaType::ULongLong }; static inline int qt_metatype_id() { return QMetaType::ULongLong; } }; 
 template<> struct QMetaTypeId2<QStringList> { enum { Defined = 1, MetaType = QMetaType::QStringList }; static inline int qt_metatype_id() { return QMetaType::QStringList; } }; 
 template<> struct QMetaTypeId2<QBitArray> { enum { Defined = 1, MetaType = QMetaType::QBitArray }; static inline int qt_metatype_id() { return QMetaType::QBitArray; } }; 
 template<> struct QMetaTypeId2<QDate> { enum { Defined = 1, MetaType = QMetaType::QDate }; static inline int qt_metatype_id() { return QMetaType::QDate; } }; 
 template<> struct QMetaTypeId2<QTime> { enum { Defined = 1, MetaType = QMetaType::QTime }; static inline int qt_metatype_id() { return QMetaType::QTime; } }; 
 template<> struct QMetaTypeId2<QDateTime> { enum { Defined = 1, MetaType = QMetaType::QDateTime }; static inline int qt_metatype_id() { return QMetaType::QDateTime; } }; 
 template<> struct QMetaTypeId2<QUrl> { enum { Defined = 1, MetaType = QMetaType::QUrl }; static inline int qt_metatype_id() { return QMetaType::QUrl; } }; 
 template<> struct QMetaTypeId2<QLocale> { enum { Defined = 1, MetaType = QMetaType::QLocale }; static inline int qt_metatype_id() { return QMetaType::QLocale; } }; 
 template<> struct QMetaTypeId2<QRect> { enum { Defined = 1, MetaType = QMetaType::QRect }; static inline int qt_metatype_id() { return QMetaType::QRect; } }; 
 template<> struct QMetaTypeId2<QRectF> { enum { Defined = 1, MetaType = QMetaType::QRectF }; static inline int qt_metatype_id() { return QMetaType::QRectF; } }; 
 template<> struct QMetaTypeId2<QSize> { enum { Defined = 1, MetaType = QMetaType::QSize }; static inline int qt_metatype_id() { return QMetaType::QSize; } }; 
 template<> struct QMetaTypeId2<QSizeF> { enum { Defined = 1, MetaType = QMetaType::QSizeF }; static inline int qt_metatype_id() { return QMetaType::QSizeF; } }; 
 template<> struct QMetaTypeId2<QLine> { enum { Defined = 1, MetaType = QMetaType::QLine }; static inline int qt_metatype_id() { return QMetaType::QLine; } }; 
 template<> struct QMetaTypeId2<QLineF> { enum { Defined = 1, MetaType = QMetaType::QLineF }; static inline int qt_metatype_id() { return QMetaType::QLineF; } }; 
 template<> struct QMetaTypeId2<QPoint> { enum { Defined = 1, MetaType = QMetaType::QPoint }; static inline int qt_metatype_id() { return QMetaType::QPoint; } }; 
 template<> struct QMetaTypeId2<QPointF> { enum { Defined = 1, MetaType = QMetaType::QPointF }; static inline int qt_metatype_id() { return QMetaType::QPointF; } }; 

# 340 "/usr/share/qt4/include/QtCore/qmetatype.h"
 template<> struct QMetaTypeId2<QRegExp> { enum { Defined = 1, MetaType = QMetaType::QRegExp }; static inline int qt_metatype_id() { return QMetaType::QRegExp; } }; 





# 346 "/usr/share/qt4/include/QtCore/qmetatype.h"
 template<> struct QMetaTypeId2<QFont> { enum { Defined = 1, MetaType = QMetaType::QFont }; static inline int qt_metatype_id() { return QMetaType::QFont; } }; 
 template<> struct QMetaTypeId2<QPixmap> { enum { Defined = 1, MetaType = QMetaType::QPixmap }; static inline int qt_metatype_id() { return QMetaType::QPixmap; } }; 
 template<> struct QMetaTypeId2<QBrush> { enum { Defined = 1, MetaType = QMetaType::QBrush }; static inline int qt_metatype_id() { return QMetaType::QBrush; } }; 
 template<> struct QMetaTypeId2<QColor> { enum { Defined = 1, MetaType = QMetaType::QColor }; static inline int qt_metatype_id() { return QMetaType::QColor; } }; 
 template<> struct QMetaTypeId2<QPalette> { enum { Defined = 1, MetaType = QMetaType::QPalette }; static inline int qt_metatype_id() { return QMetaType::QPalette; } }; 
 template<> struct QMetaTypeId2<QIcon> { enum { Defined = 1, MetaType = QMetaType::QIcon }; static inline int qt_metatype_id() { return QMetaType::QIcon; } }; 
 template<> struct QMetaTypeId2<QImage> { enum { Defined = 1, MetaType = QMetaType::QImage }; static inline int qt_metatype_id() { return QMetaType::QImage; } }; 
 template<> struct QMetaTypeId2<QPolygon> { enum { Defined = 1, MetaType = QMetaType::QPolygon }; static inline int qt_metatype_id() { return QMetaType::QPolygon; } }; 
 template<> struct QMetaTypeId2<QRegion> { enum { Defined = 1, MetaType = QMetaType::QRegion }; static inline int qt_metatype_id() { return QMetaType::QRegion; } }; 
 template<> struct QMetaTypeId2<QBitmap> { enum { Defined = 1, MetaType = QMetaType::QBitmap }; static inline int qt_metatype_id() { return QMetaType::QBitmap; } }; 
 template<> struct QMetaTypeId2<QCursor> { enum { Defined = 1, MetaType = QMetaType::QCursor }; static inline int qt_metatype_id() { return QMetaType::QCursor; } }; 
 template<> struct QMetaTypeId2<QSizePolicy> { enum { Defined = 1, MetaType = QMetaType::QSizePolicy }; static inline int qt_metatype_id() { return QMetaType::QSizePolicy; } }; 
 template<> struct QMetaTypeId2<QKeySequence> { enum { Defined = 1, MetaType = QMetaType::QKeySequence }; static inline int qt_metatype_id() { return QMetaType::QKeySequence; } }; 
 template<> struct QMetaTypeId2<QPen> { enum { Defined = 1, MetaType = QMetaType::QPen }; static inline int qt_metatype_id() { return QMetaType::QPen; } }; 
 template<> struct QMetaTypeId2<QTextLength> { enum { Defined = 1, MetaType = QMetaType::QTextLength }; static inline int qt_metatype_id() { return QMetaType::QTextLength; } }; 
 template<> struct QMetaTypeId2<QTextFormat> { enum { Defined = 1, MetaType = QMetaType::QTextFormat }; static inline int qt_metatype_id() { return QMetaType::QTextFormat; } }; 
 template<> struct QMetaTypeId2<QMatrix> { enum { Defined = 1, MetaType = QMetaType::QMatrix }; static inline int qt_metatype_id() { return QMetaType::QMatrix; } }; 
 template<> struct QMetaTypeId2<QTransform> { enum { Defined = 1, MetaType = QMetaType::QTransform }; static inline int qt_metatype_id() { return QMetaType::QTransform; } }; 
 template<> struct QMetaTypeId2<QMatrix4x4> { enum { Defined = 1, MetaType = QMetaType::QMatrix4x4 }; static inline int qt_metatype_id() { return QMetaType::QMatrix4x4; } }; 
 template<> struct QMetaTypeId2<QVector2D> { enum { Defined = 1, MetaType = QMetaType::QVector2D }; static inline int qt_metatype_id() { return QMetaType::QVector2D; } }; 
 template<> struct QMetaTypeId2<QVector3D> { enum { Defined = 1, MetaType = QMetaType::QVector3D }; static inline int qt_metatype_id() { return QMetaType::QVector3D; } }; 
 template<> struct QMetaTypeId2<QVector4D> { enum { Defined = 1, MetaType = QMetaType::QVector4D }; static inline int qt_metatype_id() { return QMetaType::QVector4D; } }; 
 template<> struct QMetaTypeId2<QQuaternion> { enum { Defined = 1, MetaType = QMetaType::QQuaternion }; static inline int qt_metatype_id() { return QMetaType::QQuaternion; } }; 




# 48 "/usr/share/qt4/include/QtCore/qvariant.h"

# 1 "/usr/share/qt4/include/QtCore/qmap.h"




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtCore/qvariant.h"

# 1 "/usr/share/qt4/include/QtCore/qhash.h"






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtCore/qvariant.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 51 "/usr/share/qt4/include/QtCore/qvariant.h"


# 53 "/usr/share/qt4/include/QtCore/qvariant.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QBitArray;
class QDataStream;
class QDate;
class QDateTime;
class QLine;
class QLineF;
class QLocale;
class QMatrix;
class QTransform;
class QStringList;
class QTime;
class QPoint;
class QPointF;
class QSize;
class QSizeF;
class QRect;
class QRectF;

# 77 "/usr/share/qt4/include/QtCore/qvariant.h"
class QRegExp;

# 79 "/usr/share/qt4/include/QtCore/qvariant.h"
class QTextFormat;
class QTextLength;
class QUrl;
class QVariant;
class QVariantComparisonHelper;


# 86 "/usr/share/qt4/include/QtCore/qvariant.h"
template <typename T>
inline QVariant qVariantFromValue(const T &);

template <typename T>
inline void qVariantSetValue(QVariant &, const T &);

template<typename T>
inline T qVariantValue(const QVariant &);

template<typename T>
inline bool qVariantCanConvert(const QVariant &);


# 99 "/usr/share/qt4/include/QtCore/qvariant.h"
class  QVariant
{
public:
enum Type {
Invalid = 0,

Bool = 1,
Int = 2,
UInt = 3,
LongLong = 4,
ULongLong = 5,
Double = 6,
Char = 7,
Map = 8,
List = 9,
String = 10,
StringList = 11,
ByteArray = 12,
BitArray = 13,
Date = 14,
Time = 15,
DateTime = 16,
Url = 17,
Locale = 18,
Rect = 19,
RectF = 20,
Size = 21,
SizeF = 22,
Line = 23,
LineF = 24,
Point = 25,
PointF = 26,
RegExp = 27,
Hash = 28,
LastCoreType = Hash,





# 139 "/usr/share/qt4/include/QtCore/qvariant.h"
Font = 64,
Pixmap = 65,
Brush = 66,
Color = 67,
Palette = 68,
Icon = 69,
Image = 70,
Polygon = 71,
Region = 72,
Bitmap = 73,
Cursor = 74,
SizePolicy = 75,
KeySequence = 76,
Pen = 77,
TextLength = 78,
TextFormat = 79,
Matrix = 80,
Transform = 81,
Matrix4x4 = 82,
Vector2D = 83,
Vector3D = 84,
Vector4D = 85,
Quaternion = 86,
LastGuiType = Quaternion,

UserType = 127,





# 170 "/usr/share/qt4/include/QtCore/qvariant.h"
LastType = 0xffffffff 
};

inline QVariant();
~QVariant();
QVariant(Type type);
QVariant(int typeOrUserType, const void *copy);
QVariant(int typeOrUserType, const void *copy, uint flags);
QVariant(const QVariant &other);


# 181 "/usr/share/qt4/include/QtCore/qvariant.h"
QVariant(QDataStream &s);


# 184 "/usr/share/qt4/include/QtCore/qvariant.h"
QVariant(int i);
QVariant(uint ui);
QVariant(qlonglong ll);
QVariant(qulonglong ull);
QVariant(bool b);
QVariant(double d);
QVariant(float f) { d.is_null = false; d.type = QMetaType::Float; d.data.f = f; }

# 192 "/usr/share/qt4/include/QtCore/qvariant.h"
 QVariant(const char *str);


# 195 "/usr/share/qt4/include/QtCore/qvariant.h"
QVariant(const QByteArray &bytearray);
QVariant(const QBitArray &bitarray);
QVariant(const QString &string);
QVariant(const QLatin1String &string);
QVariant(const QStringList &stringlist);
QVariant(const QChar &qchar);
QVariant(const QDate &date);
QVariant(const QTime &time);
QVariant(const QDateTime &datetime);
QVariant(const QList<QVariant> &list);
QVariant(const QMap<QString,QVariant> &map);
QVariant(const QHash<QString,QVariant> &hash);

# 208 "/usr/share/qt4/include/QtCore/qvariant.h"
QVariant(const QSize &size);
QVariant(const QSizeF &size);
QVariant(const QPoint &pt);
QVariant(const QPointF &pt);
QVariant(const QLine &line);
QVariant(const QLineF &line);
QVariant(const QRect &rect);
QVariant(const QRectF &rect);

# 217 "/usr/share/qt4/include/QtCore/qvariant.h"
QVariant(const QUrl &url);
QVariant(const QLocale &locale);

# 220 "/usr/share/qt4/include/QtCore/qvariant.h"
QVariant(const QRegExp &regExp);

# 222 "/usr/share/qt4/include/QtCore/qvariant.h"
QVariant(Qt::GlobalColor color);

QVariant& operator=(const QVariant &other);

Type type() const;
int userType() const;
const char *typeName() const;

bool canConvert(Type t) const;
bool convert(Type t);








# 240 "/usr/share/qt4/include/QtCore/qvariant.h"
inline bool isValid() const;
bool isNull() const;

void clear();

void detach();
inline bool isDetached() const;

int toInt(bool *ok = 0) const;
uint toUInt(bool *ok = 0) const;
qlonglong toLongLong(bool *ok = 0) const;
qulonglong toULongLong(bool *ok = 0) const;
bool toBool() const;
double toDouble(bool *ok = 0) const;
float toFloat(bool *ok = 0) const;
qreal toReal(bool *ok = 0) const;
QByteArray toByteArray() const;
QBitArray toBitArray() const;
QString toString() const;
QStringList toStringList() const;
QChar toChar() const;
QDate toDate() const;
QTime toTime() const;
QDateTime toDateTime() const;
QList<QVariant> toList() const;
QMap<QString, QVariant> toMap() const;
QHash<QString, QVariant> toHash() const;


# 269 "/usr/share/qt4/include/QtCore/qvariant.h"
QPoint toPoint() const;
QPointF toPointF() const;
QRect toRect() const;
QSize toSize() const;
QSizeF toSizeF() const;
QLine toLine() const;
QLineF toLineF() const;
QRectF toRectF() const;

# 278 "/usr/share/qt4/include/QtCore/qvariant.h"
QUrl toUrl() const;
QLocale toLocale() const;

# 281 "/usr/share/qt4/include/QtCore/qvariant.h"
QRegExp toRegExp() const;
























# 306 "/usr/share/qt4/include/QtCore/qvariant.h"
void load(QDataStream &ds);
void save(QDataStream &ds) const;

# 309 "/usr/share/qt4/include/QtCore/qvariant.h"
static const char *typeToName(Type type);
static Type nameToType(const char *name);







# 318 "/usr/share/qt4/include/QtCore/qvariant.h"
void *data();
const void *constData() const;
inline const void *data() const { return constData(); }


# 323 "/usr/share/qt4/include/QtCore/qvariant.h"
template<typename T>
inline void setValue(const T &value);

template<typename T>
inline T value() const
{ return qVariantValue<T>(*this); }

template<typename T>
static inline QVariant fromValue(const T &value)
{ return qVariantFromValue(value); }

template<typename T>
bool canConvert() const
{ return qVariantCanConvert<T>(*this); }


# 339 "/usr/share/qt4/include/QtCore/qvariant.h"
public:

# 341 "/usr/share/qt4/include/QtCore/qvariant.h"
struct PrivateShared
{
inline PrivateShared(void *v) : ptr(v), ref(1) { }
void *ptr;
QAtomicInt ref;
};
struct Private
{
inline Private(): type(Invalid), is_shared(false), is_null(true) { data.ptr = 0; }
inline Private(const Private &other)
: data(other.data), type(other.type),
is_shared(other.is_shared), is_null(other.is_null)
{}
union Data
{
char c;
int i;
uint u;
bool b;
double d;
float f;
qreal real;
qlonglong ll;
qulonglong ull;
QObject *o;
void *ptr;
PrivateShared *shared;
} data;
uint type : 30;
uint is_shared : 1;
uint is_null : 1;
};
public:
typedef void (*f_construct)(Private *, const void *);
typedef void (*f_clear)(Private *);
typedef bool (*f_null)(const Private *);

# 378 "/usr/share/qt4/include/QtCore/qvariant.h"
typedef void (*f_load)(Private *, QDataStream &);
typedef void (*f_save)(const Private *, QDataStream &);

# 381 "/usr/share/qt4/include/QtCore/qvariant.h"
typedef bool (*f_compare)(const Private *, const Private *);
typedef bool (*f_convert)(const QVariant::Private *d, Type t, void *, bool *);
typedef bool (*f_canConvert)(const QVariant::Private *d, Type t);
typedef void (*f_debugStream)(QDebug, const QVariant &);
struct Handler {
f_construct construct;
f_clear clear;
f_null isNull;

# 390 "/usr/share/qt4/include/QtCore/qvariant.h"
f_load load;
f_save save;

# 393 "/usr/share/qt4/include/QtCore/qvariant.h"
f_compare compare;
f_convert convert;
f_canConvert canConvert;
f_debugStream debugStream;
};


# 400 "/usr/share/qt4/include/QtCore/qvariant.h"
inline bool operator==(const QVariant &v) const
{ return cmp(v); }
inline bool operator!=(const QVariant &v) const
{ return !cmp(v); }

protected:
friend inline bool qvariant_cast_helper(const QVariant &, QVariant::Type, void *);
friend int qRegisterGuiVariant();
friend int qUnregisterGuiVariant();
friend inline bool operator==(const QVariant &, const QVariantComparisonHelper &);

# 411 "/usr/share/qt4/include/QtCore/qvariant.h"
friend  QDebug operator<<(QDebug, const QVariant &);

# 413 "/usr/share/qt4/include/QtCore/qvariant.h"
Private d;

static const Handler *handler;

void create(int type, const void *copy);



# 421 "/usr/share/qt4/include/QtCore/qvariant.h"
bool cmp(const QVariant &other) const;

private:

inline QVariant(void *) { qt_noop(); }





# 431 "/usr/share/qt4/include/QtCore/qvariant.h"

inline QVariant(bool, int) { qt_noop(); }

# 434 "/usr/share/qt4/include/QtCore/qvariant.h"
public:
typedef Private DataPtr;
inline DataPtr &data_ptr() { return d; }
};

typedef QList<QVariant> QVariantList;
typedef QMap<QString, QVariant> QVariantMap;
typedef QHash<QString, QVariant> QVariantHash;

inline bool qvariant_cast_helper(const QVariant &v, QVariant::Type tp, void *ptr)
{ return QVariant::handler->convert(&v.d, tp, ptr, 0); }

template <typename T>
inline QVariant qVariantFromValue(const T &t)
{
return QVariant(qMetaTypeId<T>(reinterpret_cast<T *>(0)), &t, QTypeInfo<T>::isPointer);
}

template <>
inline QVariant qVariantFromValue(const QVariant &t) { return t; }

template <typename T>
inline void qVariantSetValue(QVariant &v, const T &t)
{

const uint type = qMetaTypeId<T>(reinterpret_cast<T *>(0));
QVariant::Private &d = v.data_ptr();
if (v.isDetached() && (type == d.type || (type <= uint(QVariant::Char) && d.type <= uint(QVariant::Char)))) {
d.type = type;
d.is_null = false;
T *old = reinterpret_cast<T*>(d.is_shared ? d.data.shared->ptr : &d.data.ptr);
if (QTypeInfo<T>::isComplex)
old->~T();
new (old) T(t); 
} else {
v = QVariant(type, &t, QTypeInfo<T>::isPointer);
}
}

template <>
inline void qVariantSetValue<QVariant>(QVariant &v, const QVariant &t)
{
v = t;
}


inline QVariant::QVariant() {}
inline bool QVariant::isValid() const { return d.type != Invalid; }









































# 523 "/usr/share/qt4/include/QtCore/qvariant.h"
template<typename T>
inline void QVariant::setValue(const T &avalue)
{ qVariantSetValue(*this, avalue); }



# 529 "/usr/share/qt4/include/QtCore/qvariant.h"
 QDataStream& operator>> (QDataStream& s, QVariant& p);
 QDataStream& operator<< (QDataStream& s, const QVariant& p);
 QDataStream& operator>> (QDataStream& s, QVariant::Type& p);
 QDataStream& operator<< (QDataStream& s, const QVariant::Type p);


# 535 "/usr/share/qt4/include/QtCore/qvariant.h"
inline bool QVariant::isDetached() const
{ return !d.is_shared || d.data.shared->ref == 1; }







# 544 "/usr/share/qt4/include/QtCore/qvariant.h"



class QVariantComparisonHelper
{
public:
inline QVariantComparisonHelper(const QVariant &var)
: v(&var) {}
private:
friend inline bool operator==(const QVariant &, const QVariantComparisonHelper &);
const QVariant *v;
};

inline bool operator==(const QVariant &v1, const QVariantComparisonHelper &v2)
{
return v1.cmp(*v2.v);
}

inline bool operator!=(const QVariant &v1, const QVariantComparisonHelper &v2)
{
return !operator==(v1, v2);
}



# 569 "/usr/share/qt4/include/QtCore/qvariant.h"
template<typename T> inline T qvariant_cast(const QVariant &v)
{
const int vid = qMetaTypeId<T>(static_cast<T *>(0));
if (vid == v.userType())
return *reinterpret_cast<const T *>(v.constData());
if (vid < int(QMetaType::User)) {
T t;
if (qvariant_cast_helper(v, QVariant::Type(vid), &t))
return t;
}
return T();
}

template<> inline QVariant qvariant_cast<QVariant>(const QVariant &v)
{
static const int vid = qRegisterMetaType<QVariant>("QVariant");
if (vid == v.userType())
return *reinterpret_cast<const QVariant *>(v.constData());
return v;
}

template<typename T>
inline T qVariantValue(const QVariant &variant)
{ return qvariant_cast<T>(variant); }

template<typename T>
inline bool qVariantCanConvert(const QVariant &variant)
{
return variant.canConvert(static_cast<QVariant::Type>(
qMetaTypeId<T>(static_cast<T *>(0))));
}

# 601 "/usr/share/qt4/include/QtCore/qvariant.h"
template <> inline bool qIsDetached<QVariant>(QVariant &t) { return t.isDetached(); } template <> inline void qSwap<QVariant>(QVariant &value1, QVariant &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }
template <> class QTypeInfo<QVariant > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QVariant)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QVariant"; } };


# 605 "/usr/share/qt4/include/QtCore/qvariant.h"
 QDebug operator<<(QDebug, const QVariant &);
 QDebug operator<<(QDebug, const QVariant::Type);


# 609 "/usr/share/qt4/include/QtCore/qvariant.h"


 template<> struct QMetaTypeId2<QVariantList> { enum { Defined = 1, MetaType = QMetaType::QVariantList }; static inline int qt_metatype_id() { return QMetaType::QVariantList; } }; 
 template<> struct QMetaTypeId2<QVariantMap> { enum { Defined = 1, MetaType = QMetaType::QVariantMap }; static inline int qt_metatype_id() { return QMetaType::QVariantMap; } }; 
 template<> struct QMetaTypeId2<QVariantHash> { enum { Defined = 1, MetaType = QMetaType::QVariantHash }; static inline int qt_metatype_id() { return QMetaType::QVariantHash; } }; 




# 46 "/usr/share/qt4/include/QtCore/qsettings.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qsettings.h"


# 49 "/usr/share/qt4/include/QtCore/qsettings.h"



typedef QtValidLicenseForCoreModule QtCoreModule;










# 63 "/usr/share/qt4/include/QtCore/qsettings.h"






# 69 "/usr/share/qt4/include/QtCore/qsettings.h"
class QIODevice;
class QSettingsPrivate;


# 73 "/usr/share/qt4/include/QtCore/qsettings.h"
class  QSettings : public QObject



# 77 "/usr/share/qt4/include/QtCore/qsettings.h"
{

# 79 "/usr/share/qt4/include/QtCore/qsettings.h"
Q_OBJECT



# 83 "/usr/share/qt4/include/QtCore/qsettings.h"
inline QSettingsPrivate* d_func() { return reinterpret_cast<QSettingsPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSettingsPrivate* d_func() const { return reinterpret_cast<const QSettingsPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSettingsPrivate;

public:
enum Status {
NoError = 0,
AccessError,
FormatError
};

enum Format {
NativeFormat,
IniFormat,

InvalidFormat = 16,
CustomFormat1,
CustomFormat2,
CustomFormat3,
CustomFormat4,
CustomFormat5,
CustomFormat6,
CustomFormat7,
CustomFormat8,
CustomFormat9,
CustomFormat10,
CustomFormat11,
CustomFormat12,
CustomFormat13,
CustomFormat14,
CustomFormat15,
CustomFormat16
};

enum Scope {
UserScope,
SystemScope





# 123 "/usr/share/qt4/include/QtCore/qsettings.h"
};


# 126 "/usr/share/qt4/include/QtCore/qsettings.h"
explicit QSettings(const QString &organization,
const QString &application = QString(), QObject *parent = 0);
QSettings(Scope scope, const QString &organization,
const QString &application = QString(), QObject *parent = 0);
QSettings(Format format, Scope scope, const QString &organization,
const QString &application = QString(), QObject *parent = 0);
QSettings(const QString &fileName, Format format, QObject *parent = 0);
explicit QSettings(QObject *parent = 0);









# 143 "/usr/share/qt4/include/QtCore/qsettings.h"
~QSettings();

void clear();
void sync();
Status status() const;

void beginGroup(const QString &prefix);
void endGroup();
QString group() const;

int beginReadArray(const QString &prefix);
void beginWriteArray(const QString &prefix, int size = -1);
void endArray();
void setArrayIndex(int i);

QStringList allKeys() const;
QStringList childKeys() const;
QStringList childGroups() const;
bool isWritable() const;

void setValue(const QString &key, const QVariant &value);
QVariant value(const QString &key, const QVariant &defaultValue = QVariant()) const;

void remove(const QString &key);
bool contains(const QString &key) const;

void setFallbacksEnabled(bool b);
bool fallbacksEnabled() const;

QString fileName() const;
Format format() const;
Scope scope() const;
QString organizationName() const;
QString applicationName() const;


# 179 "/usr/share/qt4/include/QtCore/qsettings.h"
void setIniCodec(QTextCodec *codec);
void setIniCodec(const char *codecName);
QTextCodec *iniCodec() const;


# 184 "/usr/share/qt4/include/QtCore/qsettings.h"
static void setDefaultFormat(Format format);
static Format defaultFormat();
static void setSystemIniPath(const QString &dir); 
static void setUserIniPath(const QString &dir); 
static void setPath(Format format, Scope scope, const QString &path);

typedef QMap<QString, QVariant> SettingsMap;
typedef bool (*ReadFunc)(QIODevice &device, SettingsMap &map);
typedef bool (*WriteFunc)(QIODevice &device, const SettingsMap &map);

static Format registerFormat(const QString &extension, ReadFunc readFunc, WriteFunc writeFunc,
Qt::CaseSensitivity caseSensitivity = Qt::CaseSensitive);


































































































# 294 "/usr/share/qt4/include/QtCore/qsettings.h"
protected:

# 296 "/usr/share/qt4/include/QtCore/qsettings.h"
bool event(QEvent *event);


# 299 "/usr/share/qt4/include/QtCore/qsettings.h"
private:




# 304 "/usr/share/qt4/include/QtCore/qsettings.h"
QSettings(const QSettings &); QSettings &operator=(const QSettings &);
};





# 311 "/usr/share/qt4/include/QtCore/qsettings.h"



# 16 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtemporaryfile.h"












































# 1 "/usr/share/qt4/include/QtCore/qiodevice.h"






























































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtemporaryfile.h"

# 1 "/usr/share/qt4/include/QtCore/qfile.h"












































































































































































































# 46 "/usr/share/qt4/include/QtCore/qtemporaryfile.h"






# 52 "/usr/share/qt4/include/QtCore/qtemporaryfile.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 60 "/usr/share/qt4/include/QtCore/qtemporaryfile.h"
class QTemporaryFilePrivate;

class  QTemporaryFile : public QFile
{

# 65 "/usr/share/qt4/include/QtCore/qtemporaryfile.h"
Q_OBJECT

# 67 "/usr/share/qt4/include/QtCore/qtemporaryfile.h"
inline QTemporaryFilePrivate* d_func() { return reinterpret_cast<QTemporaryFilePrivate *>(qGetPtrHelper(d_ptr)); } inline const QTemporaryFilePrivate* d_func() const { return reinterpret_cast<const QTemporaryFilePrivate *>(qGetPtrHelper(d_ptr)); } friend class QTemporaryFilePrivate;

public:
QTemporaryFile();
explicit QTemporaryFile(const QString &templateName);

# 73 "/usr/share/qt4/include/QtCore/qtemporaryfile.h"
explicit QTemporaryFile(QObject *parent);
QTemporaryFile(const QString &templateName, QObject *parent);

# 76 "/usr/share/qt4/include/QtCore/qtemporaryfile.h"
~QTemporaryFile();

bool autoRemove() const;
void setAutoRemove(bool b);


bool open() { return open(QIODevice::ReadWrite); }

QString fileName() const;
QString fileTemplate() const;
void setFileTemplate(const QString &name);

inline static QTemporaryFile *createLocalFile(const QString &fileName)
{ QFile file(fileName); return createLocalFile(file); }
static QTemporaryFile *createLocalFile(QFile &file);

virtual QAbstractFileEngine *fileEngine() const;

protected:
bool open(OpenMode flags);

private:
friend class QFile;
QTemporaryFile(const QTemporaryFile &); QTemporaryFile &operator=(const QTemporaryFile &);
};



# 104 "/usr/share/qt4/include/QtCore/qtemporaryfile.h"





# 17 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtextstream.h"






















































































































































































































































































































































































# 18 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qurl.h"












































# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qurl.h"

# 1 "/usr/share/qt4/include/QtCore/qobjectdefs.h"































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qurl.h"

# 1 "/usr/share/qt4/include/QtCore/qpair.h"































































































































# 47 "/usr/share/qt4/include/QtCore/qurl.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtCore/qurl.h"


# 50 "/usr/share/qt4/include/QtCore/qurl.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QUrlPrivate;
class QDataStream;

class  QUrl
{
public:
enum ParsingMode {
TolerantMode,
StrictMode
};


enum FormattingOption {
None = 0x0,
RemoveScheme = 0x1,
RemovePassword = 0x2,
RemoveUserInfo = RemovePassword | 0x4,
RemovePort = 0x8,
RemoveAuthority = RemoveUserInfo | RemovePort | 0x10,
RemovePath = 0x20,
RemoveQuery = 0x40,
RemoveFragment = 0x80,

StripTrailingSlash = 0x10000
};
typedef QFlags<FormattingOption> FormattingOptions;

QUrl();



# 87 "/usr/share/qt4/include/QtCore/qurl.h"
QUrl(const QString &url);
QUrl(const QString &url, ParsingMode mode);

QUrl(const QUrl &copy);
QUrl &operator =(const QUrl &copy);

# 93 "/usr/share/qt4/include/QtCore/qurl.h"
QUrl &operator =(const QString &url);

# 95 "/usr/share/qt4/include/QtCore/qurl.h"
~QUrl();

void setUrl(const QString &url);
void setUrl(const QString &url, ParsingMode mode);

void setEncodedUrl(const QByteArray &url);
void setEncodedUrl(const QByteArray &url, ParsingMode mode);


bool isValid() const;

bool isEmpty() const;

void clear();

void setScheme(const QString &scheme);
QString scheme() const;

void setAuthority(const QString &authority);
QString authority() const;

void setUserInfo(const QString &userInfo);
QString userInfo() const;

void setUserName(const QString &userName);
QString userName() const;
void setEncodedUserName(const QByteArray &userName);
QByteArray encodedUserName() const;

void setPassword(const QString &password);
QString password() const;
void setEncodedPassword(const QByteArray &password);
QByteArray encodedPassword() const;

void setHost(const QString &host);
QString host() const;
void setEncodedHost(const QByteArray &host);
QByteArray encodedHost() const;

void setPort(int port);
int port() const;
int port(int defaultPort) const;


void setPath(const QString &path);
QString path() const;
void setEncodedPath(const QByteArray &path);
QByteArray encodedPath() const;

bool hasQuery() const;

void setEncodedQuery(const QByteArray &query);
QByteArray encodedQuery() const;

void setQueryDelimiters(char valueDelimiter, char pairDelimiter);
char queryValueDelimiter() const;
char queryPairDelimiter() const;

void setQueryItems(const QList<QPair<QString, QString> > &query);
void addQueryItem(const QString &key, const QString &value);
QList<QPair<QString, QString> > queryItems() const;
bool hasQueryItem(const QString &key) const;
QString queryItemValue(const QString &key) const;
QStringList allQueryItemValues(const QString &key) const;
void removeQueryItem(const QString &key);
void removeAllQueryItems(const QString &key);

void setEncodedQueryItems(const QList<QPair<QByteArray, QByteArray> > &query);
void addEncodedQueryItem(const QByteArray &key, const QByteArray &value);
QList<QPair<QByteArray, QByteArray> > encodedQueryItems() const;
bool hasEncodedQueryItem(const QByteArray &key) const;
QByteArray encodedQueryItemValue(const QByteArray &key) const;
QList<QByteArray> allEncodedQueryItemValues(const QByteArray &key) const;
void removeEncodedQueryItem(const QByteArray &key);
void removeAllEncodedQueryItems(const QByteArray &key);

void setFragment(const QString &fragment);
QString fragment() const;
void setEncodedFragment(const QByteArray &fragment);
QByteArray encodedFragment() const;
bool hasFragment() const;

QUrl resolved(const QUrl &relative) const;

bool isRelative() const;
bool isParentOf(const QUrl &url) const;

static QUrl fromLocalFile(const QString &localfile);
QString toLocalFile() const;

QString toString(FormattingOptions options = None) const;

QByteArray toEncoded(FormattingOptions options = None) const;
static QUrl fromEncoded(const QByteArray &url);
static QUrl fromEncoded(const QByteArray &url, ParsingMode mode);


static QUrl fromUserInput(const QString &userInput);

void detach();
bool isDetached() const;

bool operator <(const QUrl &url) const;
bool operator ==(const QUrl &url) const;
bool operator !=(const QUrl &url) const;

static QString fromPercentEncoding(const QByteArray &);
static QByteArray toPercentEncoding(const QString &,
const QByteArray &exclude = QByteArray(),
const QByteArray &include = QByteArray());
static QString fromPunycode(const QByteArray &);
static QByteArray toPunycode(const QString &);
static QString fromAce(const QByteArray &);
static QByteArray toAce(const QString &);
static QStringList idnWhitelist();
static void setIdnWhitelist(const QStringList &);














































# 257 "/usr/share/qt4/include/QtCore/qurl.h"
QString errorString() const;

protected:




# 264 "/usr/share/qt4/include/QtCore/qurl.h"
private:
QUrlPrivate *d;
public:
typedef QUrlPrivate * DataPtr;
inline DataPtr &data_ptr() { return d; }
};

template <> class QTypeInfo<QUrl > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QUrl)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QUrl"; } };
template <> inline bool qIsDetached<QUrl>(QUrl &t) { return t.isDetached(); } template <> inline void qSwap<QUrl>(QUrl &value1, QUrl &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }
inline QFlags<QUrl::FormattingOptions::enum_type> operator|(QUrl::FormattingOptions::enum_type f1, QUrl::FormattingOptions::enum_type f2) { return QFlags<QUrl::FormattingOptions::enum_type>(f1) | f2; } inline QFlags<QUrl::FormattingOptions::enum_type> operator|(QUrl::FormattingOptions::enum_type f1, QFlags<QUrl::FormattingOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QUrl::FormattingOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 276 "/usr/share/qt4/include/QtCore/qurl.h"
 QDataStream &operator<<(QDataStream &, const QUrl &);
 QDataStream &operator>>(QDataStream &, QUrl &);



# 281 "/usr/share/qt4/include/QtCore/qurl.h"
 QDebug operator<<(QDebug, const QUrl &);


# 284 "/usr/share/qt4/include/QtCore/qurl.h"





# 19 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qabstractanimation.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qabstractanimation.h"


# 47 "/usr/share/qt4/include/QtCore/qabstractanimation.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qabstractanimation.h"
class QAnimationGroup;
class QSequentialAnimationGroup;

class QAbstractAnimationPrivate;
class  QAbstractAnimation : public QObject
{
Q_OBJECT
Q_ENUMS(State)
Q_ENUMS(Direction)
Q_PROPERTY(State state READ state NOTIFY stateChanged)
Q_PROPERTY(int loopCount READ loopCount WRITE setLoopCount)
Q_PROPERTY(int currentTime READ currentTime WRITE setCurrentTime)
Q_PROPERTY(int currentLoop READ currentLoop NOTIFY currentLoopChanged)
Q_PROPERTY(Direction direction READ direction WRITE setDirection NOTIFY directionChanged)
Q_PROPERTY(int duration READ duration)

public:
enum Direction {
Forward,
Backward
};

enum State {
Stopped,
Paused,
Running
};

enum DeletionPolicy {
KeepWhenStopped = 0,
DeleteWhenStopped
};

QAbstractAnimation(QObject *parent = 0);
virtual ~QAbstractAnimation();

State state() const;

QAnimationGroup *group() const;

Direction direction() const;
void setDirection(Direction direction);

int currentTime() const;
int currentLoopTime() const;

int loopCount() const;
void setLoopCount(int loopCount);
int currentLoop() const;

virtual int duration() const = 0;
int totalDuration() const;

signals:
void finished();
void stateChanged(QAbstractAnimation::State newState, QAbstractAnimation::State oldState);
void currentLoopChanged(int currentLoop);
void directionChanged(QAbstractAnimation::Direction);

public slots:
void start(QAbstractAnimation::DeletionPolicy policy = KeepWhenStopped);
void pause();
void resume();
void setPaused(bool);
void stop();
void setCurrentTime(int msecs);

protected:
QAbstractAnimation(QAbstractAnimationPrivate &dd, QObject *parent = 0);
bool event(QEvent *event);

virtual void updateCurrentTime(int currentTime) = 0;
virtual void updateState(QAbstractAnimation::State newState, QAbstractAnimation::State oldState);
virtual void updateDirection(QAbstractAnimation::Direction direction);

private:
QAbstractAnimation(const QAbstractAnimation &); QAbstractAnimation &operator=(const QAbstractAnimation &);
inline QAbstractAnimationPrivate* d_func() { return reinterpret_cast<QAbstractAnimationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractAnimationPrivate* d_func() const { return reinterpret_cast<const QAbstractAnimationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractAnimationPrivate;
};



# 137 "/usr/share/qt4/include/QtCore/qabstractanimation.h"





# 20 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qanimationgroup.h"












































# 1 "/usr/share/qt4/include/QtCore/qabstractanimation.h"













































































































































# 45 "/usr/share/qt4/include/QtCore/qanimationgroup.h"


# 47 "/usr/share/qt4/include/QtCore/qanimationgroup.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qanimationgroup.h"
class QAnimationGroupPrivate;
class  QAnimationGroup : public QAbstractAnimation
{
Q_OBJECT

public:
QAnimationGroup(QObject *parent = 0);
~QAnimationGroup();

QAbstractAnimation *animationAt(int index) const;
int animationCount() const;
int indexOfAnimation(QAbstractAnimation *animation) const;
void addAnimation(QAbstractAnimation *animation);
void insertAnimation(int index, QAbstractAnimation *animation);
void removeAnimation(QAbstractAnimation *animation);
QAbstractAnimation *takeAnimation(int index);
void clear();

protected:
QAnimationGroup(QAnimationGroupPrivate &dd, QObject *parent);
bool event(QEvent *event);

private:
QAnimationGroup(const QAnimationGroup &); QAnimationGroup &operator=(const QAnimationGroup &);
inline QAnimationGroupPrivate* d_func() { return reinterpret_cast<QAnimationGroupPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAnimationGroupPrivate* d_func() const { return reinterpret_cast<const QAnimationGroupPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAnimationGroupPrivate;
};



# 84 "/usr/share/qt4/include/QtCore/qanimationgroup.h"





# 21 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qparallelanimationgroup.h"












































# 1 "/usr/share/qt4/include/QtCore/qanimationgroup.h"
























































































# 45 "/usr/share/qt4/include/QtCore/qparallelanimationgroup.h"


# 47 "/usr/share/qt4/include/QtCore/qparallelanimationgroup.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qparallelanimationgroup.h"
class QParallelAnimationGroupPrivate;
class  QParallelAnimationGroup : public QAnimationGroup
{
Q_OBJECT

public:
QParallelAnimationGroup(QObject *parent = 0);
~QParallelAnimationGroup();

int duration() const;

protected:
QParallelAnimationGroup(QParallelAnimationGroupPrivate &dd, QObject *parent);
bool event(QEvent *event);

void updateCurrentTime(int currentTime);
void updateState(QAbstractAnimation::State newState, QAbstractAnimation::State oldState);
void updateDirection(QAbstractAnimation::Direction direction);

private:
QParallelAnimationGroup(const QParallelAnimationGroup &); QParallelAnimationGroup &operator=(const QParallelAnimationGroup &);
inline QParallelAnimationGroupPrivate* d_func() { return reinterpret_cast<QParallelAnimationGroupPrivate *>(qGetPtrHelper(d_ptr)); } inline const QParallelAnimationGroupPrivate* d_func() const { return reinterpret_cast<const QParallelAnimationGroupPrivate *>(qGetPtrHelper(d_ptr)); } friend class QParallelAnimationGroupPrivate;

};



# 82 "/usr/share/qt4/include/QtCore/qparallelanimationgroup.h"





# 22 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qpauseanimation.h"












































# 1 "/usr/share/qt4/include/QtCore/qanimationgroup.h"
























































































# 45 "/usr/share/qt4/include/QtCore/qpauseanimation.h"


# 47 "/usr/share/qt4/include/QtCore/qpauseanimation.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qpauseanimation.h"
class QPauseAnimationPrivate;

class  QPauseAnimation : public QAbstractAnimation
{
Q_OBJECT
Q_PROPERTY(int duration READ duration WRITE setDuration)
public:
QPauseAnimation(QObject *parent = 0);
QPauseAnimation(int msecs, QObject *parent = 0);
~QPauseAnimation();

int duration() const;
void setDuration(int msecs);

protected:
bool event(QEvent *e);
void updateCurrentTime(int);

private:
QPauseAnimation(const QPauseAnimation &); QPauseAnimation &operator=(const QPauseAnimation &);
inline QPauseAnimationPrivate* d_func() { return reinterpret_cast<QPauseAnimationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPauseAnimationPrivate* d_func() const { return reinterpret_cast<const QPauseAnimationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPauseAnimationPrivate;
};



# 80 "/usr/share/qt4/include/QtCore/qpauseanimation.h"





# 23 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qpropertyanimation.h"












































# 1 "/usr/share/qt4/include/QtCore/qvariantanimation.h"












































# 1 "/usr/share/qt4/include/QtCore/qeasingcurve.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qeasingcurve.h"

# 1 "/usr/share/qt4/include/QtCore/qobjectdefs.h"































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qeasingcurve.h"


# 48 "/usr/share/qt4/include/QtCore/qeasingcurve.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QEasingCurvePrivate;
class  QEasingCurve
{

Q_ENUMS(Type)
public:
enum Type {
Linear,
InQuad, OutQuad, InOutQuad, OutInQuad,
InCubic, OutCubic, InOutCubic, OutInCubic,
InQuart, OutQuart, InOutQuart, OutInQuart,
InQuint, OutQuint, InOutQuint, OutInQuint,
InSine, OutSine, InOutSine, OutInSine,
InExpo, OutExpo, InOutExpo, OutInExpo,
InCirc, OutCirc, InOutCirc, OutInCirc,
InElastic, OutElastic, InOutElastic, OutInElastic,
InBack, OutBack, InOutBack, OutInBack,
InBounce, OutBounce, InOutBounce, OutInBounce,
InCurve, OutCurve, SineCurve, CosineCurve,
Custom, NCurveTypes
};

QEasingCurve(Type type = Linear);
QEasingCurve(const QEasingCurve &other);
~QEasingCurve();

QEasingCurve &operator=(const QEasingCurve &other);
bool operator==(const QEasingCurve &other) const;
inline bool operator!=(const QEasingCurve &other) const
{ return !(this->operator==(other)); }

qreal amplitude() const;
void setAmplitude(qreal amplitude);

qreal period() const;
void setPeriod(qreal period);

qreal overshoot() const;
void setOvershoot(qreal overshoot);

Type type() const;
void setType(Type type);
typedef qreal (*EasingFunction)(qreal progress);
void setCustomType(EasingFunction func);
EasingFunction customType() const;

qreal valueForProgress(qreal progress) const;
private:
QEasingCurvePrivate *d_ptr;
friend  QDebug operator<<(QDebug debug, const QEasingCurve &item);
};


# 107 "/usr/share/qt4/include/QtCore/qeasingcurve.h"
 QDebug operator<<(QDebug debug, const QEasingCurve &item);


# 110 "/usr/share/qt4/include/QtCore/qeasingcurve.h"





# 45 "/usr/share/qt4/include/QtCore/qvariantanimation.h"

# 1 "/usr/share/qt4/include/QtCore/qabstractanimation.h"













































































































































# 46 "/usr/share/qt4/include/QtCore/qvariantanimation.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qvariantanimation.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtCore/qvariantanimation.h"

# 1 "/usr/share/qt4/include/QtCore/qpair.h"































































































































# 49 "/usr/share/qt4/include/QtCore/qvariantanimation.h"


# 51 "/usr/share/qt4/include/QtCore/qvariantanimation.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 59 "/usr/share/qt4/include/QtCore/qvariantanimation.h"
class QVariantAnimationPrivate;
class  QVariantAnimation : public QAbstractAnimation
{
Q_OBJECT
Q_PROPERTY(QVariant startValue READ startValue WRITE setStartValue)
Q_PROPERTY(QVariant endValue READ endValue WRITE setEndValue)
Q_PROPERTY(QVariant currentValue READ currentValue NOTIFY valueChanged)
Q_PROPERTY(int duration READ duration WRITE setDuration)
Q_PROPERTY(QEasingCurve easingCurve READ easingCurve WRITE setEasingCurve)

public:
typedef QPair<qreal, QVariant> KeyValue;
typedef QVector<KeyValue> KeyValues;

QVariantAnimation(QObject *parent = 0);
~QVariantAnimation();

QVariant startValue() const;
void setStartValue(const QVariant &value);

QVariant endValue() const;
void setEndValue(const QVariant &value);

QVariant keyValueAt(qreal step) const;
void setKeyValueAt(qreal step, const QVariant &value);

KeyValues keyValues() const;
void setKeyValues(const KeyValues &values);

QVariant currentValue() const;

int duration() const;
void setDuration(int msecs);

QEasingCurve easingCurve() const;
void setEasingCurve(const QEasingCurve &easing);

typedef QVariant (*Interpolator)(const void *from, const void *to, qreal progress);

signals:
void valueChanged(const QVariant &value);

protected:
QVariantAnimation(QVariantAnimationPrivate &dd, QObject *parent = 0);
bool event(QEvent *event);

void updateCurrentTime(int);
void updateState(QAbstractAnimation::State newState, QAbstractAnimation::State oldState);

virtual void updateCurrentValue(const QVariant &value) = 0;
virtual QVariant interpolated(const QVariant &from, const QVariant &to, qreal progress) const;

private:
template <typename T> friend void qRegisterAnimationInterpolator(QVariant (*func)(const T &, const T &, qreal));
static void registerInterpolator(Interpolator func, int interpolationType);

QVariantAnimation(const QVariantAnimation &); QVariantAnimation &operator=(const QVariantAnimation &);
inline QVariantAnimationPrivate* d_func() { return reinterpret_cast<QVariantAnimationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QVariantAnimationPrivate* d_func() const { return reinterpret_cast<const QVariantAnimationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QVariantAnimationPrivate;
};

template <typename T>
void qRegisterAnimationInterpolator(QVariant (*func)(const T &from, const T &to, qreal progress)) {
QVariantAnimation::registerInterpolator(reinterpret_cast<QVariantAnimation::Interpolator>(func), qMetaTypeId<T>());
}



# 126 "/usr/share/qt4/include/QtCore/qvariantanimation.h"





# 45 "/usr/share/qt4/include/QtCore/qpropertyanimation.h"


# 47 "/usr/share/qt4/include/QtCore/qpropertyanimation.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qpropertyanimation.h"
class QPropertyAnimationPrivate;
class  QPropertyAnimation : public QVariantAnimation
{
Q_OBJECT
Q_PROPERTY(QByteArray propertyName READ propertyName WRITE setPropertyName)
Q_PROPERTY(QObject* targetObject READ targetObject WRITE setTargetObject)

public:
QPropertyAnimation(QObject *parent = 0);
QPropertyAnimation(QObject *target, const QByteArray &propertyName, QObject *parent = 0);
~QPropertyAnimation();

QObject *targetObject() const;
void setTargetObject(QObject *target);

QByteArray propertyName() const;
void setPropertyName(const QByteArray &propertyName);

protected:
bool event(QEvent *event);
void updateCurrentValue(const QVariant &value);
void updateState(QAbstractAnimation::State newState, QAbstractAnimation::State oldState);

private:
QPropertyAnimation(const QPropertyAnimation &); QPropertyAnimation &operator=(const QPropertyAnimation &);
inline QPropertyAnimationPrivate* d_func() { return reinterpret_cast<QPropertyAnimationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPropertyAnimationPrivate* d_func() const { return reinterpret_cast<const QPropertyAnimationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPropertyAnimationPrivate;
};



# 85 "/usr/share/qt4/include/QtCore/qpropertyanimation.h"





# 24 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qsequentialanimationgroup.h"












































# 1 "/usr/share/qt4/include/QtCore/qanimationgroup.h"
























































































# 45 "/usr/share/qt4/include/QtCore/qsequentialanimationgroup.h"


# 47 "/usr/share/qt4/include/QtCore/qsequentialanimationgroup.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qsequentialanimationgroup.h"
class QPauseAnimation;
class QSequentialAnimationGroupPrivate;

class  QSequentialAnimationGroup : public QAnimationGroup
{
Q_OBJECT
Q_PROPERTY(QAbstractAnimation* currentAnimation READ currentAnimation NOTIFY currentAnimationChanged)

public:
QSequentialAnimationGroup(QObject *parent = 0);
~QSequentialAnimationGroup();

QPauseAnimation *addPause(int msecs);
QPauseAnimation *insertPause(int index, int msecs);

QAbstractAnimation *currentAnimation() const;
int duration() const;

signals:
void currentAnimationChanged(QAbstractAnimation *current);

protected:
QSequentialAnimationGroup(QSequentialAnimationGroupPrivate &dd, QObject *parent);
bool event(QEvent *event);

void updateCurrentTime(int);
void updateState(QAbstractAnimation::State newState, QAbstractAnimation::State oldState);
void updateDirection(QAbstractAnimation::Direction direction);

private:
QSequentialAnimationGroup(const QSequentialAnimationGroup &); QSequentialAnimationGroup &operator=(const QSequentialAnimationGroup &);
inline QSequentialAnimationGroupPrivate* d_func() { return reinterpret_cast<QSequentialAnimationGroupPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSequentialAnimationGroupPrivate* d_func() const { return reinterpret_cast<const QSequentialAnimationGroupPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSequentialAnimationGroupPrivate;

};



# 92 "/usr/share/qt4/include/QtCore/qsequentialanimationgroup.h"





# 25 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qvariantanimation.h"


































































































































# 26 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 27 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qbasicatomic.h"






































































































































































































































# 28 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qmutex.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qmutex.h"



# 48 "/usr/share/qt4/include/QtCore/qmutex.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 56 "/usr/share/qt4/include/QtCore/qmutex.h"
class QMutexPrivate;

class  QMutex
{
friend class QWaitCondition;
friend class QWaitConditionPrivate;

public:
enum RecursionMode { NonRecursive, Recursive };

explicit QMutex(RecursionMode mode = NonRecursive);
~QMutex();

void lock();
bool tryLock();
bool tryLock(int timeout);
void unlock();















# 88 "/usr/share/qt4/include/QtCore/qmutex.h"
private:
QMutex(const QMutex &); QMutex &operator=(const QMutex &);

QMutexPrivate *d;
};

class  QMutexLocker
{
public:
inline explicit QMutexLocker(QMutex *m)
: mtx(m)
{
qt_noop();
relock();
}
inline ~QMutexLocker() { unlock(); }

inline void unlock()
{
if (mtx) {
if ((val & quintptr(1u)) == quintptr(1u)) {
val &= ~quintptr(1u);
mtx->unlock();
}
}
}

inline void relock()
{
if (mtx) {
if ((val & quintptr(1u)) == quintptr(0u)) {
mtx->lock();
val |= quintptr(1u);
}
}
}






# 130 "/usr/share/qt4/include/QtCore/qmutex.h"
inline QMutex *mutex() const
{
return reinterpret_cast<QMutex *>(val & ~quintptr(1u));
}





# 139 "/usr/share/qt4/include/QtCore/qmutex.h"
private:
QMutexLocker(const QMutexLocker &); QMutexLocker &operator=(const QMutexLocker &);

union {
QMutex *mtx;
quintptr val;
};
};









































# 188 "/usr/share/qt4/include/QtCore/qmutex.h"





# 29 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qreadwritelock.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qreadwritelock.h"



# 48 "/usr/share/qt4/include/QtCore/qreadwritelock.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 56 "/usr/share/qt4/include/QtCore/qreadwritelock.h"
struct QReadWriteLockPrivate;

class  QReadWriteLock
{
public:
enum RecursionMode { NonRecursive, Recursive };

QReadWriteLock(); 
QReadWriteLock(RecursionMode recursionMode);
~QReadWriteLock();

void lockForRead();
bool tryLockForRead();
bool tryLockForRead(int timeout);

void lockForWrite();
bool tryLockForWrite();
bool tryLockForWrite(int timeout);

void unlock();

private:
QReadWriteLock(const QReadWriteLock &); QReadWriteLock &operator=(const QReadWriteLock &);
QReadWriteLockPrivate *d;

friend class QWaitCondition;
};






# 89 "/usr/share/qt4/include/QtCore/qreadwritelock.h"
class  QReadLocker
{
public:
inline QReadLocker(QReadWriteLock *readWriteLock);

inline ~QReadLocker()
{ unlock(); }

inline void unlock()
{
if (q_lock) {
if ((q_val & quintptr(1u)) == quintptr(1u)) {
q_val &= ~quintptr(1u);
q_lock->unlock();
}
}
}

inline void relock()
{
if (q_lock) {
if ((q_val & quintptr(1u)) == quintptr(0u)) {
q_lock->lockForRead();
q_val |= quintptr(1u);
}
}
}

inline QReadWriteLock *readWriteLock() const
{ return reinterpret_cast<QReadWriteLock *>(q_val & ~quintptr(1u)); }

private:
QReadLocker(const QReadLocker &); QReadLocker &operator=(const QReadLocker &);
union {
QReadWriteLock *q_lock;
quintptr q_val;
};
};

inline QReadLocker::QReadLocker(QReadWriteLock *areadWriteLock)
: q_lock(areadWriteLock)
{
qt_noop();
relock();
}

class  QWriteLocker
{
public:
inline QWriteLocker(QReadWriteLock *readWriteLock);

inline ~QWriteLocker()
{ unlock(); }

inline void unlock()
{
if (q_lock) {
if ((q_val & quintptr(1u)) == quintptr(1u)) {
q_val &= ~quintptr(1u);
q_lock->unlock();
}
}
}

inline void relock()
{
if (q_lock) {
if ((q_val & quintptr(1u)) == quintptr(0u)) {
q_lock->lockForWrite();
q_val |= quintptr(1u);
}
}
}

inline QReadWriteLock *readWriteLock() const
{ return reinterpret_cast<QReadWriteLock *>(q_val & ~quintptr(1u)); }


private:
QWriteLocker(const QWriteLocker &); QWriteLocker &operator=(const QWriteLocker &);
union{
QReadWriteLock *q_lock;
quintptr q_val;
};
};

inline QWriteLocker::QWriteLocker(QReadWriteLock *areadWriteLock)
: q_lock(areadWriteLock)
{
qt_noop();
relock();
}


























































# 239 "/usr/share/qt4/include/QtCore/qreadwritelock.h"





# 30 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qsemaphore.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qsemaphore.h"


# 47 "/usr/share/qt4/include/QtCore/qsemaphore.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qsemaphore.h"
class QSemaphorePrivate;

class  QSemaphore
{
public:
explicit QSemaphore(int n = 0);
~QSemaphore();

void acquire(int n = 1);
bool tryAcquire(int n = 1);
bool tryAcquire(int n, int timeout);

void release(int n = 1);

int available() const;

private:
QSemaphore(const QSemaphore &); QSemaphore &operator=(const QSemaphore &);

QSemaphorePrivate *d;
};



# 79 "/usr/share/qt4/include/QtCore/qsemaphore.h"





# 31 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qthread.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qthread.h"




# 49 "/usr/share/qt4/include/QtCore/qthread.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QThreadData;
class QThreadPrivate;


# 59 "/usr/share/qt4/include/QtCore/qthread.h"
class  QThread : public QObject
{
public:
static Qt::HANDLE currentThreadId();
static QThread *currentThread();
static int idealThreadCount();
static void yieldCurrentThread();

explicit QThread(QObject *parent = 0);
~QThread();

enum Priority {
IdlePriority,

LowestPriority,
LowPriority,
NormalPriority,
HighPriority,
HighestPriority,

TimeCriticalPriority,

InheritPriority
};

void setPriority(Priority priority);
Priority priority() const;

bool isFinished() const;
bool isRunning() const;

void setStackSize(uint stackSize);
uint stackSize() const;

void exit(int retcode = 0);

public slots:
void start(Priority = InheritPriority);
void terminate();
void quit();

public:

bool wait(unsigned long time = Integer.MAX_VALUE);

signals:
void started();
void finished();
void terminated();

protected:
virtual void run();
int exec();

static void setTerminationEnabled(bool enabled = true);

static void sleep(unsigned long);
static void msleep(unsigned long);
static void usleep(unsigned long);







# 125 "/usr/share/qt4/include/QtCore/qthread.h"
protected:
QThread(QThreadPrivate &dd, QObject *parent = 0);

private:
Q_OBJECT
inline QThreadPrivate* d_func() { return reinterpret_cast<QThreadPrivate *>(qGetPtrHelper(d_ptr)); } inline const QThreadPrivate* d_func() const { return reinterpret_cast<const QThreadPrivate *>(qGetPtrHelper(d_ptr)); } friend class QThreadPrivate;

static void initialize();
static void cleanup();

friend class QCoreApplication;
friend class QThreadData;
};
























# 162 "/usr/share/qt4/include/QtCore/qthread.h"





# 32 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qthreadstorage.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qthreadstorage.h"




# 49 "/usr/share/qt4/include/QtCore/qthreadstorage.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class  QThreadStorageData
{
public:
explicit QThreadStorageData(void (*func)(void *));
~QThreadStorageData();

void** get() const;
void** set(void* p);

static void finish(void**);
int id;
};


# 69 "/usr/share/qt4/include/QtCore/qthreadstorage.h"



template <typename T>
inline
T *&qThreadStorage_localData(QThreadStorageData &d, T **)
{
void **v = d.get();
if (!v) v = d.set(0);
return *(reinterpret_cast<T**>(v));
}

template <typename T>
inline
T *qThreadStorage_localData_const(const QThreadStorageData &d, T **)
{
void **v = d.get();
return v ? *(reinterpret_cast<T**>(v)) : 0;
}

template <typename T>
inline
void qThreadStorage_setLocalData(QThreadStorageData &d, T **t)
{ (void) d.set(*t); }



# 96 "/usr/share/qt4/include/QtCore/qthreadstorage.h"

template <typename T>
inline
T &qThreadStorage_localData(QThreadStorageData &d, T *)
{
void **v = d.get();
if (!v) v = d.set(new T());
return *(reinterpret_cast<T*>(*v));
}

template <typename T>
inline
T qThreadStorage_localData_const(const QThreadStorageData &d, T *)
{
void **v = d.get();
return v ? *(reinterpret_cast<T*>(*v)) : T();
}

template <typename T>
inline
void qThreadStorage_setLocalData(QThreadStorageData &d, T *t)
{ (void) d.set(new T(*t)); }



# 121 "/usr/share/qt4/include/QtCore/qthreadstorage.h"



# 124 "/usr/share/qt4/include/QtCore/qthreadstorage.h"
template <class T>
class QThreadStorage
{
private:
QThreadStorageData d;

QThreadStorage(const QThreadStorage &); QThreadStorage &operator=(const QThreadStorage &);

static inline void deleteData(void *x)
{ delete static_cast<T>(x); }

public:
inline QThreadStorage() : d(deleteData) { }
inline ~QThreadStorage() { }

inline bool hasLocalData() const
{ return d.get() != 0; }

inline T& localData()
{ return qThreadStorage_localData(d, reinterpret_cast<T*>(0)); }
inline T localData() const
{ return qThreadStorage_localData_const(d, reinterpret_cast<T*>(0)); }

inline void setLocalData(T t)
{ qThreadStorage_setLocalData(d, &t); }
};








# 33 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qwaitcondition.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qwaitcondition.h"




# 49 "/usr/share/qt4/include/QtCore/qwaitcondition.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 57 "/usr/share/qt4/include/QtCore/qwaitcondition.h"
class QWaitConditionPrivate;
class QMutex;
class QReadWriteLock;

class  QWaitCondition
{
public:
QWaitCondition();
~QWaitCondition();

bool wait(QMutex *mutex, unsigned long time = Integer.MAX_VALUE);
bool wait(QReadWriteLock *readWriteLock, unsigned long time = Integer.MAX_VALUE);

void wakeOne();
void wakeAll();

private:
QWaitCondition(const QWaitCondition &); QWaitCondition &operator=(const QWaitCondition &);

QWaitConditionPrivate * d;
};























# 101 "/usr/share/qt4/include/QtCore/qwaitcondition.h"





# 34 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qabstracteventdispatcher.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qabstracteventdispatcher.h"

# 1 "/usr/share/qt4/include/QtCore/qeventloop.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qeventloop.h"


# 47 "/usr/share/qt4/include/QtCore/qeventloop.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QEventLoopPrivate;

class  QEventLoop : public QObject
{
Q_OBJECT
inline QEventLoopPrivate* d_func() { return reinterpret_cast<QEventLoopPrivate *>(qGetPtrHelper(d_ptr)); } inline const QEventLoopPrivate* d_func() const { return reinterpret_cast<const QEventLoopPrivate *>(qGetPtrHelper(d_ptr)); } friend class QEventLoopPrivate;

public:
explicit QEventLoop(QObject *parent = 0);
~QEventLoop();

enum ProcessEventsFlag {
AllEvents = 0x00,
ExcludeUserInputEvents = 0x01,
ExcludeSocketNotifiers = 0x02,
WaitForMoreEvents = 0x04,




# 73 "/usr/share/qt4/include/QtCore/qeventloop.h"
X11ExcludeTimers = 0x08

# 75 "/usr/share/qt4/include/QtCore/qeventloop.h"
, DeferredDeletion = 0x10

# 77 "/usr/share/qt4/include/QtCore/qeventloop.h"
, EventLoopExec = 0x20
, DialogExec = 0x40
};
typedef QFlags<ProcessEventsFlag> ProcessEventsFlags;

bool processEvents(ProcessEventsFlags flags = AllEvents);
void processEvents(ProcessEventsFlags flags, int maximumTime);

int exec(ProcessEventsFlags flags = AllEvents);
void exit(int returnCode = 0);
bool isRunning() const;

void wakeUp();

public slots:
void quit();
};

inline QFlags<QEventLoop::ProcessEventsFlags::enum_type> operator|(QEventLoop::ProcessEventsFlags::enum_type f1, QEventLoop::ProcessEventsFlags::enum_type f2) { return QFlags<QEventLoop::ProcessEventsFlags::enum_type>(f1) | f2; } inline QFlags<QEventLoop::ProcessEventsFlags::enum_type> operator|(QEventLoop::ProcessEventsFlags::enum_type f1, QFlags<QEventLoop::ProcessEventsFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QEventLoop::ProcessEventsFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }






# 46 "/usr/share/qt4/include/QtCore/qabstracteventdispatcher.h"


# 48 "/usr/share/qt4/include/QtCore/qabstracteventdispatcher.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QAbstractEventDispatcherPrivate;
class QSocketNotifier;
template <typename T1, typename T2> struct QPair;

class  QAbstractEventDispatcher : public QObject
{
Q_OBJECT
inline QAbstractEventDispatcherPrivate* d_func() { return reinterpret_cast<QAbstractEventDispatcherPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractEventDispatcherPrivate* d_func() const { return reinterpret_cast<const QAbstractEventDispatcherPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractEventDispatcherPrivate;

public:
typedef QPair<int, int> TimerInfo;

explicit QAbstractEventDispatcher(QObject *parent = 0);
~QAbstractEventDispatcher();

static QAbstractEventDispatcher *instance(QThread *thread = 0);

virtual bool processEvents(QEventLoop::ProcessEventsFlags flags) = 0;
virtual bool hasPendingEvents() = 0;

virtual void registerSocketNotifier(QSocketNotifier *notifier) = 0;
virtual void unregisterSocketNotifier(QSocketNotifier *notifier) = 0;

int registerTimer(int interval, QObject *object);
virtual void registerTimer(int timerId, int interval, QObject *object) = 0;
virtual bool unregisterTimer(int timerId) = 0;
virtual bool unregisterTimers(QObject *object) = 0;
virtual QList<TimerInfo> registeredTimers(QObject *object) const = 0;

virtual void wakeUp() = 0;
virtual void interrupt() = 0;
virtual void flush() = 0;

virtual void startingUp();
virtual void closingDown();

typedef bool(*EventFilter)(void *message);
EventFilter setEventFilter(EventFilter filter);
bool filterEvent(void *message);

signals:
void aboutToBlock();
void awake();

protected:
QAbstractEventDispatcher(QAbstractEventDispatcherPrivate &,
QObject *parent);
};






# 35 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"












































# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"

# 1 "/usr/share/qt4/include/QtCore/qhash.h"






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"


# 49 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QAbstractItemModel;
class QPersistentModelIndex;

class  QModelIndex
{
friend class QAbstractItemModel;
friend class QProxyModel;
public:
inline QModelIndex() : r(-1), c(-1), p(0), m(0) {}
inline QModelIndex(const QModelIndex &other)
: r(other.r), c(other.c), p(other.p), m(other.m) {}
inline ~QModelIndex() { p = 0; m = 0; }
inline int row() const { return r; }
inline int column() const { return c; }
inline void *internalPointer() const { return p; }
inline qint64 internalId() const { return reinterpret_cast<qint64>(p); }
inline QModelIndex parent() const;
inline QModelIndex sibling(int row, int column) const;
inline QModelIndex child(int row, int column) const;
inline QVariant data(int role = Qt::DisplayRole) const;
inline Qt::ItemFlags flags() const;
inline const QAbstractItemModel *model() const { return m; }
inline bool isValid() const { return (r >= 0) && (c >= 0) && (m != 0); }
inline bool operator==(const QModelIndex &other) const
{ return (other.r == r) && (other.p == p) && (other.c == c) && (other.m == m); }
inline bool operator!=(const QModelIndex &other) const
{ return !(*this == other); }
inline bool operator<(const QModelIndex &other) const
{
if (r < other.r) return true;
if (r == other.r) {
if (c < other.c) return true;
if (c == other.c) {
if (p < other.p) return true;
if (p == other.p) return m < other.m;
}
}
return false; }
private:
inline QModelIndex(int row, int column, void *ptr, const QAbstractItemModel *model);
int r, c;
void *p;
const QAbstractItemModel *m;
};
template <> class QTypeInfo<QModelIndex > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QModelIndex)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QModelIndex"; } };


# 102 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
 QDebug operator<<(QDebug, const QModelIndex &);


# 105 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
class QPersistentModelIndexData;

class  QPersistentModelIndex
{
public:
QPersistentModelIndex();
QPersistentModelIndex(const QModelIndex &index);
QPersistentModelIndex(const QPersistentModelIndex &other);
~QPersistentModelIndex();
bool operator<(const QPersistentModelIndex &other) const;
bool operator==(const QPersistentModelIndex &other) const;
inline bool operator!=(const QPersistentModelIndex &other) const
{ return !operator==(other); }
QPersistentModelIndex &operator=(const QPersistentModelIndex &other);
bool operator==(const QModelIndex &other) const;
bool operator!=(const QModelIndex &other) const;
QPersistentModelIndex &operator=(const QModelIndex &other);
operator const QModelIndex&() const;
int row() const;
int column() const;
void *internalPointer() const;
qint64 internalId() const;
QModelIndex parent() const;
QModelIndex sibling(int row, int column) const;
QModelIndex child(int row, int column) const;
QVariant data(int role = Qt::DisplayRole) const;
Qt::ItemFlags flags() const;
const QAbstractItemModel *model() const;
bool isValid() const;
private:
QPersistentModelIndexData *d;
friend uint qHash(const QPersistentModelIndex &);

# 138 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
friend  QDebug operator<<(QDebug, const QPersistentModelIndex &);

# 140 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
};
template <> class QTypeInfo<QPersistentModelIndex > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPersistentModelIndex)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QPersistentModelIndex"; } };

inline uint qHash(const QPersistentModelIndex &index)
{ return qHash(index.d); }



# 148 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
 QDebug operator<<(QDebug, const QPersistentModelIndex &);


# 151 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
template<typename T> class QList;
typedef QList<QModelIndex> QModelIndexList;

class QMimeData;
class QAbstractItemModelPrivate;
template <class Key, class T> class QMap;


class  QAbstractItemModel : public QObject
{
Q_OBJECT

friend class QPersistentModelIndexData;
friend class QAbstractItemViewPrivate;
public:

explicit QAbstractItemModel(QObject *parent = 0);
virtual ~QAbstractItemModel();

bool hasIndex(int row, int column, const QModelIndex &parent = QModelIndex()) const;
virtual QModelIndex index(int row, int column,
const QModelIndex &parent = QModelIndex()) const = 0;
virtual QModelIndex parent(const QModelIndex &child) const = 0;

inline QModelIndex sibling(int row, int column, const QModelIndex &idx) const
{ return index(row, column, parent(idx)); }

virtual int rowCount(const QModelIndex &parent = QModelIndex()) const = 0;
virtual int columnCount(const QModelIndex &parent = QModelIndex()) const = 0;
virtual bool hasChildren(const QModelIndex &parent = QModelIndex()) const;

virtual QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const = 0;
virtual bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

virtual QVariant headerData(int section, Qt::Orientation orientation,
int role = Qt::DisplayRole) const;
virtual bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value,
int role = Qt::EditRole);

virtual QMap<int, QVariant> itemData(const QModelIndex &index) const;
virtual bool setItemData(const QModelIndex &index, const QMap<int, QVariant> &roles);

virtual QStringList mimeTypes() const;
virtual QMimeData *mimeData(const QModelIndexList &indexes) const;
virtual bool dropMimeData(const QMimeData *data, Qt::DropAction action,
int row, int column, const QModelIndex &parent);
virtual Qt::DropActions supportedDropActions() const;

Qt::DropActions supportedDragActions() const;
void setSupportedDragActions(Qt::DropActions);

virtual bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
virtual bool insertColumns(int column, int count, const QModelIndex &parent = QModelIndex());
virtual bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());
virtual bool removeColumns(int column, int count, const QModelIndex &parent = QModelIndex());

inline bool insertRow(int row, const QModelIndex &parent = QModelIndex());
inline bool insertColumn(int column, const QModelIndex &parent = QModelIndex());
inline bool removeRow(int row, const QModelIndex &parent = QModelIndex());
inline bool removeColumn(int column, const QModelIndex &parent = QModelIndex());

virtual void fetchMore(const QModelIndex &parent);
virtual bool canFetchMore(const QModelIndex &parent) const;
virtual Qt::ItemFlags flags(const QModelIndex &index) const;
virtual void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);
virtual QModelIndex buddy(const QModelIndex &index) const;
virtual QModelIndexList match(const QModelIndex &start, int role,
const QVariant &value, int hits = 1,
Qt::MatchFlags flags =
Qt::MatchFlags(Qt::MatchStartsWith|Qt::MatchWrap)) const;
virtual QSize span(const QModelIndex &index) const;

const QHash<int,QByteArray> &roleNames() const;


# 226 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
inline QObject *parent() const { return QObject::parent(); }




# 231 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
signals:
void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
void headerDataChanged(Qt::Orientation orientation, int first, int last);
void layoutChanged();
void layoutAboutToBeChanged();


# 238 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
private: 

# 240 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
void rowsAboutToBeInserted(const QModelIndex &parent, int first, int last);
void rowsInserted(const QModelIndex &parent, int first, int last);

void rowsAboutToBeRemoved(const QModelIndex &parent, int first, int last);
void rowsRemoved(const QModelIndex &parent, int first, int last);

void columnsAboutToBeInserted(const QModelIndex &parent, int first, int last);
void columnsInserted(const QModelIndex &parent, int first, int last);

void columnsAboutToBeRemoved(const QModelIndex &parent, int first, int last);
void columnsRemoved(const QModelIndex &parent, int first, int last);

void modelAboutToBeReset();
void modelReset();

void rowsAboutToBeMoved( const QModelIndex &sourceParent, int sourceStart, int sourceEnd, const QModelIndex &destinationParent, int destinationRow );
void rowsMoved( const QModelIndex &parent, int start, int end, const QModelIndex &destination, int row );

void columnsAboutToBeMoved( const QModelIndex &sourceParent, int sourceStart, int sourceEnd, const QModelIndex &destinationParent, int destinationColumn );
void columnsMoved( const QModelIndex &parent, int start, int end, const QModelIndex &destination, int column );


public slots:
virtual bool submit();
virtual void revert();

protected:
QAbstractItemModel(QAbstractItemModelPrivate &dd, QObject *parent = 0);

inline QModelIndex createIndex(int row, int column, void *data = 0) const;
inline QModelIndex createIndex(int row, int column, int id) const;
inline QModelIndex createIndex(int row, int column, quint32 id) const;

void encodeData(const QModelIndexList &indexes, QDataStream &stream) const;
bool decodeData(int row, int column, const QModelIndex &parent, QDataStream &stream);

void beginInsertRows(const QModelIndex &parent, int first, int last);
void endInsertRows();

void beginRemoveRows(const QModelIndex &parent, int first, int last);
void endRemoveRows();

bool beginMoveRows(const QModelIndex &sourceParent, int sourceFirst, int sourceLast, const QModelIndex &destinationParent, int destinationRow);
void endMoveRows();

void beginInsertColumns(const QModelIndex &parent, int first, int last);
void endInsertColumns();

void beginRemoveColumns(const QModelIndex &parent, int first, int last);
void endRemoveColumns();

bool beginMoveColumns(const QModelIndex &sourceParent, int sourceFirst, int sourceLast, const QModelIndex &destinationParent, int destinationColumn);
void endMoveColumns();

void reset();

void beginResetModel();
void endResetModel();

void changePersistentIndex(const QModelIndex &from, const QModelIndex &to);
void changePersistentIndexList(const QModelIndexList &from, const QModelIndexList &to);
QModelIndexList persistentIndexList() const;

void setRoleNames(const QHash<int,QByteArray> &roleNames);

private:
inline QAbstractItemModelPrivate* d_func() { return reinterpret_cast<QAbstractItemModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractItemModelPrivate* d_func() const { return reinterpret_cast<const QAbstractItemModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractItemModelPrivate;
QAbstractItemModel(const QAbstractItemModel &); QAbstractItemModel &operator=(const QAbstractItemModel &);
};

inline bool QAbstractItemModel::insertRow(int arow, const QModelIndex &aparent)
{ return insertRows(arow, 1, aparent); }
inline bool QAbstractItemModel::insertColumn(int acolumn, const QModelIndex &aparent)
{ return insertColumns(acolumn, 1, aparent); }
inline bool QAbstractItemModel::removeRow(int arow, const QModelIndex &aparent)
{ return removeRows(arow, 1, aparent); }
inline bool QAbstractItemModel::removeColumn(int acolumn, const QModelIndex &aparent)
{ return removeColumns(acolumn, 1, aparent); }

inline QModelIndex QAbstractItemModel::createIndex(int arow, int acolumn, void *adata) const
{ return QModelIndex(arow, acolumn, adata, this); }
inline QModelIndex QAbstractItemModel::createIndex(int arow, int acolumn, int aid) const




# 326 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
{ return QModelIndex(arow, acolumn, reinterpret_cast<void*>(aid), this); }



# 330 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
inline QModelIndex QAbstractItemModel::createIndex(int arow, int acolumn, quint32 aid) const




# 335 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
{ return QModelIndex(arow, acolumn, reinterpret_cast<void*>(aid), this); }





# 341 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"
class  QAbstractTableModel : public QAbstractItemModel
{
Q_OBJECT

public:
explicit QAbstractTableModel(QObject *parent = 0);
~QAbstractTableModel();

QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
bool dropMimeData(const QMimeData *data, Qt::DropAction action,
int row, int column, const QModelIndex &parent);
protected:
QAbstractTableModel(QAbstractItemModelPrivate &dd, QObject *parent);

private:
QAbstractTableModel(const QAbstractTableModel &); QAbstractTableModel &operator=(const QAbstractTableModel &);
QModelIndex parent(const QModelIndex &child) const;
bool hasChildren(const QModelIndex &parent) const;
};

class  QAbstractListModel : public QAbstractItemModel
{
Q_OBJECT

public:
explicit QAbstractListModel(QObject *parent = 0);
~QAbstractListModel();

QModelIndex index(int row, int column = 0, const QModelIndex &parent = QModelIndex()) const;
bool dropMimeData(const QMimeData *data, Qt::DropAction action,
int row, int column, const QModelIndex &parent);
protected:
QAbstractListModel(QAbstractItemModelPrivate &dd, QObject *parent);

private:
QAbstractListModel(const QAbstractListModel &); QAbstractListModel &operator=(const QAbstractListModel &);
QModelIndex parent(const QModelIndex &child) const;
int columnCount(const QModelIndex &parent) const;
bool hasChildren(const QModelIndex &parent) const;
};



inline QModelIndex::QModelIndex(int arow, int acolumn, void *adata,
const QAbstractItemModel *amodel)
: r(arow), c(acolumn), p(adata), m(amodel) {}

inline QModelIndex QModelIndex::parent() const
{ return m ? m->parent(*this) : QModelIndex(); }

inline QModelIndex QModelIndex::sibling(int arow, int acolumn) const
{ return m ? (r == arow && c == acolumn) ? *this : m->index(arow, acolumn, m->parent(*this)) : QModelIndex(); }

inline QModelIndex QModelIndex::child(int arow, int acolumn) const
{ return m ? m->index(arow, acolumn, *this) : QModelIndex(); }

inline QVariant QModelIndex::data(int arole) const
{ return m ? m->data(*this, arole) : QVariant(); }

inline Qt::ItemFlags QModelIndex::flags() const
{ return m ? m->flags(*this) : Qt::ItemFlags(0); }

inline uint qHash(const QModelIndex &index)
{ return uint((index.row() << 4) + index.column() + index.internalId()); }






# 36 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qbasictimer.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qbasictimer.h"


# 47 "/usr/share/qt4/include/QtCore/qbasictimer.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QObject;

class  QBasicTimer
{
int id;
public:
inline QBasicTimer() : id(0) {}
inline ~QBasicTimer() { if (id) stop(); }

inline bool isActive() const { return id != 0; }
inline int timerId() const { return id; }

void start(int msec, QObject *obj);
void stop();
};
template <> class QTypeInfo<QBasicTimer > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QBasicTimer)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QBasicTimer"; } };






# 37 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qcoreapplication.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qcoreapplication.h"

# 1 "/usr/share/qt4/include/QtCore/qcoreevent.h"












































# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qcoreevent.h"

# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qcoreevent.h"

# 1 "/usr/share/qt4/include/QtCore/qobjectdefs.h"































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qcoreevent.h"


# 49 "/usr/share/qt4/include/QtCore/qcoreevent.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QEventPrivate;
class  QEvent 
{


Q_ENUMS(Type)
public:
enum Type {






None = 0, 
Timer = 1, 
MouseButtonPress = 2, 
MouseButtonRelease = 3, 
MouseButtonDblClick = 4, 
MouseMove = 5, 
KeyPress = 6, 
KeyRelease = 7, 
FocusIn = 8, 
FocusOut = 9, 
Enter = 10, 
Leave = 11, 
Paint = 12, 
Move = 13, 
Resize = 14, 
Create = 15, 
Destroy = 16, 
Show = 17, 
Hide = 18, 
Close = 19, 
Quit = 20, 
ParentChange = 21, 
ParentAboutToChange = 131, 



# 95 "/usr/share/qt4/include/QtCore/qcoreevent.h"
ThreadChange = 22, 
WindowActivate = 24, 
WindowDeactivate = 25, 
ShowToParent = 26, 
HideToParent = 27, 
Wheel = 31, 
WindowTitleChange = 33, 
WindowIconChange = 34, 
ApplicationWindowIconChange = 35, 
ApplicationFontChange = 36, 
ApplicationLayoutDirectionChange = 37, 
ApplicationPaletteChange = 38, 
PaletteChange = 39, 
Clipboard = 40, 
Speech = 42, 
MetaCall = 43, 
SockAct = 50, 
WinEventAct = 132, 
DeferredDelete = 52, 
DragEnter = 60, 
DragMove = 61, 
DragLeave = 62, 
Drop = 63, 
DragResponse = 64, 
ChildAdded = 68, 
ChildPolished = 69, 





# 126 "/usr/share/qt4/include/QtCore/qcoreevent.h"
ChildRemoved = 71, 
ShowWindowRequest = 73, 
PolishRequest = 74, 
Polish = 75, 
LayoutRequest = 76, 
UpdateRequest = 77, 
UpdateLater = 78, 

EmbeddingControl = 79, 
ActivateControl = 80, 
DeactivateControl = 81, 
ContextMenu = 82, 
InputMethod = 83, 
AccessibilityPrepare = 86, 
TabletMove = 87, 
LocaleChange = 88, 
LanguageChange = 89, 
LayoutDirectionChange = 90, 
Style = 91, 
TabletPress = 92, 
TabletRelease = 93, 
OkRequest = 94, 
HelpRequest = 95, 

IconDrag = 96, 

FontChange = 97, 
EnabledChange = 98, 
ActivationChange = 99, 
StyleChange = 100, 
IconTextChange = 101, 
ModifiedChange = 102, 
MouseTrackingChange = 109, 

WindowBlocked = 103, 
WindowUnblocked = 104, 
WindowStateChange = 105,

ToolTip = 110,
WhatsThis = 111,
StatusTip = 112,

ActionChanged = 113,
ActionAdded = 114,
ActionRemoved = 115,

FileOpen = 116, 

Shortcut = 117, 
ShortcutOverride = 51, 







# 183 "/usr/share/qt4/include/QtCore/qcoreevent.h"
WhatsThisClicked = 118,





# 189 "/usr/share/qt4/include/QtCore/qcoreevent.h"
ToolBarChange = 120, 

ApplicationActivate = 121, 
ApplicationActivated = ApplicationActivate, 
ApplicationDeactivate = 122, 
ApplicationDeactivated = ApplicationDeactivate, 

QueryWhatsThis = 123, 
EnterWhatsThisMode = 124,
LeaveWhatsThisMode = 125,

ZOrderChange = 126, 

HoverEnter = 127, 
HoverLeave = 128, 
HoverMove = 129, 

AccessibilityHelp = 119, 
AccessibilityDescription = 130, 







# 215 "/usr/share/qt4/include/QtCore/qcoreevent.h"
AcceptDropsChange = 152,

MenubarUpdated = 153, 


ZeroTimerEvent = 154, 

GraphicsSceneMouseMove = 155, 
GraphicsSceneMousePress = 156,
GraphicsSceneMouseRelease = 157,
GraphicsSceneMouseDoubleClick = 158,
GraphicsSceneContextMenu = 159,
GraphicsSceneHoverEnter = 160,
GraphicsSceneHoverMove = 161,
GraphicsSceneHoverLeave = 162,
GraphicsSceneHelp = 163,
GraphicsSceneDragEnter = 164,
GraphicsSceneDragMove = 165,
GraphicsSceneDragLeave = 166,
GraphicsSceneDrop = 167,
GraphicsSceneWheel = 168,

KeyboardLayoutChange = 169, 

DynamicPropertyChange = 170, 

TabletEnterProximity = 171,
TabletLeaveProximity = 172,

NonClientAreaMouseMove = 173,
NonClientAreaMouseButtonPress = 174,
NonClientAreaMouseButtonRelease = 175,
NonClientAreaMouseButtonDblClick = 176,

MacSizeChange = 177, 

ContentsRectChange = 178, 

MacGLWindowChange = 179, 

FutureCallOut = 180,

GraphicsSceneResize = 181,
GraphicsSceneMove = 182,

CursorChange = 183,
ToolTipChange = 184,

NetworkReplyUpdated = 185, 

GrabMouse = 186,
UngrabMouse = 187,
GrabKeyboard = 188,
UngrabKeyboard = 189,
CocoaRequestModal = 190, 
MacGLClearDrawable = 191, 

StateMachineSignal = 192,
StateMachineWrapped = 193,

TouchBegin = 194,
TouchUpdate = 195,
TouchEnd = 196,

NativeGesture = 197, 

RequestSoftwareInputPanel = 199,
CloseSoftwareInputPanel = 200,

UpdateSoftKeys = 201, 

WinIdChange = 203,
Gesture = 198,
GestureOverride = 202,




User = 1000, 
MaxUser = 65535 
};

QEvent(Type type);
virtual ~QEvent();
inline Type type() const { return static_cast<Type>(t); }
inline bool spontaneous() const { return spont; }

inline void setAccepted(bool accepted) { m_accept = accepted; }
inline bool isAccepted() const { return m_accept; }

inline void accept() { m_accept = true; }
inline void ignore() { m_accept = false; }

static int registerEventType(int hint = -1);

protected:
QEventPrivate *d;
ushort t;

private:
ushort posted : 1;
ushort spont : 1;
ushort m_accept : 1;
ushort reserved : 13;

friend class QCoreApplication;
friend class QCoreApplicationPrivate;
friend class QThreadData;
friend class QApplication;
friend class QApplicationPrivate;
friend class Q3AccelManager;
friend class QShortcutMap;
friend class QETWidget;
friend class QGraphicsView;
friend class QGraphicsViewPrivate;
friend class QGraphicsScenePrivate;
friend class QGestureManager;
};

class  QTimerEvent : public QEvent
{
public:
QTimerEvent( int timerId );
~QTimerEvent();
int timerId() const { return id; }
protected:
int id;
};

class QObject;

class  QChildEvent : public QEvent
{
public:
QChildEvent( Type type, QObject *child );
~QChildEvent();
QObject *child() const { return c; }
bool added() const { return type() == ChildAdded; }



# 356 "/usr/share/qt4/include/QtCore/qcoreevent.h"
bool polished() const { return type() == ChildPolished; }
bool removed() const { return type() == ChildRemoved; }
protected:
QObject *c;
};












# 373 "/usr/share/qt4/include/QtCore/qcoreevent.h"
class  QDynamicPropertyChangeEvent : public QEvent
{
public:
QDynamicPropertyChangeEvent(const QByteArray &name);
~QDynamicPropertyChangeEvent();

inline QByteArray propertyName() const { return n; }

private:
QByteArray n;
};






# 46 "/usr/share/qt4/include/QtCore/qcoreapplication.h"

# 1 "/usr/share/qt4/include/QtCore/qeventloop.h"





































































































# 47 "/usr/share/qt4/include/QtCore/qcoreapplication.h"










# 57 "/usr/share/qt4/include/QtCore/qcoreapplication.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QCoreApplicationPrivate;
class QTextCodec;
class QTranslator;
class QPostEventList;
class QStringList;



# 71 "/usr/share/qt4/include/QtCore/qcoreapplication.h"
class  QCoreApplication : public QObject
{
Q_OBJECT
Q_PROPERTY(QString applicationName READ applicationName WRITE setApplicationName)
Q_PROPERTY(QString applicationVersion READ applicationVersion WRITE setApplicationVersion)
Q_PROPERTY(QString organizationName READ organizationName WRITE setOrganizationName)
Q_PROPERTY(QString organizationDomain READ organizationDomain WRITE setOrganizationDomain)

inline QCoreApplicationPrivate* d_func() { return reinterpret_cast<QCoreApplicationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QCoreApplicationPrivate* d_func() const { return reinterpret_cast<const QCoreApplicationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QCoreApplicationPrivate;
public:
QCoreApplication(int &argc, char **argv);
~QCoreApplication();


# 85 "/usr/share/qt4/include/QtCore/qcoreapplication.h"
 static int argc();
 static char **argv();

# 88 "/usr/share/qt4/include/QtCore/qcoreapplication.h"
static QStringList arguments();

static void setAttribute(Qt::ApplicationAttribute attribute, bool on = true);
static bool testAttribute(Qt::ApplicationAttribute attribute);

static void setOrganizationDomain(const QString &orgDomain);
static QString organizationDomain();
static void setOrganizationName(const QString &orgName);
static QString organizationName();
static void setApplicationName(const QString &application);
static QString applicationName();
static void setApplicationVersion(const QString &version);
static QString applicationVersion();

static QCoreApplication *instance() { return self; }

static int exec();
static void processEvents(QEventLoop::ProcessEventsFlags flags = QEventLoop::AllEvents);
static void processEvents(QEventLoop::ProcessEventsFlags flags, int maxtime);
static void exit(int retcode=0);

static bool sendEvent(QObject *receiver, QEvent *event);
static void postEvent(QObject *receiver, QEvent *event);
static void postEvent(QObject *receiver, QEvent *event, int priority);
static void sendPostedEvents(QObject *receiver, int event_type);
static void sendPostedEvents();
static void removePostedEvents(QObject *receiver);
static void removePostedEvents(QObject *receiver, int eventType);
static bool hasPendingEvents();

virtual bool notify(QObject *, QEvent *);

static bool startingUp();
static bool closingDown();

static QString applicationDirPath();
static QString applicationFilePath();
static qint64 applicationPid();


# 128 "/usr/share/qt4/include/QtCore/qcoreapplication.h"
static void setLibraryPaths(const QStringList &);
static QStringList libraryPaths();
static void addLibraryPath(const QString &);
static void removeLibraryPath(const QString &);



# 135 "/usr/share/qt4/include/QtCore/qcoreapplication.h"
static void installTranslator(QTranslator * messageFile);
static void removeTranslator(QTranslator * messageFile);

# 138 "/usr/share/qt4/include/QtCore/qcoreapplication.h"
enum Encoding { CodecForTr, UnicodeUTF8, DefaultCodec = CodecForTr };

static QString translate(const char * context,
const char * key,
const char * disambiguation = 0,
Encoding encoding = CodecForTr);
static QString translate(const char * context,
const char * key,
const char * disambiguation,
Encoding encoding, int n);

static void flush();






















# 172 "/usr/share/qt4/include/QtCore/qcoreapplication.h"
typedef bool (*EventFilter)(void *message, long *result);
EventFilter setEventFilter(EventFilter filter);
bool filterEvent(void *message, long *result);

public slots:
static void quit();

signals:
void aboutToQuit();
void unixSignal(int);

protected:
bool event(QEvent *);

virtual bool compressEvent(QEvent *, QObject *receiver, QPostEventList *);

protected:
QCoreApplication(QCoreApplicationPrivate &p);

private:
static bool sendSpontaneousEvent(QObject *receiver, QEvent *event);
bool notifyInternal(QObject *receiver, QEvent *event);

void init();

static QCoreApplication *self;

QCoreApplication(const QCoreApplication &); QCoreApplication &operator=(const QCoreApplication &);

friend class QEventDispatcherUNIXPrivate;
friend class QApplication;
friend class QApplicationPrivate;
friend class QETWidget;
friend class Q3AccelManager;
friend class QShortcutMap;
friend class QWidget;
friend class QWidgetPrivate;
friend bool qt_sendSpontaneousEvent(QObject*, QEvent*);
friend  QString qAppName();
friend class QClassFactory;
};

inline bool QCoreApplication::sendEvent(QObject *receiver, QEvent *event)
{ if (event) event->spont = false; return self ? self->notifyInternal(receiver, event) : false; }

inline bool QCoreApplication::sendSpontaneousEvent(QObject *receiver, QEvent *event)
{ if (event) event->spont = true; return self ? self->notifyInternal(receiver, event) : false; }

inline void QCoreApplication::sendPostedEvents() { sendPostedEvents(0, 0); }





























# 250 "/usr/share/qt4/include/QtCore/qcoreapplication.h"



# 266 "/usr/share/qt4/include/QtCore/qcoreapplication.h"
typedef void (*QtCleanUpFunction)();

 void qAddPostRoutine(QtCleanUpFunction);
 void qRemovePostRoutine(QtCleanUpFunction);
 QString qAppName(); 






# 277 "/usr/share/qt4/include/QtCore/qcoreapplication.h"





# 38 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qcoreevent.h"
































































































































































































































































































































































































# 39 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qeventloop.h"





































































































# 40 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qmath.h"














































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qmath.h"






# 53 "/usr/share/qt4/include/QtCore/qmath.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 61 "/usr/share/qt4/include/QtCore/qmath.h"
extern  const qreal qt_sine_table[256];

inline int qCeil(qreal v)
{

# 66 "/usr/share/qt4/include/QtCore/qmath.h"
if (sizeof(qreal) == sizeof(float))
return int(ceilf(float(v)));
else

# 70 "/usr/share/qt4/include/QtCore/qmath.h"
return int(ceil(v));
}

inline int qFloor(qreal v)
{

# 76 "/usr/share/qt4/include/QtCore/qmath.h"
if (sizeof(qreal) == sizeof(float))
return int(floorf(float(v)));
else

# 80 "/usr/share/qt4/include/QtCore/qmath.h"
return int(floor(v));
}

inline qreal qFabs(qreal v)
{

# 86 "/usr/share/qt4/include/QtCore/qmath.h"
if(sizeof(qreal) == sizeof(float))
return fabsf(float(v));
else

# 90 "/usr/share/qt4/include/QtCore/qmath.h"
return fabs(v);
}

inline qreal qSin(qreal v)
{






# 101 "/usr/share/qt4/include/QtCore/qmath.h"
if (sizeof(qreal) == sizeof(float))
return sinf(float(v));
else

# 105 "/usr/share/qt4/include/QtCore/qmath.h"
return sin(v);

# 107 "/usr/share/qt4/include/QtCore/qmath.h"
}

inline qreal qCos(qreal v)
{






# 117 "/usr/share/qt4/include/QtCore/qmath.h"
if (sizeof(qreal) == sizeof(float))
return cosf(float(v));
else

# 121 "/usr/share/qt4/include/QtCore/qmath.h"
return cos(v);

# 123 "/usr/share/qt4/include/QtCore/qmath.h"
}

inline qreal qTan(qreal v)
{






# 133 "/usr/share/qt4/include/QtCore/qmath.h"
if (sizeof(qreal) == sizeof(float))
return tanf(float(v));
else

# 137 "/usr/share/qt4/include/QtCore/qmath.h"
return tan(v);

# 139 "/usr/share/qt4/include/QtCore/qmath.h"
}

inline qreal qAcos(qreal v)
{






# 149 "/usr/share/qt4/include/QtCore/qmath.h"
if (sizeof(qreal) == sizeof(float))
return acosf(float(v));
else

# 153 "/usr/share/qt4/include/QtCore/qmath.h"
return acos(v);

# 155 "/usr/share/qt4/include/QtCore/qmath.h"
}

inline qreal qAsin(qreal v)
{






# 165 "/usr/share/qt4/include/QtCore/qmath.h"
if (sizeof(qreal) == sizeof(float))
return asinf(float(v));
else

# 169 "/usr/share/qt4/include/QtCore/qmath.h"
return asin(v);

# 171 "/usr/share/qt4/include/QtCore/qmath.h"
}

inline qreal qAtan(qreal v)
{






# 181 "/usr/share/qt4/include/QtCore/qmath.h"
if(sizeof(qreal) == sizeof(float))
return atanf(float(v));
else

# 185 "/usr/share/qt4/include/QtCore/qmath.h"
return atan(v);

# 187 "/usr/share/qt4/include/QtCore/qmath.h"
}

inline qreal qAtan2(qreal x, qreal y)
{






# 197 "/usr/share/qt4/include/QtCore/qmath.h"
if(sizeof(qreal) == sizeof(float))
return atan2f(float(x), float(y));
else

# 201 "/usr/share/qt4/include/QtCore/qmath.h"
return atan2(x, y);

# 203 "/usr/share/qt4/include/QtCore/qmath.h"
}

inline qreal qSqrt(qreal v)
{






# 213 "/usr/share/qt4/include/QtCore/qmath.h"
if (sizeof(qreal) == sizeof(float))
return sqrtf(float(v));
else

# 217 "/usr/share/qt4/include/QtCore/qmath.h"
return sqrt(v);

# 219 "/usr/share/qt4/include/QtCore/qmath.h"
}

inline qreal qLn(qreal v)
{

# 224 "/usr/share/qt4/include/QtCore/qmath.h"
if (sizeof(qreal) == sizeof(float))
return logf(float(v));
else

# 228 "/usr/share/qt4/include/QtCore/qmath.h"
return log(v);
}

inline qreal qExp(qreal v)
{





# 238 "/usr/share/qt4/include/QtCore/qmath.h"


return exp(v);

# 242 "/usr/share/qt4/include/QtCore/qmath.h"
}

inline qreal qPow(qreal x, qreal y)
{






# 252 "/usr/share/qt4/include/QtCore/qmath.h"
if (sizeof(qreal) == sizeof(float))
return powf(float(x), float(y));
else

# 256 "/usr/share/qt4/include/QtCore/qmath.h"
return pow(x, y);

# 258 "/usr/share/qt4/include/QtCore/qmath.h"
}





# 264 "/usr/share/qt4/include/QtCore/qmath.h"
inline qreal qFastSin(qreal x)
{
int si = int(x * (0.5 * 256 / (3.14159265358979323846))); 
qreal d = x - si * (2.0 * (3.14159265358979323846) / 256);
int ci = si + 256 / 4;
si &= 256 - 1;
ci &= 256 - 1;
return qt_sine_table[si] + (qt_sine_table[ci] - 0.5 * qt_sine_table[si] * d) * d;
}

inline qreal qFastCos(qreal x)
{
int ci = int(x * (0.5 * 256 / (3.14159265358979323846))); 
qreal d = x - ci * (2.0 * (3.14159265358979323846) / 256);
int si = ci + 256 / 4;
si &= 256 - 1;
ci &= 256 - 1;
return qt_sine_table[si] - (qt_sine_table[ci] + 0.5 * qt_sine_table[si] * d) * d;
}






# 41 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qmetaobject.h"












































# 1 "/usr/share/qt4/include/QtCore/qobjectdefs.h"































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qmetaobject.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qmetaobject.h"


# 48 "/usr/share/qt4/include/QtCore/qmetaobject.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

template <typename T> class QList;

class  QMetaMethod
{
public:
inline QMetaMethod() : mobj(0),handle(0) {}

const char *signature() const;
const char *typeName() const;
QList<QByteArray> parameterTypes() const;
QList<QByteArray> parameterNames() const;
const char *tag() const;
enum Access { Private, Protected, Public };
Access access() const;
enum MethodType { Method, Signal, Slot, Constructor };
MethodType methodType() const;
enum Attributes { Compatibility = 0x1, Cloned = 0x2, Scriptable = 0x4 };
int attributes() const;
int methodIndex() const;

inline const QMetaObject *enclosingMetaObject() const { return mobj; }

bool invoke(QObject *object,
Qt::ConnectionType connectionType,
QGenericReturnArgument returnValue,
QGenericArgument val0 = QGenericArgument(0),
QGenericArgument val1 = QGenericArgument(),
QGenericArgument val2 = QGenericArgument(),
QGenericArgument val3 = QGenericArgument(),
QGenericArgument val4 = QGenericArgument(),
QGenericArgument val5 = QGenericArgument(),
QGenericArgument val6 = QGenericArgument(),
QGenericArgument val7 = QGenericArgument(),
QGenericArgument val8 = QGenericArgument(),
QGenericArgument val9 = QGenericArgument()) const;
inline bool invoke(QObject *object,
QGenericReturnArgument returnValue,
QGenericArgument val0 = QGenericArgument(0),
QGenericArgument val1 = QGenericArgument(),
QGenericArgument val2 = QGenericArgument(),
QGenericArgument val3 = QGenericArgument(),
QGenericArgument val4 = QGenericArgument(),
QGenericArgument val5 = QGenericArgument(),
QGenericArgument val6 = QGenericArgument(),
QGenericArgument val7 = QGenericArgument(),
QGenericArgument val8 = QGenericArgument(),
QGenericArgument val9 = QGenericArgument()) const
{
return invoke(object, Qt::AutoConnection, returnValue,
val0, val1, val2, val3, val4, val5, val6, val7, val8, val9);
}
inline bool invoke(QObject *object,
Qt::ConnectionType connectionType,
QGenericArgument val0 = QGenericArgument(0),
QGenericArgument val1 = QGenericArgument(),
QGenericArgument val2 = QGenericArgument(),
QGenericArgument val3 = QGenericArgument(),
QGenericArgument val4 = QGenericArgument(),
QGenericArgument val5 = QGenericArgument(),
QGenericArgument val6 = QGenericArgument(),
QGenericArgument val7 = QGenericArgument(),
QGenericArgument val8 = QGenericArgument(),
QGenericArgument val9 = QGenericArgument()) const
{
return invoke(object, connectionType, QGenericReturnArgument(),
val0, val1, val2, val3, val4, val5, val6, val7, val8, val9);
}
inline bool invoke(QObject *object,
QGenericArgument val0 = QGenericArgument(0),
QGenericArgument val1 = QGenericArgument(),
QGenericArgument val2 = QGenericArgument(),
QGenericArgument val3 = QGenericArgument(),
QGenericArgument val4 = QGenericArgument(),
QGenericArgument val5 = QGenericArgument(),
QGenericArgument val6 = QGenericArgument(),
QGenericArgument val7 = QGenericArgument(),
QGenericArgument val8 = QGenericArgument(),
QGenericArgument val9 = QGenericArgument()) const
{
return invoke(object, Qt::AutoConnection, QGenericReturnArgument(),
val0, val1, val2, val3, val4, val5, val6, val7, val8, val9);
}

private:
const QMetaObject *mobj;
uint handle;
friend struct QMetaObject;
};
template <> class QTypeInfo<QMetaMethod > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMetaMethod)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QMetaMethod"; } };

class  QMetaEnum
{
public:
inline QMetaEnum() : mobj(0),handle(0) {}

const char *name() const;
bool isFlag() const;

int keyCount() const;
const char *key(int index) const;
int value(int index) const;

const char *scope() const;

int keyToValue(const char *key) const;
const char* valueToKey(int value) const;
int keysToValue(const char * keys) const;
QByteArray valueToKeys(int value) const;

inline const QMetaObject *enclosingMetaObject() const { return mobj; }

inline bool isValid() const { return name() != 0; }
private:
const QMetaObject *mobj;
uint handle;
friend struct QMetaObject;
};
template <> class QTypeInfo<QMetaEnum > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMetaEnum)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QMetaEnum"; } };

class  QMetaProperty
{
public:
QMetaProperty();

const char *name() const;
const char *typeName() const;
QVariant::Type type() const;
int userType() const;
int propertyIndex() const;

bool isReadable() const;
bool isWritable() const;
bool isResettable() const;
bool isDesignable(const QObject *obj = 0) const;
bool isScriptable(const QObject *obj = 0) const;
bool isStored(const QObject *obj = 0) const;
bool isEditable(const QObject *obj = 0) const;
bool isUser(const QObject *obj = 0) const;
bool isConstant() const;
bool isFinal() const;

bool isFlagType() const;
bool isEnumType() const;
QMetaEnum enumerator() const;

bool hasNotifySignal() const;
QMetaMethod notifySignal() const;
int notifySignalIndex() const;

QVariant read(const QObject *obj) const;
bool write(QObject *obj, const QVariant &value) const;
bool reset(QObject *obj) const;

bool hasStdCppSet() const;
inline bool isValid() const { return isReadable(); }
inline const QMetaObject *enclosingMetaObject() const { return mobj; }

private:
const QMetaObject *mobj;
uint handle;
int idx;
QMetaEnum menum;
friend struct QMetaObject;
};

class  QMetaClassInfo
{
public:
inline QMetaClassInfo() : mobj(0),handle(0) {}
const char *name() const;
const char *value() const;
inline const QMetaObject *enclosingMetaObject() const { return mobj; }
private:
const QMetaObject *mobj;
uint handle;
friend struct QMetaObject;
};
template <> class QTypeInfo<QMetaClassInfo > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMetaClassInfo)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QMetaClassInfo"; } };






# 42 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qmetatype.h"































































































































































































































































































































































# 43 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qmimedata.h"












































# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qmimedata.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qmimedata.h"


# 48 "/usr/share/qt4/include/QtCore/qmimedata.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QUrl;
class QMimeDataPrivate;

class  QMimeData : public QObject
{
Q_OBJECT
public:
QMimeData();
~QMimeData();

QList<QUrl> urls() const;
void setUrls(const QList<QUrl> &urls);
bool hasUrls() const;

QString text() const;
void setText(const QString &text);
bool hasText() const;

QString html() const;
void setHtml(const QString &html);
bool hasHtml() const;

QVariant imageData() const;
void setImageData(const QVariant &image);
bool hasImage() const;

QVariant colorData() const;
void setColorData(const QVariant &color);
bool hasColor() const;

QByteArray data(const QString &mimetype) const;
void setData(const QString &mimetype, const QByteArray &data);
void removeFormat(const QString &mimetype);

virtual bool hasFormat(const QString &mimetype) const;
virtual QStringList formats() const;

void clear();
protected:
virtual QVariant retrieveData(const QString &mimetype,
QVariant::Type preferredType) const;
private:
QMimeData(const QMimeData &); QMimeData &operator=(const QMimeData &);
inline QMimeDataPrivate* d_func() { return reinterpret_cast<QMimeDataPrivate *>(qGetPtrHelper(d_ptr)); } inline const QMimeDataPrivate* d_func() const { return reinterpret_cast<const QMimeDataPrivate *>(qGetPtrHelper(d_ptr)); } friend class QMimeDataPrivate;
};






# 44 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qobjectcleanuphandler.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qobjectcleanuphandler.h"


# 47 "/usr/share/qt4/include/QtCore/qobjectcleanuphandler.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class  QObjectCleanupHandler : public QObject
{
Q_OBJECT

public:
QObjectCleanupHandler();
~QObjectCleanupHandler();

QObject* add(QObject* object);
void remove(QObject *object);
bool isEmpty() const;
void clear();

private:

QObjectList cleanupObjects;

private slots:
void objectDestroyed(QObject *);
};






# 46 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qobjectdefs.h"































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qpointer.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qpointer.h"


# 47 "/usr/share/qt4/include/QtCore/qpointer.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

template <class T>
class QPointer
{
QObject *o;
public:
inline QPointer() : o(0) {}
inline QPointer(T *p) : o(p)
{ QMetaObject::addGuard(&o); }
inline QPointer(const QPointer<T> &p) : o(p.o)
{ QMetaObject::addGuard(&o); }
inline ~QPointer()
{ QMetaObject::removeGuard(&o); }
inline QPointer<T> &operator=(const QPointer<T> &p)
{ if (this != &p) QMetaObject::changeGuard(&o, p.o); return *this; }
inline QPointer<T> &operator=(T* p)
{ if (o != p) QMetaObject::changeGuard(&o, p); return *this; }

inline bool isNull() const
{ return !o; }

inline T* operator->() const
{ return static_cast<T*>(const_cast<QObject*>(o)); }
inline T& operator*() const
{ return *static_cast<T*>(const_cast<QObject*>(o)); }
inline operator T*() const
{ return static_cast<T*>(const_cast<QObject*>(o)); }
inline T* data() const
{ return static_cast<T*>(const_cast<QObject*>(o)); }
};




# 86 "/usr/share/qt4/include/QtCore/qpointer.h"
template <class T>
inline bool operator==(const T *o, const QPointer<T> &p)
{ return o == p.operator->(); }

template<class T>
inline bool operator==(const QPointer<T> &p, const T *o)
{ return p.operator->() == o; }













# 106 "/usr/share/qt4/include/QtCore/qpointer.h"
template <class T>
inline bool operator==(T *o, const QPointer<T> &p)
{ return o == p.operator->(); }

template<class T>
inline bool operator==(const QPointer<T> &p, T *o)
{ return p.operator->() == o; }

template<class T>
inline bool operator==(const QPointer<T> &p1, const QPointer<T> &p2)
{ return p1.operator->() == p2.operator->(); }




# 121 "/usr/share/qt4/include/QtCore/qpointer.h"
template <class T>
inline bool operator!=(const T *o, const QPointer<T> &p)
{ return o != p.operator->(); }

template<class T>
inline bool operator!= (const QPointer<T> &p, const T *o)
{ return p.operator->() != o; }













# 141 "/usr/share/qt4/include/QtCore/qpointer.h"
template <class T>
inline bool operator!=(T *o, const QPointer<T> &p)
{ return o != p.operator->(); }

template<class T>
inline bool operator!= (const QPointer<T> &p, T *o)
{ return p.operator->() != o; }

template<class T>
inline bool operator!= (const QPointer<T> &p1, const QPointer<T> &p2)
{ return p1.operator->() != p2.operator->() ; }












# 164 "/usr/share/qt4/include/QtCore/qpointer.h"





# 48 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qsharedmemory.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qsharedmemory.h"


# 47 "/usr/share/qt4/include/QtCore/qsharedmemory.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qsharedmemory.h"
class QSharedMemoryPrivate;

class  QSharedMemory : public QObject
{
Q_OBJECT
inline QSharedMemoryPrivate* d_func() { return reinterpret_cast<QSharedMemoryPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSharedMemoryPrivate* d_func() const { return reinterpret_cast<const QSharedMemoryPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSharedMemoryPrivate;

public:
enum AccessMode
{
ReadOnly,
ReadWrite
};

enum SharedMemoryError
{
NoError,
PermissionDenied,
InvalidSize,
KeyError,
AlreadyExists,
NotFound,
LockError,
OutOfResources,
UnknownError
};

QSharedMemory(QObject *parent = 0);
QSharedMemory(const QString &key, QObject *parent = 0);
~QSharedMemory();

void setKey(const QString &key);
QString key() const;

bool create(int size, AccessMode mode = ReadWrite);
int size() const;

bool attach(AccessMode mode = ReadWrite);
bool isAttached() const;
bool detach();

void *data();
const void* constData() const;
const void *data() const;


# 101 "/usr/share/qt4/include/QtCore/qsharedmemory.h"
bool lock();
bool unlock();


# 105 "/usr/share/qt4/include/QtCore/qsharedmemory.h"
SharedMemoryError error() const;
QString errorString() const;

private:
QSharedMemory(const QSharedMemory &); QSharedMemory &operator=(const QSharedMemory &);
};



# 114 "/usr/share/qt4/include/QtCore/qsharedmemory.h"






# 49 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qsignalmapper.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qsignalmapper.h"


# 47 "/usr/share/qt4/include/QtCore/qsignalmapper.h"




typedef QtValidLicenseForCoreModule QtCoreModule;


# 54 "/usr/share/qt4/include/QtCore/qsignalmapper.h"
class QSignalMapperPrivate;

class  QSignalMapper : public QObject
{
Q_OBJECT
inline QSignalMapperPrivate* d_func() { return reinterpret_cast<QSignalMapperPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSignalMapperPrivate* d_func() const { return reinterpret_cast<const QSignalMapperPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSignalMapperPrivate;
public:
explicit QSignalMapper(QObject *parent = 0);
~QSignalMapper();

void setMapping(QObject *sender, int id);
void setMapping(QObject *sender, const QString &text);
void setMapping(QObject *sender, QWidget *widget);
void setMapping(QObject *sender, QObject *object);
void removeMappings(QObject *sender);

QObject *mapping(int id) const;
QObject *mapping(const QString &text) const;
QObject *mapping(QWidget *widget) const;
QObject *mapping(QObject *object) const;

signals:
void mapped(int);
void mapped(const QString &);
void mapped(QWidget *);
void mapped(QObject *);

public slots:
void map();
void map(QObject *sender);

private:
QSignalMapper(const QSignalMapper &); QSignalMapper &operator=(const QSignalMapper &);






# 93 "/usr/share/qt4/include/QtCore/qsignalmapper.h"
};


# 96 "/usr/share/qt4/include/QtCore/qsignalmapper.h"





# 50 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qsocketnotifier.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qsocketnotifier.h"


# 47 "/usr/share/qt4/include/QtCore/qsocketnotifier.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class  QSocketNotifier : public QObject
{
Q_OBJECT
inline QObjectPrivate* d_func() { return reinterpret_cast<QObjectPrivate *>(qGetPtrHelper(d_ptr)); } inline const QObjectPrivate* d_func() const { return reinterpret_cast<const QObjectPrivate *>(qGetPtrHelper(d_ptr)); } friend class QObjectPrivate;

public:
enum Type { Read, Write, Exception };

QSocketNotifier(int socket, Type, QObject *parent = 0);



# 65 "/usr/share/qt4/include/QtCore/qsocketnotifier.h"
~QSocketNotifier();

inline int socket() const { return sockfd; }
inline Type type() const { return sntype; }

inline bool isEnabled() const { return snenabled; }

public slots:
void setEnabled(bool);

signals:
void activated(int socket);

protected:
bool event(QEvent *);

private:
QSocketNotifier(const QSocketNotifier &); QSocketNotifier &operator=(const QSocketNotifier &);

int sockfd;
Type sntype;
bool snenabled;
};






# 51 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qsystemsemaphore.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qsystemsemaphore.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 46 "/usr/share/qt4/include/QtCore/qsystemsemaphore.h"


# 48 "/usr/share/qt4/include/QtCore/qsystemsemaphore.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 56 "/usr/share/qt4/include/QtCore/qsystemsemaphore.h"
class QSystemSemaphorePrivate;

class  QSystemSemaphore
{

public:
enum AccessMode
{
Open,
Create
};

enum SystemSemaphoreError
{
NoError,
PermissionDenied,
KeyError,
AlreadyExists,
NotFound,
OutOfResources,
UnknownError
};

QSystemSemaphore(const QString &key, int initialValue = 0, AccessMode mode = Open);
~QSystemSemaphore();

void setKey(const QString &key, int initialValue = 0, AccessMode mode = Open);
QString key() const;

bool acquire();
bool release(int n = 1);

SystemSemaphoreError error() const;
QString errorString() const;

private:
QSystemSemaphore(const QSystemSemaphore &); QSystemSemaphore &operator=(const QSystemSemaphore &);
QScopedPointer<QSystemSemaphorePrivate> d;
};



# 98 "/usr/share/qt4/include/QtCore/qsystemsemaphore.h"






# 52 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtimer.h"














































# 1 "/usr/share/qt4/include/QtCore/qbasictimer.h"










































































# 47 "/usr/share/qt4/include/QtCore/qtimer.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtCore/qtimer.h"


# 50 "/usr/share/qt4/include/QtCore/qtimer.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class  QTimer : public QObject
{
Q_OBJECT
Q_PROPERTY(bool singleShot READ isSingleShot WRITE setSingleShot)
Q_PROPERTY(int interval READ interval WRITE setInterval)
Q_PROPERTY(bool active READ isActive)
public:
explicit QTimer(QObject *parent = 0);



# 67 "/usr/share/qt4/include/QtCore/qtimer.h"
~QTimer();

inline bool isActive() const { return id >= 0; }
int timerId() const { return id; }

void setInterval(int msec);
int interval() const { return inter; }

inline void setSingleShot(bool singleShot);
inline bool isSingleShot() const { return single; }

static void singleShot(int msec, QObject *receiver, const char *member);

public slots:
void start(int msec);

void start();
void stop();






# 91 "/usr/share/qt4/include/QtCore/qtimer.h"
signals:
void timeout();

protected:
void timerEvent(QTimerEvent *);

private:
QTimer(const QTimer &); QTimer &operator=(const QTimer &);

inline int startTimer(int){ return -1;}
inline void killTimer(int){}

int id, inter, del;
uint single : 1;
uint nulltimer : 1;
};

inline void QTimer::setSingleShot(bool asingleShot) { single = asingleShot; }








# 53 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtranslator.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtranslator.h"

# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qtranslator.h"


# 48 "/usr/share/qt4/include/QtCore/qtranslator.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 56 "/usr/share/qt4/include/QtCore/qtranslator.h"
class QTranslatorPrivate;

class  QTranslator : public QObject
{
Q_OBJECT
public:
explicit QTranslator(QObject *parent = 0);



# 66 "/usr/share/qt4/include/QtCore/qtranslator.h"
~QTranslator();


virtual QString translate(const char *context, const char *sourceText,
const char *disambiguation = 0) const;
QString translate(const char *context, const char *sourceText, const char *disambiguation,
int n) const;

virtual bool isEmpty() const;

bool load(const QString & filename,
const QString & directory = QString(),
const QString & search_delimiters = QString(),
const QString & suffix = QString());
bool load(const uchar *data, int len);






# 87 "/usr/share/qt4/include/QtCore/qtranslator.h"
private:
QTranslator(const QTranslator &); QTranslator &operator=(const QTranslator &);
inline QTranslatorPrivate* d_func() { return reinterpret_cast<QTranslatorPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTranslatorPrivate* d_func() const { return reinterpret_cast<const QTranslatorPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTranslatorPrivate;
};



# 94 "/usr/share/qt4/include/QtCore/qtranslator.h"





# 54 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 55 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtextcodec.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtextcodec.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qtextcodec.h"


# 48 "/usr/share/qt4/include/QtCore/qtextcodec.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 56 "/usr/share/qt4/include/QtCore/qtextcodec.h"
class QTextCodec;
class QIODevice;

class QTextDecoder;
class QTextEncoder;

class  QTextCodec
{
QTextCodec(const QTextCodec &); QTextCodec &operator=(const QTextCodec &);
public:
static QTextCodec* codecForName(const QByteArray &name);
static QTextCodec* codecForName(const char *name) { return codecForName(QByteArray(name)); }
static QTextCodec* codecForMib(int mib);

static QList<QByteArray> availableCodecs();
static QList<int> availableMibs();

static QTextCodec* codecForLocale();
static void setCodecForLocale(QTextCodec *c);

static QTextCodec* codecForTr();
static void setCodecForTr(QTextCodec *c);

static QTextCodec* codecForCStrings();
static void setCodecForCStrings(QTextCodec *c);

static QTextCodec *codecForHtml(const QByteArray &ba);
static QTextCodec *codecForHtml(const QByteArray &ba, QTextCodec *defaultCodec);

static QTextCodec *codecForUtfText(const QByteArray &ba);
static QTextCodec *codecForUtfText(const QByteArray &ba, QTextCodec *defaultCodec);

QTextDecoder* makeDecoder() const;
QTextEncoder* makeEncoder() const;

bool canEncode(QChar) const;
bool canEncode(const QString&) const;

QString toUnicode(const QByteArray&) const;
QString toUnicode(const char* chars) const;
QByteArray fromUnicode(const QString& uc) const;
enum ConversionFlag {
DefaultConversion,
ConvertInvalidToNull = 0x80000000,
IgnoreHeader = 0x1,
FreeFunction = 0x2
};
typedef QFlags<ConversionFlag> ConversionFlags;

struct  ConverterState {
ConverterState(ConversionFlags f = DefaultConversion)
: flags(f), remainingChars(0), invalidChars(0), d(0) { state_data[0] = state_data[1] = state_data[2] = 0; }
~ConverterState();
ConversionFlags flags;
int remainingChars;
int invalidChars;
uint state_data[3];
void *d;
private:
ConverterState(const ConverterState &); ConverterState &operator=(const ConverterState &);
};

QString toUnicode(const char *in, int length, ConverterState *state = 0) const
{ return convertToUnicode(in, length, state); }
QByteArray fromUnicode(const QChar *in, int length, ConverterState *state = 0) const
{ return convertFromUnicode(in, length, state); }

virtual QByteArray name() const = 0;
virtual QList<QByteArray> aliases() const;
virtual int mibEnum() const = 0;

protected:
virtual QString convertToUnicode(const char *in, int length, ConverterState *state) const = 0;
virtual QByteArray convertFromUnicode(const QChar *in, int length, ConverterState *state) const = 0;

QTextCodec();
virtual ~QTextCodec();

public:










# 145 "/usr/share/qt4/include/QtCore/qtextcodec.h"
private:
friend class QTextCodecCleanup;
static QTextCodec *cftr;
};
inline QFlags<QTextCodec::ConversionFlags::enum_type> operator|(QTextCodec::ConversionFlags::enum_type f1, QTextCodec::ConversionFlags::enum_type f2) { return QFlags<QTextCodec::ConversionFlags::enum_type>(f1) | f2; } inline QFlags<QTextCodec::ConversionFlags::enum_type> operator|(QTextCodec::ConversionFlags::enum_type f1, QFlags<QTextCodec::ConversionFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTextCodec::ConversionFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

inline QTextCodec* QTextCodec::codecForTr() { return cftr; }
inline void QTextCodec::setCodecForTr(QTextCodec *c) { cftr = c; }
inline QTextCodec* QTextCodec::codecForCStrings() { return QString::codecForCStrings; }
inline void QTextCodec::setCodecForCStrings(QTextCodec *c) { QString::codecForCStrings = c; }

class  QTextEncoder {
QTextEncoder(const QTextEncoder &); QTextEncoder &operator=(const QTextEncoder &);
public:
explicit QTextEncoder(const QTextCodec *codec) : c(codec), state() {}
~QTextEncoder();
QByteArray fromUnicode(const QString& str);
QByteArray fromUnicode(const QChar *uc, int len);



# 166 "/usr/share/qt4/include/QtCore/qtextcodec.h"
bool hasFailure() const;
private:
const QTextCodec *c;
QTextCodec::ConverterState state;

friend class QXmlStreamWriter;
friend class QXmlStreamWriterPrivate;
friend class QCoreXmlStreamWriter;
friend class QCoreXmlStreamWriterPrivate;
};

class  QTextDecoder {
QTextDecoder(const QTextDecoder &); QTextDecoder &operator=(const QTextDecoder &);
public:
explicit QTextDecoder(const QTextCodec *codec) : c(codec), state() {}
~QTextDecoder();
QString toUnicode(const char* chars, int len);
QString toUnicode(const QByteArray &ba);
void toUnicode(QString *target, const char *chars, int len);
bool hasFailure() const;
private:
const QTextCodec *c;
QTextCodec::ConverterState state;
};



# 193 "/usr/share/qt4/include/QtCore/qtextcodec.h"





# 56 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtextcodecplugin.h"












































# 1 "/usr/share/qt4/include/QtCore/qplugin.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qplugin.h"

# 1 "/usr/share/qt4/include/QtCore/qpointer.h"








































































































































































# 46 "/usr/share/qt4/include/QtCore/qplugin.h"


# 48 "/usr/share/qt4/include/QtCore/qplugin.h"




typedef QtValidLicenseForCoreModule QtCoreModule;









# 62 "/usr/share/qt4/include/QtCore/qplugin.h"
typedef QObject *(*QtPluginInstanceFunction)();

void  qRegisterStaticPluginInstanceFunction(QtPluginInstanceFunction function);
















# 101 "/usr/share/qt4/include/QtCore/qplugin.h"

























# 137 "/usr/share/qt4/include/QtCore/qplugin.h"





# 45 "/usr/share/qt4/include/QtCore/qtextcodecplugin.h"

# 1 "/usr/share/qt4/include/QtCore/qfactoryinterface.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qfactoryinterface.h"

# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"



































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qfactoryinterface.h"


# 48 "/usr/share/qt4/include/QtCore/qfactoryinterface.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

struct  QFactoryInterface
{
virtual ~QFactoryInterface() {}
virtual QStringList keys() const = 0;
};


template <> inline const char *qobject_interface_iid<QFactoryInterface *>() { return "com.trolltech.Qt.QFactoryInterface"; } template <> inline QFactoryInterface *qobject_cast<QFactoryInterface *>(QObject *object) { return reinterpret_cast<QFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QFactoryInterface") : 0)); } template <> inline QFactoryInterface *qobject_cast<QFactoryInterface *>(const QObject *object) { return reinterpret_cast<QFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QFactoryInterface") : 0)); }






# 46 "/usr/share/qt4/include/QtCore/qtextcodecplugin.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qtextcodecplugin.h"

# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtCore/qtextcodecplugin.h"


# 50 "/usr/share/qt4/include/QtCore/qtextcodecplugin.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 58 "/usr/share/qt4/include/QtCore/qtextcodecplugin.h"
class QTextCodec;

struct  QTextCodecFactoryInterface : public QFactoryInterface
{
virtual QTextCodec *create(const QString &key) = 0;
};



# 67 "/usr/share/qt4/include/QtCore/qtextcodecplugin.h"
template <> inline const char *qobject_interface_iid<QTextCodecFactoryInterface *>() { return "com.trolltech.Qt.QTextCodecFactoryInterface"; } template <> inline QTextCodecFactoryInterface *qobject_cast<QTextCodecFactoryInterface *>(QObject *object) { return reinterpret_cast<QTextCodecFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QTextCodecFactoryInterface") : 0)); } template <> inline QTextCodecFactoryInterface *qobject_cast<QTextCodecFactoryInterface *>(const QObject *object) { return reinterpret_cast<QTextCodecFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QTextCodecFactoryInterface") : 0)); }


class  QTextCodecPlugin : public QObject, public QTextCodecFactoryInterface
{
Q_OBJECT

public:
explicit QTextCodecPlugin(QObject *parent = 0);
~QTextCodecPlugin();

virtual QList<QByteArray> names() const = 0;
virtual QList<QByteArray> aliases() const = 0;
virtual QTextCodec *createForName(const QByteArray &name) = 0;

virtual QList<int> mibEnums() const = 0;
virtual QTextCodec *createForMib(int mib) = 0;

private:
QStringList keys() const;
QTextCodec *create(const QString &name);
};



# 92 "/usr/share/qt4/include/QtCore/qtextcodecplugin.h"





# 57 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qabstractstate.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qabstractstate.h"


# 47 "/usr/share/qt4/include/QtCore/qabstractstate.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qabstractstate.h"
class QState;
class QStateMachine;

class QAbstractStatePrivate;
class  QAbstractState : public QObject
{
Q_OBJECT
public:
~QAbstractState();

QState *parentState() const;
QStateMachine *machine() const;

signals:

# 70 "/usr/share/qt4/include/QtCore/qabstractstate.h"
private: 

# 72 "/usr/share/qt4/include/QtCore/qabstractstate.h"
void entered();
void exited();

protected:
QAbstractState(QState *parent = 0);

virtual void onEntry(QEvent *event) = 0;
virtual void onExit(QEvent *event) = 0;

bool event(QEvent *e);

protected:
QAbstractState(QAbstractStatePrivate &dd, QState *parent);

private:
QAbstractState(const QAbstractState &); QAbstractState &operator=(const QAbstractState &);
inline QAbstractStatePrivate* d_func() { return reinterpret_cast<QAbstractStatePrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractStatePrivate* d_func() const { return reinterpret_cast<const QAbstractStatePrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractStatePrivate;
};



# 93 "/usr/share/qt4/include/QtCore/qabstractstate.h"





# 58 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qabstracttransition.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qabstracttransition.h"


# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qabstracttransition.h"


# 49 "/usr/share/qt4/include/QtCore/qabstracttransition.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 57 "/usr/share/qt4/include/QtCore/qabstracttransition.h"
class QEvent;
class QAbstractState;
class QState;
class QStateMachine;


# 63 "/usr/share/qt4/include/QtCore/qabstracttransition.h"
class QAbstractAnimation;


# 66 "/usr/share/qt4/include/QtCore/qabstracttransition.h"
class QAbstractTransitionPrivate;
class  QAbstractTransition : public QObject
{
Q_OBJECT
Q_PROPERTY(QState* sourceState READ sourceState)
Q_PROPERTY(QAbstractState* targetState READ targetState WRITE setTargetState)
Q_PROPERTY(QList<QAbstractState*> targetStates READ targetStates WRITE setTargetStates)
public:
QAbstractTransition(QState *sourceState = 0);
virtual ~QAbstractTransition();

QState *sourceState() const;
QAbstractState *targetState() const;
void setTargetState(QAbstractState* target);
QList<QAbstractState*> targetStates() const;
void setTargetStates(const QList<QAbstractState*> &targets);

QStateMachine *machine() const;


# 86 "/usr/share/qt4/include/QtCore/qabstracttransition.h"
void addAnimation(QAbstractAnimation *animation);
void removeAnimation(QAbstractAnimation *animation);
QList<QAbstractAnimation*> animations() const;


# 91 "/usr/share/qt4/include/QtCore/qabstracttransition.h"
signals:

# 93 "/usr/share/qt4/include/QtCore/qabstracttransition.h"
private: 

# 95 "/usr/share/qt4/include/QtCore/qabstracttransition.h"
void triggered();

protected:
virtual bool eventTest(QEvent *event) = 0;

virtual void onTransition(QEvent *event) = 0;

bool event(QEvent *e);

protected:
QAbstractTransition(QAbstractTransitionPrivate &dd, QState *parent);

private:
QAbstractTransition(const QAbstractTransition &); QAbstractTransition &operator=(const QAbstractTransition &);
inline QAbstractTransitionPrivate* d_func() { return reinterpret_cast<QAbstractTransitionPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractTransitionPrivate* d_func() const { return reinterpret_cast<const QAbstractTransitionPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractTransitionPrivate;
};



# 114 "/usr/share/qt4/include/QtCore/qabstracttransition.h"





# 59 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qeventtransition.h"












































# 1 "/usr/share/qt4/include/QtCore/qabstracttransition.h"






















































































































# 45 "/usr/share/qt4/include/QtCore/qeventtransition.h"

# 1 "/usr/share/qt4/include/QtCore/qcoreevent.h"
































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qeventtransition.h"


# 48 "/usr/share/qt4/include/QtCore/qeventtransition.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 56 "/usr/share/qt4/include/QtCore/qeventtransition.h"
class QEventTransitionPrivate;
class  QEventTransition : public QAbstractTransition
{
Q_OBJECT
Q_PROPERTY(QObject* eventSource READ eventSource WRITE setEventSource)
Q_PROPERTY(QEvent::Type eventType READ eventType WRITE setEventType)
public:
QEventTransition(QState *sourceState = 0);
QEventTransition(QObject *object, QEvent::Type type, QState *sourceState = 0);
~QEventTransition();

QObject *eventSource() const;
void setEventSource(QObject *object);

QEvent::Type eventType() const;
void setEventType(QEvent::Type type);

protected:
bool eventTest(QEvent *event);
void onTransition(QEvent *event);

bool event(QEvent *e);

protected:
QEventTransition(QEventTransitionPrivate &dd, QState *parent);
QEventTransition(QEventTransitionPrivate &dd, QObject *object,
QEvent::Type type, QState *parent);

private:
QEventTransition(const QEventTransition &); QEventTransition &operator=(const QEventTransition &);
inline QEventTransitionPrivate* d_func() { return reinterpret_cast<QEventTransitionPrivate *>(qGetPtrHelper(d_ptr)); } inline const QEventTransitionPrivate* d_func() const { return reinterpret_cast<const QEventTransitionPrivate *>(qGetPtrHelper(d_ptr)); } friend class QEventTransitionPrivate;
};



# 91 "/usr/share/qt4/include/QtCore/qeventtransition.h"





# 60 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qfinalstate.h"












































# 1 "/usr/share/qt4/include/QtCore/qabstractstate.h"

































































































# 45 "/usr/share/qt4/include/QtCore/qfinalstate.h"


# 47 "/usr/share/qt4/include/QtCore/qfinalstate.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qfinalstate.h"
class QFinalStatePrivate;
class  QFinalState : public QAbstractState
{
Q_OBJECT
public:
QFinalState(QState *parent = 0);
~QFinalState();

protected:
void onEntry(QEvent *event);
void onExit(QEvent *event);

bool event(QEvent *e);

private:
QFinalState(const QFinalState &); QFinalState &operator=(const QFinalState &);
inline QFinalStatePrivate* d_func() { return reinterpret_cast<QFinalStatePrivate *>(qGetPtrHelper(d_ptr)); } inline const QFinalStatePrivate* d_func() const { return reinterpret_cast<const QFinalStatePrivate *>(qGetPtrHelper(d_ptr)); } friend class QFinalStatePrivate;
};



# 76 "/usr/share/qt4/include/QtCore/qfinalstate.h"





# 61 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qhistorystate.h"












































# 1 "/usr/share/qt4/include/QtCore/qabstractstate.h"

































































































# 45 "/usr/share/qt4/include/QtCore/qhistorystate.h"


# 47 "/usr/share/qt4/include/QtCore/qhistorystate.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qhistorystate.h"
class QHistoryStatePrivate;
class  QHistoryState : public QAbstractState
{
Q_OBJECT
Q_PROPERTY(QAbstractState* defaultState READ defaultState WRITE setDefaultState)
Q_PROPERTY(HistoryType historyType READ historyType WRITE setHistoryType)
Q_ENUMS(HistoryType)
public:
enum HistoryType {
ShallowHistory,
DeepHistory
};

QHistoryState(QState *parent = 0);
QHistoryState(HistoryType type, QState *parent = 0);
~QHistoryState();

QAbstractState *defaultState() const;
void setDefaultState(QAbstractState *state);

HistoryType historyType() const;
void setHistoryType(HistoryType type);

protected:
void onEntry(QEvent *event);
void onExit(QEvent *event);

bool event(QEvent *e);

private:
QHistoryState(const QHistoryState &); QHistoryState &operator=(const QHistoryState &);
inline QHistoryStatePrivate* d_func() { return reinterpret_cast<QHistoryStatePrivate *>(qGetPtrHelper(d_ptr)); } inline const QHistoryStatePrivate* d_func() const { return reinterpret_cast<const QHistoryStatePrivate *>(qGetPtrHelper(d_ptr)); } friend class QHistoryStatePrivate;
};



# 91 "/usr/share/qt4/include/QtCore/qhistorystate.h"





# 62 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qsignaltransition.h"












































# 1 "/usr/share/qt4/include/QtCore/qabstracttransition.h"






















































































































# 45 "/usr/share/qt4/include/QtCore/qsignaltransition.h"


# 47 "/usr/share/qt4/include/QtCore/qsignaltransition.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qsignaltransition.h"
class QSignalTransitionPrivate;
class  QSignalTransition : public QAbstractTransition
{
Q_OBJECT
Q_PROPERTY(QObject* senderObject READ senderObject WRITE setSenderObject)
Q_PROPERTY(QByteArray signal READ signal WRITE setSignal)
public:
QSignalTransition(QState *sourceState = 0);
QSignalTransition(QObject *sender, const char *signal,
QState *sourceState = 0);
~QSignalTransition();

QObject *senderObject() const;
void setSenderObject(QObject *sender);

QByteArray signal() const;
void setSignal(const QByteArray &signal);

protected:
bool eventTest(QEvent *event);
void onTransition(QEvent *event);

bool event(QEvent *e);

private:
QSignalTransition(const QSignalTransition &); QSignalTransition &operator=(const QSignalTransition &);
inline QSignalTransitionPrivate* d_func() { return reinterpret_cast<QSignalTransitionPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSignalTransitionPrivate* d_func() const { return reinterpret_cast<const QSignalTransitionPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSignalTransitionPrivate;
};



# 86 "/usr/share/qt4/include/QtCore/qsignaltransition.h"





# 63 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qstate.h"












































# 1 "/usr/share/qt4/include/QtCore/qabstractstate.h"

































































































# 45 "/usr/share/qt4/include/QtCore/qstate.h"


# 47 "/usr/share/qt4/include/QtCore/qstate.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 55 "/usr/share/qt4/include/QtCore/qstate.h"
class QAbstractTransition;
class QSignalTransition;

class QStatePrivate;
class  QState : public QAbstractState
{
Q_OBJECT
Q_PROPERTY(QAbstractState* initialState READ initialState WRITE setInitialState)
Q_PROPERTY(QAbstractState* errorState READ errorState WRITE setErrorState)
Q_PROPERTY(ChildMode childMode READ childMode WRITE setChildMode)
Q_ENUMS(ChildMode)
public:
enum ChildMode {
ExclusiveStates,
ParallelStates
};

QState(QState *parent = 0);
QState(ChildMode childMode, QState *parent = 0);
~QState();

QAbstractState *errorState() const;
void setErrorState(QAbstractState *state);

void addTransition(QAbstractTransition *transition);
QSignalTransition *addTransition(QObject *sender, const char *signal, QAbstractState *target);
QAbstractTransition *addTransition(QAbstractState *target);
void removeTransition(QAbstractTransition *transition);

QAbstractState *initialState() const;
void setInitialState(QAbstractState *state);

ChildMode childMode() const;
void setChildMode(ChildMode mode);


# 91 "/usr/share/qt4/include/QtCore/qstate.h"
void assignProperty(QObject *object, const char *name,
const QVariant &value);


# 95 "/usr/share/qt4/include/QtCore/qstate.h"
signals:
void finished();
void propertiesAssigned();

protected:
void onEntry(QEvent *event);
void onExit(QEvent *event);

bool event(QEvent *e);

protected:
QState(QStatePrivate &dd, QState *parent);

private:
QState(const QState &); QState &operator=(const QState &);
inline QStatePrivate* d_func() { return reinterpret_cast<QStatePrivate *>(qGetPtrHelper(d_ptr)); } inline const QStatePrivate* d_func() const { return reinterpret_cast<const QStatePrivate *>(qGetPtrHelper(d_ptr)); } friend class QStatePrivate;
};



# 115 "/usr/share/qt4/include/QtCore/qstate.h"





# 64 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qstatemachine.h"












































# 1 "/usr/share/qt4/include/QtCore/qstate.h"























































































































# 45 "/usr/share/qt4/include/QtCore/qstatemachine.h"


# 1 "/usr/share/qt4/include/QtCore/qcoreevent.h"
































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qstatemachine.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtCore/qstatemachine.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtCore/qstatemachine.h"

# 1 "/usr/share/qt4/include/QtCore/qset.h"














































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtCore/qstatemachine.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 51 "/usr/share/qt4/include/QtCore/qstatemachine.h"


# 53 "/usr/share/qt4/include/QtCore/qstatemachine.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 61 "/usr/share/qt4/include/QtCore/qstatemachine.h"
class QStateMachinePrivate;
class QAbstractAnimation;
class  QStateMachine : public QState
{
Q_OBJECT
Q_PROPERTY(QString errorString READ errorString)
Q_PROPERTY(RestorePolicy globalRestorePolicy READ globalRestorePolicy WRITE setGlobalRestorePolicy)
Q_ENUMS(RestorePolicy)

# 70 "/usr/share/qt4/include/QtCore/qstatemachine.h"
Q_PROPERTY(bool animated READ isAnimated WRITE setAnimated)

# 72 "/usr/share/qt4/include/QtCore/qstatemachine.h"
public:
class  SignalEvent : public QEvent
{
public:
SignalEvent(QObject *sender, int signalIndex,
const QList<QVariant> &arguments);
~SignalEvent();

inline QObject *sender() const { return m_sender; }
inline int signalIndex() const { return m_signalIndex; }
inline QList<QVariant> arguments() const { return m_arguments; }

private:
QObject *m_sender;
int m_signalIndex;
QList<QVariant> m_arguments;

friend class QSignalTransitionPrivate;
};

class  WrappedEvent : public QEvent
{
public:
WrappedEvent(QObject *object, QEvent *event);
~WrappedEvent();

inline QObject *object() const { return m_object; }
inline QEvent *event() const { return m_event; }

private:
QObject *m_object;
QEvent *m_event;
};

enum EventPriority {
NormalPriority,
HighPriority
};

enum RestorePolicy {
DontRestoreProperties,
RestoreProperties
};

enum Error {
NoError, 
NoInitialStateError,
NoDefaultStateInHistoryStateError,
NoCommonAncestorForTransitionError
};

QStateMachine(QObject *parent = 0);
~QStateMachine();

void addState(QAbstractState *state);
void removeState(QAbstractState *state);

Error error() const;
QString errorString() const;
void clearError();

bool isRunning() const;


# 136 "/usr/share/qt4/include/QtCore/qstatemachine.h"
bool isAnimated() const;
void setAnimated(bool enabled);

void addDefaultAnimation(QAbstractAnimation *animation);
QList<QAbstractAnimation *> defaultAnimations() const;
void removeDefaultAnimation(QAbstractAnimation *animation);


# 144 "/usr/share/qt4/include/QtCore/qstatemachine.h"
QStateMachine::RestorePolicy globalRestorePolicy() const;
void setGlobalRestorePolicy(QStateMachine::RestorePolicy restorePolicy);

void postEvent(QEvent *event, EventPriority priority = NormalPriority);
int postDelayedEvent(QEvent *event, int delay);
bool cancelDelayedEvent(int id);

QSet<QAbstractState*> configuration() const;


# 154 "/usr/share/qt4/include/QtCore/qstatemachine.h"
bool eventFilter(QObject *watched, QEvent *event);


# 157 "/usr/share/qt4/include/QtCore/qstatemachine.h"
public slots:
void start();
void stop();

signals:
void started();
void stopped();

protected:
void onEntry(QEvent *event);
void onExit(QEvent *event);

virtual void beginSelectTransitions(QEvent *event);
virtual void endSelectTransitions(QEvent *event);

virtual void beginMicrostep(QEvent *event);
virtual void endMicrostep(QEvent *event);

bool event(QEvent *e);

protected:
QStateMachine(QStateMachinePrivate &dd, QObject *parent);

private:
QStateMachine(const QStateMachine &); QStateMachine &operator=(const QStateMachine &);
inline QStateMachinePrivate* d_func() { return reinterpret_cast<QStateMachinePrivate *>(qGetPtrHelper(d_ptr)); } inline const QStateMachinePrivate* d_func() const { return reinterpret_cast<const QStateMachinePrivate *>(qGetPtrHelper(d_ptr)); } friend class QStateMachinePrivate;



# 186 "/usr/share/qt4/include/QtCore/qstatemachine.h"


# 188 "/usr/share/qt4/include/QtCore/qstatemachine.h"
};



# 192 "/usr/share/qt4/include/QtCore/qstatemachine.h"





# 65 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qalgorithms.h"








































































































































































































































































































































































































































































































































# 66 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qbitarray.h"












































# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qbitarray.h"


# 47 "/usr/share/qt4/include/QtCore/qbitarray.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QBitRef;
class  QBitArray
{
friend  QDataStream &operator<<(QDataStream &, const QBitArray &);
friend  QDataStream &operator>>(QDataStream &, QBitArray &);
friend  uint qHash(const QBitArray &key);
QByteArray d;

public:
inline QBitArray() {}
explicit QBitArray(int size, bool val = false);
QBitArray(const QBitArray &other) : d(other.d) {}
inline QBitArray &operator=(const QBitArray &other) { d = other.d; return *this; }

inline int size() const { return (d.size() << 3) - *d.constData(); }
inline int count() const { return (d.size() << 3) - *d.constData(); }
int count(bool on) const;


inline bool isEmpty() const { return d.isEmpty(); }
inline bool isNull() const { return d.isNull(); }

void resize(int size);

inline void detach() { d.detach(); }
inline bool isDetached() const { return d.isDetached(); }
inline void clear() { d.clear(); }

bool testBit(int i) const;
void setBit(int i);
void setBit(int i, bool val);
void clearBit(int i);
bool toggleBit(int i);

bool at(int i) const;
QBitRef operator[](int i);
bool operator[](int i) const;
QBitRef operator[](uint i);
bool operator[](uint i) const;

QBitArray& operator&=(const QBitArray &);
QBitArray& operator|=(const QBitArray &);
QBitArray& operator^=(const QBitArray &);
QBitArray operator~() const;

inline bool operator==(const QBitArray& a) const { return d == a.d; }
inline bool operator!=(const QBitArray& a) const { return d != a.d; }

inline bool fill(bool val, int size = -1);
void fill(bool val, int first, int last);

inline void truncate(int pos) { if (pos < size()) resize(pos); }

public:
typedef QByteArray::DataPtr DataPtr;
inline DataPtr &data_ptr() { return d.data_ptr(); }
};

inline bool QBitArray::fill(bool aval, int asize)
{ *this = QBitArray((asize < 0 ? this->size() : asize), aval); return true; }

 QBitArray operator&(const QBitArray &, const QBitArray &);
 QBitArray operator|(const QBitArray &, const QBitArray &);
 QBitArray operator^(const QBitArray &, const QBitArray &);

inline bool QBitArray::testBit(int i) const
{ qt_noop();
return (*(reinterpret_cast<const uchar*>(d.constData())+1+(i>>3)) & (1 << (i & 7))) != 0; }

inline void QBitArray::setBit(int i)
{ qt_noop();
*(reinterpret_cast<uchar*>(d.data())+1+(i>>3)) |= uchar(1 << (i & 7)); }

inline void QBitArray::clearBit(int i)
{ qt_noop();
*(reinterpret_cast<uchar*>(d.data())+1+(i>>3)) &= ~uchar(1 << (i & 7)); }

inline void QBitArray::setBit(int i, bool val)
{ if (val) setBit(i); else clearBit(i); }

inline bool QBitArray::toggleBit(int i)
{ qt_noop();
uchar b = uchar(1<<(i&7)); uchar* p = reinterpret_cast<uchar*>(d.data())+1+(i>>3);
uchar c = uchar(*p&b); *p^=b; return c!=0; }

inline bool QBitArray::operator[](int i) const { return testBit(i); }
inline bool QBitArray::operator[](uint i) const { return testBit(i); }
inline bool QBitArray::at(int i) const { return testBit(i); }

class  QBitRef
{
private:
QBitArray& a;
int i;
inline QBitRef(QBitArray& array, int idx) : a(array), i(idx) {}
friend class QBitArray;
public:
inline operator bool() const { return a.testBit(i); }
inline bool operator!() const { return !a.testBit(i); }
QBitRef& operator=(const QBitRef& val) { a.setBit(i, val); return *this; }
QBitRef& operator=(bool val) { a.setBit(i, val); return *this; }
};

inline QBitRef QBitArray::operator[](int i)
{ qt_noop(); return QBitRef(*this, i); }
inline QBitRef QBitArray::operator[](uint i)
{ return QBitRef(*this, i); }



# 163 "/usr/share/qt4/include/QtCore/qbitarray.h"
 QDataStream &operator<<(QDataStream &, const QBitArray &);
 QDataStream &operator>>(QDataStream &, QBitArray &);


# 167 "/usr/share/qt4/include/QtCore/qbitarray.h"
template <> class QTypeInfo<QBitArray > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QBitArray)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QBitArray"; } };
template <> inline bool qIsDetached<QBitArray>(QBitArray &t) { return t.isDetached(); } template <> inline void qSwap<QBitArray>(QBitArray &value1, QBitArray &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }






# 67 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 68 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qbytearraymatcher.h"












































# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qbytearraymatcher.h"


# 47 "/usr/share/qt4/include/QtCore/qbytearraymatcher.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QByteArrayMatcherPrivate;

class  QByteArrayMatcher
{
public:
QByteArrayMatcher();
explicit QByteArrayMatcher(const QByteArray &pattern);
explicit QByteArrayMatcher(const char *pattern, int length);
QByteArrayMatcher(const QByteArrayMatcher &other);
~QByteArrayMatcher();

QByteArrayMatcher &operator=(const QByteArrayMatcher &other);

void setPattern(const QByteArray &pattern);

int indexIn(const QByteArray &ba, int from = 0) const;
int indexIn(const char *str, int len, int from = 0) const;
inline QByteArray pattern() const
{
if (q_pattern.isNull())
return QByteArray(reinterpret_cast<const char*>(p.p), p.l);
return q_pattern;
}

private:
QByteArrayMatcherPrivate *d;
QByteArray q_pattern;





# 85 "/usr/share/qt4/include/QtCore/qbytearraymatcher.h"
struct Data {
uchar q_skiptable[256];
const uchar *p;
int l;
};
union {
uint dummy[256];
Data p;
};



# 97 "/usr/share/qt4/include/QtCore/qbytearraymatcher.h"
};






# 69 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qcache.h"












































# 1 "/usr/share/qt4/include/QtCore/qhash.h"






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qcache.h"


# 47 "/usr/share/qt4/include/QtCore/qcache.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

template <class Key, class T>
class QCache
{
struct Node {
inline Node() : keyPtr(0) {}
inline Node(T *data, int cost)
: keyPtr(0), t(data), c(cost), p(0), n(0) {}
const Key *keyPtr; T *t; int c; Node *p,*n;
};
Node *f, *l;
QHash<Key, Node> hash;
void *unused;
int mx, total;

inline void unlink(Node &n) {
if (n.p) n.p->n = n.n;
if (n.n) n.n->p = n.p;
if (l == &n) l = n.p;
if (f == &n) f = n.n;
total -= n.c;
T *obj = n.t;
hash.remove(*n.keyPtr);
delete obj;
}
inline T *relink(const Key &key) {
typename QHash<Key, Node>::iterator i = hash.find(key);
if (typename QHash<Key, Node>::const_iterator(i) == hash.constEnd())
return 0;

Node &n = *i;
if (f != &n) {
if (n.p) n.p->n = n.n;
if (n.n) n.n->p = n.p;
if (l == &n) l = n.p;
n.p = 0;
n.n = f;
f->p = &n;
f = &n;
}
return n.t;
}

QCache(const QCache &); QCache &operator=(const QCache &);

public:
inline explicit QCache(int maxCost = 100);




# 103 "/usr/share/qt4/include/QtCore/qcache.h"
inline ~QCache() { clear(); }

inline int maxCost() const { return mx; }
void setMaxCost(int m);
inline int totalCost() const { return total; }

inline int size() const { return hash.size(); }
inline int count() const { return hash.size(); }
inline bool isEmpty() const { return hash.isEmpty(); }
inline QList<Key> keys() const { return hash.keys(); }

void clear();

bool insert(const Key &key, T *object, int cost = 1);
T *object(const Key &key) const;
inline bool contains(const Key &key) const { return hash.contains(key); }
T *operator[](const Key &key) const;

bool remove(const Key &key);
T *take(const Key &key);

private:
void trim(int m);





# 131 "/usr/share/qt4/include/QtCore/qcache.h"
};

template <class Key, class T>
inline QCache<Key, T>::QCache(int amaxCost)
: f(0), l(0), unused(0), mx(amaxCost), total(0) {}

template <class Key, class T>
inline void QCache<Key,T>::clear()
{ while (f) { delete f->t; f = f->n; }
hash.clear(); l = 0; total = 0; }

template <class Key, class T>
inline void QCache<Key,T>::setMaxCost(int m)
{ mx = m; trim(mx); }

template <class Key, class T>
inline T *QCache<Key,T>::object(const Key &key) const
{ return const_cast<QCache<Key,T>*>(this)->relink(key); }

template <class Key, class T>
inline T *QCache<Key,T>::operator[](const Key &key) const
{ return object(key); }

template <class Key, class T>
inline bool QCache<Key,T>::remove(const Key &key)
{
typename QHash<Key, Node>::iterator i = hash.find(key);
if (typename QHash<Key, Node>::const_iterator(i) == hash.constEnd()) {
return false;
} else {
unlink(*i);
return true;
}
}

template <class Key, class T>
inline T *QCache<Key,T>::take(const Key &key)
{
typename QHash<Key, Node>::iterator i = hash.find(key);
if (i == hash.end())
return 0;

Node &n = *i;
T *t = n.t;
n.t = 0;
unlink(n);
return t;
}

template <class Key, class T>
bool QCache<Key,T>::insert(const Key &akey, T *aobject, int acost)
{
remove(akey);
if (acost > mx) {
delete aobject;
return false;
}
trim(mx - acost);
Node sn(aobject, acost);
typename QHash<Key, Node>::iterator i = hash.insert(akey, sn);
total += acost;
Node *n = &i.value();
n->keyPtr = &i.key();
if (f) f->p = n;
n->n = f;
f = n;
if (!l) l = f;
return true;
}

template <class Key, class T>
void QCache<Key,T>::trim(int m)
{
Node *n = l;
while (n && total > m) {
Node *u = n;
n = n->p;
if (qIsDetached(*u->t))
unlink(*u);
}
}






# 70 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qchar.h"













































































































































































































































































































































































































# 71 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qcontainerfwd.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qcontainerfwd.h"


# 47 "/usr/share/qt4/include/QtCore/qcontainerfwd.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

template <class Key, class T> class QCache;
template <class Key, class T> class QHash;
template <class T> class QLinkedList;
template <class T> class QList;
template <class Key, class T> class QMap;
template <class Key, class T> class QMultiHash;
template <class Key, class T> class QMultiMap;
template <class T1, class T2> struct QPair;
template <class T> class QQueue;
template <class T> class QSet;
template <class T> class QStack;
template<class T, int Prealloc = 256> class QVarLengthArray;
template <class T> class QVector;






# 72 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qcontiguouscache.h"






































































































































































































































































































































































































































































# 73 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qcryptographichash.h"












































# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qcryptographichash.h"


# 47 "/usr/share/qt4/include/QtCore/qcryptographichash.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QCryptographicHashPrivate;

class  QCryptographicHash
{
public:
enum Algorithm {
Md4,
Md5,
Sha1
};

QCryptographicHash(Algorithm method);
~QCryptographicHash();

void reset();

void addData(const char *data, int length);
void addData(const QByteArray &data);

QByteArray result() const;

static QByteArray hash(const QByteArray &data, Algorithm method);
private:
QCryptographicHash(const QCryptographicHash &); QCryptographicHash &operator=(const QCryptographicHash &);
QCryptographicHashPrivate *d;
};






# 74 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qdatetime.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qdatetime.h"

# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qdatetime.h"

# 1 "/usr/share/qt4/include/QtCore/qsharedpointer.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qsharedpointer.h"

# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 46 "/usr/share/qt4/include/QtCore/qsharedpointer.h"

# 1 "/usr/share/qt4/include/QtCore/qshareddata.h"




































































































































































































































































# 47 "/usr/share/qt4/include/QtCore/qsharedpointer.h"




# 51 "/usr/share/qt4/include/QtCore/qsharedpointer.h"

# 1 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"



















































# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 52 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 53 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"


# 55 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"




typedef QtValidLicenseForCoreModule QtCoreModule;














# 75 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"



template <class T> class QWeakPointer;
template <class T> class QSharedPointer;

template <class X, class T>
QSharedPointer<X> qSharedPointerCast(const QSharedPointer<T> &ptr);
template <class X, class T>
QSharedPointer<X> qSharedPointerDynamicCast(const QSharedPointer<T> &ptr);
template <class X, class T>
QSharedPointer<X> qSharedPointerConstCast(const QSharedPointer<T> &ptr);


# 89 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
template <class X, class T>
QSharedPointer<X> qSharedPointerObjectCast(const QSharedPointer<T> &ptr);


# 93 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
namespace QtSharedPointer {
template <class T> class InternalRefCount;
template <class T> class ExternalRefCount;

template <class X, class Y> QSharedPointer<X> copyAndSetPointer(X * ptr, const QSharedPointer<Y> &src);


 void internalSafetyCheckAdd2(const void *, const volatile void *);
 void internalSafetyCheckRemove2(const void *);

template <class T, typename Klass, typename RetVal>
inline void executeDeleter(T *t, RetVal (Klass:: *memberDeleter)())
{ (t->*memberDeleter)(); }
template <class T, typename Deleter>
inline void executeDeleter(T *t, Deleter d)
{ d(t); }
template <class T> inline void normalDeleter(T *t) { delete t; }



template <class T> struct RemovePointer;
template <class T> struct RemovePointer<T *> { typedef T Type; };
template <class T> struct RemovePointer<QSharedPointer<T> > { typedef T Type; };
template <class T> struct RemovePointer<QWeakPointer<T> > { typedef T Type; };




template <class T>
class Basic
{

# 125 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
typedef T *Basic:: *RestrictedBool;

# 127 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
public:
typedef T Type;
typedef T element_type;
typedef T value_type;
typedef value_type *pointer;
typedef const value_type *const_pointer;
typedef value_type &reference;
typedef const value_type &const_reference;
typedef ptrdiff_t difference_type;

inline T *data() const { return value; }
inline bool isNull() const { return !data(); }

# 140 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
inline operator RestrictedBool() const { return isNull() ? 0 : &Basic::value; }



# 144 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
inline bool operator !() const { return isNull(); }
inline T &operator*() const { return *data(); }
inline T *operator->() const { return data(); }

protected:
inline Basic(T *ptr = 0) : value(ptr) { }
inline Basic(Qt::Initialization) { }


inline void internalConstruct(T *ptr)
{
value = ptr;
}




# 161 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
template <class X> friend class QWeakPointer;


# 164 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
Type *value;
};







struct ExternalRefCountData
{
QBasicAtomicInt weakref;
QBasicAtomicInt strongref;

inline ExternalRefCountData()
{
strongref = 1;
weakref = 1;
}
inline ExternalRefCountData(Qt::Initialization) { }
virtual inline ~ExternalRefCountData() { qt_noop(); qt_noop(); }




virtual inline bool destroy() { return false; }


# 192 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
 static ExternalRefCountData *getAndRef(const QObject *);
 void setQObjectShared(const QObject *, bool enable);

# 195 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
inline void setQObjectShared(...) { }
};




struct ExternalRefCountWithDestroyFn: public ExternalRefCountData
{
typedef void (*DestroyerFn)(ExternalRefCountData *);
DestroyerFn destroyer;

inline ExternalRefCountWithDestroyFn(DestroyerFn d)
: destroyer(d)
{ }

inline bool destroy() { destroyer(this); return true; }
inline void operator delete(void *ptr) { ::operator delete(ptr); }
};





template <class T, typename Deleter>
struct ExternalRefCountWithCustomDeleter: public ExternalRefCountWithDestroyFn
{
typedef ExternalRefCountWithCustomDeleter Self;
typedef ExternalRefCountWithDestroyFn BaseClass;

struct CustomDeleter
{
Deleter deleter;
T *ptr;

inline CustomDeleter(T *p, Deleter d) : deleter(d), ptr(p) {}
};
CustomDeleter extra;




static inline void deleter(ExternalRefCountData *self)
{
Self *realself = static_cast<Self *>(self);
executeDeleter(realself->extra.ptr, realself->extra.deleter);


realself->extra.~CustomDeleter();
}
static void safetyCheckDeleter(ExternalRefCountData *self)
{
internalSafetyCheckRemove2(self);
deleter(self);
}

static inline Self *create(T *ptr, Deleter userDeleter)
{



# 255 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
DestroyerFn destroy = &deleter;

# 257 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
Self *d = static_cast<Self *>(::operator new(sizeof(Self)));


new (&d->extra) CustomDeleter(ptr, userDeleter);
new (d) BaseClass(destroy); 

return d;
}
private:

ExternalRefCountWithCustomDeleter();
~ExternalRefCountWithCustomDeleter();
};





template <class T>
struct ExternalRefCountWithContiguousData: public ExternalRefCountWithDestroyFn
{
typedef ExternalRefCountWithDestroyFn Parent;
T data;

static void deleter(ExternalRefCountData *self)
{
ExternalRefCountWithContiguousData *that =
static_cast<ExternalRefCountWithContiguousData *>(self);
that->data.~T();
}
static void safetyCheckDeleter(ExternalRefCountData *self)
{
internalSafetyCheckRemove2(self);
deleter(self);
}

static inline ExternalRefCountData *create(T **ptr)
{



# 298 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
DestroyerFn destroy = &deleter;

# 300 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
ExternalRefCountWithContiguousData *d =
static_cast<ExternalRefCountWithContiguousData *>(::operator new(sizeof(ExternalRefCountWithContiguousData)));



new (d) Parent(destroy); 

*ptr = &d->data;
return d;
}

private:

ExternalRefCountWithContiguousData();
~ExternalRefCountWithContiguousData();
};



template <class T>
class ExternalRefCount: public Basic<T>
{
protected:
typedef ExternalRefCountData Data;

inline void ref() const { d->weakref.ref(); d->strongref.ref(); }
inline bool deref()
{
if (!d->strongref.deref()) {
internalDestroy();
}
return d->weakref.deref();
}

inline void internalConstruct(T *ptr)
{



# 339 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
if (ptr)
d = new Data;
else
d = 0;
internalFinishConstruction(ptr);

# 345 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
}

template <typename Deleter>
inline void internalConstruct(T *ptr, Deleter deleter)
{
if (ptr)
d = ExternalRefCountWithCustomDeleter<T, Deleter>::create(ptr, deleter);
else
d = 0;
internalFinishConstruction(ptr);
}

inline void internalCreate()
{
T *ptr;
d = ExternalRefCountWithContiguousData<T>::create(&ptr);
Basic<T>::internalConstruct(ptr);
}

inline void internalFinishConstruction(T *ptr)
{
Basic<T>::internalConstruct(ptr);
if (ptr) d->setQObjectShared(ptr, true);



# 371 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
}

inline ExternalRefCount() : d(0) { }
inline ExternalRefCount(Qt::Initialization i) : Basic<T>(i) { }
inline ExternalRefCount(const ExternalRefCount<T> &other) : Basic<T>(other), d(other.d)
{ if (d) ref(); }
template <class X>
inline ExternalRefCount(const ExternalRefCount<X> &other) : Basic<T>(other.value), d(other.d)
{ if (d) ref(); }
inline ~ExternalRefCount() { if (d && !deref()) delete d; }

template <class X>
inline void internalCopy(const ExternalRefCount<X> &other)
{
internalSet(other.d, other.data());
}

inline void internalDestroy()
{
if (!d->destroy())
delete this->value;
}

inline void internalSwap(ExternalRefCount &other)
{
qSwap(d, other.d);
qSwap(this->value, other.value);
}




# 403 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
template <class X> friend class ExternalRefCount;
template <class X> friend class QWeakPointer;
template <class X, class Y> friend QSharedPointer<X> copyAndSetPointer(X * ptr, const QSharedPointer<Y> &src);


# 408 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
inline void internalSet(Data *o, T *actual)
{
if (o) {


register int tmp = o->strongref;
while (tmp > 0) {

if (o->strongref.testAndSetRelaxed(tmp, tmp + 1))
break; 
tmp = o->strongref; 
}

if (tmp > 0)
o->weakref.ref();
else
o = 0;
}
if (d && !deref())
delete d;
d = o;
this->value = d && d->strongref ? actual : 0;
}

Data *d;

private:
template<class X> ExternalRefCount(const InternalRefCount<X> &);
};
} 

template <class T>
class QSharedPointer: public QtSharedPointer::ExternalRefCount<T>
{
typedef typename QtSharedPointer::ExternalRefCount<T> BaseClass;
public:
inline QSharedPointer() { }


inline explicit QSharedPointer(T *ptr) : BaseClass(Qt::Uninitialized)
{ BaseClass::internalConstruct(ptr); }

template <typename Deleter>
inline QSharedPointer(T *ptr, Deleter d) { BaseClass::internalConstruct(ptr, d); }

inline QSharedPointer(const QSharedPointer<T> &other) : BaseClass(other) { }
inline QSharedPointer<T> &operator=(const QSharedPointer<T> &other)
{
BaseClass::internalCopy(other);
return *this;
}

template <class X>
inline QSharedPointer(const QSharedPointer<X> &other) : BaseClass(other)
{ }

template <class X>
inline QSharedPointer<T> &operator=(const QSharedPointer<X> &other)
{
qt_noop(); 
BaseClass::internalCopy(other);
return *this;
}

template <class X>
inline QSharedPointer(const QWeakPointer<X> &other) : BaseClass(Qt::Uninitialized)
{ this->d = 0; *this = other; }

template <class X>
inline QSharedPointer<T> &operator=(const QWeakPointer<X> &other)
{ BaseClass::internalSet(other.d, other.value); return *this; }

inline void swap(QSharedPointer &other)
{ QSharedPointer<T>::internalSwap(other); }

template <class X>
QSharedPointer<X> staticCast() const
{
return qSharedPointerCast<X, T>(*this);
}

template <class X>
QSharedPointer<X> dynamicCast() const
{
return qSharedPointerDynamicCast<X, T>(*this);
}

template <class X>
QSharedPointer<X> constCast() const
{
return qSharedPointerConstCast<X, T>(*this);
}


# 502 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
template <class X>
QSharedPointer<X> objectCast() const
{
return qSharedPointerObjectCast<X, T>(*this);
}


# 509 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
inline void clear() { *this = QSharedPointer<T>(); }

QWeakPointer<T> toWeakRef() const;

protected:
inline explicit QSharedPointer(Qt::Initialization i) : BaseClass(i) {}

public:
static inline QSharedPointer<T> create()
{
QSharedPointer<T> result(Qt::Uninitialized);
result.internalCreate();


new (result.data()) T();
result.internalFinishConstruction(result.data());
return result;
}
};

template <class T>
class QWeakPointer
{

# 533 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
typedef T *QWeakPointer:: *RestrictedBool;

# 535 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
typedef QtSharedPointer::ExternalRefCountData Data;

public:
typedef T element_type;
typedef T value_type;
typedef value_type *pointer;
typedef const value_type *const_pointer;
typedef value_type &reference;
typedef const value_type &const_reference;
typedef ptrdiff_t difference_type;

inline bool isNull() const { return d == 0 || d->strongref == 0 || value == 0; }

# 548 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
inline operator RestrictedBool() const { return isNull() ? 0 : &QWeakPointer::value; }



# 552 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
inline bool operator !() const { return isNull(); }
inline T *data() const { return d == 0 || d->strongref == 0 ? 0 : value; }

inline QWeakPointer() : d(0), value(0) { }
inline ~QWeakPointer() { if (d && !d->weakref.deref()) delete d; }


# 559 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"

template <class X>
inline QWeakPointer(X *ptr) : d(ptr ? d->getAndRef(ptr) : 0), value(ptr)
{ }

# 564 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
template <class X>
inline QWeakPointer &operator=(X *ptr)
{ return *this = QWeakPointer(ptr); }

inline QWeakPointer(const QWeakPointer<T> &o) : d(o.d), value(o.value)
{ if (d) d->weakref.ref(); }
inline QWeakPointer<T> &operator=(const QWeakPointer<T> &o)
{
internalSet(o.d, o.value);
return *this;
}

inline QWeakPointer(const QSharedPointer<T> &o) : d(o.d), value(o.data())
{ if (d) d->weakref.ref();}
inline QWeakPointer<T> &operator=(const QSharedPointer<T> &o)
{
internalSet(o.d, o.value);
return *this;
}

template <class X>
inline QWeakPointer(const QWeakPointer<X> &o) : d(0), value(0)
{ *this = o; }

template <class X>
inline QWeakPointer<T> &operator=(const QWeakPointer<X> &o)
{


*this = o.toStrongRef();
return *this;
}

template <class X>
inline bool operator==(const QWeakPointer<X> &o) const
{ return d == o.d && value == static_cast<const T *>(o.value); }

template <class X>
inline bool operator!=(const QWeakPointer<X> &o) const
{ return !(*this == o); }

template <class X>
inline QWeakPointer(const QSharedPointer<X> &o) : d(0), value(0)
{ *this = o; }

template <class X>
inline QWeakPointer<T> &operator=(const QSharedPointer<X> &o)
{
qt_noop(); 
internalSet(o.d, o.data());
return *this;
}

template <class X>
inline bool operator==(const QSharedPointer<X> &o) const
{ return d == o.d; }

template <class X>
inline bool operator!=(const QSharedPointer<X> &o) const
{ return !(*this == o); }

inline void clear() { *this = QWeakPointer<T>(); }

inline QSharedPointer<T> toStrongRef() const { return QSharedPointer<T>(*this); }





# 633 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
private:




# 638 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
template <class X> friend class QSharedPointer;


# 641 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
inline void internalSet(Data *o, T *actual)
{
if (d == o) return;
if (o)
o->weakref.ref();
if (d && !d->weakref.deref())
delete d;
d = o;
value = actual;
}

Data *d;
T *value;
};

template <class T, class X>
bool operator==(const QSharedPointer<T> &ptr1, const QSharedPointer<X> &ptr2)
{
return ptr1.data() == ptr2.data();
}
template <class T, class X>
bool operator!=(const QSharedPointer<T> &ptr1, const QSharedPointer<X> &ptr2)
{
return ptr1.data() != ptr2.data();
}

template <class T, class X>
bool operator==(const QSharedPointer<T> &ptr1, const X *ptr2)
{
return ptr1.data() == ptr2;
}
template <class T, class X>
bool operator==(const T *ptr1, const QSharedPointer<X> &ptr2)
{
return ptr1 == ptr2.data();
}

template <class T, class X>
bool operator!=(const QSharedPointer<T> &ptr1, const X *ptr2)
{
return !(ptr1 == ptr2);
}
template <class T, class X>
bool operator!=(const T *ptr1, const QSharedPointer<X> &ptr2)
{
return !(ptr2 == ptr1);
}

template <class T, class X>
bool operator==(const QSharedPointer<T> &ptr1, const QWeakPointer<X> &ptr2)
{
return ptr2 == ptr1;
}
template <class T, class X>
bool operator!=(const QSharedPointer<T> &ptr1, const QWeakPointer<X> &ptr2)
{
return ptr2 != ptr1;
}

template <class T, class X>
inline typename T::difference_type operator-(const QSharedPointer<T> &ptr1, const QSharedPointer<X> &ptr2)
{
return ptr1.data() - ptr2.data();
}

template <class T>
inline QWeakPointer<T> QSharedPointer<T>::toWeakRef() const
{
return QWeakPointer<T>(*this);
}

template <class T>
inline void qSwap(QSharedPointer<T> &p1, QSharedPointer<T> &p2)
{
p1.swap(p2);
}

namespace QtSharedPointer {

template <class X, class T>
inline QSharedPointer<X> copyAndSetPointer(X *ptr, const QSharedPointer<T> &src)
{
QSharedPointer<X> result;
result.internalSet(src.d, ptr);
return result;
}
}


template <class X, class T>
inline QSharedPointer<X> qSharedPointerCast(const QSharedPointer<T> &src)
{
register X *ptr = static_cast<X *>(src.data()); 
return QtSharedPointer::copyAndSetPointer(ptr, src);
}
template <class X, class T>
inline QSharedPointer<X> qSharedPointerCast(const QWeakPointer<T> &src)
{
return qSharedPointerCast<X, T>(src.toStrongRef());
}

template <class X, class T>
inline QSharedPointer<X> qSharedPointerDynamicCast(const QSharedPointer<T> &src)
{
register X *ptr = dynamic_cast<X *>(src.data()); 
return QtSharedPointer::copyAndSetPointer(ptr, src);
}
template <class X, class T>
inline QSharedPointer<X> qSharedPointerDynamicCast(const QWeakPointer<T> &src)
{
return qSharedPointerDynamicCast<X, T>(src.toStrongRef());
}

template <class X, class T>
inline QSharedPointer<X> qSharedPointerConstCast(const QSharedPointer<T> &src)
{
register X *ptr = const_cast<X *>(src.data()); 
return QtSharedPointer::copyAndSetPointer(ptr, src);
}
template <class X, class T>
inline QSharedPointer<X> qSharedPointerConstCast(const QWeakPointer<T> &src)
{
return qSharedPointerConstCast<X, T>(src.toStrongRef());
}

template <class X, class T>
inline
QWeakPointer<X> qWeakPointerCast(const QSharedPointer<T> &src)
{
return qSharedPointerCast<X, T>(src).toWeakRef();
}


# 774 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"
template <class X, class T>
inline QSharedPointer<X> qSharedPointerObjectCast(const QSharedPointer<T> &src)
{
register X *ptr = qobject_cast<X *>(src.data());
return QtSharedPointer::copyAndSetPointer(ptr, src);
}
template <class X, class T>
inline QSharedPointer<X> qSharedPointerObjectCast(const QWeakPointer<T> &src)
{
return qSharedPointerObjectCast<X>(src.toStrongRef());
}

template <class X, class T>
inline QSharedPointer<typename QtSharedPointer::RemovePointer<X>::Type>
qobject_cast(const QSharedPointer<T> &src)
{
return qSharedPointerObjectCast<typename QtSharedPointer::RemovePointer<X>::Type, T>(src);
}
template <class X, class T>
inline QSharedPointer<typename QtSharedPointer::RemovePointer<X>::Type>
qobject_cast(const QWeakPointer<T> &src)
{
return qSharedPointerObjectCast<typename QtSharedPointer::RemovePointer<X>::Type, T>(src);
}



# 801 "/usr/share/qt4/include/QtCore/qsharedpointer_impl.h"





# 52 "/usr/share/qt4/include/QtCore/qsharedpointer.h"








































































































# 47 "/usr/share/qt4/include/QtCore/qdatetime.h"


# 49 "/usr/share/qt4/include/QtCore/qdatetime.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class  QDate
{
public:
enum MonthNameType {
DateFormat = 0,
StandaloneFormat
};
public:
QDate() { jd = 0; }
QDate(int y, int m, int d);

bool isNull() const { return jd == 0; }
bool isValid() const;

int year() const;
int month() const;
int day() const;
int dayOfWeek() const;
int dayOfYear() const;
int daysInMonth() const;
int daysInYear() const;
int weekNumber(int *yearNum = 0) const;






# 83 "/usr/share/qt4/include/QtCore/qdatetime.h"

static QString shortMonthName(int month);
static QString shortMonthName(int month, MonthNameType type);
static QString shortDayName(int weekday);
static QString shortDayName(int weekday, MonthNameType type);
static QString longMonthName(int month);
static QString longMonthName(int month, MonthNameType type);
static QString longDayName(int weekday);
static QString longDayName(int weekday, MonthNameType type);


# 94 "/usr/share/qt4/include/QtCore/qdatetime.h"
QString toString(Qt::DateFormat f = Qt::TextDate) const;
QString toString(const QString &format) const;

# 97 "/usr/share/qt4/include/QtCore/qdatetime.h"
bool setYMD(int y, int m, int d);
bool setDate(int year, int month, int day);

void getDate(int *year, int *month, int *day);

QDate addDays(int days) const;
QDate addMonths(int months) const;
QDate addYears(int years) const;
int daysTo(const QDate &) const;

bool operator==(const QDate &other) const { return jd == other.jd; }
bool operator!=(const QDate &other) const { return jd != other.jd; }
bool operator<(const QDate &other) const { return jd < other.jd; }
bool operator<=(const QDate &other) const { return jd <= other.jd; }
bool operator>(const QDate &other) const { return jd > other.jd; }
bool operator>=(const QDate &other) const { return jd >= other.jd; }

static QDate currentDate();

# 116 "/usr/share/qt4/include/QtCore/qdatetime.h"
static QDate fromString(const QString &s, Qt::DateFormat f = Qt::TextDate);
static QDate fromString(const QString &s, const QString &format);

# 119 "/usr/share/qt4/include/QtCore/qdatetime.h"
static bool isValid(int y, int m, int d);
static bool isLeapYear(int year);




# 125 "/usr/share/qt4/include/QtCore/qdatetime.h"

static uint gregorianToJulian(int y, int m, int d);
static void julianToGregorian(uint jd, int &y, int &m, int &d);





# 133 "/usr/share/qt4/include/QtCore/qdatetime.h"
static inline QDate fromJulianDay(int jd) { QDate d; d.jd = jd; return d; }
inline int toJulianDay() const { return jd; }

private:
uint jd;

friend class QDateTime;
friend class QDateTimePrivate;

# 142 "/usr/share/qt4/include/QtCore/qdatetime.h"
friend  QDataStream &operator<<(QDataStream &, const QDate &);
friend  QDataStream &operator>>(QDataStream &, QDate &);

# 145 "/usr/share/qt4/include/QtCore/qdatetime.h"
};
template <> class QTypeInfo<QDate > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QDate)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QDate"; } };

class  QTime
{
public:
QTime(): mds(NullTime)



# 155 "/usr/share/qt4/include/QtCore/qdatetime.h"
{}
QTime(int h, int m, int s = 0, int ms = 0);

bool isNull() const { return mds == NullTime; }
bool isValid() const;

int hour() const;
int minute() const;
int second() const;
int msec() const;

# 166 "/usr/share/qt4/include/QtCore/qdatetime.h"
QString toString(Qt::DateFormat f = Qt::TextDate) const;
QString toString(const QString &format) const;

# 169 "/usr/share/qt4/include/QtCore/qdatetime.h"
bool setHMS(int h, int m, int s, int ms = 0);

QTime addSecs(int secs) const;
int secsTo(const QTime &) const;
QTime addMSecs(int ms) const;
int msecsTo(const QTime &) const;

bool operator==(const QTime &other) const { return mds == other.mds; }
bool operator!=(const QTime &other) const { return mds != other.mds; }
bool operator<(const QTime &other) const { return mds < other.mds; }
bool operator<=(const QTime &other) const { return mds <= other.mds; }
bool operator>(const QTime &other) const { return mds > other.mds; }
bool operator>=(const QTime &other) const { return mds >= other.mds; }

static QTime currentTime();

# 185 "/usr/share/qt4/include/QtCore/qdatetime.h"
static QTime fromString(const QString &s, Qt::DateFormat f = Qt::TextDate);
static QTime fromString(const QString &s, const QString &format);

# 188 "/usr/share/qt4/include/QtCore/qdatetime.h"
static bool isValid(int h, int m, int s, int ms = 0);





# 194 "/usr/share/qt4/include/QtCore/qdatetime.h"
void start();
int restart();
int elapsed() const;
private:
enum TimeFlag { NullTime = -1 };
inline int ds() const { return mds == -1 ? 0 : mds; }
int mds;




# 205 "/usr/share/qt4/include/QtCore/qdatetime.h"
friend class QDateTime;
friend class QDateTimePrivate;

# 208 "/usr/share/qt4/include/QtCore/qdatetime.h"
friend  QDataStream &operator<<(QDataStream &, const QTime &);
friend  QDataStream &operator>>(QDataStream &, QTime &);

# 211 "/usr/share/qt4/include/QtCore/qdatetime.h"
};
template <> class QTypeInfo<QTime > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTime)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTime"; } };

class QDateTimePrivate;

class  QDateTime
{
public:
QDateTime();
explicit QDateTime(const QDate &);
QDateTime(const QDate &, const QTime &, Qt::TimeSpec spec = Qt::LocalTime);
QDateTime(const QDateTime &other);
~QDateTime();

QDateTime &operator=(const QDateTime &other);

bool isNull() const;
bool isValid() const;

QDate date() const;
QTime time() const;
Qt::TimeSpec timeSpec() const;
uint toTime_t() const;
void setDate(const QDate &date);
void setTime(const QTime &time);
void setTimeSpec(Qt::TimeSpec spec);
void setTime_t(uint secsSince1Jan1970UTC);

# 239 "/usr/share/qt4/include/QtCore/qdatetime.h"
QString toString(Qt::DateFormat f = Qt::TextDate) const;
QString toString(const QString &format) const;

# 242 "/usr/share/qt4/include/QtCore/qdatetime.h"
QDateTime addDays(int days) const;
QDateTime addMonths(int months) const;
QDateTime addYears(int years) const;
QDateTime addSecs(int secs) const;
QDateTime addMSecs(qint64 msecs) const;
QDateTime toTimeSpec(Qt::TimeSpec spec) const;
inline QDateTime toLocalTime() const { return toTimeSpec(Qt::LocalTime); }
inline QDateTime toUTC() const { return toTimeSpec(Qt::UTC); }
int daysTo(const QDateTime &) const;
int secsTo(const QDateTime &) const;

bool operator==(const QDateTime &other) const;
inline bool operator!=(const QDateTime &other) const { return !(*this == other); }
bool operator<(const QDateTime &other) const;
inline bool operator<=(const QDateTime &other) const { return !(other < *this); }
inline bool operator>(const QDateTime &other) const { return other < *this; }
inline bool operator>=(const QDateTime &other) const { return !(*this < other); }

void setUtcOffset(int seconds);
int utcOffset() const;

static QDateTime currentDateTime();

# 265 "/usr/share/qt4/include/QtCore/qdatetime.h"
static QDateTime fromString(const QString &s, Qt::DateFormat f = Qt::TextDate);
static QDateTime fromString(const QString &s, const QString &format);

# 268 "/usr/share/qt4/include/QtCore/qdatetime.h"
static QDateTime fromTime_t(uint secsSince1Jan1970UTC);
















# 285 "/usr/share/qt4/include/QtCore/qdatetime.h"
private:
friend class QDateTimePrivate;
void detach();
QExplicitlySharedDataPointer<QDateTimePrivate> d;


# 291 "/usr/share/qt4/include/QtCore/qdatetime.h"
friend  QDataStream &operator<<(QDataStream &, const QDateTime &);
friend  QDataStream &operator>>(QDataStream &, QDateTime &);

# 294 "/usr/share/qt4/include/QtCore/qdatetime.h"
};
template <> class QTypeInfo<QDateTime > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QDateTime)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QDateTime"; } };




















# 316 "/usr/share/qt4/include/QtCore/qdatetime.h"
 QDataStream &operator<<(QDataStream &, const QDate &);
 QDataStream &operator>>(QDataStream &, QDate &);
 QDataStream &operator<<(QDataStream &, const QTime &);
 QDataStream &operator>>(QDataStream &, QTime &);
 QDataStream &operator<<(QDataStream &, const QDateTime &);
 QDataStream &operator>>(QDataStream &, QDateTime &);



# 325 "/usr/share/qt4/include/QtCore/qdatetime.h"
 QDebug operator<<(QDebug, const QDate &);
 QDebug operator<<(QDebug, const QTime &);
 QDebug operator<<(QDebug, const QDateTime &);


# 330 "/usr/share/qt4/include/QtCore/qdatetime.h"





# 75 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qeasingcurve.h"


















































































































# 76 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qhash.h"






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 77 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qiterator.h"






































































# 78 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qline.h"












































# 1 "/usr/share/qt4/include/QtCore/qpoint.h"












































# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qpoint.h"


# 47 "/usr/share/qt4/include/QtCore/qpoint.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class  QPoint
{
public:
QPoint();
QPoint(int xpos, int ypos);

bool isNull() const;

int x() const;
int y() const;
void setX(int x);
void setY(int y);

int manhattanLength() const;

int &rx();
int &ry();

QPoint &operator+=(const QPoint &p);
QPoint &operator-=(const QPoint &p);
QPoint &operator*=(qreal c);
QPoint &operator/=(qreal c);

friend inline bool operator==(const QPoint &, const QPoint &);
friend inline bool operator!=(const QPoint &, const QPoint &);
friend inline const QPoint operator+(const QPoint &, const QPoint &);
friend inline const QPoint operator-(const QPoint &, const QPoint &);
friend inline const QPoint operator*(const QPoint &, qreal);
friend inline const QPoint operator*(qreal, const QPoint &);
friend inline const QPoint operator-(const QPoint &);
friend inline const QPoint operator/(const QPoint &, qreal);

private:
friend class QTransform;





# 92 "/usr/share/qt4/include/QtCore/qpoint.h"
int xp;
int yp;

# 95 "/usr/share/qt4/include/QtCore/qpoint.h"
};

template <> class QTypeInfo<QPoint > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPoint)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QPoint"; } };





# 103 "/usr/share/qt4/include/QtCore/qpoint.h"
 QDataStream &operator<<(QDataStream &, const QPoint &);
 QDataStream &operator>>(QDataStream &, QPoint &);


# 107 "/usr/share/qt4/include/QtCore/qpoint.h"




inline QPoint::QPoint()
{ xp=0; yp=0; }

inline QPoint::QPoint(int xpos, int ypos)
{ xp = xpos; yp = ypos; }

inline bool QPoint::isNull() const
{ return xp == 0 && yp == 0; }

inline int QPoint::x() const
{ return xp; }

inline int QPoint::y() const
{ return yp; }

inline void QPoint::setX(int xpos)
{ xp = xpos; }

inline void QPoint::setY(int ypos)
{ yp = ypos; }

inline int &QPoint::rx()
{ return xp; }

inline int &QPoint::ry()
{ return yp; }

inline QPoint &QPoint::operator+=(const QPoint &p)
{ xp+=p.xp; yp+=p.yp; return *this; }

inline QPoint &QPoint::operator-=(const QPoint &p)
{ xp-=p.xp; yp-=p.yp; return *this; }

inline QPoint &QPoint::operator*=(qreal c)
{ xp = qRound(xp*c); yp = qRound(yp*c); return *this; }

inline bool operator==(const QPoint &p1, const QPoint &p2)
{ return p1.xp == p2.xp && p1.yp == p2.yp; }

inline bool operator!=(const QPoint &p1, const QPoint &p2)
{ return p1.xp != p2.xp || p1.yp != p2.yp; }

inline const QPoint operator+(const QPoint &p1, const QPoint &p2)
{ return QPoint(p1.xp+p2.xp, p1.yp+p2.yp); }

inline const QPoint operator-(const QPoint &p1, const QPoint &p2)
{ return QPoint(p1.xp-p2.xp, p1.yp-p2.yp); }

inline const QPoint operator*(const QPoint &p, qreal c)
{ return QPoint(qRound(p.xp*c), qRound(p.yp*c)); }

inline const QPoint operator*(qreal c, const QPoint &p)
{ return QPoint(qRound(p.xp*c), qRound(p.yp*c)); }

inline const QPoint operator-(const QPoint &p)
{ return QPoint(-p.xp, -p.yp); }

inline QPoint &QPoint::operator/=(qreal c)
{
xp = qRound(xp/c);
yp = qRound(yp/c);
return *this;
}

inline const QPoint operator/(const QPoint &p, qreal c)
{
return QPoint(qRound(p.xp/c), qRound(p.yp/c));
}


# 181 "/usr/share/qt4/include/QtCore/qpoint.h"
 QDebug operator<<(QDebug, const QPoint &);






# 188 "/usr/share/qt4/include/QtCore/qpoint.h"
class  QPointF
{
public:
QPointF();
QPointF(const QPoint &p);
QPointF(qreal xpos, qreal ypos);

qreal manhattanLength() const;

bool isNull() const;

qreal x() const;
qreal y() const;
void setX(qreal x);
void setY(qreal y);

qreal &rx();
qreal &ry();

QPointF &operator+=(const QPointF &p);
QPointF &operator-=(const QPointF &p);
QPointF &operator*=(qreal c);
QPointF &operator/=(qreal c);

friend inline bool operator==(const QPointF &, const QPointF &);
friend inline bool operator!=(const QPointF &, const QPointF &);
friend inline const QPointF operator+(const QPointF &, const QPointF &);
friend inline const QPointF operator-(const QPointF &, const QPointF &);
friend inline const QPointF operator*(qreal, const QPointF &);
friend inline const QPointF operator*(const QPointF &, qreal);
friend inline const QPointF operator-(const QPointF &);
friend inline const QPointF operator/(const QPointF &, qreal);

QPoint toPoint() const;

private:
friend class QMatrix;
friend class QTransform;

qreal xp;
qreal yp;
};

template <> class QTypeInfo<QPointF > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPointF)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QPointF"; } };





# 237 "/usr/share/qt4/include/QtCore/qpoint.h"
 QDataStream &operator<<(QDataStream &, const QPointF &);
 QDataStream &operator>>(QDataStream &, QPointF &);


# 241 "/usr/share/qt4/include/QtCore/qpoint.h"




inline QPointF::QPointF() : xp(0), yp(0) { }

inline QPointF::QPointF(qreal xpos, qreal ypos) : xp(xpos), yp(ypos) { }

inline QPointF::QPointF(const QPoint &p) : xp(p.x()), yp(p.y()) { }

inline bool QPointF::isNull() const
{
return qIsNull(xp) && qIsNull(yp);
}

inline qreal QPointF::x() const
{
return xp;
}

inline qreal QPointF::y() const
{
return yp;
}

inline void QPointF::setX(qreal xpos)
{
xp = xpos;
}

inline void QPointF::setY(qreal ypos)
{
yp = ypos;
}

inline qreal &QPointF::rx()
{
return xp;
}

inline qreal &QPointF::ry()
{
return yp;
}

inline QPointF &QPointF::operator+=(const QPointF &p)
{
xp+=p.xp;
yp+=p.yp;
return *this;
}

inline QPointF &QPointF::operator-=(const QPointF &p)
{
xp-=p.xp; yp-=p.yp; return *this;
}

inline QPointF &QPointF::operator*=(qreal c)
{
xp*=c; yp*=c; return *this;
}

inline bool operator==(const QPointF &p1, const QPointF &p2)
{
return qFuzzyIsNull(p1.xp - p2.xp) && qFuzzyIsNull(p1.yp - p2.yp);
}

inline bool operator!=(const QPointF &p1, const QPointF &p2)
{
return !qFuzzyIsNull(p1.xp - p2.xp) || !qFuzzyIsNull(p1.yp - p2.yp);
}

inline const QPointF operator+(const QPointF &p1, const QPointF &p2)
{
return QPointF(p1.xp+p2.xp, p1.yp+p2.yp);
}

inline const QPointF operator-(const QPointF &p1, const QPointF &p2)
{
return QPointF(p1.xp-p2.xp, p1.yp-p2.yp);
}

inline const QPointF operator*(const QPointF &p, qreal c)
{
return QPointF(p.xp*c, p.yp*c);
}

inline const QPointF operator*(qreal c, const QPointF &p)
{
return QPointF(p.xp*c, p.yp*c);
}

inline const QPointF operator-(const QPointF &p)
{
return QPointF(-p.xp, -p.yp);
}

inline QPointF &QPointF::operator/=(qreal c)
{
xp/=c;
yp/=c;
return *this;
}

inline const QPointF operator/(const QPointF &p, qreal c)
{
return QPointF(p.xp/c, p.yp/c);
}

inline QPoint QPointF::toPoint() const
{
return QPoint(qRound(xp), qRound(yp));
}


# 356 "/usr/share/qt4/include/QtCore/qpoint.h"
 QDebug operator<<(QDebug d, const QPointF &p);


# 359 "/usr/share/qt4/include/QtCore/qpoint.h"





# 45 "/usr/share/qt4/include/QtCore/qline.h"


# 47 "/usr/share/qt4/include/QtCore/qline.h"




typedef QtValidLicenseForCoreModule QtCoreModule;





class  QLine
{
public:
inline QLine();
inline QLine(const QPoint &pt1, const QPoint &pt2);
inline QLine(int x1, int y1, int x2, int y2);

inline bool isNull() const;

inline QPoint p1() const;
inline QPoint p2() const;

inline int x1() const;
inline int y1() const;

inline int x2() const;
inline int y2() const;

inline int dx() const;
inline int dy() const;

inline void translate(const QPoint &p);
inline void translate(int dx, int dy);

inline QLine translated(const QPoint &p) const;
inline QLine translated(int dx, int dy) const;

inline void setP1(const QPoint &p1);
inline void setP2(const QPoint &p2);
inline void setPoints(const QPoint &p1, const QPoint &p2);
inline void setLine(int x1, int y1, int x2, int y2);

inline bool operator==(const QLine &d) const;
inline bool operator!=(const QLine &d) const { return !(*this == d); }

private:
QPoint pt1, pt2;
};
template <> class QTypeInfo<QLine > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QLine)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QLine"; } };





inline QLine::QLine() { }

inline QLine::QLine(const QPoint &pt1_, const QPoint &pt2_) : pt1(pt1_), pt2(pt2_) { }

inline QLine::QLine(int x1pos, int y1pos, int x2pos, int y2pos) : pt1(QPoint(x1pos, y1pos)), pt2(QPoint(x2pos, y2pos)) { }

inline bool QLine::isNull() const
{
return pt1 == pt2;
}

inline int QLine::x1() const
{
return pt1.x();
}

inline int QLine::y1() const
{
return pt1.y();
}

inline int QLine::x2() const
{
return pt2.x();
}

inline int QLine::y2() const
{
return pt2.y();
}

inline QPoint QLine::p1() const
{
return pt1;
}

inline QPoint QLine::p2() const
{
return pt2;
}

inline int QLine::dx() const
{
return pt2.x() - pt1.x();
}

inline int QLine::dy() const
{
return pt2.y() - pt1.y();
}

inline void QLine::translate(const QPoint &point)
{
pt1 += point;
pt2 += point;
}

inline void QLine::translate(int adx, int ady)
{
this->translate(QPoint(adx, ady));
}

inline QLine QLine::translated(const QPoint &p) const
{
return QLine(pt1 + p, pt2 + p);
}

inline QLine QLine::translated(int adx, int ady) const
{
return translated(QPoint(adx, ady));
}

inline void QLine::setP1(const QPoint &aP1)
{
pt1 = aP1;
}

inline void QLine::setP2(const QPoint &aP2)
{
pt2 = aP2;
}

inline void QLine::setPoints(const QPoint &aP1, const QPoint &aP2)
{
pt1 = aP1;
pt2 = aP2;
}

inline void QLine::setLine(int aX1, int aY1, int aX2, int aY2)
{
pt1 = QPoint(aX1, aY1);
pt2 = QPoint(aX2, aY2);
}

inline bool QLine::operator==(const QLine &d) const
{
return pt1 == d.pt1 && pt2 == d.pt2;
}


# 201 "/usr/share/qt4/include/QtCore/qline.h"
 QDebug operator<<(QDebug d, const QLine &p);



# 205 "/usr/share/qt4/include/QtCore/qline.h"
 QDataStream &operator<<(QDataStream &, const QLine &);
 QDataStream &operator>>(QDataStream &, QLine &);


# 209 "/usr/share/qt4/include/QtCore/qline.h"



class  QLineF {
public:

enum IntersectType { NoIntersection, BoundedIntersection, UnboundedIntersection };

inline QLineF();
inline QLineF(const QPointF &pt1, const QPointF &pt2);
inline QLineF(qreal x1, qreal y1, qreal x2, qreal y2);
inline QLineF(const QLine &line) : pt1(line.p1()), pt2(line.p2()) { }

static QLineF fromPolar(qreal length, qreal angle);

bool isNull() const;

inline QPointF p1() const;
inline QPointF p2() const;

inline qreal x1() const;
inline qreal y1() const;

inline qreal x2() const;
inline qreal y2() const;

inline qreal dx() const;
inline qreal dy() const;

qreal length() const;
void setLength(qreal len);

qreal angle() const;
void setAngle(qreal angle);

qreal angleTo(const QLineF &l) const;

QLineF unitVector() const;
QLineF normalVector() const;


IntersectType intersect(const QLineF &l, QPointF *intersectionPoint) const;

qreal angle(const QLineF &l) const;

QPointF pointAt(qreal t) const;
inline void translate(const QPointF &p);
inline void translate(qreal dx, qreal dy);

inline QLineF translated(const QPointF &p) const;
inline QLineF translated(qreal dx, qreal dy) const;

inline void setP1(const QPointF &p1);
inline void setP2(const QPointF &p2);
inline void setPoints(const QPointF &p1, const QPointF &p2);
inline void setLine(qreal x1, qreal y1, qreal x2, qreal y2);

inline bool operator==(const QLineF &d) const;
inline bool operator!=(const QLineF &d) const { return !(*this == d); }

QLine toLine() const;

private:
QPointF pt1, pt2;
};
template <> class QTypeInfo<QLineF > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QLineF)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QLineF"; } };





inline QLineF::QLineF()
{
}

inline QLineF::QLineF(const QPointF &apt1, const QPointF &apt2)
: pt1(apt1), pt2(apt2)
{
}

inline QLineF::QLineF(qreal x1pos, qreal y1pos, qreal x2pos, qreal y2pos)
: pt1(x1pos, y1pos), pt2(x2pos, y2pos)
{
}

inline qreal QLineF::x1() const
{
return pt1.x();
}

inline qreal QLineF::y1() const
{
return pt1.y();
}

inline qreal QLineF::x2() const
{
return pt2.x();
}

inline qreal QLineF::y2() const
{
return pt2.y();
}

inline QPointF QLineF::p1() const
{
return pt1;
}

inline QPointF QLineF::p2() const
{
return pt2;
}

inline qreal QLineF::dx() const
{
return pt2.x() - pt1.x();
}

inline qreal QLineF::dy() const
{
return pt2.y() - pt1.y();
}

inline QLineF QLineF::normalVector() const
{
return QLineF(p1(), p1() + QPointF(dy(), -dx()));
}

inline void QLineF::translate(const QPointF &point)
{
pt1 += point;
pt2 += point;
}

inline void QLineF::translate(qreal adx, qreal ady)
{
this->translate(QPointF(adx, ady));
}

inline QLineF QLineF::translated(const QPointF &p) const
{
return QLineF(pt1 + p, pt2 + p);
}

inline QLineF QLineF::translated(qreal adx, qreal ady) const
{
return translated(QPointF(adx, ady));
}

inline void QLineF::setLength(qreal len)
{
if (isNull())
return;
QLineF v = unitVector();
pt2 = QPointF(pt1.x() + v.dx() * len, pt1.y() + v.dy() * len);
}

inline QPointF QLineF::pointAt(qreal t) const
{
qreal vx = pt2.x() - pt1.x();
qreal vy = pt2.y() - pt1.y();
return QPointF(pt1.x() + vx * t, pt1.y() + vy * t);
}

inline QLine QLineF::toLine() const
{
return QLine(pt1.toPoint(), pt2.toPoint());
}


inline void QLineF::setP1(const QPointF &aP1)
{
pt1 = aP1;
}

inline void QLineF::setP2(const QPointF &aP2)
{
pt2 = aP2;
}

inline void QLineF::setPoints(const QPointF &aP1, const QPointF &aP2)
{
pt1 = aP1;
pt2 = aP2;
}

inline void QLineF::setLine(qreal aX1, qreal aY1, qreal aX2, qreal aY2)
{
pt1 = QPointF(aX1, aY1);
pt2 = QPointF(aX2, aY2);
}


inline bool QLineF::operator==(const QLineF &d) const
{
return pt1 == d.pt1 && pt2 == d.pt2;
}




# 412 "/usr/share/qt4/include/QtCore/qline.h"
 QDebug operator<<(QDebug d, const QLineF &p);



# 416 "/usr/share/qt4/include/QtCore/qline.h"
 QDataStream &operator<<(QDataStream &, const QLineF &);
 QDataStream &operator>>(QDataStream &, QLineF &);


# 420 "/usr/share/qt4/include/QtCore/qline.h"





# 79 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qlinkedlist.h"












































# 1 "/usr/share/qt4/include/QtCore/qiterator.h"






































































# 45 "/usr/share/qt4/include/QtCore/qlinkedlist.h"

# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 46 "/usr/share/qt4/include/QtCore/qlinkedlist.h"







# 53 "/usr/share/qt4/include/QtCore/qlinkedlist.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

struct  QLinkedListData
{
QLinkedListData *n, *p;
QBasicAtomicInt ref;
int size;
uint sharable : 1;

static QLinkedListData shared_null;
};

template <typename T>
struct QLinkedListNode
{
inline QLinkedListNode(const T &arg): t(arg) { }
QLinkedListNode *n, *p;
T t;
};

template <class T>
class QLinkedList
{
typedef QLinkedListNode<T> Node;
union { QLinkedListData *d; QLinkedListNode<T> *e; };

public:
inline QLinkedList() : d(&QLinkedListData::shared_null) { d->ref.ref(); }
inline QLinkedList(const QLinkedList<T> &l) : d(l.d) { d->ref.ref(); if (!d->sharable) detach(); }
~QLinkedList();
QLinkedList<T> &operator=(const QLinkedList<T> &);
bool operator==(const QLinkedList<T> &l) const;
inline bool operator!=(const QLinkedList<T> &l) const { return !(*this == l); }

inline int size() const { return d->size; }
inline void detach()
{ if (d->ref != 1) detach_helper(); }
inline bool isDetached() const { return d->ref == 1; }
inline void setSharable(bool sharable) { if (!sharable) detach(); d->sharable = sharable; }

inline bool isEmpty() const { return d->size == 0; }

void clear();

void append(const T &);
void prepend(const T &);
T takeFirst();
T takeLast();
int removeAll(const T &t);
bool removeOne(const T &t);
bool contains(const T &t) const;
int count(const T &t) const;

class const_iterator;

class iterator
{
public:
typedef std::bidirectional_iterator_tag iterator_category;
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef T *pointer;
typedef T &reference;
Node *i;
inline iterator() : i(0) {}
inline iterator(Node *n) : i(n) {}
inline iterator(const iterator &o) : i(o.i) {}
inline iterator &operator=(const iterator &o) { i = o.i; return *this; }
inline T &operator*() const { return i->t; }
inline T *operator->() const { return &i->t; }
inline bool operator==(const iterator &o) const { return i == o.i; }
inline bool operator!=(const iterator &o) const { return i != o.i; }
inline bool operator==(const const_iterator &o) const
{ return i == o.i; }
inline bool operator!=(const const_iterator &o) const
{ return i != o.i; }
inline iterator &operator++() { i = i->n; return *this; }
inline iterator operator++(int) { Node *n = i; i = i->n; return n; }
inline iterator &operator--() { i = i->p; return *this; }
inline iterator operator--(int) { Node *n = i; i = i->p; return n; }
inline iterator operator+(int j) const
{ Node *n = i; if (j > 0) while (j--) n = n->n; else while (j++) n = n->p; return n; }
inline iterator operator-(int j) const { return operator+(-j); }
inline iterator &operator+=(int j) { return *this = *this + j; }
inline iterator &operator-=(int j) { return *this = *this - j; }
};
friend class iterator;

class const_iterator
{
public:
typedef std::bidirectional_iterator_tag iterator_category;
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef const T *pointer;
typedef const T &reference;
Node *i;
inline const_iterator() : i(0) {}
inline const_iterator(Node *n) : i(n) {}
inline const_iterator(const const_iterator &o) : i(o.i){}
inline const_iterator(iterator ci) : i(ci.i){}
inline const_iterator &operator=(const const_iterator &o) { i = o.i; return *this; }
inline const T &operator*() const { return i->t; }
inline const T *operator->() const { return &i->t; }
inline bool operator==(const const_iterator &o) const { return i == o.i; }
inline bool operator!=(const const_iterator &o) const { return i != o.i; }
inline const_iterator &operator++() { i = i->n; return *this; }
inline const_iterator operator++(int) { Node *n = i; i = i->n; return n; }
inline const_iterator &operator--() { i = i->p; return *this; }
inline const_iterator operator--(int) { Node *n = i; i = i->p; return n; }
inline const_iterator operator+(int j) const
{ Node *n = i; if (j > 0) while (j--) n = n->n; else while (j++) n = n->p; return n; }
inline const_iterator operator-(int j) const { return operator+(-j); }
inline const_iterator &operator+=(int j) { return *this = *this + j; }
inline const_iterator &operator-=(int j) { return *this = *this - j; }
};
friend class const_iterator;


inline iterator begin() { detach(); return e->n; }
inline const_iterator begin() const { return e->n; }
inline const_iterator constBegin() const { return e->n; }
inline iterator end() { detach(); return e; }
inline const_iterator end() const { return e; }
inline const_iterator constEnd() const { return e; }
iterator insert(iterator before, const T &t);
iterator erase(iterator pos);
iterator erase(iterator first, iterator last);


typedef iterator Iterator;
typedef const_iterator ConstIterator;
inline int count() const { return d->size; }
inline T& first() { qt_noop(); return *begin(); }
inline const T& first() const { qt_noop(); return *begin(); }
T& last() { qt_noop(); return *(--end()); }
const T& last() const { qt_noop(); return *(--end()); }
inline void removeFirst() { qt_noop(); erase(begin()); }
inline void removeLast() { qt_noop(); erase(--end()); }
inline bool startsWith(const T &t) const { return !isEmpty() && first() == t; }
inline bool endsWith(const T &t) const { return !isEmpty() && last() == t; }


inline void push_back(const T &t) { append(t); }
inline void push_front(const T &t) { prepend(t); }
inline T& front() { return first(); }
inline const T& front() const { return first(); }
inline T& back() { return last(); }
inline const T& back() const { return last(); }
inline void pop_front() { removeFirst(); }
inline void pop_back() { removeLast(); }
inline bool empty() const { return isEmpty(); }
typedef int size_type;
typedef T value_type;
typedef value_type *pointer;
typedef const value_type *const_pointer;
typedef value_type &reference;
typedef const value_type &const_reference;
typedef ptrdiff_t difference_type;























# 239 "/usr/share/qt4/include/QtCore/qlinkedlist.h"

QLinkedList<T> &operator+=(const QLinkedList<T> &l);
QLinkedList<T> operator+(const QLinkedList<T> &l) const;
inline QLinkedList<T> &operator+=(const T &t) { append(t); return *this; }
inline QLinkedList<T> &operator<< (const T &t) { append(t); return *this; }
inline QLinkedList<T> &operator<<(const QLinkedList<T> &l) { *this += l; return *this; }

private:
void detach_helper();
void free(QLinkedListData*);
};

template <typename T>
inline QLinkedList<T>::~QLinkedList()
{
if (!d)
return;
if (!d->ref.deref())
free(d);
}

template <typename T>
void QLinkedList<T>::detach_helper()
{
union { QLinkedListData *d; Node *e; } x;
x.d = new QLinkedListData;
x.d->ref = 1;
x.d->size = d->size;
x.d->sharable = true;
Node *original = e->n;
Node *copy = x.e;
while (original != e) {
try {
copy->n = new Node(original->t);
copy->n->p = copy;
original = original->n;
copy = copy->n;
} catch (...) {
copy->n = x.e;
free(x.d);
throw;
}
}
copy->n = x.e;
x.e->p = copy;
if (!d->ref.deref())
free(d);
d = x.d;
}

template <typename T>
void QLinkedList<T>::free(QLinkedListData *x)
{
Node *y = reinterpret_cast<Node*>(x);
Node *i = y->n;
if (x->ref == 0) {
while(i != y) {
Node *n = i;
i = i->n;
delete n;
}
delete x;
}
}

template <typename T>
void QLinkedList<T>::clear()
{
*this = QLinkedList<T>();
}

template <typename T>
QLinkedList<T> &QLinkedList<T>::operator=(const QLinkedList<T> &l)
{
if (d != l.d) {
l.d->ref.ref();
if (!d->ref.deref())
free(d);
d = l.d;
if (!d->sharable)
detach_helper();
}
return *this;
}

template <typename T>
bool QLinkedList<T>::operator== (const QLinkedList<T> &l) const
{
if (d->size != l.d->size)
return false;
if (e == l.e)
return true;
Node *i = e->n;
Node *il = l.e->n;
while (i != e) {
if (! (i->t == il->t))
return false;
i = i->n;
il = il->n;
}
return true;
}

template <typename T>
void QLinkedList<T>::append(const T &t)
{
detach();
Node *i = new Node(t);
i->n = e;
i->p = e->p;
i->p->n = i;
e->p = i;
d->size++;
}

template <typename T>
void QLinkedList<T>::prepend(const T &t)
{
detach();
Node *i = new Node(t);
i->n = e->n;
i->p = e;
i->n->p = i;
e->n = i;
d->size++;
}

template <typename T>
int QLinkedList<T>::removeAll(const T &_t)
{
detach();
const T t = _t;
Node *i = e->n;
int c = 0;
while (i != e) {
if (i->t == t) {
Node *n = i;
i->n->p = i->p;
i->p->n = i->n;
i = i->n;
delete n;
c++;
} else {
i = i->n;
}
}
d->size-=c;
return c;
}

template <typename T>
bool QLinkedList<T>::removeOne(const T &_t)
{
detach();
iterator it = qFind(begin(), end(), _t);
if (it != end()) {
erase(it);
return true;
}
return false;
}

template <typename T>
inline T QLinkedList<T>::takeFirst()
{
T t = first();
removeFirst();
return t;
}

template <typename T>
inline T QLinkedList<T>::takeLast()
{
T t = last();
removeLast();
return t;
}

template <typename T>
bool QLinkedList<T>::contains(const T &t) const
{
Node *i = e;
while ((i = i->n) != e)
if (i->t == t)
return true;
return false;
}

template <typename T>
int QLinkedList<T>::count(const T &t) const
{
Node *i = e;
int c = 0;
while ((i = i->n) != e)
if (i->t == t)
c++;
return c;
}


template <typename T>
typename QLinkedList<T>::iterator QLinkedList<T>::insert(iterator before, const T &t)
{
Node *i = before.i;
Node *m = new Node(t);
m->n = i;
m->p = i->p;
m->p->n = m;
i->p = m;
d->size++;
return m;
}

template <typename T>
typename QLinkedList<T>::iterator QLinkedList<T>::erase(typename QLinkedList<T>::iterator afirst,
typename QLinkedList<T>::iterator alast)
{
while (afirst != alast)
erase(afirst++);
return alast;
}


template <typename T>
typename QLinkedList<T>::iterator QLinkedList<T>::erase(iterator pos)
{
detach();
Node *i = pos.i;
if (i != e) {
Node *n = i;
i->n->p = i->p;
i->p->n = i->n;
i = i->n;
delete n;
d->size--;
}
return i;
}

template <typename T>
QLinkedList<T> &QLinkedList<T>::operator+=(const QLinkedList<T> &l)
{
detach();
int n = l.d->size;
d->size += n;
Node *original = l.e->n;
while (n--) {
try {
Node *copy = new Node(original->t);
original = original->n;
copy->n = e;
copy->p = e->p;
copy->p->n = copy;
e->p = copy;
} catch (...) {

while (n++<d->size)
removeLast();
throw;
}
}
return *this;
}

template <typename T>
QLinkedList<T> QLinkedList<T>::operator+(const QLinkedList<T> &l) const
{
QLinkedList<T> n = *this;
n += l;
return n;
}

template <class T> class QLinkedListIterator { typedef typename QLinkedList<T>::const_iterator const_iterator; QLinkedList<T> c; const_iterator i; public: inline QLinkedListIterator(const QLinkedList<T> &container) : c(container), i(c.constBegin()) {} inline QLinkedListIterator &operator=(const QLinkedList<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };
template <class T> class QMutableLinkedListIterator { typedef typename QLinkedList<T>::iterator iterator; typedef typename QLinkedList<T>::const_iterator const_iterator; QLinkedList<T> *c; iterator i, n; inline bool item_exists() const { return const_iterator(n) != c->constEnd(); } public: inline QMutableLinkedListIterator(QLinkedList<T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableLinkedListIterator() { c->setSharable(true); } inline QMutableLinkedListIterator &operator=(QLinkedList<T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = i; } inline bool hasNext() const { return c->constEnd() != const_iterator(i); } inline T &next() { n = i++; return *n; } inline T &peekNext() const { return *i; } inline bool hasPrevious() const { return c->constBegin() != const_iterator(i); } inline T &previous() { n = --i; return *n; } inline T &peekPrevious() const { iterator p = i; return *--p; } inline void remove() { if (c->constEnd() != const_iterator(n)) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) const { if (c->constEnd() != const_iterator(n)) *n = t; } inline T &value() { qt_noop(); return *n; } inline const T &value() const { qt_noop(); return *n; } inline void insert(const T &t) { n = i = c->insert(i, t); ++i; } inline bool findNext(const T &t) { while (c->constEnd() != const_iterator(n = i)) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (c->constBegin() != const_iterator(i)) if (*(n = --i) == t) return true; n = c->end(); return false; } };






# 80 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 81 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qlocale.h"




































































































































































































































































































































































































































































































































































































































































































# 82 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qmap.h"




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 83 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qmargins.h"












































# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qmargins.h"


# 47 "/usr/share/qt4/include/QtCore/qmargins.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QMargins
{
public:
QMargins();
QMargins(int left, int top, int right, int bottom);

bool isNull() const;

int left() const;
int top() const;
int right() const;
int bottom() const;

void setLeft(int left);
void setTop(int top);
void setRight(int right);
void setBottom(int bottom);

private:
int m_left;
int m_top;
int m_right;
int m_bottom;

friend inline bool operator==(const QMargins &, const QMargins &);
friend inline bool operator!=(const QMargins &, const QMargins &);
};

template <> class QTypeInfo<QMargins > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMargins)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QMargins"; } };





inline QMargins::QMargins()
{ m_top = m_bottom = m_left = m_right = 0; }

inline QMargins::QMargins(int aleft, int atop, int aright, int abottom)
: m_left(aleft), m_top(atop), m_right(aright), m_bottom(abottom) {}

inline bool QMargins::isNull() const
{ return m_left==0 && m_top==0 && m_right==0 && m_bottom==0; }

inline int QMargins::left() const
{ return m_left; }

inline int QMargins::top() const
{ return m_top; }

inline int QMargins::right() const
{ return m_right; }

inline int QMargins::bottom() const
{ return m_bottom; }


inline void QMargins::setLeft(int aleft)
{ m_left = aleft; }

inline void QMargins::setTop(int atop)
{ m_top = atop; }

inline void QMargins::setRight(int aright)
{ m_right = aright; }

inline void QMargins::setBottom(int abottom)
{ m_bottom = abottom; }

inline bool operator==(const QMargins &m1, const QMargins &m2)
{
return
m1.m_left == m2.m_left &&
m1.m_top == m2.m_top &&
m1.m_right == m2.m_right &&
m1.m_bottom == m2.m_bottom;
}

inline bool operator!=(const QMargins &m1, const QMargins &m2)
{
return
m1.m_left != m2.m_left ||
m1.m_top != m2.m_top ||
m1.m_right != m2.m_right ||
m1.m_bottom != m2.m_bottom;
}


# 140 "/usr/share/qt4/include/QtCore/qmargins.h"
 QDebug operator<<(QDebug, const QMargins &);


# 143 "/usr/share/qt4/include/QtCore/qmargins.h"





# 84 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qpair.h"































































































































# 85 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 86 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qqueue.h"












































# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qqueue.h"


# 47 "/usr/share/qt4/include/QtCore/qqueue.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

template <class T>
class QQueue : public QList<T>
{
public:
inline QQueue() {}
inline ~QQueue() {}
inline void enqueue(const T &t) { QList<T>::append(t); }
inline T dequeue() { return QList<T>::takeFirst(); }
inline T &head() { return QList<T>::first(); }
inline const T &head() const { return QList<T>::first(); }
};






# 87 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"












































# 1 "/usr/share/qt4/include/QtCore/qsize.h"












































# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qsize.h"


# 47 "/usr/share/qt4/include/QtCore/qsize.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class  QSize
{
public:
QSize();
QSize(int w, int h);

bool isNull() const;
bool isEmpty() const;
bool isValid() const;

int width() const;
int height() const;
void setWidth(int w);
void setHeight(int h);
void transpose();

void scale(int w, int h, Qt::AspectRatioMode mode);
void scale(const QSize &s, Qt::AspectRatioMode mode);

QSize expandedTo(const QSize &) const;
QSize boundedTo(const QSize &) const;

int &rwidth();
int &rheight();

QSize &operator+=(const QSize &);
QSize &operator-=(const QSize &);
QSize &operator*=(qreal c);
QSize &operator/=(qreal c);

friend inline bool operator==(const QSize &, const QSize &);
friend inline bool operator!=(const QSize &, const QSize &);
friend inline const QSize operator+(const QSize &, const QSize &);
friend inline const QSize operator-(const QSize &, const QSize &);
friend inline const QSize operator*(const QSize &, qreal);
friend inline const QSize operator*(qreal, const QSize &);
friend inline const QSize operator/(const QSize &, qreal);

private:
int wd;
int ht;
};
template <> class QTypeInfo<QSize > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QSize)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QSize"; } };






# 102 "/usr/share/qt4/include/QtCore/qsize.h"
 QDataStream &operator<<(QDataStream &, const QSize &);
 QDataStream &operator>>(QDataStream &, QSize &);



# 107 "/usr/share/qt4/include/QtCore/qsize.h"




inline QSize::QSize()
{ wd = ht = -1; }

inline QSize::QSize(int w, int h)
{ wd = w; ht = h; }

inline bool QSize::isNull() const
{ return wd==0 && ht==0; }

inline bool QSize::isEmpty() const
{ return wd<1 || ht<1; }

inline bool QSize::isValid() const
{ return wd>=0 && ht>=0; }

inline int QSize::width() const
{ return wd; }

inline int QSize::height() const
{ return ht; }

inline void QSize::setWidth(int w)
{ wd = w; }

inline void QSize::setHeight(int h)
{ ht = h; }

inline void QSize::scale(int w, int h, Qt::AspectRatioMode mode)
{ scale(QSize(w, h), mode); }

inline int &QSize::rwidth()
{ return wd; }

inline int &QSize::rheight()
{ return ht; }

inline QSize &QSize::operator+=(const QSize &s)
{ wd+=s.wd; ht+=s.ht; return *this; }

inline QSize &QSize::operator-=(const QSize &s)
{ wd-=s.wd; ht-=s.ht; return *this; }

inline QSize &QSize::operator*=(qreal c)
{ wd = qRound(wd*c); ht = qRound(ht*c); return *this; }

inline bool operator==(const QSize &s1, const QSize &s2)
{ return s1.wd == s2.wd && s1.ht == s2.ht; }

inline bool operator!=(const QSize &s1, const QSize &s2)
{ return s1.wd != s2.wd || s1.ht != s2.ht; }

inline const QSize operator+(const QSize & s1, const QSize & s2)
{ return QSize(s1.wd+s2.wd, s1.ht+s2.ht); }

inline const QSize operator-(const QSize &s1, const QSize &s2)
{ return QSize(s1.wd-s2.wd, s1.ht-s2.ht); }

inline const QSize operator*(const QSize &s, qreal c)
{ return QSize(qRound(s.wd*c), qRound(s.ht*c)); }

inline const QSize operator*(qreal c, const QSize &s)
{ return QSize(qRound(s.wd*c), qRound(s.ht*c)); }

inline QSize &QSize::operator/=(qreal c)
{
qt_noop();
wd = qRound(wd/c); ht = qRound(ht/c);
return *this;
}

inline const QSize operator/(const QSize &s, qreal c)
{
qt_noop();
return QSize(qRound(s.wd/c), qRound(s.ht/c));
}

inline QSize QSize::expandedTo(const QSize & otherSize) const
{
return QSize(qMax(wd,otherSize.wd), qMax(ht,otherSize.ht));
}

inline QSize QSize::boundedTo(const QSize & otherSize) const
{
return QSize(qMin(wd,otherSize.wd), qMin(ht,otherSize.ht));
}


# 198 "/usr/share/qt4/include/QtCore/qsize.h"
 QDebug operator<<(QDebug, const QSize &);



# 202 "/usr/share/qt4/include/QtCore/qsize.h"
class  QSizeF
{
public:
QSizeF();
QSizeF(const QSize &sz);
QSizeF(qreal w, qreal h);

bool isNull() const;
bool isEmpty() const;
bool isValid() const;

qreal width() const;
qreal height() const;
void setWidth(qreal w);
void setHeight(qreal h);
void transpose();

void scale(qreal w, qreal h, Qt::AspectRatioMode mode);
void scale(const QSizeF &s, Qt::AspectRatioMode mode);

QSizeF expandedTo(const QSizeF &) const;
QSizeF boundedTo(const QSizeF &) const;

qreal &rwidth();
qreal &rheight();

QSizeF &operator+=(const QSizeF &);
QSizeF &operator-=(const QSizeF &);
QSizeF &operator*=(qreal c);
QSizeF &operator/=(qreal c);

friend inline bool operator==(const QSizeF &, const QSizeF &);
friend inline bool operator!=(const QSizeF &, const QSizeF &);
friend inline const QSizeF operator+(const QSizeF &, const QSizeF &);
friend inline const QSizeF operator-(const QSizeF &, const QSizeF &);
friend inline const QSizeF operator*(const QSizeF &, qreal);
friend inline const QSizeF operator*(qreal, const QSizeF &);
friend inline const QSizeF operator/(const QSizeF &, qreal);

inline QSize toSize() const;

private:
qreal wd;
qreal ht;
};
template <> class QTypeInfo<QSizeF > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QSizeF)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QSizeF"; } };







# 255 "/usr/share/qt4/include/QtCore/qsize.h"
 QDataStream &operator<<(QDataStream &, const QSizeF &);
 QDataStream &operator>>(QDataStream &, QSizeF &);



# 260 "/usr/share/qt4/include/QtCore/qsize.h"




inline QSizeF::QSizeF()
{ wd = ht = -1.; }

inline QSizeF::QSizeF(const QSize &sz)
: wd(sz.width()), ht(sz.height())
{
}

inline QSizeF::QSizeF(qreal w, qreal h)
{ wd = w; ht = h; }

inline bool QSizeF::isNull() const
{ return qIsNull(wd) && qIsNull(ht); }

inline bool QSizeF::isEmpty() const
{ return wd <= 0. || ht <= 0.; }

inline bool QSizeF::isValid() const
{ return wd >= 0. && ht >= 0.; }

inline qreal QSizeF::width() const
{ return wd; }

inline qreal QSizeF::height() const
{ return ht; }

inline void QSizeF::setWidth(qreal w)
{ wd = w; }

inline void QSizeF::setHeight(qreal h)
{ ht = h; }

inline void QSizeF::scale(qreal w, qreal h, Qt::AspectRatioMode mode)
{ scale(QSizeF(w, h), mode); }

inline qreal &QSizeF::rwidth()
{ return wd; }

inline qreal &QSizeF::rheight()
{ return ht; }

inline QSizeF &QSizeF::operator+=(const QSizeF &s)
{ wd += s.wd; ht += s.ht; return *this; }

inline QSizeF &QSizeF::operator-=(const QSizeF &s)
{ wd -= s.wd; ht -= s.ht; return *this; }

inline QSizeF &QSizeF::operator*=(qreal c)
{ wd *= c; ht *= c; return *this; }

inline bool operator==(const QSizeF &s1, const QSizeF &s2)
{ return qFuzzyCompare(s1.wd, s2.wd) && qFuzzyCompare(s1.ht, s2.ht); }

inline bool operator!=(const QSizeF &s1, const QSizeF &s2)
{ return !qFuzzyCompare(s1.wd, s2.wd) || !qFuzzyCompare(s1.ht, s2.ht); }

inline const QSizeF operator+(const QSizeF & s1, const QSizeF & s2)
{ return QSizeF(s1.wd+s2.wd, s1.ht+s2.ht); }

inline const QSizeF operator-(const QSizeF &s1, const QSizeF &s2)
{ return QSizeF(s1.wd-s2.wd, s1.ht-s2.ht); }

inline const QSizeF operator*(const QSizeF &s, qreal c)
{ return QSizeF(s.wd*c, s.ht*c); }

inline const QSizeF operator*(qreal c, const QSizeF &s)
{ return QSizeF(s.wd*c, s.ht*c); }

inline QSizeF &QSizeF::operator/=(qreal c)
{
qt_noop();
wd = wd/c; ht = ht/c;
return *this;
}

inline const QSizeF operator/(const QSizeF &s, qreal c)
{
qt_noop();
return QSizeF(s.wd/c, s.ht/c);
}

inline QSizeF QSizeF::expandedTo(const QSizeF & otherSize) const
{
return QSizeF(qMax(wd,otherSize.wd), qMax(ht,otherSize.ht));
}

inline QSizeF QSizeF::boundedTo(const QSizeF & otherSize) const
{
return QSizeF(qMin(wd,otherSize.wd), qMin(ht,otherSize.ht));
}

inline QSize QSizeF::toSize() const
{
return QSize(qRound(wd), qRound(ht));
}


# 361 "/usr/share/qt4/include/QtCore/qsize.h"
 QDebug operator<<(QDebug, const QSizeF &);


# 364 "/usr/share/qt4/include/QtCore/qsize.h"





# 45 "/usr/share/qt4/include/QtCore/qrect.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qrect.h"






# 52 "/usr/share/qt4/include/QtCore/qrect.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class  QRect
{
public:
QRect() { x1 = y1 = 0; x2 = y2 = -1; }
QRect(const QPoint &topleft, const QPoint &bottomright);
QRect(const QPoint &topleft, const QSize &size);
QRect(int left, int top, int width, int height);

bool isNull() const;
bool isEmpty() const;
bool isValid() const;

int left() const;
int top() const;
int right() const;
int bottom() const;
QRect normalized() const;










# 85 "/usr/share/qt4/include/QtCore/qrect.h"
int x() const;
int y() const;
void setLeft(int pos);
void setTop(int pos);
void setRight(int pos);
void setBottom(int pos);
void setX(int x);
void setY(int y);

void setTopLeft(const QPoint &p);
void setBottomRight(const QPoint &p);
void setTopRight(const QPoint &p);
void setBottomLeft(const QPoint &p);

QPoint topLeft() const;
QPoint bottomRight() const;
QPoint topRight() const;
QPoint bottomLeft() const;
QPoint center() const;

void moveLeft(int pos);
void moveTop(int pos);
void moveRight(int pos);
void moveBottom(int pos);
void moveTopLeft(const QPoint &p);
void moveBottomRight(const QPoint &p);
void moveTopRight(const QPoint &p);
void moveBottomLeft(const QPoint &p);
void moveCenter(const QPoint &p);

inline void translate(int dx, int dy);
inline void translate(const QPoint &p);
inline QRect translated(int dx, int dy) const;
inline QRect translated(const QPoint &p) const;

void moveTo(int x, int t);
void moveTo(const QPoint &p);






# 128 "/usr/share/qt4/include/QtCore/qrect.h"
void setRect(int x, int y, int w, int h);
inline void getRect(int *x, int *y, int *w, int *h) const;

void setCoords(int x1, int y1, int x2, int y2);



# 135 "/usr/share/qt4/include/QtCore/qrect.h"
inline void getCoords(int *x1, int *y1, int *x2, int *y2) const;

inline void adjust(int x1, int y1, int x2, int y2);
inline QRect adjusted(int x1, int y1, int x2, int y2) const;

QSize size() const;
int width() const;
int height() const;
void setWidth(int w);
void setHeight(int h);
void setSize(const QSize &s);

QRect operator|(const QRect &r) const;
QRect operator&(const QRect &r) const;
QRect& operator|=(const QRect &r);
QRect& operator&=(const QRect &r);

bool contains(const QPoint &p, bool proper=false) const;
bool contains(int x, int y) const; 
bool contains(int x, int y, bool proper) const;
bool contains(const QRect &r, bool proper = false) const;
QRect unite(const QRect &r) const; 
QRect united(const QRect &other) const;
QRect intersect(const QRect &r) const; 
QRect intersected(const QRect &other) const;
bool intersects(const QRect &r) const;

friend  inline bool operator==(const QRect &, const QRect &);
friend  inline bool operator!=(const QRect &, const QRect &);







# 171 "/usr/share/qt4/include/QtCore/qrect.h"
private:



# 175 "/usr/share/qt4/include/QtCore/qrect.h"







# 182 "/usr/share/qt4/include/QtCore/qrect.h"
int x1;
int y1;
int x2;
int y2;


# 188 "/usr/share/qt4/include/QtCore/qrect.h"
};
template <> class QTypeInfo<QRect > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QRect)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QRect"; } };

 inline bool operator==(const QRect &, const QRect &);
 inline bool operator!=(const QRect &, const QRect &);






# 199 "/usr/share/qt4/include/QtCore/qrect.h"
 QDataStream &operator<<(QDataStream &, const QRect &);
 QDataStream &operator>>(QDataStream &, QRect &);


# 203 "/usr/share/qt4/include/QtCore/qrect.h"




inline QRect::QRect(int aleft, int atop, int awidth, int aheight)
{
x1 = aleft;
y1 = atop;
x2 = (aleft + awidth - 1);
y2 = (atop + aheight - 1);
}

inline QRect::QRect(const QPoint &atopLeft, const QPoint &abottomRight)
{
x1 = atopLeft.x();
y1 = atopLeft.y();
x2 = abottomRight.x();
y2 = abottomRight.y();
}

inline QRect::QRect(const QPoint &atopLeft, const QSize &asize)
{
x1 = atopLeft.x();
y1 = atopLeft.y();
x2 = (x1+asize.width() - 1);
y2 = (y1+asize.height() - 1);
}

inline bool QRect::isNull() const
{ return x2 == x1 - 1 && y2 == y1 - 1; }

inline bool QRect::isEmpty() const
{ return x1 > x2 || y1 > y2; }

inline bool QRect::isValid() const
{ return x1 <= x2 && y1 <= y2; }

inline int QRect::left() const
{ return x1; }

inline int QRect::top() const
{ return y1; }

inline int QRect::right() const
{ return x2; }

inline int QRect::bottom() const
{ return y2; }

inline int QRect::x() const
{ return x1; }

inline int QRect::y() const
{ return y1; }

inline void QRect::setLeft(int pos)
{ x1 = pos; }

inline void QRect::setTop(int pos)
{ y1 = pos; }

inline void QRect::setRight(int pos)
{ x2 = pos; }

inline void QRect::setBottom(int pos)
{ y2 = pos; }

inline void QRect::setTopLeft(const QPoint &p)
{ x1 = p.x(); y1 = p.y(); }

inline void QRect::setBottomRight(const QPoint &p)
{ x2 = p.x(); y2 = p.y(); }

inline void QRect::setTopRight(const QPoint &p)
{ x2 = p.x(); y1 = p.y(); }

inline void QRect::setBottomLeft(const QPoint &p)
{ x1 = p.x(); y2 = p.y(); }

inline void QRect::setX(int ax)
{ x1 = ax; }

inline void QRect::setY(int ay)
{ y1 = ay; }

inline QPoint QRect::topLeft() const
{ return QPoint(x1, y1); }

inline QPoint QRect::bottomRight() const
{ return QPoint(x2, y2); }

inline QPoint QRect::topRight() const
{ return QPoint(x2, y1); }

inline QPoint QRect::bottomLeft() const
{ return QPoint(x1, y2); }

inline QPoint QRect::center() const
{ return QPoint((x1+x2)/2, (y1+y2)/2); }

inline int QRect::width() const
{ return x2 - x1 + 1; }

inline int QRect::height() const
{ return y2 - y1 + 1; }

inline QSize QRect::size() const
{ return QSize(width(), height()); }

inline void QRect::translate(int dx, int dy)
{
x1 += dx;
y1 += dy;
x2 += dx;
y2 += dy;
}

inline void QRect::translate(const QPoint &p)
{
x1 += p.x();
y1 += p.y();
x2 += p.x();
y2 += p.y();
}

inline QRect QRect::translated(int dx, int dy) const
{ return QRect(QPoint(x1 + dx, y1 + dy), QPoint(x2 + dx, y2 + dy)); }

inline QRect QRect::translated(const QPoint &p) const
{ return QRect(QPoint(x1 + p.x(), y1 + p.y()), QPoint(x2 + p.x(), y2 + p.y())); }

inline void QRect::moveTo(int ax, int ay)
{
x2 += ax - x1;
y2 += ay - y1;
x1 = ax;
y1 = ay;
}

inline void QRect::moveTo(const QPoint &p)
{
x2 += p.x() - x1;
y2 += p.y() - y1;
x1 = p.x();
y1 = p.y();
}

inline void QRect::moveLeft(int pos)
{ x2 += (pos - x1); x1 = pos; }

inline void QRect::moveTop(int pos)
{ y2 += (pos - y1); y1 = pos; }

inline void QRect::moveRight(int pos)
{
x1 += (pos - x2);
x2 = pos;
}

inline void QRect::moveBottom(int pos)
{
y1 += (pos - y2);
y2 = pos;
}

inline void QRect::moveTopLeft(const QPoint &p)
{
moveLeft(p.x());
moveTop(p.y());
}

inline void QRect::moveBottomRight(const QPoint &p)
{
moveRight(p.x());
moveBottom(p.y());
}

inline void QRect::moveTopRight(const QPoint &p)
{
moveRight(p.x());
moveTop(p.y());
}

inline void QRect::moveBottomLeft(const QPoint &p)
{
moveLeft(p.x());
moveBottom(p.y());
}

inline void QRect::getRect(int *ax, int *ay, int *aw, int *ah) const
{
*ax = x1;
*ay = y1;
*aw = x2 - x1 + 1;
*ah = y2 - y1 + 1;
}

inline void QRect::setRect(int ax, int ay, int aw, int ah)
{
x1 = ax;
y1 = ay;
x2 = (ax + aw - 1);
y2 = (ay + ah - 1);
}

inline void QRect::getCoords(int *xp1, int *yp1, int *xp2, int *yp2) const
{
*xp1 = x1;
*yp1 = y1;
*xp2 = x2;
*yp2 = y2;
}

inline void QRect::setCoords(int xp1, int yp1, int xp2, int yp2)
{
x1 = xp1;
y1 = yp1;
x2 = xp2;
y2 = yp2;
}








# 431 "/usr/share/qt4/include/QtCore/qrect.h"
inline QRect QRect::adjusted(int xp1, int yp1, int xp2, int yp2) const
{ return QRect(QPoint(x1 + xp1, y1 + yp1), QPoint(x2 + xp2, y2 + yp2)); }

inline void QRect::adjust(int dx1, int dy1, int dx2, int dy2)
{
x1 += dx1;
y1 += dy1;
x2 += dx2;
y2 += dy2;
}

inline void QRect::setWidth(int w)
{ x2 = (x1 + w - 1); }

inline void QRect::setHeight(int h)
{ y2 = (y1 + h - 1); }

inline void QRect::setSize(const QSize &s)
{
x2 = (s.width() + x1 - 1);
y2 = (s.height() + y1 - 1);
}

inline bool QRect::contains(int ax, int ay, bool aproper) const
{
return contains(QPoint(ax, ay), aproper);
}

inline bool QRect::contains(int ax, int ay) const
{
return contains(QPoint(ax, ay), false);
}

inline QRect& QRect::operator|=(const QRect &r)
{
*this = *this | r;
return *this;
}

inline QRect& QRect::operator&=(const QRect &r)
{
*this = *this & r;
return *this;
}

inline QRect QRect::intersect(const QRect &r) const
{
return *this & r;
}

inline QRect QRect::intersected(const QRect &other) const
{
return intersect(other);
}

inline QRect QRect::unite(const QRect &r) const
{
return *this | r;
}

inline QRect QRect::united(const QRect &r) const
{
return unite(r);
}

inline bool operator==(const QRect &r1, const QRect &r2)
{
return r1.x1==r2.x1 && r1.x2==r2.x2 && r1.y1==r2.y1 && r1.y2==r2.y2;
}

inline bool operator!=(const QRect &r1, const QRect &r2)
{
return r1.x1!=r2.x1 || r1.x2!=r2.x2 || r1.y1!=r2.y1 || r1.y2!=r2.y2;
}


# 507 "/usr/share/qt4/include/QtCore/qrect.h"
 QDebug operator<<(QDebug, const QRect &);



# 511 "/usr/share/qt4/include/QtCore/qrect.h"
class  QRectF
{
public:
QRectF() { xp = yp = 0.; w = h = 0.; }
QRectF(const QPointF &topleft, const QSizeF &size);
QRectF(const QPointF &topleft, const QPointF &bottomRight);
QRectF(qreal left, qreal top, qreal width, qreal height);
QRectF(const QRect &rect);

bool isNull() const;
bool isEmpty() const;
bool isValid() const;
QRectF normalized() const;

inline qreal left() const { return xp; }
inline qreal top() const { return yp; }
inline qreal right() const { return xp + w; }
inline qreal bottom() const { return yp + h; }

inline qreal x() const;
inline qreal y() const;
inline void setLeft(qreal pos);
inline void setTop(qreal pos);
inline void setRight(qreal pos);
inline void setBottom(qreal pos);
inline void setX(qreal pos) { setLeft(pos); }
inline void setY(qreal pos) { setTop(pos); }

inline QPointF topLeft() const { return QPointF(xp, yp); }
inline QPointF bottomRight() const { return QPointF(xp+w, yp+h); }
inline QPointF topRight() const { return QPointF(xp+w, yp); }
inline QPointF bottomLeft() const { return QPointF(xp, yp+h); }
inline QPointF center() const;

void setTopLeft(const QPointF &p);
void setBottomRight(const QPointF &p);
void setTopRight(const QPointF &p);
void setBottomLeft(const QPointF &p);

void moveLeft(qreal pos);
void moveTop(qreal pos);
void moveRight(qreal pos);
void moveBottom(qreal pos);
void moveTopLeft(const QPointF &p);
void moveBottomRight(const QPointF &p);
void moveTopRight(const QPointF &p);
void moveBottomLeft(const QPointF &p);
void moveCenter(const QPointF &p);

void translate(qreal dx, qreal dy);
void translate(const QPointF &p);

QRectF translated(qreal dx, qreal dy) const;
QRectF translated(const QPointF &p) const;

void moveTo(qreal x, qreal t);
void moveTo(const QPointF &p);

void setRect(qreal x, qreal y, qreal w, qreal h);
void getRect(qreal *x, qreal *y, qreal *w, qreal *h) const;

void setCoords(qreal x1, qreal y1, qreal x2, qreal y2);
void getCoords(qreal *x1, qreal *y1, qreal *x2, qreal *y2) const;

inline void adjust(qreal x1, qreal y1, qreal x2, qreal y2);
inline QRectF adjusted(qreal x1, qreal y1, qreal x2, qreal y2) const;

QSizeF size() const;
qreal width() const;
qreal height() const;
void setWidth(qreal w);
void setHeight(qreal h);
void setSize(const QSizeF &s);

QRectF operator|(const QRectF &r) const;
QRectF operator&(const QRectF &r) const;
QRectF& operator|=(const QRectF &r);
QRectF& operator&=(const QRectF &r);

bool contains(const QPointF &p) const;
bool contains(qreal x, qreal y) const;
bool contains(const QRectF &r) const;
QRectF unite(const QRectF &r) const; 
QRectF united(const QRectF &other) const;
QRectF intersect(const QRectF &r) const; 
QRectF intersected(const QRectF &other) const;
bool intersects(const QRectF &r) const;

friend  inline bool operator==(const QRectF &, const QRectF &);
friend  inline bool operator!=(const QRectF &, const QRectF &);

QRect toRect() const;
QRect toAlignedRect() const;

private:
qreal xp;
qreal yp;
qreal w;
qreal h;
};
template <> class QTypeInfo<QRectF > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QRectF)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QRectF"; } };

 inline bool operator==(const QRectF &, const QRectF &);
 inline bool operator!=(const QRectF &, const QRectF &);






# 621 "/usr/share/qt4/include/QtCore/qrect.h"
 QDataStream &operator<<(QDataStream &, const QRectF &);
 QDataStream &operator>>(QDataStream &, QRectF &);


# 625 "/usr/share/qt4/include/QtCore/qrect.h"




inline QRectF::QRectF(qreal aleft, qreal atop, qreal awidth, qreal aheight)
: xp(aleft), yp(atop), w(awidth), h(aheight)
{
}

inline QRectF::QRectF(const QPointF &atopLeft, const QSizeF &asize)
{
xp = atopLeft.x();
yp = atopLeft.y();
w = asize.width();
h = asize.height();
}

inline QRectF::QRectF(const QPointF &atopLeft, const QPointF &abottomRight)
{
xp = atopLeft.x();
yp = atopLeft.y();
w = abottomRight.x() - xp;
h = abottomRight.y() - yp;
}

inline QRectF::QRectF(const QRect &r)
: xp(r.x()), yp(r.y()), w(r.width()), h(r.height())
{
}

inline bool QRectF::isNull() const
{ return w == 0. && h == 0.; }

inline bool QRectF::isEmpty() const
{ return w <= 0. || h <= 0.; }

inline bool QRectF::isValid() const
{ return w > 0. && h > 0.; }

inline qreal QRectF::x() const
{ return xp; }

inline qreal QRectF::y() const
{ return yp; }

inline void QRectF::setLeft(qreal pos) { qreal diff = pos - xp; xp += diff; w -= diff; }

inline void QRectF::setRight(qreal pos) { w = pos - xp; }

inline void QRectF::setTop(qreal pos) { qreal diff = pos - yp; yp += diff; h -= diff; }

inline void QRectF::setBottom(qreal pos) { h = pos - yp; }

inline void QRectF::setTopLeft(const QPointF &p) { setLeft(p.x()); setTop(p.y()); }

inline void QRectF::setTopRight(const QPointF &p) { setRight(p.x()); setTop(p.y()); }

inline void QRectF::setBottomLeft(const QPointF &p) { setLeft(p.x()); setBottom(p.y()); }

inline void QRectF::setBottomRight(const QPointF &p) { setRight(p.x()); setBottom(p.y()); }

inline QPointF QRectF::center() const
{ return QPointF(xp + w/2, yp + h/2); }

inline void QRectF::moveLeft(qreal pos) { xp = pos; }

inline void QRectF::moveTop(qreal pos) { yp = pos; }

inline void QRectF::moveRight(qreal pos) { xp = pos - w; }

inline void QRectF::moveBottom(qreal pos) { yp = pos - h; }

inline void QRectF::moveTopLeft(const QPointF &p) { moveLeft(p.x()); moveTop(p.y()); }

inline void QRectF::moveTopRight(const QPointF &p) { moveRight(p.x()); moveTop(p.y()); }

inline void QRectF::moveBottomLeft(const QPointF &p) { moveLeft(p.x()); moveBottom(p.y()); }

inline void QRectF::moveBottomRight(const QPointF &p) { moveRight(p.x()); moveBottom(p.y()); }

inline void QRectF::moveCenter(const QPointF &p) { xp = p.x() - w/2; yp = p.y() - h/2; }

inline qreal QRectF::width() const
{ return w; }

inline qreal QRectF::height() const
{ return h; }

inline QSizeF QRectF::size() const
{ return QSizeF(w, h); }

inline void QRectF::translate(qreal dx, qreal dy)
{
xp += dx;
yp += dy;
}

inline void QRectF::translate(const QPointF &p)
{
xp += p.x();
yp += p.y();
}

inline void QRectF::moveTo(qreal ax, qreal ay)
{
xp = ax;
yp = ay;
}

inline void QRectF::moveTo(const QPointF &p)
{
xp = p.x();
yp = p.y();
}

inline QRectF QRectF::translated(qreal dx, qreal dy) const
{ return QRectF(xp + dx, yp + dy, w, h); }

inline QRectF QRectF::translated(const QPointF &p) const
{ return QRectF(xp + p.x(), yp + p.y(), w, h); }

inline void QRectF::getRect(qreal *ax, qreal *ay, qreal *aaw, qreal *aah) const
{
*ax = this->xp;
*ay = this->yp;
*aaw = this->w;
*aah = this->h;
}

inline void QRectF::setRect(qreal ax, qreal ay, qreal aaw, qreal aah)
{
this->xp = ax;
this->yp = ay;
this->w = aaw;
this->h = aah;
}

inline void QRectF::getCoords(qreal *xp1, qreal *yp1, qreal *xp2, qreal *yp2) const
{
*xp1 = xp;
*yp1 = yp;
*xp2 = xp + w;
*yp2 = yp + h;
}

inline void QRectF::setCoords(qreal xp1, qreal yp1, qreal xp2, qreal yp2)
{
xp = xp1;
yp = yp1;
w = xp2 - xp1;
h = yp2 - yp1;
}

inline void QRectF::adjust(qreal xp1, qreal yp1, qreal xp2, qreal yp2)
{ xp += xp1; yp += yp1; w += xp2 - xp1; h += yp2 - yp1; }

inline QRectF QRectF::adjusted(qreal xp1, qreal yp1, qreal xp2, qreal yp2) const
{ return QRectF(xp + xp1, yp + yp1, w + xp2 - xp1, h + yp2 - yp1); }

inline void QRectF::setWidth(qreal aw)
{ this->w = aw; }

inline void QRectF::setHeight(qreal ah)
{ this->h = ah; }

inline void QRectF::setSize(const QSizeF &s)
{
w = s.width();
h = s.height();
}

inline bool QRectF::contains(qreal ax, qreal ay) const
{
return contains(QPointF(ax, ay));
}

inline QRectF& QRectF::operator|=(const QRectF &r)
{
*this = *this | r;
return *this;
}

inline QRectF& QRectF::operator&=(const QRectF &r)
{
*this = *this & r;
return *this;
}

inline QRectF QRectF::intersect(const QRectF &r) const
{
return *this & r;
}

inline QRectF QRectF::intersected(const QRectF &r) const
{
return intersect(r);
}

inline QRectF QRectF::unite(const QRectF &r) const
{
return *this | r;
}

inline QRectF QRectF::united(const QRectF &r) const
{
return unite(r);
}

inline bool operator==(const QRectF &r1, const QRectF &r2)
{
return qFuzzyCompare(r1.xp, r2.xp) && qFuzzyCompare(r1.yp, r2.yp)
&& qFuzzyCompare(r1.w, r2.w) && qFuzzyCompare(r1.h, r2.h);
}

inline bool operator!=(const QRectF &r1, const QRectF &r2)
{
return !qFuzzyCompare(r1.xp, r2.xp) || !qFuzzyCompare(r1.yp, r2.yp)
|| !qFuzzyCompare(r1.w, r2.w) || !qFuzzyCompare(r1.h, r2.h);
}

inline QRect QRectF::toRect() const
{
return QRect(qRound(xp), qRound(yp), qRound(w), qRound(h));
}


# 851 "/usr/share/qt4/include/QtCore/qrect.h"
 QDebug operator<<(QDebug, const QRectF &);


# 854 "/usr/share/qt4/include/QtCore/qrect.h"





# 88 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qregexp.h"




































































































































































# 89 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 90 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qset.h"














































































































































































































































































































































































# 91 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qshareddata.h"




































































































































































































































































# 92 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qsharedpointer.h"



























































































































































# 93 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qsize.h"








































































































































































































































































































































































# 94 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qstack.h"












































# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qstack.h"


# 47 "/usr/share/qt4/include/QtCore/qstack.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

template<class T>
class QStack : public QVector<T>
{
public:
inline QStack() {}
inline ~QStack() {}
inline void push(const T &t) { QVector<T>::append(t); }
T pop();
T &top();
const T &top() const;
};

template<class T>
inline T QStack<T>::pop()
{ qt_noop(); T t = this->data()[this->size() -1];
this->resize(this->size()-1); return t; }

template<class T>
inline T &QStack<T>::top()
{ qt_noop(); this->detach(); return this->data()[this->size()-1]; }

template<class T>
inline const T &QStack<T>::top() const
{ qt_noop(); return this->data()[this->size()-1]; }






# 95 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 96 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qstringbuilder.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qstringbuilder.h"










# 55 "/usr/share/qt4/include/QtCore/qstringbuilder.h"




typedef QtValidLicenseForCoreModule QtCoreModule;


class QLatin1Literal
{
public:
int size() const { return m_size; }
const char *data() const { return m_data; }

template <int N>
QLatin1Literal(const char (&str)[N])
: m_size(N - 1), m_data(str) {}

private:
const int m_size;
const char *m_data;
};

struct  QAbstractConcatenable
{
protected:
static void convertFromAscii(const char *a, int len, QChar *&out);

static inline void convertFromAscii(char a, QChar *&out)
{

# 85 "/usr/share/qt4/include/QtCore/qstringbuilder.h"
if (QString::codecForCStrings)
*out++ = QChar::fromAscii(a);
else

# 89 "/usr/share/qt4/include/QtCore/qstringbuilder.h"
*out++ = QLatin1Char(a);
}
};

template <typename T> struct QConcatenable {};

template <typename A, typename B>
class QStringBuilder
{
public:
QStringBuilder(const A &a_, const B &b_) : a(a_), b(b_) {}

operator QString() const
{
QString s(QConcatenable< QStringBuilder<A, B> >::size(*this),
Qt::Uninitialized);

QChar *d = s.data();
QConcatenable< QStringBuilder<A, B> >::appendTo(*this, d);


s.resize(d - s.data());
return s;
}
QByteArray toLatin1() const { return QString(*this).toLatin1(); }

const A &a;
const B &b;
};


template <> struct QConcatenable<char> : private QAbstractConcatenable
{
typedef char type;
static int size(const char) { return 1; }
static inline void appendTo(const char c, QChar *&out)
{
QAbstractConcatenable::convertFromAscii(c, out);
}
};

template <> struct QConcatenable<QLatin1Char>
{
typedef QLatin1Char type;
static int size(const QLatin1Char) { return 1; }
static inline void appendTo(const QLatin1Char c, QChar *&out)
{
*out++ = c;
}
};

template <> struct QConcatenable<QChar>
{
typedef QChar type;
static int size(const QChar) { return 1; }
static inline void appendTo(const QChar c, QChar *&out)
{
*out++ = c;
}
};

template <> struct QConcatenable<QCharRef>
{
typedef QCharRef type;
static int size(const QCharRef &) { return 1; }
static inline void appendTo(const QCharRef &c, QChar *&out)
{
*out++ = QChar(c);
}
};

template <> struct QConcatenable<QLatin1String>
{
typedef QLatin1String type;
static int size(const QLatin1String &a) { return qstrlen(a.latin1()); }
static inline void appendTo(const QLatin1String &a, QChar *&out)
{
for (const char *s = a.latin1(); *s; )
*out++ = QLatin1Char(*s++);
}

};

template <> struct QConcatenable<QLatin1Literal>
{
typedef QLatin1Literal type;
static int size(const QLatin1Literal &a) { return a.size(); }
static inline void appendTo(const QLatin1Literal &a, QChar *&out)
{
for (const char *s = a.data(); *s; )
*out++ = QLatin1Char(*s++);
}
};

template <> struct QConcatenable<QString>
{
typedef QString type;
static int size(const QString &a) { return a.size(); }
static inline void appendTo(const QString &a, QChar *&out)
{
const int n = a.size();
memcpy(out, reinterpret_cast<const char*>(a.constData()), sizeof(QChar) * n);
out += n;
}
};

template <> struct QConcatenable<QStringRef>
{
typedef QStringRef type;
static int size(const QStringRef &a) { return a.size(); }
static inline void appendTo(QStringRef a, QChar *&out)
{
const int n = a.size();
memcpy(out, reinterpret_cast<const char*>(a.constData()), sizeof(QChar) * n);
out += n;
}
};


# 208 "/usr/share/qt4/include/QtCore/qstringbuilder.h"
template <int N> struct QConcatenable<char[N]> : private QAbstractConcatenable
{
typedef char type[N];
static int size(const char[N])
{
return N - 1;
}
static inline void appendTo(const char a[N], QChar *&out)
{
QAbstractConcatenable::convertFromAscii(a, N, out);
}
};

template <int N> struct QConcatenable<const char[N]> : private QAbstractConcatenable
{
typedef const char type[N];
static int size(const char[N]) { return N - 1; }
static inline void appendTo(const char a[N], QChar *&out)
{
QAbstractConcatenable::convertFromAscii(a, N, out);
}
};

template <> struct QConcatenable<const char *> : private QAbstractConcatenable
{
typedef char const *type;
static int size(const char *a) { return qstrlen(a); }
static inline void appendTo(const char *a, QChar *&out)
{
QAbstractConcatenable::convertFromAscii(a, -1, out);
}
};

template <> struct QConcatenable<QByteArray> : private QAbstractConcatenable
{
typedef QByteArray type;
static int size(const QByteArray &ba) { return qstrnlen(ba.constData(), ba.size()); }
static inline void appendTo(const QByteArray &ba, QChar *&out)
{
QAbstractConcatenable::convertFromAscii(ba.constData(), -1, out);
}
};


# 252 "/usr/share/qt4/include/QtCore/qstringbuilder.h"
template <typename A, typename B>
struct QConcatenable< QStringBuilder<A, B> >
{
typedef QStringBuilder<A, B> type;
static int size(const type &p)
{
return QConcatenable<A>::size(p.a) + QConcatenable<B>::size(p.b);
}
static inline void appendTo(const QStringBuilder<A, B> &p, QChar *&out)
{
QConcatenable<A>::appendTo(p.a, out);
QConcatenable<B>::appendTo(p.b, out);
}
};

template <typename A, typename B>
QStringBuilder<typename QConcatenable<A>::type, typename QConcatenable<B>::type>
operator%(const A &a, const B &b)
{
return QStringBuilder<typename QConcatenable<A>::type, typename QConcatenable<B>::type>(a, b);
}










# 283 "/usr/share/qt4/include/QtCore/qstringbuilder.h"





# 97 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"



































































































































































































































































# 98 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qstringmatcher.h"







































































































# 99 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtextboundaryfinder.h"












































# 1 "/usr/share/qt4/include/QtCore/qchar.h"













































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtextboundaryfinder.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qtextboundaryfinder.h"


# 48 "/usr/share/qt4/include/QtCore/qtextboundaryfinder.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QTextBoundaryFinderPrivate;

class  QTextBoundaryFinder
{
public:
QTextBoundaryFinder();
QTextBoundaryFinder(const QTextBoundaryFinder &other);
QTextBoundaryFinder &operator=(const QTextBoundaryFinder &other);
~QTextBoundaryFinder();

enum BoundaryType {
Grapheme,
Word,
Line,
Sentence
};

enum BoundaryReason {
NotAtBoundary = 0,
StartWord = 1,
EndWord = 2

};
typedef QFlags<BoundaryReason > BoundaryReasons;

QTextBoundaryFinder(BoundaryType type, const QString &string);
QTextBoundaryFinder(BoundaryType type, const QChar *chars, int length, unsigned char *buffer = 0, int bufferSize = 0);

inline bool isValid() const { return d; }

inline BoundaryType type() const { return t; }
QString string() const;

void toStart();
void toEnd();
int position() const;
void setPosition(int position);

int toNextBoundary();
int toPreviousBoundary();

bool isAtBoundary() const;
BoundaryReasons boundaryReasons() const;

private:
BoundaryType t;
QString s;
const QChar *chars;
int length;
int pos;
uint freePrivate : 1;
uint unused : 31;
QTextBoundaryFinderPrivate *d;
};







# 100 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtimeline.h"












































# 1 "/usr/share/qt4/include/QtCore/qeasingcurve.h"


















































































































# 45 "/usr/share/qt4/include/QtCore/qtimeline.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qtimeline.h"


# 48 "/usr/share/qt4/include/QtCore/qtimeline.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QTimeLinePrivate;
class  QTimeLine : public QObject
{
Q_OBJECT
Q_PROPERTY(int duration READ duration WRITE setDuration)
Q_PROPERTY(int updateInterval READ updateInterval WRITE setUpdateInterval)
Q_PROPERTY(int currentTime READ currentTime WRITE setCurrentTime)
Q_PROPERTY(Direction direction READ direction WRITE setDirection)
Q_PROPERTY(int loopCount READ loopCount WRITE setLoopCount)
Q_PROPERTY(CurveShape curveShape READ curveShape WRITE setCurveShape)
Q_PROPERTY(QEasingCurve easingCurve READ easingCurve WRITE setEasingCurve)
public:
enum State {
NotRunning,
Paused,
Running
};
enum Direction {
Forward,
Backward
};
enum CurveShape {
EaseInCurve,
EaseOutCurve,
EaseInOutCurve,
LinearCurve,
SineCurve,
CosineCurve
};

explicit QTimeLine(int duration = 1000, QObject *parent = 0);
virtual ~QTimeLine();

State state() const;

int loopCount() const;
void setLoopCount(int count);

Direction direction() const;
void setDirection(Direction direction);

int duration() const;
void setDuration(int duration);

int startFrame() const;
void setStartFrame(int frame);
int endFrame() const;
void setEndFrame(int frame);
void setFrameRange(int startFrame, int endFrame);

int updateInterval() const;
void setUpdateInterval(int interval);

CurveShape curveShape() const;
void setCurveShape(CurveShape shape);

QEasingCurve easingCurve() const;
void setEasingCurve(const QEasingCurve &curve);

int currentTime() const;
int currentFrame() const;
qreal currentValue() const;

int frameForTime(int msec) const;
virtual qreal valueForTime(int msec) const;

public slots:
void start();
void resume();
void stop();
void setPaused(bool paused);
void setCurrentTime(int msec);
void toggleDirection();

signals:
void valueChanged(qreal x);
void frameChanged(int);
void stateChanged(QTimeLine::State newState);
void finished();

protected:
void timerEvent(QTimerEvent *event);

private:
QTimeLine(const QTimeLine &); QTimeLine &operator=(const QTimeLine &);
inline QTimeLinePrivate* d_func() { return reinterpret_cast<QTimeLinePrivate *>(qGetPtrHelper(d_ptr)); } inline const QTimeLinePrivate* d_func() const { return reinterpret_cast<const QTimeLinePrivate *>(qGetPtrHelper(d_ptr)); } friend class QTimeLinePrivate;
};







# 101 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qvarlengtharray.h"












































# 1 "/usr/share/qt4/include/QtCore/qcontainerfwd.h"







































































# 45 "/usr/share/qt4/include/QtCore/qvarlengtharray.h"

# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qvarlengtharray.h"



# 49 "/usr/share/qt4/include/QtCore/qvarlengtharray.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

template<class T, int Prealloc>
class QPodList;


template<class T, int Prealloc>
class QVarLengthArray
{
public:
inline explicit QVarLengthArray(int size = 0);

inline QVarLengthArray(const QVarLengthArray<T, Prealloc> &other)
: a(Prealloc), s(0), ptr(reinterpret_cast<T *>(array))
{
append(other.constData(), other.size());
}

inline ~QVarLengthArray() {
if (QTypeInfo<T>::isComplex) {
T *i = ptr + s;
while (i-- != ptr)
i->~T();
}
if (ptr != reinterpret_cast<T *>(array))
qFree(ptr);
}
inline QVarLengthArray<T, Prealloc> &operator=(const QVarLengthArray<T, Prealloc> &other)
{
if (this != &other) {
clear();
append(other.constData(), other.size());
}
return *this;
}

inline void removeLast() {
qt_noop();
realloc(s - 1, a);
}
inline int size() const { return s; }
inline int count() const { return s; }
inline bool isEmpty() const { return (s == 0); }
inline void resize(int size);
inline void clear() { resize(0); }

inline int capacity() const { return a; }
inline void reserve(int size);

inline T &operator[](int idx) {
qt_noop();
return ptr[idx];
}
inline const T &operator[](int idx) const {
qt_noop();
return ptr[idx];
}

inline void append(const T &t) {
if (s == a) 
realloc(s, s<<1);
const int idx = s++;
if (QTypeInfo<T>::isComplex) {
new (ptr + idx) T(t);
} else {
ptr[idx] = t;
}
}
void append(const T *buf, int size);

inline T *data() { return ptr; }
inline const T *data() const { return ptr; }
inline const T * constData() const { return ptr; }

private:
friend class QPodList<T, Prealloc>;
void realloc(int size, int alloc);

int a;
int s;
T *ptr;
union {

char array[sizeof(qint64) * (((Prealloc * sizeof(T)) / sizeof(qint64)) + 1)];
qint64 q_for_alignment_1;
double q_for_alignment_2;
};
};

template <class T, int Prealloc>
inline QVarLengthArray<T, Prealloc>::QVarLengthArray(int asize)
: s(asize) {
if (s > Prealloc) {
ptr = reinterpret_cast<T *>(qMalloc(s * sizeof(T)));
do { if (!(ptr)) qBadAlloc(); } while (0);
a = s;
} else {
ptr = reinterpret_cast<T *>(array);
a = Prealloc;
}
if (QTypeInfo<T>::isComplex) {
T *i = ptr + s;
while (i != ptr)
new (--i) T;
}
}

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::resize(int asize)
{ realloc(asize, qMax(asize, a)); }

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::reserve(int asize)
{ if (asize > a) realloc(s, asize); }

template <class T, int Prealloc>
 void QVarLengthArray<T, Prealloc>::append(const T *abuf, int increment)
{
qt_noop();
if (increment <= 0)
return;

const int asize = s + increment;

if (asize >= a)
realloc(s, qMax(s*2, asize));

if (QTypeInfo<T>::isComplex) {

while (s < asize)
new (ptr+(s++)) T(*abuf++);
} else {
qMemCopy(&ptr[s], abuf, increment * sizeof(T));
s = asize;
}
}

template <class T, int Prealloc>
 void QVarLengthArray<T, Prealloc>::realloc(int asize, int aalloc)
{
qt_noop();
T *oldPtr = ptr;
int osize = s;


if (aalloc != a) {
ptr = reinterpret_cast<T *>(qMalloc(aalloc * sizeof(T)));
do { if (!(ptr)) qBadAlloc(); } while (0);
if (ptr) {
s = 0;
a = aalloc;

if (QTypeInfo<T>::isStatic) {
try {

const int copySize = qMin(asize, osize);
while (s < copySize) {
new (ptr+s) T(*(oldPtr+s));
(oldPtr+s)->~T();
s++;
}
} catch (...) {

int sClean = s;
while (sClean < osize)
(oldPtr+(sClean++))->~T();
if (oldPtr != reinterpret_cast<T *>(array) && oldPtr != ptr)
qFree(oldPtr);
throw;
}
} else {
qMemCopy(ptr, oldPtr, qMin(asize, osize) * sizeof(T));
s = asize;
}
} else {
ptr = oldPtr;
return;
}
}

if (QTypeInfo<T>::isComplex) {
while (osize > asize)
(oldPtr+(--osize))->~T();
if( oldPtr == ptr )
s = osize;
}

if (oldPtr != reinterpret_cast<T *>(array) && oldPtr != ptr)
qFree(oldPtr);

if (QTypeInfo<T>::isComplex) {

while (s < asize)
new (ptr+(s++)) T;
} else {
s = asize;
}
}






# 102 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 103 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qxmlstream.h"












































# 1 "/usr/share/qt4/include/QtCore/qiodevice.h"






























































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qxmlstream.h"




# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtCore/qxmlstream.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtCore/qxmlstream.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 51 "/usr/share/qt4/include/QtCore/qxmlstream.h"


# 53 "/usr/share/qt4/include/QtCore/qxmlstream.h"




typedef QtValidLicenseForCoreModule QtCoreModule;


























































# 116 "/usr/share/qt4/include/QtCore/qxmlstream.h"
class  QXmlStreamStringRef {
QString m_string;
int m_position, m_size;
public:
inline QXmlStreamStringRef():m_position(0), m_size(0){}
inline QXmlStreamStringRef(const QStringRef &aString)
:m_string(aString.string()?*aString.string():QString()), m_position(aString.position()), m_size(aString.size()){}
inline QXmlStreamStringRef(const QString &aString):m_string(aString), m_position(0), m_size(aString.size()){}
inline ~QXmlStreamStringRef(){}
inline void clear() { m_string.clear(); m_position = m_size = 0; }
inline operator QStringRef() const { return QStringRef(&m_string, m_position, m_size); }
inline const QString *string() const { return &m_string; }
inline int position() const { return m_position; }
inline int size() const { return m_size; }
};


class QXmlStreamReaderPrivate;
class QXmlStreamAttributes;
class  QXmlStreamAttribute {
QXmlStreamStringRef m_name, m_namespaceUri, m_qualifiedName, m_value;
void *reserved;
uint m_isDefault : 1;
friend class QXmlStreamReaderPrivate;
friend class QXmlStreamAttributes;
public:
QXmlStreamAttribute();
QXmlStreamAttribute(const QString &qualifiedName, const QString &value);
QXmlStreamAttribute(const QString &namespaceUri, const QString &name, const QString &value);
QXmlStreamAttribute(const QXmlStreamAttribute &);
QXmlStreamAttribute& operator=(const QXmlStreamAttribute &);
~QXmlStreamAttribute();
inline QStringRef namespaceUri() const { return m_namespaceUri; }
inline QStringRef name() const { return m_name; }
inline QStringRef qualifiedName() const { return m_qualifiedName; }
inline QStringRef prefix() const {
return QStringRef(m_qualifiedName.string(),
m_qualifiedName.position(),
qMax(0, m_qualifiedName.size() - m_name.size() - 1));
}
inline QStringRef value() const { return m_value; }
inline bool isDefault() const { return m_isDefault; }
inline bool operator==(const QXmlStreamAttribute &other) const {
return (value() == other.value()
&& (namespaceUri().isNull() ? (qualifiedName() == other.qualifiedName())
: (namespaceUri() == other.namespaceUri() && name() == other.name())));
}
inline bool operator!=(const QXmlStreamAttribute &other) const
{ return !operator==(other); }
};

template <> class QTypeInfo<QXmlStreamAttribute > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QXmlStreamAttribute)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QXmlStreamAttribute"; } };

class  QXmlStreamAttributes : public QVector<QXmlStreamAttribute>
{
public:
QStringRef value(const QString &namespaceUri, const QString &name) const;
QStringRef value(const QString &namespaceUri, const QLatin1String &name) const;
QStringRef value(const QLatin1String &namespaceUri, const QLatin1String &name) const;
QStringRef value(const QString &qualifiedName) const;
QStringRef value(const QLatin1String &qualifiedName) const;
void append(const QString &namespaceUri, const QString &name, const QString &value);
void append(const QString &qualifiedName, const QString &value);

inline bool hasAttribute(const QString &qualifiedName) const
{
return !value(qualifiedName).isNull();
}

inline bool hasAttribute(const QLatin1String &qualifiedName) const
{
return !value(qualifiedName).isNull();
}

inline bool hasAttribute(const QString &namespaceUri, const QString &name) const
{
return !value(namespaceUri, name).isNull();
}




# 198 "/usr/share/qt4/include/QtCore/qxmlstream.h"
inline void append(const QXmlStreamAttribute &attribute)
{ QVector<QXmlStreamAttribute>::append(attribute); }

# 201 "/usr/share/qt4/include/QtCore/qxmlstream.h"
};

class  QXmlStreamNamespaceDeclaration {
QXmlStreamStringRef m_prefix, m_namespaceUri;
void *reserved;

friend class QXmlStreamReaderPrivate;
public:
QXmlStreamNamespaceDeclaration();
QXmlStreamNamespaceDeclaration(const QXmlStreamNamespaceDeclaration &);
QXmlStreamNamespaceDeclaration(const QString &prefix, const QString &namespaceUri);
~QXmlStreamNamespaceDeclaration();
QXmlStreamNamespaceDeclaration& operator=(const QXmlStreamNamespaceDeclaration &);
inline QStringRef prefix() const { return m_prefix; }
inline QStringRef namespaceUri() const { return m_namespaceUri; }
inline bool operator==(const QXmlStreamNamespaceDeclaration &other) const {
return (prefix() == other.prefix() && namespaceUri() == other.namespaceUri());
}
inline bool operator!=(const QXmlStreamNamespaceDeclaration &other) const
{ return !operator==(other); }
};

template <> class QTypeInfo<QXmlStreamNamespaceDeclaration > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QXmlStreamNamespaceDeclaration)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QXmlStreamNamespaceDeclaration"; } };
typedef QVector<QXmlStreamNamespaceDeclaration> QXmlStreamNamespaceDeclarations;

class  QXmlStreamNotationDeclaration {
QXmlStreamStringRef m_name, m_systemId, m_publicId;
void *reserved;

friend class QXmlStreamReaderPrivate;
public:
QXmlStreamNotationDeclaration();
~QXmlStreamNotationDeclaration();
QXmlStreamNotationDeclaration(const QXmlStreamNotationDeclaration &);
QXmlStreamNotationDeclaration& operator=(const QXmlStreamNotationDeclaration &);
inline QStringRef name() const { return m_name; }
inline QStringRef systemId() const { return m_systemId; }
inline QStringRef publicId() const { return m_publicId; }
inline bool operator==(const QXmlStreamNotationDeclaration &other) const {
return (name() == other.name() && systemId() == other.systemId()
&& publicId() == other.publicId());
}
inline bool operator!=(const QXmlStreamNotationDeclaration &other) const
{ return !operator==(other); }
};

template <> class QTypeInfo<QXmlStreamNotationDeclaration > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QXmlStreamNotationDeclaration)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QXmlStreamNotationDeclaration"; } };
typedef QVector<QXmlStreamNotationDeclaration> QXmlStreamNotationDeclarations;

class  QXmlStreamEntityDeclaration {
QXmlStreamStringRef m_name, m_notationName, m_systemId, m_publicId, m_value;
void *reserved;

friend class QXmlStreamReaderPrivate;
public:
QXmlStreamEntityDeclaration();
~QXmlStreamEntityDeclaration();
QXmlStreamEntityDeclaration(const QXmlStreamEntityDeclaration &);
QXmlStreamEntityDeclaration& operator=(const QXmlStreamEntityDeclaration &);
inline QStringRef name() const { return m_name; }
inline QStringRef notationName() const { return m_notationName; }
inline QStringRef systemId() const { return m_systemId; }
inline QStringRef publicId() const { return m_publicId; }
inline QStringRef value() const { return m_value; }
inline bool operator==(const QXmlStreamEntityDeclaration &other) const {
return (name() == other.name()
&& notationName() == other.notationName()
&& systemId() == other.systemId()
&& publicId() == other.publicId()
&& value() == other.value());
}
inline bool operator!=(const QXmlStreamEntityDeclaration &other) const
{ return !operator==(other); }
};

template <> class QTypeInfo<QXmlStreamEntityDeclaration > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QXmlStreamEntityDeclaration)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QXmlStreamEntityDeclaration"; } };
typedef QVector<QXmlStreamEntityDeclaration> QXmlStreamEntityDeclarations;


class  QXmlStreamEntityResolver
{
public:
virtual ~QXmlStreamEntityResolver();
virtual QString resolveEntity(const QString& publicId, const QString& systemId);
virtual QString resolveUndeclaredEntity(const QString &name);
};


# 289 "/usr/share/qt4/include/QtCore/qxmlstream.h"
class  QXmlStreamReader {

public:
enum TokenType {
NoToken = 0,
Invalid,
StartDocument,
EndDocument,
StartElement,
EndElement,
Characters,
Comment,
DTD,
EntityReference,
ProcessingInstruction
};


QXmlStreamReader();
QXmlStreamReader(QIODevice *device);
QXmlStreamReader(const QByteArray &data);
QXmlStreamReader(const QString &data);
QXmlStreamReader(const char * data);
~QXmlStreamReader();

void setDevice(QIODevice *device);
QIODevice *device() const;
void addData(const QByteArray &data);
void addData(const QString &data);
void addData(const char *data);
void clear();


bool atEnd() const;
TokenType readNext();

bool readNextStartElement();
void skipCurrentElement();

TokenType tokenType() const;
QString tokenString() const;

void setNamespaceProcessing(bool);
bool namespaceProcessing() const;

inline bool isStartDocument() const { return tokenType() == StartDocument; }
inline bool isEndDocument() const { return tokenType() == EndDocument; }
inline bool isStartElement() const { return tokenType() == StartElement; }
inline bool isEndElement() const { return tokenType() == EndElement; }
inline bool isCharacters() const { return tokenType() == Characters; }
bool isWhitespace() const;
bool isCDATA() const;
inline bool isComment() const { return tokenType() == Comment; }
inline bool isDTD() const { return tokenType() == DTD; }
inline bool isEntityReference() const { return tokenType() == EntityReference; }
inline bool isProcessingInstruction() const { return tokenType() == ProcessingInstruction; }

bool isStandaloneDocument() const;
QStringRef documentVersion() const;
QStringRef documentEncoding() const;

qint64 lineNumber() const;
qint64 columnNumber() const;
qint64 characterOffset() const;

QXmlStreamAttributes attributes() const;

enum ReadElementTextBehaviour {
ErrorOnUnexpectedElement,
IncludeChildElements,
SkipChildElements
};
QString readElementText(ReadElementTextBehaviour behaviour);
QString readElementText();

QStringRef name() const;
QStringRef namespaceUri() const;
QStringRef qualifiedName() const;
QStringRef prefix() const;

QStringRef processingInstructionTarget() const;
QStringRef processingInstructionData() const;

QStringRef text() const;

QXmlStreamNamespaceDeclarations namespaceDeclarations() const;
void addExtraNamespaceDeclaration(const QXmlStreamNamespaceDeclaration &extraNamespaceDeclaraction);
void addExtraNamespaceDeclarations(const QXmlStreamNamespaceDeclarations &extraNamespaceDeclaractions);
QXmlStreamNotationDeclarations notationDeclarations() const;
QXmlStreamEntityDeclarations entityDeclarations() const;
QStringRef dtdName() const;
QStringRef dtdPublicId() const;
QStringRef dtdSystemId() const;


enum Error {
NoError,
UnexpectedElementError,
CustomError,
NotWellFormedError,
PrematureEndOfDocumentError
};
void raiseError(const QString& message = QString());
QString errorString() const;
Error error() const;

inline bool hasError() const
{
return error() != NoError;
}

void setEntityResolver(QXmlStreamEntityResolver *resolver);
QXmlStreamEntityResolver *entityResolver() const;

private:
QXmlStreamReader(const QXmlStreamReader &); QXmlStreamReader &operator=(const QXmlStreamReader &);
inline QXmlStreamReaderPrivate* d_func() { return reinterpret_cast<QXmlStreamReaderPrivate *>(qGetPtrHelper(d_ptr)); } inline const QXmlStreamReaderPrivate* d_func() const { return reinterpret_cast<const QXmlStreamReaderPrivate *>(qGetPtrHelper(d_ptr)); } friend class QXmlStreamReaderPrivate;
QScopedPointer<QXmlStreamReaderPrivate> d_ptr;

};




# 413 "/usr/share/qt4/include/QtCore/qxmlstream.h"
class QXmlStreamWriterPrivate;

class  QXmlStreamWriter
{


public:
QXmlStreamWriter();
QXmlStreamWriter(QIODevice *device);
QXmlStreamWriter(QByteArray *array);
QXmlStreamWriter(QString *string);
~QXmlStreamWriter();

void setDevice(QIODevice *device);
QIODevice *device() const;


# 430 "/usr/share/qt4/include/QtCore/qxmlstream.h"
void setCodec(QTextCodec *codec);
void setCodec(const char *codecName);
QTextCodec *codec() const;


# 435 "/usr/share/qt4/include/QtCore/qxmlstream.h"
void setAutoFormatting(bool);
bool autoFormatting() const;

void setAutoFormattingIndent(int spacesOrTabs);
int autoFormattingIndent() const;

void writeAttribute(const QString &qualifiedName, const QString &value);
void writeAttribute(const QString &namespaceUri, const QString &name, const QString &value);
void writeAttribute(const QXmlStreamAttribute& attribute);
void writeAttributes(const QXmlStreamAttributes& attributes);

void writeCDATA(const QString &text);
void writeCharacters(const QString &text);
void writeComment(const QString &text);

void writeDTD(const QString &dtd);

void writeEmptyElement(const QString &qualifiedName);
void writeEmptyElement(const QString &namespaceUri, const QString &name);

void writeTextElement(const QString &qualifiedName, const QString &text);
void writeTextElement(const QString &namespaceUri, const QString &name, const QString &text);

void writeEndDocument();
void writeEndElement();

void writeEntityReference(const QString &name);
void writeNamespace(const QString &namespaceUri, const QString &prefix = QString());
void writeDefaultNamespace(const QString &namespaceUri);
void writeProcessingInstruction(const QString &target, const QString &data = QString());

void writeStartDocument();
void writeStartDocument(const QString &version);
void writeStartDocument(const QString &version, bool standalone);
void writeStartElement(const QString &qualifiedName);
void writeStartElement(const QString &namespaceUri, const QString &name);


# 473 "/usr/share/qt4/include/QtCore/qxmlstream.h"
void writeCurrentToken(const QXmlStreamReader &reader);


# 476 "/usr/share/qt4/include/QtCore/qxmlstream.h"
private:
QXmlStreamWriter(const QXmlStreamWriter &); QXmlStreamWriter &operator=(const QXmlStreamWriter &);
inline QXmlStreamWriterPrivate* d_func() { return reinterpret_cast<QXmlStreamWriterPrivate *>(qGetPtrHelper(d_ptr)); } inline const QXmlStreamWriterPrivate* d_func() const { return reinterpret_cast<const QXmlStreamWriterPrivate *>(qGetPtrHelper(d_ptr)); } friend class QXmlStreamWriterPrivate;
QScopedPointer<QXmlStreamWriterPrivate> d_ptr;
};


# 483 "/usr/share/qt4/include/QtCore/qxmlstream.h"






# 104 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qfuture.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qfuture.h"




# 1 "/usr/share/qt4/include/QtCore/qfutureinterface.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qfutureinterface.h"

# 1 "/usr/share/qt4/include/QtCore/qrunnable.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qrunnable.h"


# 47 "/usr/share/qt4/include/QtCore/qrunnable.h"



typedef QtValidLicenseForCoreModule QtCoreModule;

class QRunnable
{
int ref;

friend class QThreadPool;
friend class QThreadPoolPrivate;
friend class QThreadPoolThread;

public:
virtual void run() = 0;

QRunnable() : ref(0) { }
virtual ~QRunnable() { }

bool autoDelete() const { return ref != -1; }
void setAutoDelete(bool _autoDelete) { ref = _autoDelete ? 0 : -1; }
};





# 46 "/usr/share/qt4/include/QtCore/qfutureinterface.h"




# 1 "/usr/share/qt4/include/QtCore/qmutex.h"

































































































































































































# 50 "/usr/share/qt4/include/QtCore/qfutureinterface.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentexception.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentexception.h"




# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 49 "/usr/share/qt4/include/QtCore/qtconcurrentexception.h"






# 55 "/usr/share/qt4/include/QtCore/qtconcurrentexception.h"



typedef QtValidLicenseForCoreModule QtCoreModule;

namespace QtConcurrent
{



# 65 "/usr/share/qt4/include/QtCore/qtconcurrentexception.h"
class  Exception : public std::exception
{
public:
virtual void raise() const;
virtual Exception *clone() const;
};

class  UnhandledException : public Exception
{
public:
void raise() const;
Exception *clone() const;
};

namespace internal {

class Base;
class ExceptionHolder
{
public:
ExceptionHolder(Exception *exception = 0);
ExceptionHolder(const ExceptionHolder &other);
void operator=(const ExceptionHolder &other);
~ExceptionHolder();
Exception *exception() const;
Base *base;
};

class  ExceptionStore
{
public:
void setException(const Exception &e);
bool hasException() const;
ExceptionHolder exception();
void throwPossibleException();
bool hasThrown() const;
ExceptionHolder exceptionHolder;
};

} 
















# 121 "/usr/share/qt4/include/QtCore/qtconcurrentexception.h"
} 







# 51 "/usr/share/qt4/include/QtCore/qfutureinterface.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentresultstore.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentresultstore.h"




# 1 "/usr/share/qt4/include/QtCore/qmap.h"




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtCore/qtconcurrentresultstore.h"

# 1 "/usr/share/qt4/include/QtCore/qdebug.h"




























































































































































































































































































# 50 "/usr/share/qt4/include/QtCore/qtconcurrentresultstore.h"


# 52 "/usr/share/qt4/include/QtCore/qtconcurrentresultstore.h"



typedef QtValidLicenseForCoreModule QtCoreModule;











# 67 "/usr/share/qt4/include/QtCore/qtconcurrentresultstore.h"
namespace QtConcurrent {

class ResultItem
{
public:
ResultItem(const void *_result, int _count) : m_count(_count), result(_result) { } 
ResultItem(const void *_result) : m_count(0), result(_result) { } 
ResultItem() : m_count(0), result(0) { }
bool isValid() const { return result != 0; }
bool isVector() const { return m_count != 0; }
int count() const { return (m_count == 0) ? 1 : m_count; }
int m_count; 
const void *result; 
};

class  ResultIteratorBase
{
public:
ResultIteratorBase();
ResultIteratorBase(QMap<int, ResultItem>::const_iterator _mapIterator, int _vectorIndex = 0);
int vectorIndex() const;
int resultIndex() const;

ResultIteratorBase operator++();
int batchSize() const;
void batchedAdvance();
bool operator==(const ResultIteratorBase &other) const;
bool operator!=(const ResultIteratorBase &other) const;
bool isVector() const;
bool canIncrementVectorIndex() const;
protected:
QMap<int, ResultItem>::const_iterator mapIterator;
int m_vectorIndex;
};

template <typename T>
class ResultIterator : public ResultIteratorBase
{
public:
ResultIterator(const ResultIteratorBase &base)
: ResultIteratorBase(base) { }

const T &value() const
{
return *pointer();
}

const T *pointer() const
{
if (mapIterator.value().isVector())
return &(reinterpret_cast<const QVector<T> *>(mapIterator.value().result)->at(m_vectorIndex));
else
return reinterpret_cast<const T *>(mapIterator.value().result);
}
};

class  ResultStoreBase
{
public:
ResultStoreBase();
void setFilterMode(bool enable);
bool filterMode() const;
int addResult(int index, const void *result);
int addResults(int index, const void *results, int vectorSize, int logicalCount);
ResultIteratorBase begin() const;
ResultIteratorBase end() const;
bool hasNextResult() const;
ResultIteratorBase resultAt(int index) const;
bool contains(int index) const;
int count() const;
virtual ~ResultStoreBase() { };

protected:
int insertResultItem(int index, ResultItem &resultItem);
void insertResultItemIfValid(int index, ResultItem &resultItem);
void syncPendingResults();
void syncResultCount();
int updateInsertIndex(int index, int _count);

QMap<int, ResultItem> m_results;
int insertIndex; 
int resultCount; 

bool m_filterMode;
QMap<int, ResultItem> pendingResults;
int filteredResults;

};

template <typename T>
class ResultStore : public ResultStoreBase
{
public:
ResultStore() { }

ResultStore(const ResultStoreBase &base)
: ResultStoreBase(base) { }

int addResult(int index, const T *result)
{
if (result == 0)
return ResultStoreBase::addResult(index, result);
else
return ResultStoreBase::addResult(index, new T(*result));
}

int addResults(int index, const QVector<T> *results)
{
return ResultStoreBase::addResults(index, new QVector<T>(*results), results->count(), results->count());
}

int addResults(int index, const QVector<T> *results, int totalCount)
{
return ResultStoreBase::addResults(index, new QVector<T>(*results), results->count(), totalCount);
}

int addCanceledResult(int index)
{
return addResult(index, 0);
}

int addCanceledResults(int index, int _count)
{
QVector<T> empty;
return addResults(index, &empty, _count);
}

ResultIterator<T> begin() const
{
return static_cast<ResultIterator<T> >(ResultStoreBase::begin());
}

ResultIterator<T> end() const
{
return static_cast<ResultIterator<T> >(ResultStoreBase::end());
}

ResultIterator<T> resultAt(int index) const
{
return static_cast<ResultIterator<T> >(ResultStoreBase::resultAt(index));
}

void clear()
{
QMap<int, ResultItem>::const_iterator mapIterator = m_results.constBegin();
while (mapIterator != m_results.constEnd()) {
if (mapIterator.value().isVector())
delete reinterpret_cast<const QVector<T> *>(mapIterator.value().result);
else
delete reinterpret_cast<const T *>(mapIterator.value().result);
++mapIterator;
}
resultCount = 0;
m_results.clear();
}

~ResultStore()
{
clear();
}

};

} 



# 234 "/usr/share/qt4/include/QtCore/qtconcurrentresultstore.h"






# 52 "/usr/share/qt4/include/QtCore/qfutureinterface.h"


# 54 "/usr/share/qt4/include/QtCore/qfutureinterface.h"



typedef QtValidLicenseForCoreModule QtCoreModule;

template <typename T> class QFuture;
class QFutureInterfaceBasePrivate;
class QFutureWatcherBase;
class QFutureWatcherBasePrivate;

class  QFutureInterfaceBase
{
public:
enum State {
NoState = 0x00,
Running = 0x01,
Started = 0x02,
Finished = 0x04,
Canceled = 0x08,
Paused = 0x10,
Throttled = 0x20
};

QFutureInterfaceBase(State initialState = NoState);
QFutureInterfaceBase(const QFutureInterfaceBase &other);
virtual ~QFutureInterfaceBase();


void reportStarted();
void reportFinished();
void reportCanceled();

# 86 "/usr/share/qt4/include/QtCore/qfutureinterface.h"
void reportException(const QtConcurrent::Exception &e);

# 88 "/usr/share/qt4/include/QtCore/qfutureinterface.h"
void reportResultsReady(int beginIndex, int endIndex);

void setRunnable(QRunnable *runnable);
void setFilterMode(bool enable);
void setProgressRange(int minimum, int maximum);
int progressMinimum() const;
int progressMaximum() const;
bool isProgressUpdateNeeded() const;
void setProgressValue(int progressValue);
int progressValue() const;
void setProgressValueAndText(int progressValue, const QString &progressText);
QString progressText() const;

void setExpectedResultCount(int resultCount);
int expectedResultCount();
int resultCount() const;

bool queryState(State state) const;
bool isRunning() const;
bool isStarted() const;
bool isCanceled() const;
bool isFinished() const;
bool isPaused() const;
bool isThrottled() const;
bool isResultReadyAt(int index) const;

void cancel();
void setPaused(bool paused);
void togglePaused();
void setThrottled(bool enable);

void waitForFinished();
bool waitForNextResult();
void waitForResult(int resultIndex);
void waitForResume();

QMutex *mutex() const;
QtConcurrent::internal::ExceptionStore &exceptionStore();
QtConcurrent::ResultStoreBase &resultStoreBase();
const QtConcurrent::ResultStoreBase &resultStoreBase() const;

inline bool operator==(const QFutureInterfaceBase &other) const { return d == other.d; }
inline bool operator!=(const QFutureInterfaceBase &other) const { return d != other.d; }
QFutureInterfaceBase &operator=(const QFutureInterfaceBase &other);

protected:
bool referenceCountIsOne() const;
public:


# 138 "/usr/share/qt4/include/QtCore/qfutureinterface.h"
private:

# 140 "/usr/share/qt4/include/QtCore/qfutureinterface.h"
QFutureInterfaceBasePrivate *d;

private:
friend class QFutureWatcherBase;
friend class QFutureWatcherBasePrivate;
};

template <typename T>
class QFutureInterface : public QFutureInterfaceBase
{
public:
QFutureInterface(State initialState = NoState)
: QFutureInterfaceBase(initialState)
{ }
QFutureInterface(const QFutureInterface &other)
: QFutureInterfaceBase(other)
{ }
~QFutureInterface()
{
if (referenceCountIsOne())
resultStore().clear();
}

static QFutureInterface canceledResult()
{ return QFutureInterface(State(Started | Finished | Canceled)); }

QFutureInterface &operator=(const QFutureInterface &other)
{
if (referenceCountIsOne())
resultStore().clear();
QFutureInterfaceBase::operator=(other);
return *this;
}

inline QFuture<T> future(); 

inline void reportResult(const T *result, int index = -1);
inline void reportResult(const T &result, int index = -1);
inline void reportResults(const QVector<T> &results, int beginIndex = -1, int count = -1);
inline void reportFinished(const T *result = 0);

inline const T &resultReference(int index) const;
inline const T *resultPointer(int index) const;
inline QList<T> results();
private:
QtConcurrent::ResultStore<T> &resultStore()
{ return static_cast<QtConcurrent::ResultStore<T> &>(resultStoreBase()); }
const QtConcurrent::ResultStore<T> &resultStore() const
{ return static_cast<const QtConcurrent::ResultStore<T> &>(resultStoreBase()); }
};

template <typename T>
inline void QFutureInterface<T>::reportResult(const T *result, int index)
{
QMutexLocker locker(mutex());
if (this->queryState(Canceled) || this->queryState(Finished)) {
return;
}

QtConcurrent::ResultStore<T> &store = resultStore();


if (store.filterMode()) {
const int resultCountBefore = store.count();
store.addResult(index, result);
this->reportResultsReady(resultCountBefore, resultCountBefore + store.count());
} else {
const int insertIndex = store.addResult(index, result);
this->reportResultsReady(insertIndex, insertIndex + 1);
}
}

template <typename T>
inline void QFutureInterface<T>::reportResult(const T &result, int index)
{
reportResult(&result, index);
}

template <typename T>
inline void QFutureInterface<T>::reportResults(const QVector<T> &_results, int beginIndex, int count)
{
QMutexLocker locker(mutex());
if (this->queryState(Canceled) || this->queryState(Finished)) {
return;
}

QtConcurrent::ResultStore<T> &store = resultStore();

if (store.filterMode()) {
const int resultCountBefore = store.count();
store.addResults(beginIndex, &_results, count);
this->reportResultsReady(resultCountBefore, store.count());
} else {
const int insertIndex = store.addResults(beginIndex, &_results, count);
this->reportResultsReady(insertIndex, insertIndex + _results.count()); 
}
}

template <typename T>
inline void QFutureInterface<T>::reportFinished(const T *result)
{
if (result)
reportResult(result);
QFutureInterfaceBase::reportFinished();
}

template <typename T>
inline const T &QFutureInterface<T>::resultReference(int index) const
{
QMutexLocker lock(mutex());
return resultStore().resultAt(index).value();
}

template <typename T>
inline const T *QFutureInterface<T>::resultPointer(int index) const
{
QMutexLocker lock(mutex());
return resultStore().resultAt(index).pointer();
}

template <typename T>
inline QList<T> QFutureInterface<T>::results()
{
if (this->isCanceled()) {
exceptionStore().throwPossibleException();
return QList<T>();
}
QFutureInterfaceBase::waitForResult(-1);

QList<T> res;
QMutexLocker lock(mutex());

QtConcurrent::ResultIterator<T> it = resultStore().begin();
while (it != resultStore().end()) {
res.append(it.value());
++it;
}

return res;
}

template <>
class QFutureInterface<void> : public QFutureInterfaceBase
{
public:
QFutureInterface<void>(State initialState = NoState)
: QFutureInterfaceBase(initialState)
{ }
QFutureInterface<void>(const QFutureInterface<void> &other)
: QFutureInterfaceBase(other)
{ }

static QFutureInterface<void> canceledResult()
{ return QFutureInterface(State(Started | Finished | Canceled)); }

QFutureInterface<void> &operator=(const QFutureInterface<void> &other)
{
QFutureInterfaceBase::operator=(other);
return *this;
}

inline QFuture<void> future(); 

void reportResult(const void *, int) { }
void reportResults(const QVector<void> &, int) { }
void reportFinished(void * = 0) { QFutureInterfaceBase::reportFinished(); }
};







# 49 "/usr/share/qt4/include/QtCore/qfuture.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtCore/qfuture.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentcompilertest.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentcompilertest.h"




# 49 "/usr/share/qt4/include/QtCore/qtconcurrentcompilertest.h"



typedef QtValidLicenseForCoreModule QtCoreModule;













# 66 "/usr/share/qt4/include/QtCore/qtconcurrentcompilertest.h"






# 51 "/usr/share/qt4/include/QtCore/qfuture.h"


# 53 "/usr/share/qt4/include/QtCore/qfuture.h"



typedef QtValidLicenseForCoreModule QtCoreModule;

template <typename T>
class QFutureWatcher;
template <>
class QFutureWatcher<void>;

template <typename T>
class QFuture
{
public:
QFuture()
: d(QFutureInterface<T>::canceledResult())
{ }
explicit QFuture(QFutureInterface<T> *p) 
: d(*p)
{ }
QFuture(const QFuture &other)
: d(other.d)
{ }
~QFuture()
{ }

inline QFuture &operator=(const QFuture &other);
bool operator==(const QFuture &other) const { return (d == other.d); }
bool operator!=(const QFuture &other) const { return (d != other.d); }

void cancel() { d.cancel(); }
bool isCanceled() const { return d.isCanceled(); }

void setPaused(bool paused) { d.setPaused(paused); }
bool isPaused() const { return d.isPaused(); }
void pause() { setPaused(true); }
void resume() { setPaused(false); }
void togglePaused() { d.togglePaused(); }

bool isStarted() const { return d.isStarted(); }
bool isFinished() const { return d.isFinished(); }
bool isRunning() const { return d.isRunning(); }

int resultCount() const { return d.resultCount(); }
int progressValue() const { return d.progressValue(); }
int progressMinimum() const { return d.progressMinimum(); }
int progressMaximum() const { return d.progressMaximum(); }
QString progressText() const { return d.progressText(); }
void waitForFinished() { d.waitForFinished(); }

inline T result() const;
inline T resultAt(int index) const;
bool isResultReadyAt(int resultIndex) const { return d.isResultReadyAt(resultIndex); }

operator T() const { return result(); }
QList<T> results() const { return d.results(); }

class const_iterator
{
public:
typedef std::bidirectional_iterator_tag iterator_category;
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef const T *pointer;
typedef const T &reference;

inline const_iterator() {}
inline const_iterator(QFuture const * const _future, int _index) : future(_future), index(_index) {}
inline const_iterator(const const_iterator &o) : future(o.future), index(o.index) {}
inline const_iterator &operator=(const const_iterator &o)
{ future = o.future; index = o.index; return *this; }
inline const T &operator*() const { return future->d.resultReference(index); }
inline const T *operator->() const { return future->d.resultPointer(index); }

inline bool operator!=(const const_iterator &other) const
{
if (index == -1 && other.index == -1) 
return false;
if (other.index == -1)
return (future->isRunning() || (index < future->resultCount()));
return (index != other.index);
}

inline bool operator==(const const_iterator &o) const { return !operator!=(o); }
inline const_iterator &operator++() { ++index; return *this; }
inline const_iterator operator++(int) { const_iterator r = *this; ++index; return r; }
inline const_iterator &operator--() { --index; return *this; }
inline const_iterator operator--(int) { const_iterator r = *this; --index; return r; }
inline const_iterator operator+(int j) const { return const_iterator(future, index + j); }
inline const_iterator operator-(int j) const { return const_iterator(future, index - j); }
inline const_iterator &operator+=(int j) { index += j; return *this; }
inline const_iterator &operator-=(int j) { index -= j; return *this; }
private:
QFuture const * future;
int index;
};
friend class const_iterator;
typedef const_iterator ConstIterator;

const_iterator begin() const { return const_iterator(this, 0); }
const_iterator constBegin() const { return const_iterator(this, 0); }
const_iterator end() const { return const_iterator(this, -1); }
const_iterator constEnd() const { return const_iterator(this, -1); }

private:
friend class QFutureWatcher<T>;

public: 
mutable QFutureInterface<T> d;
};

template <typename T>
inline QFuture<T> &QFuture<T>::operator=(const QFuture<T> &other)
{
d = other.d;
return *this;
}

template <typename T>
inline T QFuture<T>::result() const
{
d.waitForResult(0);
return d.resultReference(0);
}

template <typename T>
inline T QFuture<T>::resultAt(int index) const
{
d.waitForResult(index);
return d.resultReference(index);
}

template <typename T>
inline QFuture<T> QFutureInterface<T>::future()
{
return QFuture<T>(this);
}

template <class T> class QFutureIterator { typedef typename QFuture<T>::const_iterator const_iterator; QFuture<T> c; const_iterator i; public: inline QFutureIterator(const QFuture<T> &container) : c(container), i(c.constBegin()) {} inline QFutureIterator &operator=(const QFuture<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };

template <>
class QFuture<void>
{
public:
QFuture()
: d(QFutureInterface<void>::canceledResult())
{ }
explicit QFuture(QFutureInterfaceBase *p) 
: d(*p)
{ }
QFuture(const QFuture &other)
: d(other.d)
{ }
~QFuture()
{ }

QFuture &operator=(const QFuture &other);
bool operator==(const QFuture &other) const { return (d == other.d); }
bool operator!=(const QFuture &other) const { return (d != other.d); }


# 214 "/usr/share/qt4/include/QtCore/qfuture.h"
template <typename T>
QFuture(const QFuture<T> &other)
: d(other.d)
{ }

template <typename T>
QFuture<void> &operator=(const QFuture<T> &other)
{
d = other.d;
return *this;
}


# 227 "/usr/share/qt4/include/QtCore/qfuture.h"
void cancel() { d.cancel(); }
bool isCanceled() const { return d.isCanceled(); }

void setPaused(bool paused) { d.setPaused(paused); }
bool isPaused() const { return d.isPaused(); }
void pause() { setPaused(true); }
void resume() { setPaused(false); }
void togglePaused() { d.togglePaused(); }

bool isStarted() const { return d.isStarted(); }
bool isFinished() const { return d.isFinished(); }
bool isRunning() const { return d.isRunning(); }

int resultCount() const { return d.resultCount(); }
int progressValue() const { return d.progressValue(); }
int progressMinimum() const { return d.progressMinimum(); }
int progressMaximum() const { return d.progressMaximum(); }
QString progressText() const { return d.progressText(); }
void waitForFinished() { d.waitForFinished(); }

private:
friend class QFutureWatcher<void>;




# 253 "/usr/share/qt4/include/QtCore/qfuture.h"
mutable QFutureInterfaceBase d;
};

inline QFuture<void> &QFuture<void>::operator=(const QFuture<void> &other)
{
d = other.d;
return *this;
}

inline QFuture<void> QFutureInterface<void>::future()
{
return QFuture<void>(this);
}

template <typename T>
QFuture<void> qToVoidFuture(const QFuture<T> &future)
{
return QFuture<void>(future.d);
}







# 105 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qfutureinterface.h"

























































































































































































































































































































# 106 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qfuturesynchronizer.h"












































# 1 "/usr/share/qt4/include/QtCore/qfuture.h"






















































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qfuturesynchronizer.h"




# 49 "/usr/share/qt4/include/QtCore/qfuturesynchronizer.h"



typedef QtValidLicenseForCoreModule QtCoreModule;

template <typename T>
class QFutureSynchronizer
{
QFutureSynchronizer(const QFutureSynchronizer &); QFutureSynchronizer &operator=(const QFutureSynchronizer &);

public:
QFutureSynchronizer() : m_cancelOnWait(false) { }
explicit QFutureSynchronizer(const QFuture<T> &future)
: m_cancelOnWait(false)
{ addFuture(future); }
~QFutureSynchronizer() { waitForFinished(); }

void setFuture(const QFuture<T> &future)
{
waitForFinished();
m_futures.clear();
addFuture(future);
}

void addFuture(const QFuture<T> &future)
{
m_futures.append(future);
}

void waitForFinished()
{
if (m_cancelOnWait) {
for (int i = 0; i < m_futures.count(); ++i) {
m_futures[i].cancel();
}
}

for (int i = 0; i < m_futures.count(); ++i) {
m_futures[i].waitForFinished();
}
}

void clearFutures()
{
m_futures.clear();
}

QList<QFuture<T> > futures() const
{
return m_futures;
}

void setCancelOnWait(bool enabled)
{
m_cancelOnWait = enabled;
}

bool cancelOnWait() const
{
return m_cancelOnWait;
}

protected:
QList<QFuture<T> > m_futures;
bool m_cancelOnWait;
};







# 107 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qfuturewatcher.h"












































# 1 "/usr/share/qt4/include/QtCore/qfuture.h"






















































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qfuturewatcher.h"




# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtCore/qfuturewatcher.h"


# 51 "/usr/share/qt4/include/QtCore/qfuturewatcher.h"



typedef QtValidLicenseForCoreModule QtCoreModule;

class QEvent;

class QFutureWatcherBasePrivate;
class  QFutureWatcherBase : public QObject
{
Q_OBJECT
inline QFutureWatcherBasePrivate* d_func() { return reinterpret_cast<QFutureWatcherBasePrivate *>(qGetPtrHelper(d_ptr)); } inline const QFutureWatcherBasePrivate* d_func() const { return reinterpret_cast<const QFutureWatcherBasePrivate *>(qGetPtrHelper(d_ptr)); } friend class QFutureWatcherBasePrivate;

public:
QFutureWatcherBase(QObject *parent = 0);

int progressValue() const;
int progressMinimum() const;
int progressMaximum() const;
QString progressText() const;

bool isStarted() const;
bool isFinished() const;
bool isRunning() const;
bool isCanceled() const;
bool isPaused() const;

void waitForFinished();

void setPendingResultsLimit(int limit);

bool event(QEvent *event);

signals:
void started();
void finished();
void canceled();
void paused();
void resumed();
void resultReadyAt(int resultIndex);
void resultsReadyAt(int beginIndex, int endIndex);
void progressRangeChanged(int minimum, int maximum);
void progressValueChanged(int progressValue);
void progressTextChanged(const QString &progressText);

public slots:
void cancel();
void setPaused(bool paused);
void pause();
void resume();
void togglePaused();

protected:
void connectNotify (const char * signal);
void disconnectNotify (const char * signal);


void connectOutputInterface();
void disconnectOutputInterface(bool pendingAssignment = false);

private:

virtual const QFutureInterfaceBase &futureInterface() const = 0;
virtual QFutureInterfaceBase &futureInterface() = 0;
};

template <typename T>
class QFutureWatcher : public QFutureWatcherBase
{
public:
QFutureWatcher(QObject *_parent = 0)
: QFutureWatcherBase(_parent)
{ }
~QFutureWatcher()
{ disconnectOutputInterface(); }

void setFuture(const QFuture<T> &future);
QFuture<T> future() const
{ return m_future; }

T result() const { return m_future.result(); }
T resultAt(int index) const { return m_future.resultAt(index); }





































# 170 "/usr/share/qt4/include/QtCore/qfuturewatcher.h"
private:
QFuture<T> m_future;
const QFutureInterfaceBase &futureInterface() const { return m_future.d; }
QFutureInterfaceBase &futureInterface() { return m_future.d; }
};

template <typename T>
inline void QFutureWatcher<T>::setFuture(const QFuture<T> &_future)
{
if (_future == m_future)
return;

disconnectOutputInterface(true);
m_future = _future;
connectOutputInterface();
}

template <>
class QFutureWatcher<void> : public QFutureWatcherBase
{
public:
QFutureWatcher(QObject *_parent = 0)
: QFutureWatcherBase(_parent)
{ }
~QFutureWatcher()
{ disconnectOutputInterface(); }

void setFuture(const QFuture<void> &future);
QFuture<void> future() const
{ return m_future; }

private:
QFuture<void> m_future;
const QFutureInterfaceBase &futureInterface() const { return m_future.d; }
QFutureInterfaceBase &futureInterface() { return m_future.d; }
};

inline void QFutureWatcher<void>::setFuture(const QFuture<void> &_future)
{
if (_future == m_future)
return;

disconnectOutputInterface(true);
m_future = _future;
connectOutputInterface();
}







# 108 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qrunnable.h"









































































# 109 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentcompilertest.h"







































































# 110 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentexception.h"
































































































































# 111 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentfilter.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentfilter.h"




# 1 "/usr/share/qt4/include/QtCore/qtconcurrentfilterkernel.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentfilterkernel.h"




# 1 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"




# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 49 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentmedian.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentmedian.h"




# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtCore/qtconcurrentmedian.h"

# 1 "/usr/share/qt4/include/QtCore/qalgorithms.h"








































































































































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtCore/qtconcurrentmedian.h"


# 52 "/usr/share/qt4/include/QtCore/qtconcurrentmedian.h"



typedef QtValidLicenseForCoreModule QtCoreModule;



# 59 "/usr/share/qt4/include/QtCore/qtconcurrentmedian.h"
namespace QtConcurrent {

template <typename T>
class Median
{
public:
Median(int _bufferSize)
: currentMedian(), bufferSize(_bufferSize), currentIndex(0), valid(false), dirty(true)
{
values.resize(bufferSize);
}

void reset()
{
values.fill(0);
currentIndex = 0;
valid = false;
dirty = true;
}

void addValue(T value)
{
currentIndex = ((currentIndex + 1) % bufferSize);
if (valid == false && currentIndex % bufferSize == 0)
valid = true;




const T currentIndexValue = values[currentIndex];
if ((currentIndexValue > currentMedian && currentMedian > value)
|| (currentMedian > currentIndexValue && value > currentMedian)) {
dirty = true;
}

values[currentIndex] = value;
}

bool isMedianValid() const
{
return valid;
}

T median()
{
if (dirty) {
dirty = false;
QVector<T> sorted = values;
qSort(sorted);
currentMedian = sorted.at(bufferSize / 2 + 1);
}
return currentMedian;
}
private:
QVector<T> values;
T currentMedian;
int bufferSize;
int currentIndex;
bool valid;
bool dirty;
};

} 



# 125 "/usr/share/qt4/include/QtCore/qtconcurrentmedian.h"






# 50 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"




# 1 "/usr/share/qt4/include/QtCore/qthreadpool.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qthreadpool.h"


# 1 "/usr/share/qt4/include/QtCore/qthread.h"






































































































































































# 47 "/usr/share/qt4/include/QtCore/qthreadpool.h"

# 1 "/usr/share/qt4/include/QtCore/qrunnable.h"









































































# 48 "/usr/share/qt4/include/QtCore/qthreadpool.h"




# 52 "/usr/share/qt4/include/QtCore/qthreadpool.h"



typedef QtValidLicenseForCoreModule QtCoreModule;

class QThreadPoolPrivate;
class  QThreadPool : public QObject
{
Q_OBJECT
inline QThreadPoolPrivate* d_func() { return reinterpret_cast<QThreadPoolPrivate *>(qGetPtrHelper(d_ptr)); } inline const QThreadPoolPrivate* d_func() const { return reinterpret_cast<const QThreadPoolPrivate *>(qGetPtrHelper(d_ptr)); } friend class QThreadPoolPrivate;
Q_PROPERTY(int expiryTimeout READ expiryTimeout WRITE setExpiryTimeout)
Q_PROPERTY(int maxThreadCount READ maxThreadCount WRITE setMaxThreadCount)
Q_PROPERTY(int activeThreadCount READ activeThreadCount)
friend class QFutureInterfaceBase;

public:
QThreadPool(QObject *parent = 0);
~QThreadPool();

static QThreadPool *globalInstance();

void start(QRunnable *runnable, int priority = 0);
bool tryStart(QRunnable *runnable);

int expiryTimeout() const;
void setExpiryTimeout(int expiryTimeout);

int maxThreadCount() const;
void setMaxThreadCount(int maxThreadCount);

int activeThreadCount() const;

void reserveThread();
void releaseThread();

void waitForDone();
};







# 49 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"

# 1 "/usr/share/qt4/include/QtCore/qfuture.h"






















































































































































































































































































# 50 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"

# 1 "/usr/share/qt4/include/QtCore/qdebug.h"




























































































































































































































































































# 51 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentexception.h"
































































































































# 52 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"

# 1 "/usr/share/qt4/include/QtCore/qwaitcondition.h"









































































































# 53 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"

# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 54 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"

# 1 "/usr/share/qt4/include/QtCore/qsemaphore.h"



















































































# 55 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"


# 57 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"



typedef QtValidLicenseForCoreModule QtCoreModule;



# 64 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"
namespace QtConcurrent {




class ThreadEngineBarrier
{
private:






QMutex mutex;
QAtomicInt count;

QSemaphore semaphore;
public:
ThreadEngineBarrier();
void acquire();
int release();
void wait();
int currentCount();
bool releaseUnlessLast();
};

enum ThreadFunctionResult { ThrottleThread, ThreadFinished };





class  ThreadEngineBase: public QRunnable
{
public:

ThreadEngineBase();
virtual ~ThreadEngineBase();
void startSingleThreaded();
void startBlocking();
void startThread();
bool isCanceled();
void waitForResume();
bool isProgressReportingEnabled();
void setProgressValue(int progress);
void setProgressRange(int minimum, int maximum);
void acquireBarrierSemaphore();

protected: 
virtual void start() {}
virtual void finish() {}
virtual ThreadFunctionResult threadFunction() { return ThreadFinished; }
virtual bool shouldStartThread() { return futureInterface ? !futureInterface->isPaused() : true; }
virtual bool shouldThrottleThread() { return futureInterface ? futureInterface->isPaused() : false; }
private:
bool startThreadInternal();
void startThreads();
void threadExit();
bool threadThrottleExit();
void run();
virtual void asynchronousFinish() = 0;

# 127 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"
void handleException(const QtConcurrent::Exception &exception);

# 129 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"
protected:
QFutureInterfaceBase *futureInterface;
QThreadPool *threadPool;
ThreadEngineBarrier barrier;
QtConcurrent::internal::ExceptionStore exceptionStore;
};


template <typename T>
class ThreadEngine : public virtual ThreadEngineBase
{
public:
typedef T ResultType;

virtual T *result() { return 0; }

QFutureInterface<T> *futureInterfaceTyped()
{
return static_cast<QFutureInterface<T> *>(futureInterface);
}


T *startSingleThreaded()
{
ThreadEngineBase::startSingleThreaded();
return result();
}




T *startBlocking()
{
ThreadEngineBase::startBlocking();
return result();
}



QFuture<T> startAsynchronously()
{
futureInterface = new QFutureInterface<T>();




futureInterface->reportStarted();
QFuture<T> future = QFuture<T>(futureInterfaceTyped());
start();

acquireBarrierSemaphore();
threadPool->start(this);
return future;
}

void asynchronousFinish()
{
finish();
futureInterfaceTyped()->reportFinished(result());
delete futureInterfaceTyped();
delete this;
}


void reportResult(const T *_result, int index = -1)
{
if (futureInterface)
futureInterfaceTyped()->reportResult(_result, index);
}

void reportResults(const QVector<T> &_result, int index = -1, int count = -1)
{
if (futureInterface)
futureInterfaceTyped()->reportResults(_result, index, count);
}
};





template <typename T>
class ThreadEngineStarterBase
{
public:
ThreadEngineStarterBase(ThreadEngine<T> *_threadEngine)
: threadEngine(_threadEngine) { }

inline ThreadEngineStarterBase(const ThreadEngineStarterBase &other)
: threadEngine(other.threadEngine) { }

QFuture<T> startAsynchronously()
{
return threadEngine->startAsynchronously();
}

operator QFuture<T>()
{
return startAsynchronously();
}

protected:
ThreadEngine<T> *threadEngine;
};





template <typename T>
class ThreadEngineStarter : public ThreadEngineStarterBase<T>
{
typedef ThreadEngineStarterBase<T> Base;
typedef ThreadEngine<T> TypedThreadEngine;
public:
ThreadEngineStarter(TypedThreadEngine *eng)
: Base(eng) { }

T startBlocking()
{
T t = *this->threadEngine->startBlocking();
delete this->threadEngine;
return t;
}
};


template <>
class ThreadEngineStarter<void> : public ThreadEngineStarterBase<void>
{
public:
ThreadEngineStarter<void>(ThreadEngine<void> *_threadEngine)
:ThreadEngineStarterBase<void>(_threadEngine) {}

void startBlocking()
{
this->threadEngine->startBlocking();
delete this->threadEngine;
}
};

template <typename ThreadEngine>
inline ThreadEngineStarter<typename ThreadEngine::ResultType> startThreadEngine(ThreadEngine *threadEngine)
{
return ThreadEngineStarter<typename ThreadEngine::ResultType>(threadEngine);
}

} 



# 280 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"






# 51 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"






# 57 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"



typedef QtValidLicenseForCoreModule QtCoreModule;



# 64 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"
namespace QtConcurrent {




# 69 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"
template <typename It, typename T>
void advance(It &it, T value)
{
it+=value;
}


# 76 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"








class  BlockSizeManager
{
public:
BlockSizeManager(int iterationCount);
void timeBeforeUser();
void timeAfterUser();
int blockSize();
private:
inline bool blockSizeMaxed()
{
return (m_blockSize >= maxBlockSize);
}

const int maxBlockSize;
qint64 beforeUser;
qint64 afterUser;
Median<double> controlPartElapsed;
Median<double> userPartElapsed;
int m_blockSize;
};

template <typename T>
class ResultReporter
{
public:
ResultReporter(ThreadEngine<T> *_threadEngine)
:threadEngine(_threadEngine)
{

}

void reserveSpace(int resultCount)
{
currentResultCount = resultCount;
vector.resize(qMax(resultCount, vector.count()));
}

void reportResults(int begin)
{
const int useVectorThreshold = 4; 
if (currentResultCount > useVectorThreshold) {
vector.resize(currentResultCount);
threadEngine->reportResults(vector, begin);
} else {
for (int i = 0; i < currentResultCount; ++i)
threadEngine->reportResult(&vector.at(i), begin + i);
}
}

inline T * getPointer()
{
return vector.data();
}

int currentResultCount;
ThreadEngine<T> *threadEngine;
QVector<T> vector;
};

template <>
class ResultReporter<void>
{
public:
inline ResultReporter(ThreadEngine<void> *) { }
inline void reserveSpace(int) { };
inline void reportResults(int) { };
inline void * getPointer() { return 0; }
};

















# 169 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"

template <typename T>
inline bool selectIteration(T)
{
return false; 
}


# 177 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"
template <typename Iterator, typename T>
class IterateKernel : public ThreadEngine<T>
{
public:
typedef T ResultType;

IterateKernel(Iterator _begin, Iterator _end)

# 185 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"
: begin(_begin), end(_end), current(_begin), currentIndex(0),
forIteration(false), progressReportingEnabled(true)







# 194 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"
{

# 196 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"
iterationCount = 0;




# 201 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"
}

virtual ~IterateKernel() { }

virtual bool runIteration(Iterator it, int index , T *result)
{ (void)it;; (void)index;; (void)result;; return false; }
virtual bool runIterations(Iterator _begin, int beginIndex, int endIndex, T *results)
{ (void)_begin;; (void)beginIndex;; (void)endIndex;; (void)results;; return false; }

void start()
{
progressReportingEnabled = this->isProgressReportingEnabled();
if (progressReportingEnabled && iterationCount > 0)
this->setProgressRange(0, iterationCount);
}

bool shouldStartThread()
{
if (forIteration)
return (currentIndex < iterationCount) && !this->shouldThrottleThread();
else 
return (iteratorThreads == 0);
}

ThreadFunctionResult threadFunction()
{
if (forIteration)
return this->forThreadFunction();
else 
return this->whileThreadFunction();
}

ThreadFunctionResult forThreadFunction()
{
BlockSizeManager blockSizeManager(iterationCount);
ResultReporter<T> resultReporter(this);

for(;;) {
if (this->isCanceled())
break;

const int currentBlockSize = blockSizeManager.blockSize();

if (currentIndex >= iterationCount)
break;


const int beginIndex = currentIndex.fetchAndAddRelease(currentBlockSize);
const int endIndex = qMin(beginIndex + currentBlockSize, iterationCount);

if (beginIndex >= endIndex) {

break;
}

this->waitForResume(); 

if (shouldStartThread())
this->startThread();

const int finalBlockSize = endIndex - beginIndex; 
resultReporter.reserveSpace(finalBlockSize);


blockSizeManager.timeBeforeUser();
const bool resultsAvailable = this->runIterations(begin, beginIndex, endIndex, resultReporter.getPointer());
blockSizeManager.timeAfterUser();

if (resultsAvailable)
resultReporter.reportResults(beginIndex);


if (progressReportingEnabled) {
completed.fetchAndAddAcquire(finalBlockSize);
this->setProgressValue(this->completed);
}

if (this->shouldThrottleThread())
return ThrottleThread;
}
return ThreadFinished;
}

ThreadFunctionResult whileThreadFunction()
{
if (iteratorThreads.testAndSetAcquire(0, 1) == false)
return ThreadFinished;

ResultReporter<T> resultReporter(this);
resultReporter.reserveSpace(1);

while (current != end) {



Iterator prev = current;
++current;
int index = currentIndex.fetchAndAddRelaxed(1);
iteratorThreads.testAndSetRelease(1, 0);

this->waitForResume(); 

if (shouldStartThread())
this->startThread();

const bool resultAavailable = this->runIteration(prev, index, resultReporter.getPointer());
if (resultAavailable)
resultReporter.reportResults(index);

if (this->shouldThrottleThread())
return ThrottleThread;

if (iteratorThreads.testAndSetAcquire(0, 1) == false)
return ThreadFinished;
}

return ThreadFinished;
}


public:
const Iterator begin;
const Iterator end;
Iterator current;
QAtomicInt currentIndex;
bool forIteration;
QAtomicInt iteratorThreads;
int iterationCount;

bool progressReportingEnabled;
QAtomicInt completed;
};

} 



# 338 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"






# 49 "/usr/share/qt4/include/QtCore/qtconcurrentfilterkernel.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentmapkernel.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentmapkernel.h"




# 1 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"
















































































































































































































































































































































# 49 "/usr/share/qt4/include/QtCore/qtconcurrentmapkernel.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"




# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 49 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"

# 1 "/usr/share/qt4/include/QtCore/qmap.h"




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 51 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"

# 1 "/usr/share/qt4/include/QtCore/qmutex.h"

































































































































































































# 52 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"

# 1 "/usr/share/qt4/include/QtCore/qthread.h"






































































































































































# 53 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"

# 1 "/usr/share/qt4/include/QtCore/qthreadpool.h"































































































# 54 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 55 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"


# 57 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"



typedef QtValidLicenseForCoreModule QtCoreModule;

namespace QtConcurrent {



# 66 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"







enum {
ReduceQueueStartLimit = 20,
ReduceQueueThrottleLimit = 30
};




template <typename T>
class IntermediateResults
{
public:
int begin, end;
QVector<T> vector;
};



# 91 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"
enum ReduceOption {
UnorderedReduce = 0x1,
OrderedReduce = 0x2,
SequentialReduce = 0x4

};
typedef QFlags<ReduceOption> ReduceOptions;
inline QFlags<ReduceOptions::enum_type> operator|(ReduceOptions::enum_type f1, ReduceOptions::enum_type f2) { return QFlags<ReduceOptions::enum_type>(f1) | f2; } inline QFlags<ReduceOptions::enum_type> operator|(ReduceOptions::enum_type f1, QFlags<ReduceOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(ReduceOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 102 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"

template <typename ReduceFunctor, typename ReduceResultType, typename T>
class ReduceKernel
{
typedef QMap<int, IntermediateResults<T> > ResultsMap;

const ReduceOptions reduceOptions;

QMutex mutex;
int progress, resultsMapSize, threadCount;
ResultsMap resultsMap;

bool canReduce(int begin) const
{
return (((reduceOptions & UnorderedReduce)
&& progress == 0)
|| ((reduceOptions & OrderedReduce)
&& progress == begin));
}

void reduceResult(ReduceFunctor &reduce,
ReduceResultType &r,
const IntermediateResults<T> &result)
{
for (int i = 0; i < result.vector.size(); ++i) {
reduce(r, result.vector.at(i));
}
}

void reduceResults(ReduceFunctor &reduce,
ReduceResultType &r,
ResultsMap &map)
{
typename ResultsMap::iterator it = map.begin();
while (it != map.end()) {
reduceResult(reduce, r, it.value());
++it;
}
}

public:
ReduceKernel(ReduceOptions _reduceOptions)
: reduceOptions(_reduceOptions), progress(0), resultsMapSize(0), 
threadCount(QThreadPool::globalInstance()->maxThreadCount())
{ }

void runReduce(ReduceFunctor &reduce,
ReduceResultType &r,
const IntermediateResults<T> &result)
{
QMutexLocker locker(&mutex);
if (!canReduce(result.begin)) {
++resultsMapSize;
resultsMap.insert(result.begin, result);
return;
}

if (reduceOptions & UnorderedReduce) {

progress = -1;


locker.unlock();
reduceResult(reduce, r, result);
locker.relock();


while (!resultsMap.isEmpty()) {
ResultsMap resultsMapCopy = resultsMap;
resultsMap.clear();

locker.unlock();
reduceResults(reduce, r, resultsMapCopy);
locker.relock();

resultsMapSize -= resultsMapCopy.size();
}

progress = 0;
} else {

locker.unlock();
reduceResult(reduce, r, result);
locker.relock();


progress += result.end - result.begin;


typename ResultsMap::iterator it = resultsMap.begin();
while (it != resultsMap.end()) {
if (it.value().begin != progress)
break;

locker.unlock();
reduceResult(reduce, r, it.value());
locker.relock();

--resultsMapSize;
progress += it.value().end - it.value().begin;
it = resultsMap.erase(it);
}
}
}


void finish(ReduceFunctor &reduce, ReduceResultType &r)
{
reduceResults(reduce, r, resultsMap);
}

inline bool shouldThrottle()
{
return (resultsMapSize > (ReduceQueueThrottleLimit * threadCount));
}

inline bool shouldStartThread()
{
return (resultsMapSize <= (ReduceQueueStartLimit * threadCount));
}
};

template <typename Sequence, typename Base, typename Functor1, typename Functor2>
struct SequenceHolder2 : public Base
{
SequenceHolder2(const Sequence &_sequence,
Functor1 functor1,
Functor2 functor2,
ReduceOptions reduceOptions)
: Base(_sequence.begin(), _sequence.end(), functor1, functor2, reduceOptions),
sequence(_sequence)
{ }

Sequence sequence;

void finish()
{
Base::finish();


sequence = Sequence();
}
};



# 248 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"
} 







# 50 "/usr/share/qt4/include/QtCore/qtconcurrentmapkernel.h"


# 52 "/usr/share/qt4/include/QtCore/qtconcurrentmapkernel.h"



typedef QtValidLicenseForCoreModule QtCoreModule;


# 58 "/usr/share/qt4/include/QtCore/qtconcurrentmapkernel.h"
namespace QtConcurrent {


template <typename Iterator, typename MapFunctor>
class MapKernel : public IterateKernel<Iterator, void>
{
MapFunctor map;
public:
typedef void ReturnType;
MapKernel(Iterator begin, Iterator end, MapFunctor _map)
: IterateKernel<Iterator, void>(begin, end), map(_map)
{ }

bool runIteration(Iterator it, int, void *)
{
map(*it);
return false;
}

bool runIterations(Iterator sequenceBeginIterator, int beginIndex, int endIndex, void *)
{
Iterator it = sequenceBeginIterator;
advance(it, beginIndex);
for (int i = beginIndex; i < endIndex; ++i) {
runIteration(it, i, 0);
advance(it, 1);
}

return false;
}
};

template <typename ReducedResultType,
typename Iterator,
typename MapFunctor,
typename ReduceFunctor,
typename Reducer = ReduceKernel<ReduceFunctor,
ReducedResultType,
typename MapFunctor::result_type> >
class MappedReducedKernel : public IterateKernel<Iterator, ReducedResultType>
{
ReducedResultType reducedResult;
MapFunctor map;
ReduceFunctor reduce;
Reducer reducer;
public:
typedef ReducedResultType ReturnType;
MappedReducedKernel(Iterator begin, Iterator end, MapFunctor _map, ReduceFunctor _reduce, ReduceOptions reduceOptions)
: IterateKernel<Iterator, ReducedResultType>(begin, end), reducedResult(), map(_map), reduce(_reduce), reducer(reduceOptions)
{ }

MappedReducedKernel(ReducedResultType initialValue,
MapFunctor _map,
ReduceFunctor _reduce)
: reducedResult(initialValue), map(_map), reduce(_reduce)
{ }

bool runIteration(Iterator it, int index, ReducedResultType *)
{
IntermediateResults<typename MapFunctor::result_type> results;
results.begin = index;
results.end = index + 1;

results.vector.append(map(*it));
reducer.runReduce(reduce, reducedResult, results);
return false;
}

bool runIterations(Iterator sequenceBeginIterator, int begin, int end, ReducedResultType *)
{
IntermediateResults<typename MapFunctor::result_type> results;
results.begin = begin;
results.end = end;
results.vector.reserve(end - begin);

Iterator it = sequenceBeginIterator;
advance(it, begin);
for (int i = begin; i < end; ++i) {
results.vector.append(map(*(it)));
advance(it, 1);
}

reducer.runReduce(reduce, reducedResult, results);
return false;
}

void finish()
{
reducer.finish(reduce, reducedResult);
}

bool shouldThrottleThread()
{
return IterateKernel<Iterator, ReducedResultType>::shouldThrottleThread() || reducer.shouldThrottle();
}

bool shouldStartThread()
{
return IterateKernel<Iterator, ReducedResultType>::shouldStartThread() && reducer.shouldStartThread();
}

typedef ReducedResultType ResultType;
ReducedResultType *result()
{
return &reducedResult;
}
};

template <typename Iterator, typename MapFunctor>
class MappedEachKernel : public IterateKernel<Iterator, typename MapFunctor::result_type>
{
MapFunctor map;
typedef typename MapFunctor::result_type T;
public:
typedef T ReturnType;
typedef T ResultType;

MappedEachKernel(Iterator begin, Iterator end, MapFunctor _map)
: IterateKernel<Iterator, T>(begin, end), map(_map) { }

bool runIteration(Iterator it, int, T *result)
{
*result = map(*it);
return true;
}

bool runIterations(Iterator sequenceBeginIterator, int begin, int end, T *results)
{

Iterator it = sequenceBeginIterator;
advance(it, begin);
for (int i = begin; i < end; ++i) {
runIteration(it, i, results + (i - begin));
advance(it, 1);
}

return true;
}
};

template <typename Iterator, typename Functor>
inline ThreadEngineStarter<void> startMap(Iterator begin, Iterator end, Functor functor)
{
return startThreadEngine(new MapKernel<Iterator, Functor>(begin, end, functor));
}

template <typename T, typename Iterator, typename Functor>
inline ThreadEngineStarter<T> startMapped(Iterator begin, Iterator end, Functor functor)
{
return startThreadEngine(new MappedEachKernel<Iterator, Functor>(begin, end, functor));
}





template <typename Sequence, typename Base, typename Functor>
struct SequenceHolder1 : public Base
{
SequenceHolder1(const Sequence &_sequence, Functor functor)
: Base(_sequence.begin(), _sequence.end(), functor), sequence(_sequence)
{ }

Sequence sequence;

void finish()
{
Base::finish();


sequence = Sequence();
}
};

template <typename T, typename Sequence, typename Functor>
inline ThreadEngineStarter<T> startMapped(const Sequence &sequence, Functor functor)
{
typedef SequenceHolder1<Sequence,
MappedEachKernel<typename Sequence::const_iterator , Functor>, Functor>
SequenceHolderType;

return startThreadEngine(new SequenceHolderType(sequence, functor));
}

template <typename IntermediateType, typename ResultType, typename Sequence, typename MapFunctor, typename ReduceFunctor>
inline ThreadEngineStarter<ResultType> startMappedReduced(const Sequence & sequence,
MapFunctor mapFunctor, ReduceFunctor reduceFunctor,
ReduceOptions options)
{
typedef typename Sequence::const_iterator Iterator;
typedef ReduceKernel<ReduceFunctor, ResultType, IntermediateType> Reducer;
typedef MappedReducedKernel<ResultType, Iterator, MapFunctor, ReduceFunctor, Reducer> MappedReduceType;
typedef SequenceHolder2<Sequence, MappedReduceType, MapFunctor, ReduceFunctor> SequenceHolderType;
return startThreadEngine(new SequenceHolderType(sequence, mapFunctor, reduceFunctor, options));
}

template <typename IntermediateType, typename ResultType, typename Iterator, typename MapFunctor, typename ReduceFunctor>
inline ThreadEngineStarter<ResultType> startMappedReduced(Iterator begin, Iterator end,
MapFunctor mapFunctor, ReduceFunctor reduceFunctor,
ReduceOptions options)
{
typedef ReduceKernel<ReduceFunctor, ResultType, IntermediateType> Reducer;
typedef MappedReducedKernel<ResultType, Iterator, MapFunctor, ReduceFunctor, Reducer> MappedReduceType;
return startThreadEngine(new MappedReduceType(begin, end, mapFunctor, reduceFunctor, options));
}

} 



# 268 "/usr/share/qt4/include/QtCore/qtconcurrentmapkernel.h"






# 50 "/usr/share/qt4/include/QtCore/qtconcurrentfilterkernel.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"

























































































































































































































































# 51 "/usr/share/qt4/include/QtCore/qtconcurrentfilterkernel.h"


# 53 "/usr/share/qt4/include/QtCore/qtconcurrentfilterkernel.h"



typedef QtValidLicenseForCoreModule QtCoreModule;



# 60 "/usr/share/qt4/include/QtCore/qtconcurrentfilterkernel.h"
namespace QtConcurrent {

template <typename T>
struct qValueType
{
typedef typename T::value_type value_type;
};

template <typename T>
struct qValueType<const T*>
{
typedef T value_type;
};

template <typename T>
struct qValueType<T*>
{
typedef T value_type;
};


template <typename Sequence, typename KeepFunctor, typename ReduceFunctor>
class FilterKernel : public IterateKernel<typename Sequence::const_iterator, void>
{
typedef ReduceKernel<ReduceFunctor, Sequence, typename Sequence::value_type> Reducer;
typedef IterateKernel<typename Sequence::const_iterator, void> IterateKernelType;
typedef typename ReduceFunctor::result_type T;

Sequence reducedResult;
Sequence &sequence;
KeepFunctor keep;
ReduceFunctor reduce;
Reducer reducer;

public:
FilterKernel(Sequence &_sequence, KeepFunctor _keep, ReduceFunctor _reduce)
: IterateKernelType(const_cast<const Sequence &>(_sequence).begin(), const_cast<const Sequence &>(_sequence).end()), reducedResult(),
sequence(_sequence),
keep(_keep),
reduce(_reduce),
reducer(OrderedReduce)
{ }

bool runIteration(typename Sequence::const_iterator it, int index, T *)
{
IntermediateResults<typename Sequence::value_type> results;
results.begin = index;
results.end = index + 1;

if (keep(*it))
results.vector.append(*it);

reducer.runReduce(reduce, reducedResult, results);
return false;
}

bool runIterations(typename Sequence::const_iterator sequenceBeginIterator, int begin, int end, T *)
{
IntermediateResults<typename Sequence::value_type> results;
results.begin = begin;
results.end = end;
results.vector.reserve(end - begin);


typename Sequence::const_iterator it = sequenceBeginIterator;
advance(it, begin);
for (int i = begin; i < end; ++i) {
if (keep(*it))
results.vector.append(*it);
advance(it, 1);
}

reducer.runReduce(reduce, reducedResult, results);
return false;
}

void finish()
{
reducer.finish(reduce, reducedResult);
sequence = reducedResult;
}

inline bool shouldThrottleThread()
{
return IterateKernelType::shouldThrottleThread() || reducer.shouldThrottle();
}

inline bool shouldStartThread()
{
return IterateKernelType::shouldStartThread() && reducer.shouldStartThread();
}

typedef void ReturnType;
typedef void ResultType;
};


template <typename ReducedResultType,
typename Iterator,
typename KeepFunctor,
typename ReduceFunctor,
typename Reducer = ReduceKernel<ReduceFunctor,
ReducedResultType,
typename qValueType<Iterator>::value_type> >
class FilteredReducedKernel : public IterateKernel<Iterator, ReducedResultType>
{
ReducedResultType reducedResult;
KeepFunctor keep;
ReduceFunctor reduce;
Reducer reducer;
typedef IterateKernel<Iterator, ReducedResultType> IterateKernelType;

public:
FilteredReducedKernel(Iterator begin,
Iterator end,
KeepFunctor _keep,
ReduceFunctor _reduce,
ReduceOptions reduceOption)
: IterateKernelType(begin, end), reducedResult(), keep(_keep), reduce(_reduce), reducer(reduceOption)
{ }










# 190 "/usr/share/qt4/include/QtCore/qtconcurrentfilterkernel.h"
bool runIteration(Iterator it, int index, ReducedResultType *)
{
IntermediateResults<typename qValueType<Iterator>::value_type> results;
results.begin = index;
results.end = index + 1;

if (keep(*it))
results.vector.append(*it);

reducer.runReduce(reduce, reducedResult, results);
return false;
}

bool runIterations(Iterator sequenceBeginIterator, int begin, int end, ReducedResultType *)
{
IntermediateResults<typename qValueType<Iterator>::value_type> results;
results.begin = begin;
results.end = end;
results.vector.reserve(end - begin);

Iterator it = sequenceBeginIterator;
advance(it, begin);
for (int i = begin; i < end; ++i) {
if (keep(*it))
results.vector.append(*it);
advance(it, 1);
}

reducer.runReduce(reduce, reducedResult, results);
return false;
}

void finish()
{
reducer.finish(reduce, reducedResult);
}

inline bool shouldThrottleThread()
{
return IterateKernelType::shouldThrottleThread() || reducer.shouldThrottle();
}

inline bool shouldStartThread()
{
return IterateKernelType::shouldStartThread() && reducer.shouldStartThread();
}

typedef ReducedResultType ReturnType;
typedef ReducedResultType ResultType;
ReducedResultType *result()
{
return &reducedResult;
}
};


template <typename Iterator, typename KeepFunctor>
class FilteredEachKernel : public IterateKernel<Iterator, typename qValueType<Iterator>::value_type>
{
typedef typename qValueType<Iterator>::value_type T;
typedef IterateKernel<Iterator, T> IterateKernelType;

KeepFunctor keep;

public:
typedef T ReturnType;
typedef T ResultType;

FilteredEachKernel(Iterator begin, Iterator end, KeepFunctor _keep)
: IterateKernelType(begin, end), keep(_keep)
{ }

void start()
{
if (this->futureInterface)
this->futureInterface->setFilterMode(true);
IterateKernelType::start();
}

bool runIteration(Iterator it, int index, T *)
{
if (keep(*it))
this->reportResult(&(*it), index);
else
this->reportResult(0, index);
return false;
}

bool runIterations(Iterator sequenceBeginIterator, int begin, int end, T *)
{
const int count = end - begin;
IntermediateResults<typename qValueType<Iterator>::value_type> results;
results.begin = begin;
results.end = end;
results.vector.reserve(count);

Iterator it = sequenceBeginIterator;
advance(it, begin);
for (int i = begin; i < end; ++i) {
if (keep(*it))
results.vector.append(*it);
advance(it, 1);
}

this->reportResults(results.vector, begin, count);
return false;
}
};

template <typename Iterator, typename KeepFunctor>
inline
ThreadEngineStarter<typename qValueType<Iterator>::value_type>
startFiltered(Iterator begin, Iterator end, KeepFunctor functor)
{
return startThreadEngine(new FilteredEachKernel<Iterator, KeepFunctor>(begin, end, functor));
}

template <typename Sequence, typename KeepFunctor>
inline ThreadEngineStarter<typename Sequence::value_type>
startFiltered(const Sequence &sequence, KeepFunctor functor)
{
typedef SequenceHolder1<Sequence,
FilteredEachKernel<typename Sequence::const_iterator, KeepFunctor>,
KeepFunctor>
SequenceHolderType;
return startThreadEngine(new SequenceHolderType(sequence, functor));
}

template <typename ResultType, typename Sequence, typename MapFunctor, typename ReduceFunctor>
inline ThreadEngineStarter<ResultType> startFilteredReduced(const Sequence & sequence,
MapFunctor mapFunctor, ReduceFunctor reduceFunctor,
ReduceOptions options)
{
typedef typename Sequence::const_iterator Iterator;
typedef ReduceKernel<ReduceFunctor, ResultType, typename qValueType<Iterator>::value_type > Reducer;
typedef FilteredReducedKernel<ResultType, Iterator, MapFunctor, ReduceFunctor, Reducer> FilteredReduceType;
typedef SequenceHolder2<Sequence, FilteredReduceType, MapFunctor, ReduceFunctor> SequenceHolderType;
return startThreadEngine(new SequenceHolderType(sequence, mapFunctor, reduceFunctor, options));
}


template <typename ResultType, typename Iterator, typename MapFunctor, typename ReduceFunctor>
inline ThreadEngineStarter<ResultType> startFilteredReduced(Iterator begin, Iterator end,
MapFunctor mapFunctor, ReduceFunctor reduceFunctor,
ReduceOptions options)
{
typedef ReduceKernel<ReduceFunctor, ResultType, typename qValueType<Iterator>::value_type> Reducer;
typedef FilteredReducedKernel<ResultType, Iterator, MapFunctor, ReduceFunctor, Reducer> FilteredReduceType;
return startThreadEngine(new FilteredReduceType(begin, end, mapFunctor, reduceFunctor, options));
}


} 



# 346 "/usr/share/qt4/include/QtCore/qtconcurrentfilterkernel.h"






# 49 "/usr/share/qt4/include/QtCore/qtconcurrentfilter.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentfunctionwrappers.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentfunctionwrappers.h"




# 49 "/usr/share/qt4/include/QtCore/qtconcurrentfunctionwrappers.h"



typedef QtValidLicenseForCoreModule QtCoreModule;



# 56 "/usr/share/qt4/include/QtCore/qtconcurrentfunctionwrappers.h"
namespace QtConcurrent {

template <typename T>
class FunctionWrapper0
{
public:
typedef T (*FunctionPointerType)();
typedef T result_type;
inline FunctionWrapper0(FunctionPointerType _functionPointer)
:functionPointer(_functionPointer) { }

inline T operator()()
{
return functionPointer();
}
private:
FunctionPointerType functionPointer;
};

template <typename T, typename U>
class FunctionWrapper1
{
public:
typedef T (*FunctionPointerType)(U u);
typedef T result_type;
inline FunctionWrapper1(FunctionPointerType _functionPointer)
:functionPointer(_functionPointer) { }

inline T operator()(U u)
{
return functionPointer(u);
}

private:
FunctionPointerType functionPointer;
};

template <typename T, typename U, typename V>
class FunctionWrapper2
{
public:
typedef T (*FunctionPointerType)(U u, V v);
typedef T result_type;
inline FunctionWrapper2(FunctionPointerType _functionPointer)
:functionPointer(_functionPointer) { }

inline T operator()(U u, V v)
{
return functionPointer(u, v);
}
private:
FunctionPointerType functionPointer;
};

template <typename T, typename C>
class MemberFunctionWrapper
{
public:
typedef T (C::*FunctionPointerType)();
typedef T result_type;
inline MemberFunctionWrapper(FunctionPointerType _functionPointer)
:functionPointer(_functionPointer) { }

inline T operator()(C &c)
{
return (c.*functionPointer)();
}
private:
FunctionPointerType functionPointer;
};

template <typename T, typename C, typename U>
class MemberFunctionWrapper1
{
public:
typedef T (C::*FunctionPointerType)(U);
typedef T result_type;

inline MemberFunctionWrapper1(FunctionPointerType _functionPointer)
: functionPointer(_functionPointer)
{ }

inline T operator()(C &c, U u)
{
return (c.*functionPointer)(u);
}

private:
FunctionPointerType functionPointer;
};

template <typename T, typename C>
class ConstMemberFunctionWrapper
{
public:
typedef T (C::*FunctionPointerType)() const;
typedef T result_type;
inline ConstMemberFunctionWrapper(FunctionPointerType _functionPointer)
:functionPointer(_functionPointer) { }

inline T operator()(const C &c) const
{
return (c.*functionPointer)();
}
private:
FunctionPointerType functionPointer;
};

} 



# 168 "/usr/share/qt4/include/QtCore/qtconcurrentfunctionwrappers.h"






# 50 "/usr/share/qt4/include/QtCore/qtconcurrentfilter.h"


# 52 "/usr/share/qt4/include/QtCore/qtconcurrentfilter.h"



typedef QtValidLicenseForCoreModule QtCoreModule;















































# 103 "/usr/share/qt4/include/QtCore/qtconcurrentfilter.h"
namespace QtConcurrent {

template <typename Sequence, typename KeepFunctor, typename T, typename C, typename U>
ThreadEngineStarter<void> filterInternal(Sequence &sequence, KeepFunctor keep, T (C::*reduce)(U))
{
typedef MemberFunctionWrapper1<T, C, U> ReduceFunctor;
typedef typename Sequence::const_iterator Iterator;
typedef FilterKernel<Sequence, KeepFunctor, ReduceFunctor> KernelType;
return startThreadEngine(new KernelType(sequence, keep, reduce));
}


template <typename Sequence, typename KeepFunctor>
QFuture<void> filter(Sequence &sequence, KeepFunctor keep)
{
return filterInternal(sequence, keep, &Sequence::push_back);
}

template <typename Sequence, typename T>
QFuture<void> filter(Sequence &sequence, bool (keep)(T))
{
return filterInternal(sequence, FunctionWrapper1<bool, T>(keep), &Sequence::push_back);
}

template <typename Sequence, typename C>
QFuture<void> filter(Sequence &sequence, bool (C::*keep)() const)
{
return filterInternal(sequence, ConstMemberFunctionWrapper<bool, C>(keep), &Sequence::push_back);
}


template <typename ResultType, typename Sequence, typename KeepFunctor, typename ReduceFunctor>
QFuture<ResultType> filteredReduced(const Sequence &sequence,
KeepFunctor keep,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startFilteredReduced<ResultType>(sequence, keep, reduce, options);
}

template <typename ResultType, typename Sequence, typename T, typename ReduceFunctor>
QFuture<ResultType> filteredReduced(const Sequence &sequence,
bool (filter)(T),
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<ResultType>(sequence,
FunctionWrapper1<bool, T>(filter),
reduce,
options);
}

template <typename ResultType, typename Sequence, typename C, typename ReduceFunctor>
QFuture<ResultType> filteredReduced(const Sequence &sequence,
bool (C::*filter)() const,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<ResultType>(sequence,
ConstMemberFunctionWrapper<bool, C>(filter),
reduce,
options);
}

template <typename Sequence, typename KeepFunctor, typename T, typename U, typename V>
QFuture<U> filteredReduced(const Sequence &sequence,
KeepFunctor keep,
T (reduce)(U &, V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<U>(sequence,
keep,
FunctionWrapper2<T, U &, V>(reduce),
options);
}

template <typename Sequence, typename KeepFunctor, typename T, typename C, typename U>
QFuture<C> filteredReduced(const Sequence &sequence,
KeepFunctor keep,
T (C::*reduce)(U),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<C>(sequence,
keep,
MemberFunctionWrapper1<T, C, U>(reduce),
options);
}

template <typename Sequence, typename T, typename U, typename V, typename W>
QFuture<V> filteredReduced(const Sequence &sequence,
bool (keep)(T),
U (reduce)(V &, W),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<V>(sequence,
FunctionWrapper1<bool, T>(keep),
FunctionWrapper2<U, V &, W>(reduce),
options);
}

template <typename Sequence, typename C, typename T, typename U, typename V>
QFuture<U> filteredReduced(const Sequence &sequence,
bool (C::*keep)() const,
T (reduce)(U &, V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<U>(sequence,
ConstMemberFunctionWrapper<bool, C>(keep),
FunctionWrapper2<T, U &, V>(reduce),
options);
}

template <typename Sequence, typename T, typename U, typename C, typename V>
QFuture<C> filteredReduced(const Sequence &sequence,
bool (keep)(T),
U (C::*reduce)(V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<C>(sequence,
FunctionWrapper1<bool, T>(keep),
MemberFunctionWrapper1<U, C, V>(reduce),
options);
}

template <typename Sequence, typename C, typename T, typename D, typename U>
QFuture<D> filteredReduced(const Sequence &sequence,
bool (C::*keep)() const,
T (D::*reduce)(U),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<D>(sequence,
ConstMemberFunctionWrapper<bool, C>(keep),
MemberFunctionWrapper1<T, D, U>(reduce),
options);
}


template <typename ResultType, typename Iterator, typename KeepFunctor, typename ReduceFunctor>
QFuture<ResultType> filteredReduced(Iterator begin,
Iterator end,
KeepFunctor keep,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startFilteredReduced<ResultType>(begin, end, keep, reduce, options);
}

template <typename ResultType, typename Iterator, typename T, typename ReduceFunctor>
QFuture<ResultType> filteredReduced(Iterator begin,
Iterator end,
bool (filter)(T),
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<ResultType>(begin,
end,
FunctionWrapper1<bool, T>(filter),
reduce,
options);
}

template <typename ResultType, typename Iterator, typename C, typename ReduceFunctor>
QFuture<ResultType> filteredReduced(Iterator begin,
Iterator end,
bool (C::*filter)() const,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<ResultType>(begin,
end,
ConstMemberFunctionWrapper<bool, C>(filter),
reduce,
options);
}

template <typename Iterator, typename KeepFunctor, typename T, typename U, typename V>
QFuture<U> filteredReduced(Iterator begin,
Iterator end,
KeepFunctor keep,
T (reduce)(U &, V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<U>(begin,
end,
keep,
FunctionWrapper2<T, U &, V>(reduce),
options);
}

template <typename Iterator, typename KeepFunctor, typename T, typename C, typename U>
QFuture<C> filteredReduced(Iterator begin,
Iterator end,
KeepFunctor keep,
T (C::*reduce)(U),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<C>(begin,
end,
keep,
MemberFunctionWrapper1<T, C, U>(reduce),
options);
}

template <typename Iterator, typename T, typename U, typename V, typename W>
QFuture<V> filteredReduced(Iterator begin,
Iterator end,
bool (keep)(T),
U (reduce)(V &, W),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<V>(begin,
end,
FunctionWrapper1<bool, T>(keep),
FunctionWrapper2<U, V &, W>(reduce),
options);
}

template <typename Iterator, typename C, typename T, typename U, typename V>
QFuture<U> filteredReduced(Iterator begin,
Iterator end,
bool (C::*keep)() const,
T (reduce)(U &, V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<U>(begin,
end,
ConstMemberFunctionWrapper<bool, C>(keep),
FunctionWrapper2<T, U &, V>(reduce),
options);
}

template <typename Iterator, typename T, typename U, typename C, typename V>
QFuture<C> filteredReduced(Iterator begin,
Iterator end,
bool (keep)(T),
U (C::*reduce)(V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<C>(begin,
end,
FunctionWrapper1<bool, T>(keep),
MemberFunctionWrapper1<U, C, V>(reduce),
options);
}

template <typename Iterator, typename C, typename T, typename D, typename U>
QFuture<D> filteredReduced(Iterator begin,
Iterator end,
bool (C::*keep)() const,
T (D::*reduce)(U),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return filteredReduced<D>(begin,
end,
ConstMemberFunctionWrapper<bool, C>(keep),
MemberFunctionWrapper1<T, D, U>(reduce),
options);
}



template <typename Sequence, typename KeepFunctor>
QFuture<typename Sequence::value_type> filtered(const Sequence &sequence, KeepFunctor keep)
{
return startFiltered(sequence, keep);
}

template <typename Sequence, typename T>
QFuture<typename Sequence::value_type> filtered(const Sequence &sequence, bool (keep)(T))
{
return startFiltered(sequence, FunctionWrapper1<bool, T>(keep));
}

template <typename Sequence, typename C>
QFuture<typename Sequence::value_type> filtered(const Sequence &sequence, bool (C::*keep)() const)
{
return startFiltered(sequence, ConstMemberFunctionWrapper<bool, C>(keep));
}


template <typename Iterator, typename KeepFunctor>
QFuture<typename qValueType<Iterator>::value_type> filtered(Iterator begin, Iterator end, KeepFunctor keep)
{
return startFiltered(begin, end, keep);
}

template <typename Iterator, typename T>
QFuture<typename qValueType<Iterator>::value_type> filtered(Iterator begin, Iterator end, bool (keep)(T))
{
return startFiltered(begin, end, FunctionWrapper1<bool, T>(keep));
}

template <typename Iterator, typename C>
QFuture<typename qValueType<Iterator>::value_type> filtered(Iterator begin,
Iterator end,
bool (C::*keep)() const)
{
return startFiltered(begin, end, ConstMemberFunctionWrapper<bool, C>(keep));
}



template <typename Sequence, typename KeepFunctor>
void blockingFilter(Sequence &sequence, KeepFunctor keep)
{
filterInternal(sequence, keep, &Sequence::push_back).startBlocking();
}

template <typename Sequence, typename T>
void blockingFilter(Sequence &sequence, bool (keep)(T))
{
filterInternal(sequence, FunctionWrapper1<bool, T>(keep), &Sequence::push_back)
.startBlocking();
}

template <typename Sequence, typename C>
void blockingFilter(Sequence &sequence, bool (C::*keep)() const)
{
filterInternal(sequence,
ConstMemberFunctionWrapper<bool, C>(keep),
&Sequence::push_back)
.startBlocking();
}


template <typename ResultType, typename Sequence, typename KeepFunctor, typename ReduceFunctor>
ResultType blockingFilteredReduced(const Sequence &sequence,
KeepFunctor keep,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startFilteredReduced<ResultType>(sequence, keep, reduce, options)
.startBlocking();
}

template <typename ResultType, typename Sequence, typename T, typename ReduceFunctor>
ResultType blockingFilteredReduced(const Sequence &sequence,
bool (filter)(T),
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<ResultType>
(sequence,
FunctionWrapper1<bool, T>(filter),
reduce,
options);
}

template <typename ResultType, typename Sequence, typename C, typename ReduceFunctor>
ResultType blockingFilteredReduced(const Sequence &sequence,
bool (C::*filter)() const,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<ResultType>
(sequence,
ConstMemberFunctionWrapper<bool, C>(filter),
reduce,
options);
}

template <typename Sequence, typename KeepFunctor, typename T, typename U, typename V>
U blockingFilteredReduced(const Sequence &sequence,
KeepFunctor keep,
T (reduce)(U &, V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<U>
(sequence,
keep,
FunctionWrapper2<T, U &, V>(reduce),
options);
}

template <typename Sequence, typename KeepFunctor, typename T, typename C, typename U>
C blockingFilteredReduced(const Sequence &sequence,
KeepFunctor keep,
T (C::*reduce)(U),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<C>
(sequence,
keep,
MemberFunctionWrapper1<T, C, U>(reduce),
options);
}

template <typename Sequence, typename T, typename U, typename V, typename W>
V blockingFilteredReduced(const Sequence &sequence,
bool (keep)(T),
U (reduce)(V &, W),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<V>
(sequence,
FunctionWrapper1<bool, T>(keep),
FunctionWrapper2<U, V &, W>(reduce),
options);
}

template <typename Sequence, typename C, typename T, typename U, typename V>
U blockingFilteredReduced(const Sequence &sequence,
bool (C::*keep)() const,
T (reduce)(U &, V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<U>
(sequence,
ConstMemberFunctionWrapper<bool, C>(keep),
FunctionWrapper2<T, U &, V>(reduce),
options);
}

template <typename Sequence, typename T, typename U, typename C, typename V>
C blockingFilteredReduced(const Sequence &sequence,
bool (keep)(T),
U (C::*reduce)(V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<C>
(sequence,
FunctionWrapper1<bool, T>(keep),
MemberFunctionWrapper1<U, C, V>(reduce),
options);
}

template <typename Sequence, typename C, typename T, typename D, typename U>
D blockingFilteredReduced(const Sequence &sequence,
bool (C::*keep)() const,
T (D::*reduce)(U),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<D>
(sequence,
ConstMemberFunctionWrapper<bool, C>(keep),
MemberFunctionWrapper1<T, D, U>(reduce),
options);
}


template <typename ResultType, typename Iterator, typename KeepFunctor, typename ReduceFunctor>
ResultType blockingFilteredReduced(Iterator begin,
Iterator end,
KeepFunctor keep,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startFilteredReduced<ResultType>(begin, end, keep, reduce, options)
.startBlocking();
}

template <typename ResultType, typename Iterator, typename T, typename ReduceFunctor>
ResultType blockingFilteredReduced(Iterator begin,
Iterator end,
bool (filter)(T),
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<ResultType>
(begin,
end,
FunctionWrapper1<bool, T>(filter),
reduce,
options);
}

template <typename ResultType, typename Iterator, typename C, typename ReduceFunctor>
ResultType blockingFilteredReduced(Iterator begin,
Iterator end,
bool (C::*filter)() const,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<ResultType>
(begin,
end,
ConstMemberFunctionWrapper<bool, C>(filter),
reduce,
options);
}

template <typename Iterator, typename KeepFunctor, typename T, typename U, typename V>
U blockingFilteredReduced(Iterator begin,
Iterator end,
KeepFunctor keep,
T (reduce)(U &, V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<U>
(begin,
end,
keep,
FunctionWrapper2<T, U &, V>(reduce),
options);
}

template <typename Iterator, typename KeepFunctor, typename T, typename C, typename U>
C blockingFilteredReduced(Iterator begin,
Iterator end,
KeepFunctor keep,
T (C::*reduce)(U),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<C>
(begin,
end,
keep,
MemberFunctionWrapper1<T, C, U>(reduce),
options);
}

template <typename Iterator, typename T, typename U, typename V, typename W>
V blockingFilteredReduced(Iterator begin,
Iterator end,
bool (keep)(T),
U (reduce)(V &, W),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<V>
(begin,
end,
FunctionWrapper1<bool, T>(keep),
FunctionWrapper2<U, V &, W>(reduce),
options);
}

template <typename Iterator, typename C, typename T, typename U, typename V>
U blockingFilteredReduced(Iterator begin,
Iterator end,
bool (C::*keep)() const,
T (reduce)(U &, V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<U>
(begin,
end,
ConstMemberFunctionWrapper<bool, C>(keep),
FunctionWrapper2<T, U &, V>(reduce),
options);
}

template <typename Iterator, typename T, typename U, typename C, typename V>
C blockingFilteredReduced(Iterator begin,
Iterator end,
bool (keep)(T),
U (C::*reduce)(V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<C>
(begin,
end,
FunctionWrapper1<bool, T>(keep),
MemberFunctionWrapper1<U, C, V>(reduce),
options);
}

template <typename Iterator, typename C, typename T, typename D, typename U>
D blockingFilteredReduced(Iterator begin,
Iterator end,
bool (C::*keep)() const,
T (D::*reduce)(U),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return blockingFilteredReduced<D>
(begin,
end,
ConstMemberFunctionWrapper<bool, C>(keep),
MemberFunctionWrapper1<T, D, U>(reduce),
options);
}


template <typename Sequence, typename KeepFunctor>
Sequence blockingFiltered(const Sequence &sequence, KeepFunctor keep)
{
return blockingFilteredReduced(sequence, keep, &Sequence::push_back, OrderedReduce);
}

template <typename Sequence, typename T>
Sequence blockingFiltered(const Sequence &sequence, bool (keep)(T))
{
return blockingFilteredReduced(sequence, keep, &Sequence::push_back, OrderedReduce);
}

template <typename Sequence, typename C>
Sequence blockingFiltered(const Sequence &sequence, bool (C::*filter)() const)
{
return blockingFilteredReduced(sequence,
filter,
&Sequence::push_back,
OrderedReduce);
}


template <typename OutputSequence, typename Iterator, typename KeepFunctor>
OutputSequence blockingFiltered(Iterator begin, Iterator end, KeepFunctor keep)
{
return blockingFilteredReduced(begin,
end,
keep,
&OutputSequence::push_back,
OrderedReduce);
}

template <typename OutputSequence, typename Iterator, typename T>
OutputSequence blockingFiltered(Iterator begin, Iterator end, bool (keep)(T))
{
return blockingFilteredReduced(begin,
end,
keep,
&OutputSequence::push_back,
OrderedReduce);
}

template <typename OutputSequence, typename Iterator, typename C>
OutputSequence blockingFiltered(Iterator begin, Iterator end, bool (C::*filter)() const)
{
return blockingFilteredReduced(begin,
end,
filter,
&OutputSequence::push_back,
OrderedReduce);
}

} 



# 731 "/usr/share/qt4/include/QtCore/qtconcurrentfilter.h"






# 112 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentfilterkernel.h"































































































































































































































































































































































# 113 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentfunctionwrappers.h"













































































































































































# 114 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentiteratekernel.h"
















































































































































































































































































































































# 115 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentmap.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentmap.h"




# 1 "/usr/share/qt4/include/QtCore/qtconcurrentmapkernel.h"














































































































































































































































































# 49 "/usr/share/qt4/include/QtCore/qtconcurrentmap.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"

























































































































































































































































# 50 "/usr/share/qt4/include/QtCore/qtconcurrentmap.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentfunctionwrappers.h"













































































































































































# 51 "/usr/share/qt4/include/QtCore/qtconcurrentmap.h"

# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"



































































































































































































































































# 52 "/usr/share/qt4/include/QtCore/qtconcurrentmap.h"


# 54 "/usr/share/qt4/include/QtCore/qtconcurrentmap.h"



typedef QtValidLicenseForCoreModule QtCoreModule;

















































# 107 "/usr/share/qt4/include/QtCore/qtconcurrentmap.h"
namespace QtConcurrent {


template <typename Sequence, typename MapFunctor>
QFuture<void> map(Sequence &sequence, MapFunctor map)
{
return startMap(sequence.begin(), sequence.end(), map);
}

template <typename Sequence, typename T, typename U>
QFuture<void> map(Sequence &sequence, T (map)(U))
{
return startMap(sequence.begin(), sequence.end(), FunctionWrapper1<T, U>(map));
}

template <typename Sequence, typename T, typename C>
QFuture<void> map(Sequence &sequence, T (C::*map)())
{
return startMap(sequence.begin(), sequence.end(), MemberFunctionWrapper<T, C>(map));
}


template <typename Iterator, typename MapFunctor>
QFuture<void> map(Iterator begin, Iterator end, MapFunctor map)
{
return startMap(begin, end, map);
}

template <typename Iterator, typename T, typename U>
QFuture<void> map(Iterator begin, Iterator end, T (map)(U))
{
return startMap(begin, end, FunctionWrapper1<T, U>(map));
}

template <typename Iterator, typename T, typename C>
QFuture<void> map(Iterator begin, Iterator end, T (C::*map)())
{
return startMap(begin, end, MemberFunctionWrapper<T, C>(map));
}


template <typename ResultType, typename Sequence, typename MapFunctor, typename ReduceFunctor>
QFuture<ResultType> mappedReduced(const Sequence &sequence,
MapFunctor map,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<typename MapFunctor::result_type, ResultType>
(sequence, map, reduce, options);
}

template <typename Sequence, typename MapFunctor, typename T, typename U, typename V>
QFuture<U> mappedReduced(const Sequence &sequence,
MapFunctor map,
T (reduce)(U &, V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<typename MapFunctor::result_type, U>
(sequence, map, FunctionWrapper2<T, U &, V>(reduce), options);
}

template <typename Sequence, typename MapFunctor, typename T, typename C, typename U>
QFuture<C> mappedReduced(const Sequence &sequence,
MapFunctor map,
T (C::*reduce)(U),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<typename MapFunctor::result_type, C>
(sequence, map, MemberFunctionWrapper1<T, C, U>(reduce), options);
}

template <typename ResultType, typename Sequence, typename T, typename U, typename ReduceFunctor>
QFuture<ResultType> mappedReduced(const Sequence &sequence,
T (map)(U),
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<T, ResultType>
(sequence, FunctionWrapper1<T, U>(map), reduce, options);
}

template <typename ResultType, typename Sequence, typename T, typename C, typename ReduceFunctor>
QFuture<ResultType> mappedReduced(const Sequence &sequence,
T (C::*map)() const,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<T, ResultType>
(sequence, ConstMemberFunctionWrapper<T, C>(map), reduce, options);
}

template <typename Sequence, typename T, typename U, typename V, typename W, typename X>
QFuture<W> mappedReduced(const Sequence &sequence,
T (map)(U),
V (reduce)(W &, X),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<T, W>
(sequence, FunctionWrapper1<T, U>(map), FunctionWrapper2<V, W &, X>(reduce), options);
}

template <typename Sequence, typename T, typename C, typename U, typename V, typename W>
QFuture<V> mappedReduced(const Sequence &sequence,
T (C::*map)() const,
U (reduce)(V &, W),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<T, V> (sequence, ConstMemberFunctionWrapper<T, C>(map),
FunctionWrapper2<U, V &, W>(reduce), options);
}

template <typename Sequence, typename T, typename U, typename V, typename C, typename W>
QFuture<C> mappedReduced(const Sequence &sequence,
T (map)(U),
V (C::*reduce)(W),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<T, C> (sequence, FunctionWrapper1<T, U>(map),
MemberFunctionWrapper1<V, C, W>(reduce), options);
}

template <typename Sequence, typename T, typename C, typename U,typename D, typename V>
QFuture<D> mappedReduced(const Sequence &sequence,
T (C::*map)() const,
U (D::*reduce)(V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<T, D>(sequence, ConstMemberFunctionWrapper<T, C>(map),
MemberFunctionWrapper1<U, D, V>(reduce), options);
}


template <typename ResultType, typename Iterator, typename MapFunctor, typename ReduceFunctor>
QFuture<ResultType> mappedReduced(Iterator begin,
Iterator end,
MapFunctor map,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<ResultType, typename MapFunctor::result_type>
(begin, end, map, reduce, options);
}

template <typename Iterator, typename MapFunctor, typename T, typename U, typename V>
QFuture<U> mappedReduced(Iterator begin,
Iterator end,
MapFunctor map,
T (reduce)(U &, V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<typename MapFunctor::result_type, U>
(begin, end, map, FunctionWrapper2<T, U &, V>(reduce), options);
}

template <typename Iterator, typename MapFunctor, typename T, typename C, typename U>
QFuture<C> mappedReduced(Iterator begin,
Iterator end,
MapFunctor map,
T (C::*reduce)(U),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<typename MapFunctor::result_type, C>
(begin, end, map, MemberFunctionWrapper1<T, C, U>(reduce), options);
}

template <typename ResultType, typename Iterator, typename T, typename U, typename ReduceFunctor>
QFuture<ResultType> mappedReduced(Iterator begin,
Iterator end,
T (map)(U),
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<T, ResultType>
(begin, end, FunctionWrapper1<T, U>(map), reduce, options);
}

template <typename ResultType, typename Iterator, typename T, typename C, typename ReduceFunctor>
QFuture<ResultType> mappedReduced(Iterator begin,
Iterator end,
T (C::*map)() const,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<T, ResultType>
(begin, end, ConstMemberFunctionWrapper<T, C>(map), reduce, options);
}

template <typename Iterator, typename T, typename U, typename V, typename W, typename X>
QFuture<W> mappedReduced(Iterator begin,
Iterator end,
T (map)(U),
V (reduce)(W &, X),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<T, W>
(begin, end, FunctionWrapper1<T, U>(map), FunctionWrapper2<V, W &, X>(reduce), options);
}

template <typename Iterator, typename T, typename C, typename U, typename V, typename W>
QFuture<V> mappedReduced(Iterator begin,
Iterator end,
T (C::*map)() const,
U (reduce)(V &, W),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<T, V>(begin, end, ConstMemberFunctionWrapper<T, C>(map),
FunctionWrapper2<U, V &, W>(reduce), options);
}

template <typename Iterator, typename T, typename U, typename V, typename C, typename W>
QFuture<C> mappedReduced(Iterator begin,
Iterator end,
T (map)(U),
V (C::*reduce)(W),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<T, C>
(begin, end, FunctionWrapper1<T, U>(map), MemberFunctionWrapper1<V, C, W>(reduce), options);
}

template <typename Iterator, typename T, typename C, typename U,typename D, typename V>
QFuture<D> mappedReduced(Iterator begin,
Iterator end,
T (C::*map)() const,
U (D::*reduce)(V),
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return startMappedReduced<T, D>(begin, end, ConstMemberFunctionWrapper<T, C>(map),
MemberFunctionWrapper1<U, D, V>(reduce), options);
}


template <typename Sequence, typename MapFunctor>
QFuture<typename MapFunctor::result_type> mapped(const Sequence &sequence, MapFunctor map)
{
return startMapped<typename MapFunctor::result_type>(sequence, map);
}

template <typename Sequence, typename T, typename U>
QFuture<T> mapped(const Sequence &sequence, T (map)(U))
{
return startMapped<T>(sequence, FunctionWrapper1<T, U>(map));
}

template <typename Sequence, typename T, typename C>
QFuture<T> mapped(const Sequence &sequence, T (C::*map)() const)
{
return startMapped<T>(sequence, ConstMemberFunctionWrapper<T, C>(map));
}


template <typename Iterator, typename MapFunctor>
QFuture<typename MapFunctor::result_type> mapped(Iterator begin, Iterator end, MapFunctor map)
{
return startMapped<typename MapFunctor::result_type>(begin, end, map);
}

template <typename Iterator, typename T, typename U>
QFuture<T> mapped(Iterator begin, Iterator end, T (map)(U))
{
return startMapped<T>(begin, end, FunctionWrapper1<T, U>(map));
}

template <typename Iterator, typename T, typename C>
QFuture<T> mapped(Iterator begin, Iterator end, T (C::*map)() const)
{
return startMapped<T>(begin, end, ConstMemberFunctionWrapper<T, C>(map));
}


template <typename Sequence, typename MapFunctor>
void blockingMap(Sequence &sequence, MapFunctor map)
{
startMap(sequence.begin(), sequence.end(), map).startBlocking();
}

template <typename Sequence, typename T, typename U>
void blockingMap(Sequence &sequence, T (map)(U))
{
startMap(sequence.begin(), sequence.end(), QtConcurrent::FunctionWrapper1<T, U>(map)).startBlocking();
}

template <typename Sequence, typename T, typename C>
void blockingMap(Sequence &sequence, T (C::*map)())
{
startMap(sequence.begin(), sequence.end(), QtConcurrent::MemberFunctionWrapper<T, C>(map)).startBlocking();
}

template <typename Iterator, typename MapFunctor>
void blockingMap(Iterator begin, Iterator end, MapFunctor map)
{
startMap(begin, end, map).startBlocking();
}

template <typename Iterator, typename T, typename U>
void blockingMap(Iterator begin, Iterator end, T (map)(U))
{
startMap(begin, end, QtConcurrent::FunctionWrapper1<T, U>(map)).startBlocking();
}

template <typename Iterator, typename T, typename C>
void blockingMap(Iterator begin, Iterator end, T (C::*map)())
{
startMap(begin, end, QtConcurrent::MemberFunctionWrapper<T, C>(map)).startBlocking();
}

template <typename ResultType, typename Sequence, typename MapFunctor, typename ReduceFunctor>
ResultType blockingMappedReduced(const Sequence &sequence,
MapFunctor map,
ReduceFunctor reduce,
ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
{
return QtConcurrent::startMappedReduced<typename MapFunctor::result_type, ResultType>
(sequence, map, reduce, options).startBlocking();
}

template <typename Sequence, typename MapFunctor, typename T, typename U, typename V>
U blockingMappedReduced(const Sequence &sequence,
MapFunctor map,
T (reduce)(U &, V),
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<typename MapFunctor::result_type, U>
(sequence,
map,
QtConcurrent::FunctionWrapper2<T, U &, V>(reduce),
options)
.startBlocking();
}

template <typename Sequence, typename MapFunctor, typename T, typename C, typename U>
C blockingMappedReduced(const Sequence &sequence,
MapFunctor map,
T (C::*reduce)(U),
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<typename MapFunctor::result_type, C>
(sequence,
map,
QtConcurrent::MemberFunctionWrapper1<T, C, U>(reduce),
options)
.startBlocking();
}

template <typename ResultType, typename Sequence, typename T, typename U, typename ReduceFunctor>
ResultType blockingMappedReduced(const Sequence &sequence,
T (map)(U),
ReduceFunctor reduce,
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<T, ResultType>
(sequence,
QtConcurrent::FunctionWrapper1<T, U>(map),
reduce,
options)
.startBlocking();
}

template <typename ResultType, typename Sequence, typename T, typename C, typename ReduceFunctor>
ResultType blockingMappedReduced(const Sequence &sequence,
T (C::*map)() const,
ReduceFunctor reduce,
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<T, ResultType>
(sequence,
QtConcurrent::ConstMemberFunctionWrapper<T, C>(map),
reduce,
options)
.startBlocking();
}

template <typename Sequence, typename T, typename U, typename V, typename W, typename X>
W blockingMappedReduced(const Sequence &sequence,
T (map)(U),
V (reduce)(W &, X),
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<T, W>
(sequence,
QtConcurrent::FunctionWrapper1<T, U>(map),
QtConcurrent::FunctionWrapper2<V, W &, X>(reduce),
options)
.startBlocking();
}

template <typename Sequence, typename T, typename C, typename U, typename V, typename W>
V blockingMappedReduced(const Sequence &sequence,
T (C::*map)() const,
U (reduce)(V &, W),
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<T, V>
(sequence,
QtConcurrent::ConstMemberFunctionWrapper<T, C>(map),
QtConcurrent::FunctionWrapper2<U, V &, W>(reduce),
options)
.startBlocking();
}

template <typename Sequence, typename T, typename U, typename V, typename C, typename W>
C blockingMappedReduced(const Sequence &sequence,
T (map)(U),
V (C::*reduce)(W),
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<T, C>
(sequence,
QtConcurrent::FunctionWrapper1<T, U>(map),
QtConcurrent::MemberFunctionWrapper1<V, C, W>(reduce),
options)
.startBlocking();
}

template <typename Sequence, typename T, typename C, typename U,typename D, typename V>
D blockingMappedReduced(const Sequence &sequence,
T (C::*map)() const,
U (D::*reduce)(V),
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<T, D>
(sequence,
QtConcurrent::ConstMemberFunctionWrapper<T, C>(map),
QtConcurrent::MemberFunctionWrapper1<U, D, V>(reduce),
options)
.startBlocking();
}

template <typename ResultType, typename Iterator, typename MapFunctor, typename ReduceFunctor>
ResultType blockingMappedReduced(Iterator begin,
Iterator end,
MapFunctor map,
ReduceFunctor reduce,
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<typename MapFunctor::result_type, ResultType>
(begin, end, map, reduce, options).startBlocking();
}

template <typename Iterator, typename MapFunctor, typename T, typename U, typename V>
U blockingMappedReduced(Iterator begin,
Iterator end,
MapFunctor map,
T (reduce)(U &, V),
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<typename MapFunctor::result_type, U>
(begin,
end,
map,
QtConcurrent::FunctionWrapper2<T, U &, V>(reduce),
options)
.startBlocking();
}

template <typename Iterator, typename MapFunctor, typename T, typename C, typename U>
C blockingMappedReduced(Iterator begin,
Iterator end,
MapFunctor map,
T (C::*reduce)(U),
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<typename MapFunctor::result_type, C>
(begin,
end,
map,
QtConcurrent::MemberFunctionWrapper1<T, C, U>(reduce),
options)
.startBlocking();
}

template <typename ResultType, typename Iterator, typename T, typename U, typename ReduceFunctor>
ResultType blockingMappedReduced(Iterator begin,
Iterator end,
T (map)(U),
ReduceFunctor reduce,
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<T, ResultType>
(begin,
end,
QtConcurrent::FunctionWrapper1<T, U>(map),
reduce,
options)
.startBlocking();
}

template <typename ResultType, typename Iterator, typename T, typename C, typename ReduceFunctor>
ResultType blockingMappedReduced(Iterator begin,
Iterator end,
T (C::*map)() const,
ReduceFunctor reduce,
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<T, ResultType>
(begin,
end,
QtConcurrent::ConstMemberFunctionWrapper<T, C>(map),
reduce,
options)
.startBlocking();
}

template <typename Iterator, typename T, typename U, typename V, typename W, typename X>
W blockingMappedReduced(Iterator begin,
Iterator end,
T (map)(U),
V (reduce)(W &, X),
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<T, W>
(begin,
end,
QtConcurrent::FunctionWrapper1<T, U>(map),
QtConcurrent::FunctionWrapper2<V, W &, X>(reduce),
options)
.startBlocking();
}

template <typename Iterator, typename T, typename C, typename U, typename V, typename W>
V blockingMappedReduced(Iterator begin,
Iterator end,
T (C::*map)() const,
U (reduce)(V &, W),
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<T, V>
(begin,
end,
QtConcurrent::ConstMemberFunctionWrapper<T, C>(map),
QtConcurrent::FunctionWrapper2<U, V &, W>(reduce),
options)
.startBlocking();
}

template <typename Iterator, typename T, typename U, typename V, typename C, typename W>
C blockingMappedReduced(Iterator begin,
Iterator end,
T (map)(U),
V (C::*reduce)(W),
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<T, C>
(begin,
end,
QtConcurrent::FunctionWrapper1<T, U>(map),
QtConcurrent::MemberFunctionWrapper1<V, C, W>(reduce),
options)
.startBlocking();
}

template <typename Iterator, typename T, typename C, typename U,typename D, typename V>
D blockingMappedReduced(Iterator begin,
Iterator end,
T (C::*map)() const,
U (D::*reduce)(V),
QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
{
return QtConcurrent::startMappedReduced<T, D>
(begin,
end,
QtConcurrent::ConstMemberFunctionWrapper<T, C>(map),
QtConcurrent::MemberFunctionWrapper1<U, D, V>(reduce),
options)
.startBlocking();
}


template <typename OutputSequence, typename InputSequence, typename MapFunctor>
OutputSequence blockingMapped(const InputSequence &sequence, MapFunctor map)
{
return blockingMappedReduced(sequence, map, &OutputSequence::push_back,
QtConcurrent::OrderedReduce);
}

template <typename OutputSequence, typename InputSequence, typename T, typename U>
OutputSequence blockingMapped(const InputSequence &sequence, T (map)(U))
{
return blockingMappedReduced(sequence, map, &OutputSequence::push_back,
QtConcurrent::OrderedReduce);
}

template <typename OutputSequence, typename InputSequence, typename T, typename C>
OutputSequence blockingMapped(const InputSequence &sequence, T (C::*map)() const)
{
return blockingMappedReduced(sequence, map, &OutputSequence::push_back,
QtConcurrent::OrderedReduce);
}


# 697 "/usr/share/qt4/include/QtCore/qtconcurrentmap.h"

template <template <typename> class Sequence, typename MapFunctor, typename T>
Sequence<typename MapFunctor::result_type> blockingMapped(const Sequence<T> &sequence, MapFunctor map)
{
typedef Sequence<typename MapFunctor::result_type> OutputSequence;
return blockingMappedReduced(sequence, map, &OutputSequence::push_back,
QtConcurrent::OrderedReduce);
}

template <template <typename> class Sequence, typename T, typename U, typename V>
Sequence<U> blockingMapped(const Sequence<T> &sequence, U (map)(V))
{
typedef Sequence<U> OutputSequence;
return blockingMappedReduced(sequence, map, &OutputSequence::push_back,
QtConcurrent::OrderedReduce);
}

template <template <typename> class Sequence, typename T, typename U, typename C>
Sequence<U> blockingMapped(const Sequence<T> &sequence, U (C::*map)() const)
{
typedef Sequence<U> OutputSequence;
return blockingMappedReduced(sequence, map, &OutputSequence::push_back,
QtConcurrent::OrderedReduce);
}



# 724 "/usr/share/qt4/include/QtCore/qtconcurrentmap.h"

template <typename MapFunctor>
QList<typename MapFunctor::result_type> blockingMapped(const QStringList &sequence, MapFunctor map)
{
typedef QList<typename MapFunctor::result_type> OutputSequence;
return blockingMappedReduced(sequence, map, &OutputSequence::push_back,
QtConcurrent::OrderedReduce);
}

template <typename U, typename V>
QList<U> blockingMapped(const QStringList &sequence, U (map)(V))
{
typedef QList<U> OutputSequence;
return blockingMappedReduced(sequence, map, &OutputSequence::push_back,
QtConcurrent::OrderedReduce);
}

template <typename U, typename C>
QList<U> blockingMapped(const QStringList &sequence, U (C::*map)() const)
{
typedef QList<U> OutputSequence;
return blockingMappedReduced(sequence, map, &OutputSequence::push_back,
QtConcurrent::OrderedReduce);
}


template <typename Sequence, typename Iterator, typename MapFunctor>
Sequence blockingMapped(Iterator begin, Iterator end, MapFunctor map)
{
return blockingMappedReduced(begin, end, map, &Sequence::push_back,
QtConcurrent::OrderedReduce);
}

template <typename Sequence, typename Iterator, typename T, typename U>
Sequence blockingMapped(Iterator begin, Iterator end, T (map)(U))
{
return blockingMappedReduced(begin, end, map, &Sequence::push_back,
QtConcurrent::OrderedReduce);
}

template <typename Sequence, typename Iterator, typename T, typename C>
Sequence blockingMapped(Iterator begin, Iterator end, T (C::*map)() const)
{
return blockingMappedReduced(begin, end, map, &Sequence::push_back,
QtConcurrent::OrderedReduce);
}

} 



# 775 "/usr/share/qt4/include/QtCore/qtconcurrentmap.h"






# 116 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentmapkernel.h"














































































































































































































































































# 117 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentmedian.h"


































































































































# 118 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentreducekernel.h"

























































































































































































































































# 119 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentresultstore.h"









































































































































































































































# 120 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentrun.h"













































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qtconcurrentrun.h"




# 1 "/usr/share/qt4/include/QtCore/qtconcurrentrunbase.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qtconcurrentrunbase.h"




# 1 "/usr/share/qt4/include/QtCore/qfuture.h"






















































































































































































































































































# 49 "/usr/share/qt4/include/QtCore/qtconcurrentrunbase.h"

# 1 "/usr/share/qt4/include/QtCore/qrunnable.h"









































































# 50 "/usr/share/qt4/include/QtCore/qtconcurrentrunbase.h"

# 1 "/usr/share/qt4/include/QtCore/qthreadpool.h"































































































# 51 "/usr/share/qt4/include/QtCore/qtconcurrentrunbase.h"


# 53 "/usr/share/qt4/include/QtCore/qtconcurrentrunbase.h"



typedef QtValidLicenseForCoreModule QtCoreModule;



# 60 "/usr/share/qt4/include/QtCore/qtconcurrentrunbase.h"
namespace QtConcurrent {

template <typename T>
struct SelectSpecialization
{
template <class Normal, class Void>
struct Type { typedef Normal type; };
};

template <>
struct SelectSpecialization<void>
{
template <class Normal, class Void>
struct Type { typedef Void type; };
};

template <typename T>
class RunFunctionTaskBase : public QFutureInterface<T> , public QRunnable
{
public:
QFuture<T> start()
{
this->setRunnable(this);
this->reportStarted();
QFuture<T> future = this->future();
QThreadPool::globalInstance()->start(this,  0);
return future;
}

void run() {}
virtual void runFunctor() = 0;
};

template <typename T>
class RunFunctionTask : public RunFunctionTaskBase<T>
{
public:
void run()
{
if (this->isCanceled()) {
this->reportFinished();
return;
}
this->runFunctor();
this->reportResult(result);
this->reportFinished();
}
T result;
};

template <>
class RunFunctionTask<void> : public RunFunctionTaskBase<void>
{
public:
void run()
{
if (this->isCanceled()) {
this->reportFinished();
return;
}
this->runFunctor();
this->reportFinished();
}
};

} 



# 129 "/usr/share/qt4/include/QtCore/qtconcurrentrunbase.h"






# 50 "/usr/share/qt4/include/QtCore/qtconcurrentrun.h"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentstoredfunctioncall.h"













































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtCore/qtconcurrentstoredfunctioncall.h"



# 1 "/usr/share/qt4/include/QtCore/qtconcurrentrunbase.h"






































































































































# 49 "/usr/share/qt4/include/QtCore/qtconcurrentstoredfunctioncall.h"


# 51 "/usr/share/qt4/include/QtCore/qtconcurrentstoredfunctioncall.h"



typedef QtValidLicenseForCoreModule QtCoreModule;



# 58 "/usr/share/qt4/include/QtCore/qtconcurrentstoredfunctioncall.h"
namespace QtConcurrent {
template <typename T, typename FunctionPointer>
struct StoredFunctorCall0: public RunFunctionTask<T>
{
inline StoredFunctorCall0(FunctionPointer _function)
: function(_function) {}
void runFunctor() { this->result = function(); }
FunctionPointer function;

};

template <typename T, typename FunctionPointer>
struct VoidStoredFunctorCall0: public RunFunctionTask<T>
{
inline VoidStoredFunctorCall0(FunctionPointer _function)
: function(_function) {}
void runFunctor() { function(); }
FunctionPointer function;

};

template <typename T, typename FunctionPointer>
struct SelectStoredFunctorCall0
{
typedef typename SelectSpecialization<T>::template
Type<StoredFunctorCall0 <T, FunctionPointer>,
VoidStoredFunctorCall0<T, FunctionPointer> >::type type;
};
template <typename T, typename FunctionPointer>
struct StoredFunctorPointerCall0: public RunFunctionTask<T>
{
inline StoredFunctorPointerCall0(FunctionPointer * _function)
: function(_function) {}
void runFunctor() { this->result =(*function)(); }
FunctionPointer * function;

};

template <typename T, typename FunctionPointer>
struct VoidStoredFunctorPointerCall0: public RunFunctionTask<T>
{
inline VoidStoredFunctorPointerCall0(FunctionPointer * _function)
: function(_function) {}
void runFunctor() {(*function)(); }
FunctionPointer * function;

};

template <typename T, typename FunctionPointer>
struct SelectStoredFunctorPointerCall0
{
typedef typename SelectSpecialization<T>::template
Type<StoredFunctorPointerCall0 <T, FunctionPointer>,
VoidStoredFunctorPointerCall0<T, FunctionPointer> >::type type;
};
template <typename T, typename Class>
class StoredMemberFunctionCall0 : public RunFunctionTask<T>
{
public:
StoredMemberFunctionCall0(T (Class::*_fn)() , const Class &_object)
: fn(_fn), object(_object){ }

void runFunctor()
{
this->result = (object.*fn)();
}
private:
T (Class::*fn)();
Class object;

};
template <typename T, typename Class>
class VoidStoredMemberFunctionCall0 : public RunFunctionTask<T>
{
public:
VoidStoredMemberFunctionCall0(T (Class::*_fn)() , const Class &_object)
: fn(_fn), object(_object){ }

void runFunctor()
{
(object.*fn)();
}
private:
T (Class::*fn)();
Class object;

};
template <typename T, typename Class>
struct SelectStoredMemberFunctionCall0
{
typedef typename SelectSpecialization<T>::template
Type<StoredMemberFunctionCall0 <T, Class>,
VoidStoredMemberFunctionCall0<T, Class> >::type type;
};
template <typename T, typename Class>
class StoredConstMemberFunctionCall0 : public RunFunctionTask<T>
{
public:
StoredConstMemberFunctionCall0(T (Class::*_fn)() const, const Class &_object)
: fn(_fn), object(_object){ }

void runFunctor()
{
this->result = (object.*fn)();
}
private:
T (Class::*fn)()const;
const Class object;

};
template <typename T, typename Class>
class VoidStoredConstMemberFunctionCall0 : public RunFunctionTask<T>
{
public:
VoidStoredConstMemberFunctionCall0(T (Class::*_fn)() const, const Class &_object)
: fn(_fn), object(_object){ }

void runFunctor()
{
(object.*fn)();
}
private:
T (Class::*fn)()const;
const Class object;

};
template <typename T, typename Class>
struct SelectStoredConstMemberFunctionCall0
{
typedef typename SelectSpecialization<T>::template
Type<StoredConstMemberFunctionCall0 <T, Class>,
VoidStoredConstMemberFunctionCall0<T, Class> >::type type;
};
template <typename T, typename Class>
class StoredMemberFunctionPointerCall0 : public RunFunctionTask<T>
{
public:
StoredMemberFunctionPointerCall0(T (Class::*_fn)() , Class *_object)
: fn(_fn), object(_object){ }

void runFunctor()
{
this->result = (object->*fn)();
}
private:
T (Class::*fn)();
Class *object;

};
template <typename T, typename Class>
class VoidStoredMemberFunctionPointerCall0 : public RunFunctionTask<T>
{
public:
VoidStoredMemberFunctionPointerCall0(T (Class::*_fn)() , Class *_object)
: fn(_fn), object(_object){ }

void runFunctor()
{
(object->*fn)();
}
private:
T (Class::*fn)();
Class *object;

};
template <typename T, typename Class>
struct SelectStoredMemberFunctionPointerCall0
{
typedef typename SelectSpecialization<T>::template
Type<StoredMemberFunctionPointerCall0 <T, Class>,
VoidStoredMemberFunctionPointerCall0<T, Class> >::type type;
};
template <typename T, typename Class>
class StoredConstMemberFunctionPointerCall0 : public RunFunctionTask<T>
{
public:
StoredConstMemberFunctionPointerCall0(T (Class::*_fn)() const, Class const *_object)
: fn(_fn), object(_object){ }

void runFunctor()
{
this->result = (object->*fn)();
}
private:
T (Class::*fn)()const;
Class const *object;

};
template <typename T, typename Class>
class VoidStoredConstMemberFunctionPointerCall0 : public RunFunctionTask<T>
{
public:
VoidStoredConstMemberFunctionPointerCall0(T (Class::*_fn)() const, Class const *_object)
: fn(_fn), object(_object){ }

void runFunctor()
{
(object->*fn)();
}
private:
T (Class::*fn)()const;
Class const *object;

};
template <typename T, typename Class>
struct SelectStoredConstMemberFunctionPointerCall0
{
typedef typename SelectSpecialization<T>::template
Type<StoredConstMemberFunctionPointerCall0 <T, Class>,
VoidStoredConstMemberFunctionPointerCall0<T, Class> >::type type;
};
template <typename T, typename FunctionPointer, typename Arg1>
struct StoredFunctorCall1: public RunFunctionTask<T>
{
inline StoredFunctorCall1(FunctionPointer _function, const Arg1 &_arg1)
: function(_function), arg1(_arg1) {}
void runFunctor() { this->result = function(arg1); }
FunctionPointer function;
Arg1 arg1;
};

template <typename T, typename FunctionPointer, typename Arg1>
struct VoidStoredFunctorCall1: public RunFunctionTask<T>
{
inline VoidStoredFunctorCall1(FunctionPointer _function, const Arg1 &_arg1)
: function(_function), arg1(_arg1) {}
void runFunctor() { function(arg1); }
FunctionPointer function;
Arg1 arg1;
};

template <typename T, typename FunctionPointer, typename Arg1>
struct SelectStoredFunctorCall1
{
typedef typename SelectSpecialization<T>::template
Type<StoredFunctorCall1 <T, FunctionPointer, Arg1>,
VoidStoredFunctorCall1<T, FunctionPointer, Arg1> >::type type;
};
template <typename T, typename FunctionPointer, typename Arg1>
struct StoredFunctorPointerCall1: public RunFunctionTask<T>
{
inline StoredFunctorPointerCall1(FunctionPointer * _function, const Arg1 &_arg1)
: function(_function), arg1(_arg1) {}
void runFunctor() { this->result =(*function)(arg1); }
FunctionPointer * function;
Arg1 arg1;
};

template <typename T, typename FunctionPointer, typename Arg1>
struct VoidStoredFunctorPointerCall1: public RunFunctionTask<T>
{
inline VoidStoredFunctorPointerCall1(FunctionPointer * _function, const Arg1 &_arg1)
: function(_function), arg1(_arg1) {}
void runFunctor() {(*function)(arg1); }
FunctionPointer * function;
Arg1 arg1;
};

template <typename T, typename FunctionPointer, typename Arg1>
struct SelectStoredFunctorPointerCall1
{
typedef typename SelectSpecialization<T>::template
Type<StoredFunctorPointerCall1 <T, FunctionPointer, Arg1>,
VoidStoredFunctorPointerCall1<T, FunctionPointer, Arg1> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1>
class StoredMemberFunctionCall1 : public RunFunctionTask<T>
{
public:
StoredMemberFunctionCall1(T (Class::*_fn)(Param1) , const Class &_object, const Arg1 &_arg1)
: fn(_fn), object(_object), arg1(_arg1){ }

void runFunctor()
{
this->result = (object.*fn)(arg1);
}
private:
T (Class::*fn)(Param1);
Class object;
Arg1 arg1;
};
template <typename T, typename Class, typename Param1, typename Arg1>
class VoidStoredMemberFunctionCall1 : public RunFunctionTask<T>
{
public:
VoidStoredMemberFunctionCall1(T (Class::*_fn)(Param1) , const Class &_object, const Arg1 &_arg1)
: fn(_fn), object(_object), arg1(_arg1){ }

void runFunctor()
{
(object.*fn)(arg1);
}
private:
T (Class::*fn)(Param1);
Class object;
Arg1 arg1;
};
template <typename T, typename Class, typename Param1, typename Arg1>
struct SelectStoredMemberFunctionCall1
{
typedef typename SelectSpecialization<T>::template
Type<StoredMemberFunctionCall1 <T, Class, Param1, Arg1>,
VoidStoredMemberFunctionCall1<T, Class, Param1, Arg1> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1>
class StoredConstMemberFunctionCall1 : public RunFunctionTask<T>
{
public:
StoredConstMemberFunctionCall1(T (Class::*_fn)(Param1) const, const Class &_object, const Arg1 &_arg1)
: fn(_fn), object(_object), arg1(_arg1){ }

void runFunctor()
{
this->result = (object.*fn)(arg1);
}
private:
T (Class::*fn)(Param1)const;
const Class object;
Arg1 arg1;
};
template <typename T, typename Class, typename Param1, typename Arg1>
class VoidStoredConstMemberFunctionCall1 : public RunFunctionTask<T>
{
public:
VoidStoredConstMemberFunctionCall1(T (Class::*_fn)(Param1) const, const Class &_object, const Arg1 &_arg1)
: fn(_fn), object(_object), arg1(_arg1){ }

void runFunctor()
{
(object.*fn)(arg1);
}
private:
T (Class::*fn)(Param1)const;
const Class object;
Arg1 arg1;
};
template <typename T, typename Class, typename Param1, typename Arg1>
struct SelectStoredConstMemberFunctionCall1
{
typedef typename SelectSpecialization<T>::template
Type<StoredConstMemberFunctionCall1 <T, Class, Param1, Arg1>,
VoidStoredConstMemberFunctionCall1<T, Class, Param1, Arg1> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1>
class StoredMemberFunctionPointerCall1 : public RunFunctionTask<T>
{
public:
StoredMemberFunctionPointerCall1(T (Class::*_fn)(Param1) , Class *_object, const Arg1 &_arg1)
: fn(_fn), object(_object), arg1(_arg1){ }

void runFunctor()
{
this->result = (object->*fn)(arg1);
}
private:
T (Class::*fn)(Param1);
Class *object;
Arg1 arg1;
};
template <typename T, typename Class, typename Param1, typename Arg1>
class VoidStoredMemberFunctionPointerCall1 : public RunFunctionTask<T>
{
public:
VoidStoredMemberFunctionPointerCall1(T (Class::*_fn)(Param1) , Class *_object, const Arg1 &_arg1)
: fn(_fn), object(_object), arg1(_arg1){ }

void runFunctor()
{
(object->*fn)(arg1);
}
private:
T (Class::*fn)(Param1);
Class *object;
Arg1 arg1;
};
template <typename T, typename Class, typename Param1, typename Arg1>
struct SelectStoredMemberFunctionPointerCall1
{
typedef typename SelectSpecialization<T>::template
Type<StoredMemberFunctionPointerCall1 <T, Class, Param1, Arg1>,
VoidStoredMemberFunctionPointerCall1<T, Class, Param1, Arg1> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1>
class StoredConstMemberFunctionPointerCall1 : public RunFunctionTask<T>
{
public:
StoredConstMemberFunctionPointerCall1(T (Class::*_fn)(Param1) const, Class const *_object, const Arg1 &_arg1)
: fn(_fn), object(_object), arg1(_arg1){ }

void runFunctor()
{
this->result = (object->*fn)(arg1);
}
private:
T (Class::*fn)(Param1)const;
Class const *object;
Arg1 arg1;
};
template <typename T, typename Class, typename Param1, typename Arg1>
class VoidStoredConstMemberFunctionPointerCall1 : public RunFunctionTask<T>
{
public:
VoidStoredConstMemberFunctionPointerCall1(T (Class::*_fn)(Param1) const, Class const *_object, const Arg1 &_arg1)
: fn(_fn), object(_object), arg1(_arg1){ }

void runFunctor()
{
(object->*fn)(arg1);
}
private:
T (Class::*fn)(Param1)const;
Class const *object;
Arg1 arg1;
};
template <typename T, typename Class, typename Param1, typename Arg1>
struct SelectStoredConstMemberFunctionPointerCall1
{
typedef typename SelectSpecialization<T>::template
Type<StoredConstMemberFunctionPointerCall1 <T, Class, Param1, Arg1>,
VoidStoredConstMemberFunctionPointerCall1<T, Class, Param1, Arg1> >::type type;
};
template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
struct StoredFunctorCall2: public RunFunctionTask<T>
{
inline StoredFunctorCall2(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2)
: function(_function), arg1(_arg1), arg2(_arg2) {}
void runFunctor() { this->result = function(arg1, arg2); }
FunctionPointer function;
Arg1 arg1; Arg2 arg2;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
struct VoidStoredFunctorCall2: public RunFunctionTask<T>
{
inline VoidStoredFunctorCall2(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2)
: function(_function), arg1(_arg1), arg2(_arg2) {}
void runFunctor() { function(arg1, arg2); }
FunctionPointer function;
Arg1 arg1; Arg2 arg2;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
struct SelectStoredFunctorCall2
{
typedef typename SelectSpecialization<T>::template
Type<StoredFunctorCall2 <T, FunctionPointer, Arg1, Arg2>,
VoidStoredFunctorCall2<T, FunctionPointer, Arg1, Arg2> >::type type;
};
template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
struct StoredFunctorPointerCall2: public RunFunctionTask<T>
{
inline StoredFunctorPointerCall2(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2)
: function(_function), arg1(_arg1), arg2(_arg2) {}
void runFunctor() { this->result =(*function)(arg1, arg2); }
FunctionPointer * function;
Arg1 arg1; Arg2 arg2;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
struct VoidStoredFunctorPointerCall2: public RunFunctionTask<T>
{
inline VoidStoredFunctorPointerCall2(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2)
: function(_function), arg1(_arg1), arg2(_arg2) {}
void runFunctor() {(*function)(arg1, arg2); }
FunctionPointer * function;
Arg1 arg1; Arg2 arg2;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
struct SelectStoredFunctorPointerCall2
{
typedef typename SelectSpecialization<T>::template
Type<StoredFunctorPointerCall2 <T, FunctionPointer, Arg1, Arg2>,
VoidStoredFunctorPointerCall2<T, FunctionPointer, Arg1, Arg2> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
class StoredMemberFunctionCall2 : public RunFunctionTask<T>
{
public:
StoredMemberFunctionCall2(T (Class::*_fn)(Param1, Param2) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }

void runFunctor()
{
this->result = (object.*fn)(arg1, arg2);
}
private:
T (Class::*fn)(Param1, Param2);
Class object;
Arg1 arg1; Arg2 arg2;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
class VoidStoredMemberFunctionCall2 : public RunFunctionTask<T>
{
public:
VoidStoredMemberFunctionCall2(T (Class::*_fn)(Param1, Param2) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }

void runFunctor()
{
(object.*fn)(arg1, arg2);
}
private:
T (Class::*fn)(Param1, Param2);
Class object;
Arg1 arg1; Arg2 arg2;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
struct SelectStoredMemberFunctionCall2
{
typedef typename SelectSpecialization<T>::template
Type<StoredMemberFunctionCall2 <T, Class, Param1, Arg1, Param2, Arg2>,
VoidStoredMemberFunctionCall2<T, Class, Param1, Arg1, Param2, Arg2> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
class StoredConstMemberFunctionCall2 : public RunFunctionTask<T>
{
public:
StoredConstMemberFunctionCall2(T (Class::*_fn)(Param1, Param2) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }

void runFunctor()
{
this->result = (object.*fn)(arg1, arg2);
}
private:
T (Class::*fn)(Param1, Param2)const;
const Class object;
Arg1 arg1; Arg2 arg2;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
class VoidStoredConstMemberFunctionCall2 : public RunFunctionTask<T>
{
public:
VoidStoredConstMemberFunctionCall2(T (Class::*_fn)(Param1, Param2) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }

void runFunctor()
{
(object.*fn)(arg1, arg2);
}
private:
T (Class::*fn)(Param1, Param2)const;
const Class object;
Arg1 arg1; Arg2 arg2;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
struct SelectStoredConstMemberFunctionCall2
{
typedef typename SelectSpecialization<T>::template
Type<StoredConstMemberFunctionCall2 <T, Class, Param1, Arg1, Param2, Arg2>,
VoidStoredConstMemberFunctionCall2<T, Class, Param1, Arg1, Param2, Arg2> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
class StoredMemberFunctionPointerCall2 : public RunFunctionTask<T>
{
public:
StoredMemberFunctionPointerCall2(T (Class::*_fn)(Param1, Param2) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }

void runFunctor()
{
this->result = (object->*fn)(arg1, arg2);
}
private:
T (Class::*fn)(Param1, Param2);
Class *object;
Arg1 arg1; Arg2 arg2;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
class VoidStoredMemberFunctionPointerCall2 : public RunFunctionTask<T>
{
public:
VoidStoredMemberFunctionPointerCall2(T (Class::*_fn)(Param1, Param2) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }

void runFunctor()
{
(object->*fn)(arg1, arg2);
}
private:
T (Class::*fn)(Param1, Param2);
Class *object;
Arg1 arg1; Arg2 arg2;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
struct SelectStoredMemberFunctionPointerCall2
{
typedef typename SelectSpecialization<T>::template
Type<StoredMemberFunctionPointerCall2 <T, Class, Param1, Arg1, Param2, Arg2>,
VoidStoredMemberFunctionPointerCall2<T, Class, Param1, Arg1, Param2, Arg2> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
class StoredConstMemberFunctionPointerCall2 : public RunFunctionTask<T>
{
public:
StoredConstMemberFunctionPointerCall2(T (Class::*_fn)(Param1, Param2) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }

void runFunctor()
{
this->result = (object->*fn)(arg1, arg2);
}
private:
T (Class::*fn)(Param1, Param2)const;
Class const *object;
Arg1 arg1; Arg2 arg2;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
class VoidStoredConstMemberFunctionPointerCall2 : public RunFunctionTask<T>
{
public:
VoidStoredConstMemberFunctionPointerCall2(T (Class::*_fn)(Param1, Param2) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }

void runFunctor()
{
(object->*fn)(arg1, arg2);
}
private:
T (Class::*fn)(Param1, Param2)const;
Class const *object;
Arg1 arg1; Arg2 arg2;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
struct SelectStoredConstMemberFunctionPointerCall2
{
typedef typename SelectSpecialization<T>::template
Type<StoredConstMemberFunctionPointerCall2 <T, Class, Param1, Arg1, Param2, Arg2>,
VoidStoredConstMemberFunctionPointerCall2<T, Class, Param1, Arg1, Param2, Arg2> >::type type;
};
template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
struct StoredFunctorCall3: public RunFunctionTask<T>
{
inline StoredFunctorCall3(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
: function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3) {}
void runFunctor() { this->result = function(arg1, arg2, arg3); }
FunctionPointer function;
Arg1 arg1; Arg2 arg2; Arg3 arg3;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
struct VoidStoredFunctorCall3: public RunFunctionTask<T>
{
inline VoidStoredFunctorCall3(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
: function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3) {}
void runFunctor() { function(arg1, arg2, arg3); }
FunctionPointer function;
Arg1 arg1; Arg2 arg2; Arg3 arg3;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
struct SelectStoredFunctorCall3
{
typedef typename SelectSpecialization<T>::template
Type<StoredFunctorCall3 <T, FunctionPointer, Arg1, Arg2, Arg3>,
VoidStoredFunctorCall3<T, FunctionPointer, Arg1, Arg2, Arg3> >::type type;
};
template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
struct StoredFunctorPointerCall3: public RunFunctionTask<T>
{
inline StoredFunctorPointerCall3(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
: function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3) {}
void runFunctor() { this->result =(*function)(arg1, arg2, arg3); }
FunctionPointer * function;
Arg1 arg1; Arg2 arg2; Arg3 arg3;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
struct VoidStoredFunctorPointerCall3: public RunFunctionTask<T>
{
inline VoidStoredFunctorPointerCall3(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
: function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3) {}
void runFunctor() {(*function)(arg1, arg2, arg3); }
FunctionPointer * function;
Arg1 arg1; Arg2 arg2; Arg3 arg3;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
struct SelectStoredFunctorPointerCall3
{
typedef typename SelectSpecialization<T>::template
Type<StoredFunctorPointerCall3 <T, FunctionPointer, Arg1, Arg2, Arg3>,
VoidStoredFunctorPointerCall3<T, FunctionPointer, Arg1, Arg2, Arg3> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
class StoredMemberFunctionCall3 : public RunFunctionTask<T>
{
public:
StoredMemberFunctionCall3(T (Class::*_fn)(Param1, Param2, Param3) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }

void runFunctor()
{
this->result = (object.*fn)(arg1, arg2, arg3);
}
private:
T (Class::*fn)(Param1, Param2, Param3);
Class object;
Arg1 arg1; Arg2 arg2; Arg3 arg3;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
class VoidStoredMemberFunctionCall3 : public RunFunctionTask<T>
{
public:
VoidStoredMemberFunctionCall3(T (Class::*_fn)(Param1, Param2, Param3) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }

void runFunctor()
{
(object.*fn)(arg1, arg2, arg3);
}
private:
T (Class::*fn)(Param1, Param2, Param3);
Class object;
Arg1 arg1; Arg2 arg2; Arg3 arg3;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
struct SelectStoredMemberFunctionCall3
{
typedef typename SelectSpecialization<T>::template
Type<StoredMemberFunctionCall3 <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>,
VoidStoredMemberFunctionCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
class StoredConstMemberFunctionCall3 : public RunFunctionTask<T>
{
public:
StoredConstMemberFunctionCall3(T (Class::*_fn)(Param1, Param2, Param3) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }

void runFunctor()
{
this->result = (object.*fn)(arg1, arg2, arg3);
}
private:
T (Class::*fn)(Param1, Param2, Param3)const;
const Class object;
Arg1 arg1; Arg2 arg2; Arg3 arg3;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
class VoidStoredConstMemberFunctionCall3 : public RunFunctionTask<T>
{
public:
VoidStoredConstMemberFunctionCall3(T (Class::*_fn)(Param1, Param2, Param3) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }

void runFunctor()
{
(object.*fn)(arg1, arg2, arg3);
}
private:
T (Class::*fn)(Param1, Param2, Param3)const;
const Class object;
Arg1 arg1; Arg2 arg2; Arg3 arg3;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
struct SelectStoredConstMemberFunctionCall3
{
typedef typename SelectSpecialization<T>::template
Type<StoredConstMemberFunctionCall3 <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>,
VoidStoredConstMemberFunctionCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
class StoredMemberFunctionPointerCall3 : public RunFunctionTask<T>
{
public:
StoredMemberFunctionPointerCall3(T (Class::*_fn)(Param1, Param2, Param3) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }

void runFunctor()
{
this->result = (object->*fn)(arg1, arg2, arg3);
}
private:
T (Class::*fn)(Param1, Param2, Param3);
Class *object;
Arg1 arg1; Arg2 arg2; Arg3 arg3;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
class VoidStoredMemberFunctionPointerCall3 : public RunFunctionTask<T>
{
public:
VoidStoredMemberFunctionPointerCall3(T (Class::*_fn)(Param1, Param2, Param3) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }

void runFunctor()
{
(object->*fn)(arg1, arg2, arg3);
}
private:
T (Class::*fn)(Param1, Param2, Param3);
Class *object;
Arg1 arg1; Arg2 arg2; Arg3 arg3;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
struct SelectStoredMemberFunctionPointerCall3
{
typedef typename SelectSpecialization<T>::template
Type<StoredMemberFunctionPointerCall3 <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>,
VoidStoredMemberFunctionPointerCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
class StoredConstMemberFunctionPointerCall3 : public RunFunctionTask<T>
{
public:
StoredConstMemberFunctionPointerCall3(T (Class::*_fn)(Param1, Param2, Param3) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }

void runFunctor()
{
this->result = (object->*fn)(arg1, arg2, arg3);
}
private:
T (Class::*fn)(Param1, Param2, Param3)const;
Class const *object;
Arg1 arg1; Arg2 arg2; Arg3 arg3;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
class VoidStoredConstMemberFunctionPointerCall3 : public RunFunctionTask<T>
{
public:
VoidStoredConstMemberFunctionPointerCall3(T (Class::*_fn)(Param1, Param2, Param3) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }

void runFunctor()
{
(object->*fn)(arg1, arg2, arg3);
}
private:
T (Class::*fn)(Param1, Param2, Param3)const;
Class const *object;
Arg1 arg1; Arg2 arg2; Arg3 arg3;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
struct SelectStoredConstMemberFunctionPointerCall3
{
typedef typename SelectSpecialization<T>::template
Type<StoredConstMemberFunctionPointerCall3 <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>,
VoidStoredConstMemberFunctionPointerCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3> >::type type;
};
template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
struct StoredFunctorCall4: public RunFunctionTask<T>
{
inline StoredFunctorCall4(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
: function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4) {}
void runFunctor() { this->result = function(arg1, arg2, arg3, arg4); }
FunctionPointer function;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
struct VoidStoredFunctorCall4: public RunFunctionTask<T>
{
inline VoidStoredFunctorCall4(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
: function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4) {}
void runFunctor() { function(arg1, arg2, arg3, arg4); }
FunctionPointer function;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
struct SelectStoredFunctorCall4
{
typedef typename SelectSpecialization<T>::template
Type<StoredFunctorCall4 <T, FunctionPointer, Arg1, Arg2, Arg3, Arg4>,
VoidStoredFunctorCall4<T, FunctionPointer, Arg1, Arg2, Arg3, Arg4> >::type type;
};
template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
struct StoredFunctorPointerCall4: public RunFunctionTask<T>
{
inline StoredFunctorPointerCall4(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
: function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4) {}
void runFunctor() { this->result =(*function)(arg1, arg2, arg3, arg4); }
FunctionPointer * function;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
struct VoidStoredFunctorPointerCall4: public RunFunctionTask<T>
{
inline VoidStoredFunctorPointerCall4(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
: function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4) {}
void runFunctor() {(*function)(arg1, arg2, arg3, arg4); }
FunctionPointer * function;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
struct SelectStoredFunctorPointerCall4
{
typedef typename SelectSpecialization<T>::template
Type<StoredFunctorPointerCall4 <T, FunctionPointer, Arg1, Arg2, Arg3, Arg4>,
VoidStoredFunctorPointerCall4<T, FunctionPointer, Arg1, Arg2, Arg3, Arg4> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
class StoredMemberFunctionCall4 : public RunFunctionTask<T>
{
public:
StoredMemberFunctionCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }

void runFunctor()
{
this->result = (object.*fn)(arg1, arg2, arg3, arg4);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4);
Class object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
class VoidStoredMemberFunctionCall4 : public RunFunctionTask<T>
{
public:
VoidStoredMemberFunctionCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }

void runFunctor()
{
(object.*fn)(arg1, arg2, arg3, arg4);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4);
Class object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
struct SelectStoredMemberFunctionCall4
{
typedef typename SelectSpecialization<T>::template
Type<StoredMemberFunctionCall4 <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>,
VoidStoredMemberFunctionCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
class StoredConstMemberFunctionCall4 : public RunFunctionTask<T>
{
public:
StoredConstMemberFunctionCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }

void runFunctor()
{
this->result = (object.*fn)(arg1, arg2, arg3, arg4);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4)const;
const Class object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
class VoidStoredConstMemberFunctionCall4 : public RunFunctionTask<T>
{
public:
VoidStoredConstMemberFunctionCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }

void runFunctor()
{
(object.*fn)(arg1, arg2, arg3, arg4);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4)const;
const Class object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
struct SelectStoredConstMemberFunctionCall4
{
typedef typename SelectSpecialization<T>::template
Type<StoredConstMemberFunctionCall4 <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>,
VoidStoredConstMemberFunctionCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
class StoredMemberFunctionPointerCall4 : public RunFunctionTask<T>
{
public:
StoredMemberFunctionPointerCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }

void runFunctor()
{
this->result = (object->*fn)(arg1, arg2, arg3, arg4);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4);
Class *object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
class VoidStoredMemberFunctionPointerCall4 : public RunFunctionTask<T>
{
public:
VoidStoredMemberFunctionPointerCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }

void runFunctor()
{
(object->*fn)(arg1, arg2, arg3, arg4);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4);
Class *object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
struct SelectStoredMemberFunctionPointerCall4
{
typedef typename SelectSpecialization<T>::template
Type<StoredMemberFunctionPointerCall4 <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>,
VoidStoredMemberFunctionPointerCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
class StoredConstMemberFunctionPointerCall4 : public RunFunctionTask<T>
{
public:
StoredConstMemberFunctionPointerCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }

void runFunctor()
{
this->result = (object->*fn)(arg1, arg2, arg3, arg4);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4)const;
Class const *object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
class VoidStoredConstMemberFunctionPointerCall4 : public RunFunctionTask<T>
{
public:
VoidStoredConstMemberFunctionPointerCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }

void runFunctor()
{
(object->*fn)(arg1, arg2, arg3, arg4);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4)const;
Class const *object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
struct SelectStoredConstMemberFunctionPointerCall4
{
typedef typename SelectSpecialization<T>::template
Type<StoredConstMemberFunctionPointerCall4 <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>,
VoidStoredConstMemberFunctionPointerCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4> >::type type;
};
template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
struct StoredFunctorCall5: public RunFunctionTask<T>
{
inline StoredFunctorCall5(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
: function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5) {}
void runFunctor() { this->result = function(arg1, arg2, arg3, arg4, arg5); }
FunctionPointer function;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
struct VoidStoredFunctorCall5: public RunFunctionTask<T>
{
inline VoidStoredFunctorCall5(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
: function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5) {}
void runFunctor() { function(arg1, arg2, arg3, arg4, arg5); }
FunctionPointer function;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
struct SelectStoredFunctorCall5
{
typedef typename SelectSpecialization<T>::template
Type<StoredFunctorCall5 <T, FunctionPointer, Arg1, Arg2, Arg3, Arg4, Arg5>,
VoidStoredFunctorCall5<T, FunctionPointer, Arg1, Arg2, Arg3, Arg4, Arg5> >::type type;
};
template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
struct StoredFunctorPointerCall5: public RunFunctionTask<T>
{
inline StoredFunctorPointerCall5(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
: function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5) {}
void runFunctor() { this->result =(*function)(arg1, arg2, arg3, arg4, arg5); }
FunctionPointer * function;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
struct VoidStoredFunctorPointerCall5: public RunFunctionTask<T>
{
inline VoidStoredFunctorPointerCall5(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
: function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5) {}
void runFunctor() {(*function)(arg1, arg2, arg3, arg4, arg5); }
FunctionPointer * function;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
};

template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
struct SelectStoredFunctorPointerCall5
{
typedef typename SelectSpecialization<T>::template
Type<StoredFunctorPointerCall5 <T, FunctionPointer, Arg1, Arg2, Arg3, Arg4, Arg5>,
VoidStoredFunctorPointerCall5<T, FunctionPointer, Arg1, Arg2, Arg3, Arg4, Arg5> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
class StoredMemberFunctionCall5 : public RunFunctionTask<T>
{
public:
StoredMemberFunctionCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }

void runFunctor()
{
this->result = (object.*fn)(arg1, arg2, arg3, arg4, arg5);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
Class object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
class VoidStoredMemberFunctionCall5 : public RunFunctionTask<T>
{
public:
VoidStoredMemberFunctionCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }

void runFunctor()
{
(object.*fn)(arg1, arg2, arg3, arg4, arg5);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
Class object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
struct SelectStoredMemberFunctionCall5
{
typedef typename SelectSpecialization<T>::template
Type<StoredMemberFunctionCall5 <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>,
VoidStoredMemberFunctionCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
class StoredConstMemberFunctionCall5 : public RunFunctionTask<T>
{
public:
StoredConstMemberFunctionCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }

void runFunctor()
{
this->result = (object.*fn)(arg1, arg2, arg3, arg4, arg5);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4, Param5)const;
const Class object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
class VoidStoredConstMemberFunctionCall5 : public RunFunctionTask<T>
{
public:
VoidStoredConstMemberFunctionCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }

void runFunctor()
{
(object.*fn)(arg1, arg2, arg3, arg4, arg5);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4, Param5)const;
const Class object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
struct SelectStoredConstMemberFunctionCall5
{
typedef typename SelectSpecialization<T>::template
Type<StoredConstMemberFunctionCall5 <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>,
VoidStoredConstMemberFunctionCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
class StoredMemberFunctionPointerCall5 : public RunFunctionTask<T>
{
public:
StoredMemberFunctionPointerCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }

void runFunctor()
{
this->result = (object->*fn)(arg1, arg2, arg3, arg4, arg5);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
Class *object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
class VoidStoredMemberFunctionPointerCall5 : public RunFunctionTask<T>
{
public:
VoidStoredMemberFunctionPointerCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }

void runFunctor()
{
(object->*fn)(arg1, arg2, arg3, arg4, arg5);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
Class *object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
struct SelectStoredMemberFunctionPointerCall5
{
typedef typename SelectSpecialization<T>::template
Type<StoredMemberFunctionPointerCall5 <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>,
VoidStoredMemberFunctionPointerCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5> >::type type;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
class StoredConstMemberFunctionPointerCall5 : public RunFunctionTask<T>
{
public:
StoredConstMemberFunctionPointerCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }

void runFunctor()
{
this->result = (object->*fn)(arg1, arg2, arg3, arg4, arg5);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4, Param5)const;
Class const *object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
class VoidStoredConstMemberFunctionPointerCall5 : public RunFunctionTask<T>
{
public:
VoidStoredConstMemberFunctionPointerCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
: fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }

void runFunctor()
{
(object->*fn)(arg1, arg2, arg3, arg4, arg5);
}
private:
T (Class::*fn)(Param1, Param2, Param3, Param4, Param5)const;
Class const *object;
Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
};
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
struct SelectStoredConstMemberFunctionPointerCall5
{
typedef typename SelectSpecialization<T>::template
Type<StoredConstMemberFunctionPointerCall5 <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>,
VoidStoredConstMemberFunctionPointerCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5> >::type type;
};
} 



# 1323 "/usr/share/qt4/include/QtCore/qtconcurrentstoredfunctioncall.h"






# 51 "/usr/share/qt4/include/QtCore/qtconcurrentrun.h"


# 53 "/usr/share/qt4/include/QtCore/qtconcurrentrun.h"



typedef QtValidLicenseForCoreModule QtCoreModule;












# 69 "/usr/share/qt4/include/QtCore/qtconcurrentrun.h"
namespace QtConcurrent {

template <typename T>
QFuture<T> run(T (*functionPointer)())
{
return (new typename SelectStoredFunctorCall0<T, T (*)()>::type(functionPointer))->start();
}
template <typename T, typename Param1, typename Arg1>
QFuture<T> run(T (*functionPointer)(Param1), const Arg1 &arg1)
{
return (new typename SelectStoredFunctorCall1<T, T (*)(Param1), Arg1>::type(functionPointer, arg1))->start();
}
template <typename T, typename Param1, typename Arg1, typename Param2, typename Arg2>
QFuture<T> run(T (*functionPointer)(Param1, Param2), const Arg1 &arg1, const Arg2 &arg2)
{
return (new typename SelectStoredFunctorCall2<T, T (*)(Param1, Param2), Arg1, Arg2>::type(functionPointer, arg1, arg2))->start();
}
template <typename T, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
QFuture<T> run(T (*functionPointer)(Param1, Param2, Param3), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
{
return (new typename SelectStoredFunctorCall3<T, T (*)(Param1, Param2, Param3), Arg1, Arg2, Arg3>::type(functionPointer, arg1, arg2, arg3))->start();
}
template <typename T, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
QFuture<T> run(T (*functionPointer)(Param1, Param2, Param3, Param4), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
{
return (new typename SelectStoredFunctorCall4<T, T (*)(Param1, Param2, Param3, Param4), Arg1, Arg2, Arg3, Arg4>::type(functionPointer, arg1, arg2, arg3, arg4))->start();
}
template <typename T, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
QFuture<T> run(T (*functionPointer)(Param1, Param2, Param3, Param4, Param5), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
{
return (new typename SelectStoredFunctorCall5<T, T (*)(Param1, Param2, Param3, Param4, Param5), Arg1, Arg2, Arg3, Arg4, Arg5>::type(functionPointer, arg1, arg2, arg3, arg4, arg5))->start();
}

template <typename FunctionObject>
QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject)
{
return (new typename SelectStoredFunctorCall0<typename FunctionObject::result_type, FunctionObject>::type(functionObject))->start();
}
template <typename FunctionObject, typename Arg1>
QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1)
{
return (new typename SelectStoredFunctorCall1<typename FunctionObject::result_type, FunctionObject, Arg1>::type(functionObject, arg1))->start();
}
template <typename FunctionObject, typename Arg1, typename Arg2>
QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1, const Arg2 &arg2)
{
return (new typename SelectStoredFunctorCall2<typename FunctionObject::result_type, FunctionObject, Arg1, Arg2>::type(functionObject, arg1, arg2))->start();
}
template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3>
QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
{
return (new typename SelectStoredFunctorCall3<typename FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3>::type(functionObject, arg1, arg2, arg3))->start();
}
template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
{
return (new typename SelectStoredFunctorCall4<typename FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3, Arg4>::type(functionObject, arg1, arg2, arg3, arg4))->start();
}
template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
{
return (new typename SelectStoredFunctorCall5<typename FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3, Arg4, Arg5>::type(functionObject, arg1, arg2, arg3, arg4, arg5))->start();
}

template <typename FunctionObject>
QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject)
{
return (new typename SelectStoredFunctorPointerCall0<typename FunctionObject::result_type, FunctionObject>::type(functionObject))->start();
}
template <typename FunctionObject, typename Arg1>
QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1)
{
return (new typename SelectStoredFunctorPointerCall1<typename FunctionObject::result_type, FunctionObject, Arg1>::type(functionObject, arg1))->start();
}
template <typename FunctionObject, typename Arg1, typename Arg2>
QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1, const Arg2 &arg2)
{
return (new typename SelectStoredFunctorPointerCall2<typename FunctionObject::result_type, FunctionObject, Arg1, Arg2>::type(functionObject, arg1, arg2))->start();
}
template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3>
QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
{
return (new typename SelectStoredFunctorPointerCall3<typename FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3>::type(functionObject, arg1, arg2, arg3))->start();
}
template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
{
return (new typename SelectStoredFunctorPointerCall4<typename FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3, Arg4>::type(functionObject, arg1, arg2, arg3, arg4))->start();
}
template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
{
return (new typename SelectStoredFunctorPointerCall5<typename FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3, Arg4, Arg5>::type(functionObject, arg1, arg2, arg3, arg4, arg5))->start();
}

template <typename T, typename Class>
QFuture<T> run(const Class &object, T (Class::*fn)())
{
return (new typename SelectStoredMemberFunctionCall0<T, Class>::type(fn, object))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1>
QFuture<T> run(const Class &object, T (Class::*fn)(Param1), const Arg1 &arg1)
{
return (new typename SelectStoredMemberFunctionCall1<T, Class, Param1, Arg1>::type(fn, object, arg1))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2), const Arg1 &arg1, const Arg2 &arg2)
{
return (new typename SelectStoredMemberFunctionCall2<T, Class, Param1, Arg1, Param2, Arg2>::type(fn, object, arg1, arg2))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
{
return (new typename SelectStoredMemberFunctionCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>::type(fn, object, arg1, arg2, arg3))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3, Param4), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
{
return (new typename SelectStoredMemberFunctionCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>::type(fn, object, arg1, arg2, arg3, arg4))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3, Param4, Param5), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
{
return (new typename SelectStoredMemberFunctionCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>::type(fn, object, arg1, arg2, arg3, arg4, arg5))->start();
}

template <typename T, typename Class>
QFuture<T> run(const Class &object, T (Class::*fn)() const)
{
return (new typename SelectStoredConstMemberFunctionCall0<T, Class>::type(fn, object))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1>
QFuture<T> run(const Class &object, T (Class::*fn)(Param1) const, const Arg1 &arg1)
{
return (new typename SelectStoredConstMemberFunctionCall1<T, Class, Param1, Arg1>::type(fn, object, arg1))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2) const, const Arg1 &arg1, const Arg2 &arg2)
{
return (new typename SelectStoredConstMemberFunctionCall2<T, Class, Param1, Arg1, Param2, Arg2>::type(fn, object, arg1, arg2))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
{
return (new typename SelectStoredConstMemberFunctionCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>::type(fn, object, arg1, arg2, arg3))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3, Param4) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
{
return (new typename SelectStoredConstMemberFunctionCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>::type(fn, object, arg1, arg2, arg3, arg4))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3, Param4, Param5) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
{
return (new typename SelectStoredConstMemberFunctionCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>::type(fn, object, arg1, arg2, arg3, arg4, arg5))->start();
}

template <typename T, typename Class>
QFuture<T> run(Class *object, T (Class::*fn)())
{
return (new typename SelectStoredMemberFunctionPointerCall0<T, Class>::type(fn, object))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1>
QFuture<T> run(Class *object, T (Class::*fn)(Param1), const Arg1 &arg1)
{
return (new typename SelectStoredMemberFunctionPointerCall1<T, Class, Param1, Arg1>::type(fn, object, arg1))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
QFuture<T> run(Class *object, T (Class::*fn)(Param1, Param2), const Arg1 &arg1, const Arg2 &arg2)
{
return (new typename SelectStoredMemberFunctionPointerCall2<T, Class, Param1, Arg1, Param2, Arg2>::type(fn, object, arg1, arg2))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
QFuture<T> run(Class *object, T (Class::*fn)(Param1, Param2, Param3), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
{
return (new typename SelectStoredMemberFunctionPointerCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>::type(fn, object, arg1, arg2, arg3))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
QFuture<T> run(Class *object, T (Class::*fn)(Param1, Param2, Param3, Param4), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
{
return (new typename SelectStoredMemberFunctionPointerCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>::type(fn, object, arg1, arg2, arg3, arg4))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
QFuture<T> run(Class *object, T (Class::*fn)(Param1, Param2, Param3, Param4, Param5), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
{
return (new typename SelectStoredMemberFunctionPointerCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>::type(fn, object, arg1, arg2, arg3, arg4, arg5))->start();
}

template <typename T, typename Class>
QFuture<T> run(const Class *object, T (Class::*fn)() const)
{
return (new typename SelectStoredConstMemberFunctionPointerCall0<T, Class>::type(fn, object))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1>
QFuture<T> run(const Class *object, T (Class::*fn)(Param1) const, const Arg1 &arg1)
{
return (new typename SelectStoredConstMemberFunctionPointerCall1<T, Class, Param1, Arg1>::type(fn, object, arg1))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
QFuture<T> run(const Class *object, T (Class::*fn)(Param1, Param2) const, const Arg1 &arg1, const Arg2 &arg2)
{
return (new typename SelectStoredConstMemberFunctionPointerCall2<T, Class, Param1, Arg1, Param2, Arg2>::type(fn, object, arg1, arg2))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
QFuture<T> run(const Class *object, T (Class::*fn)(Param1, Param2, Param3) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
{
return (new typename SelectStoredConstMemberFunctionPointerCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>::type(fn, object, arg1, arg2, arg3))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
QFuture<T> run(const Class *object, T (Class::*fn)(Param1, Param2, Param3, Param4) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
{
return (new typename SelectStoredConstMemberFunctionPointerCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>::type(fn, object, arg1, arg2, arg3, arg4))->start();
}
template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
QFuture<T> run(const Class *object, T (Class::*fn)(Param1, Param2, Param3, Param4, Param5) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
{
return (new typename SelectStoredConstMemberFunctionPointerCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>::type(fn, object, arg1, arg2, arg3, arg4, arg5))->start();
}

} 



# 292 "/usr/share/qt4/include/QtCore/qtconcurrentrun.h"






# 121 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentrunbase.h"






































































































































# 122 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentstoredfunctioncall.h"
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 123 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qtconcurrentthreadengine.h"





























































































































































































































































































# 124 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qthreadpool.h"































































































# 125 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qendian.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qendian.h"


# 47 "/usr/share/qt4/include/QtCore/qendian.h"




typedef QtValidLicenseForCoreModule QtCoreModule;




inline void qbswap_helper(const uchar *src, uchar *dest, int size)
{
for (int i = 0; i < size ; ++i) dest[i] = src[size - 1 - i];
}







template <typename T> inline void qbswap(const T src, uchar *dest)
{
qbswap_helper(reinterpret_cast<const uchar *>(&src), dest, sizeof(T));
}



template <typename T> inline void qToUnaligned(const T src, uchar *dest)
{
qMemCopy(dest, &src, sizeof(T));
}

















































# 127 "/usr/share/qt4/include/QtCore/qendian.h"
template <typename T> inline T qFromLittleEndian(const uchar *src);
template <> inline quint64 qFromLittleEndian<quint64>(const uchar *src)
{
return 0
| src[0]
| src[1] * static_cast<unsigned long long>(0x0000000000000100ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 

| src[2] * static_cast<unsigned long long>(0x0000000000010000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 

| src[3] * static_cast<unsigned long long>(0x0000000001000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 

| src[4] * static_cast<unsigned long long>(0x0000000100000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 

| src[5] * static_cast<unsigned long long>(0x0000010000000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 

| src[6] * static_cast<unsigned long long>(0x0001000000000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 

| src[7] * static_cast<unsigned long long>(0x0100000000000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 
;
}

template <> inline quint32 qFromLittleEndian<quint32>(const uchar *src)
{
return 0
| src[0]
| src[1] * quint32(0x00000100)
| src[2] * quint32(0x00010000)
| src[3] * quint32(0x01000000);
}

template <> inline quint16 qFromLittleEndian<quint16>(const uchar *src)
{
return quint16(0
| src[0]
| src[1] * 0x0100);
}


template <> inline qint64 qFromLittleEndian<qint64>(const uchar *src)
{ return static_cast<qint64>(qFromLittleEndian<quint64>(src)); }

template <> inline qint32 qFromLittleEndian<qint32>(const uchar *src)
{ return static_cast<qint32>(qFromLittleEndian<quint32>(src)); }

template <> inline qint16 qFromLittleEndian<qint16>(const uchar *src)
{ return static_cast<qint16>(qFromLittleEndian<quint16>(src)); }
# 166 "/usr/share/qt4/include/QtCore/qendian.h"


# 168 "/usr/share/qt4/include/QtCore/qendian.h"
















































# 216 "/usr/share/qt4/include/QtCore/qendian.h"
template <class T> inline T qFromBigEndian(const uchar *src);
template<>
inline quint64 qFromBigEndian<quint64>(const uchar *src)
{
return 0
| src[7]
| src[6] * static_cast<unsigned long long>(0x0000000000000100ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 

| src[5] * static_cast<unsigned long long>(0x0000000000010000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 

| src[4] * static_cast<unsigned long long>(0x0000000001000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 

| src[3] * static_cast<unsigned long long>(0x0000000100000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 

| src[2] * static_cast<unsigned long long>(0x0000010000000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 

| src[1] * static_cast<unsigned long long>(0x0001000000000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 

| src[0] * static_cast<unsigned long long>(0x0100000000000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 
;
}

template<>
inline quint32 qFromBigEndian<quint32>(const uchar *src)
{
return 0
| src[3]
| src[2] * quint32(0x00000100)
| src[1] * quint32(0x00010000)
| src[0] * quint32(0x01000000);
}

template<>
inline quint16 qFromBigEndian<quint16>(const uchar *src)
{
return quint16( 0
| src[1]
| src[0] * quint16(0x0100));
}



template <> inline qint64 qFromBigEndian<qint64>(const uchar *src)
{ return static_cast<qint64>(qFromBigEndian<quint64>(src)); }

template <> inline qint32 qFromBigEndian<qint32>(const uchar *src)
{ return static_cast<qint32>(qFromBigEndian<quint32>(src)); }

template <> inline qint16 qFromBigEndian<qint16>(const uchar *src)
{ return static_cast<qint16>(qFromBigEndian<quint16>(src)); }
# 259 "/usr/share/qt4/include/QtCore/qendian.h"

# 260 "/usr/share/qt4/include/QtCore/qendian.h"






template <typename T> T qbswap(T source);
template <> inline quint64 qbswap<quint64>(quint64 source)
{
return 0
| ((source & static_cast<unsigned long long>(0x00000000000000ffULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 
) << 56)
| ((source & static_cast<unsigned long long>(0x000000000000ff00ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 
) << 40)
| ((source & static_cast<unsigned long long>(0x0000000000ff0000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 
) << 24)
| ((source & static_cast<unsigned long long>(0x00000000ff000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 
) << 8)
| ((source & static_cast<unsigned long long>(0x000000ff00000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 
) >> 8)
| ((source & static_cast<unsigned long long>(0x0000ff0000000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 
) >> 24)
| ((source & static_cast<unsigned long long>(0x00ff000000000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 
) >> 40)
| ((source & static_cast<unsigned long long>(0xff00000000000000ULL) 
typedef long long qint64; 
typedef unsigned long long quint64; 
) >> 56);
}

template <> inline quint32 qbswap<quint32>(quint32 source)
{
return 0
| ((source & 0x000000ff) << 24)
| ((source & 0x0000ff00) << 8)
| ((source & 0x00ff0000) >> 8)
| ((source & 0xff000000) >> 24);
}

template <> inline quint16 qbswap<quint16>(quint16 source)
{
return quint16( 0
| ((source & 0x00ff) << 8)
| ((source & 0xff00) >> 8) );
}


template <> inline qint64 qbswap<qint64>(qint64 source)
{
return qbswap<quint64>(quint64(source));
}

template <> inline qint32 qbswap<qint32>(qint32 source)
{
return qbswap<quint32>(quint32(source));
}

template <> inline qint16 qbswap<qint16>(qint16 source)
{
return qbswap<quint16>(quint16(source));
}

# 312 "/usr/share/qt4/include/QtCore/qendian.h"
















# 328 "/usr/share/qt4/include/QtCore/qendian.h"
template <typename T> inline T qToBigEndian(T source)
{ return qbswap<T>(source); }
template <typename T> inline T qFromBigEndian(T source)
{ return qbswap<T>(source); }
template <typename T> inline T qToLittleEndian(T source)
{ return source; }
template <typename T> inline T qFromLittleEndian(T source)
{ return source; }
template <typename T> inline void qToBigEndian(T src, uchar *dest)
{ qbswap<T>(src, dest); }
template <typename T> inline void qToLittleEndian(T src, uchar *dest)
{ qToUnaligned<T>(src, dest); }



# 343 "/usr/share/qt4/include/QtCore/qendian.h"





# 126 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qfeatures.h"





























































































































































































































































































































# 318 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 323 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 328 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 333 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 338 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 343 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 348 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 353 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 358 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 363 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 368 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 373 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 378 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 383 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 388 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 393 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 398 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 403 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 408 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 413 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 418 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 423 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 428 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 433 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 438 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 443 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 448 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 453 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 458 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 463 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 468 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 473 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 478 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 483 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 488 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 493 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 498 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 503 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 508 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 513 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 518 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 523 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 528 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 533 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 538 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 543 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 548 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 553 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 558 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 563 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 568 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 573 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 578 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 583 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 588 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 593 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 598 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 603 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 608 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 613 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 618 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 623 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 628 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 633 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 638 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 643 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 648 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 653 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 658 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 663 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 668 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 673 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 678 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 683 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 688 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 693 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 698 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 703 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 708 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 713 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 718 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 723 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 728 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 733 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 738 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 743 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 748 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 753 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 758 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 763 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 768 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 773 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 778 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 783 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 788 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 793 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 798 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 803 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 808 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 813 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 818 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 823 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 828 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 833 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 838 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 843 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 848 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 853 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 858 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 863 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 868 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 873 "/usr/share/qt4/include/QtCore/qfeatures.h"





# 127 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 128 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qlibraryinfo.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qlibraryinfo.h"

# 1 "/usr/share/qt4/include/QtCore/qdatetime.h"














































































































































































































































































































































# 1 "/usr/share/qt4/include/QtCore/QDate"

# 46 "/usr/share/qt4/include/QtCore/qlibraryinfo.h"


# 48 "/usr/share/qt4/include/QtCore/qlibraryinfo.h"




typedef QtValidLicenseForCoreModule QtCoreModule;



# 56 "/usr/share/qt4/include/QtCore/qlibraryinfo.h"
class  QLibraryInfo
{
public:
static QString licensee();
static QString licensedProducts();

static QString buildKey();

# 64 "/usr/share/qt4/include/QtCore/qlibraryinfo.h"
static QDate buildDate();


# 67 "/usr/share/qt4/include/QtCore/qlibraryinfo.h"
enum LibraryLocation
{
PrefixPath,
DocumentationPath,
HeadersPath,
LibrariesPath,
BinariesPath,
PluginsPath,
DataPath,
TranslationsPath,
SettingsPath,
DemosPath,
ExamplesPath
};
static QString location(LibraryLocation); 

private:
QLibraryInfo();
};



# 89 "/usr/share/qt4/include/QtCore/qlibraryinfo.h"





# 129 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 130 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qnumeric.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qnumeric.h"


# 47 "/usr/share/qt4/include/QtCore/qnumeric.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

 bool qIsInf(double d);
 bool qIsNaN(double d);
 bool qIsFinite(double d);
 bool qIsInf(float f);
 bool qIsNaN(float f);
 bool qIsFinite(float f);
 double qSNaN();
 double qQNaN();
 double qInf();





# 67 "/usr/share/qt4/include/QtCore/qnumeric.h"





# 131 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qfactoryinterface.h"



































































# 132 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qlibrary.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/qlibrary.h"


# 47 "/usr/share/qt4/include/QtCore/qlibrary.h"




typedef QtValidLicenseForCoreModule QtCoreModule;








# 60 "/usr/share/qt4/include/QtCore/qlibrary.h"
class QLibraryPrivate;

class  QLibrary : public QObject
{
Q_OBJECT
Q_PROPERTY(QString fileName READ fileName WRITE setFileName)
Q_PROPERTY(LoadHints loadHints READ loadHints WRITE setLoadHints)

public:
enum LoadHint {
ResolveAllSymbolsHint = 0x01,
ExportExternalSymbolsHint = 0x02,
LoadArchiveMemberHint = 0x04
};
typedef QFlags<LoadHint> LoadHints;

explicit QLibrary(QObject *parent = 0);
explicit QLibrary(const QString& fileName, QObject *parent = 0);
explicit QLibrary(const QString& fileName, int verNum, QObject *parent = 0);
explicit QLibrary(const QString& fileName, const QString &version, QObject *parent = 0);
~QLibrary();

void *resolve(const char *symbol);
static void *resolve(const QString &fileName, const char *symbol);
static void *resolve(const QString &fileName, int verNum, const char *symbol);
static void *resolve(const QString &fileName, const QString &version, const char *symbol);

bool load();
bool unload();
bool isLoaded() const;

static bool isLibrary(const QString &fileName);

void setFileName(const QString &fileName);
QString fileName() const;

void setFileNameAndVersion(const QString &fileName, int verNum);
void setFileNameAndVersion(const QString &fileName, const QString &version);
QString errorString() const;

void setLoadHints(LoadHints hints);
LoadHints loadHints() const;




# 106 "/usr/share/qt4/include/QtCore/qlibrary.h"
private:
QLibraryPrivate *d;
bool did_load;
QLibrary(const QLibrary &); QLibrary &operator=(const QLibrary &);
};

inline QFlags<QLibrary::LoadHints::enum_type> operator|(QLibrary::LoadHints::enum_type f1, QLibrary::LoadHints::enum_type f2) { return QFlags<QLibrary::LoadHints::enum_type>(f1) | f2; } inline QFlags<QLibrary::LoadHints::enum_type> operator|(QLibrary::LoadHints::enum_type f1, QFlags<QLibrary::LoadHints::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QLibrary::LoadHints::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 116 "/usr/share/qt4/include/QtCore/qlibrary.h"





# 133 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qplugin.h"














































































































# 134 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/qpluginloader.h"












































# 1 "/usr/share/qt4/include/QtCore/qlibrary.h"
























































































































# 45 "/usr/share/qt4/include/QtCore/qpluginloader.h"









# 54 "/usr/share/qt4/include/QtCore/qpluginloader.h"




typedef QtValidLicenseForCoreModule QtCoreModule;

class QLibraryPrivate;

class  QPluginLoader : public QObject
{
Q_OBJECT
Q_PROPERTY(QString fileName READ fileName WRITE setFileName)
Q_PROPERTY(QLibrary::LoadHints loadHints READ loadHints WRITE setLoadHints)
public:
explicit QPluginLoader(QObject *parent = 0);
explicit QPluginLoader(const QString &fileName, QObject *parent = 0);
~QPluginLoader();

QObject *instance();

static QObjectList staticInstances();

bool load();
bool unload();
bool isLoaded() const;

void setFileName(const QString &fileName);
QString fileName() const;

QString errorString() const;

void setLoadHints(QLibrary::LoadHints loadHints);
QLibrary::LoadHints loadHints() const;

private:
QLibraryPrivate *d;
bool did_load;
QPluginLoader(const QPluginLoader &); QPluginLoader &operator=(const QPluginLoader &);
};








# 135 "/usr/share/qt4/include/QtCore/QtCore"

# 1 "/usr/share/qt4/include/QtCore/quuid.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtCore/quuid.h"


# 47 "/usr/share/qt4/include/QtCore/quuid.h"
















# 63 "/usr/share/qt4/include/QtCore/quuid.h"


typedef QtValidLicenseForCoreModule QtCoreModule;

struct  QUuid
{
enum Variant {
VarUnknown =-1,
NCS = 0, 
DCE = 2, 
Microsoft = 6, 
Reserved = 7 
};

enum Version {
VerUnknown =-1,
Time = 1, 
EmbeddedPOSIX = 2, 
Name = 3, 
Random = 4 
};

QUuid()
{
data1 = 0;
data2 = 0;
data3 = 0;
for(int i = 0; i < 8; i++)
data4[i] = 0;
}
QUuid(uint l, ushort w1, ushort w2, uchar b1, uchar b2, uchar b3, uchar b4, uchar b5, uchar b6, uchar b7, uchar b8)
{
data1 = l;
data2 = w1;
data3 = w2;
data4[0] = b1;
data4[1] = b2;
data4[2] = b3;
data4[3] = b4;
data4[4] = b5;
data4[5] = b6;
data4[6] = b7;
data4[7] = b8;
}

# 108 "/usr/share/qt4/include/QtCore/quuid.h"
QUuid(const QString &);
QUuid(const char *);
QString toString() const;
operator QString() const { return toString(); }

# 113 "/usr/share/qt4/include/QtCore/quuid.h"
bool isNull() const;

bool operator==(const QUuid &orig) const
{
uint i;
if (data1 != orig.data1 || data2 != orig.data2 ||
data3 != orig.data3)
return false;

for(i = 0; i < 8; i++)
if (data4[i] != orig.data4[i])
return false;

return true;
}

bool operator!=(const QUuid &orig) const
{
return !(*this == orig);
}

bool operator<(const QUuid &other) const;
bool operator>(const QUuid &other) const;



































# 171 "/usr/share/qt4/include/QtCore/quuid.h"
static QUuid createUuid();
QUuid::Variant variant() const;
QUuid::Version version() const;

uint data1;
ushort data2;
ushort data3;
uchar data4[8];
};


# 182 "/usr/share/qt4/include/QtCore/quuid.h"
 QDataStream &operator<<(QDataStream &, const QUuid &);
 QDataStream &operator>>(QDataStream &, QUuid &);


# 186 "/usr/share/qt4/include/QtCore/quuid.h"





# 136 "/usr/share/qt4/include/QtCore/QtCore"


# 5 "qwt.h"












































































































































# 3 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qbrush.h"












































# 1 "/usr/share/qt4/include/QtCore/qpair.h"































































































































# 45 "/usr/share/qt4/include/QtGui/qbrush.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qbrush.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qbrush.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 48 "/usr/share/qt4/include/QtGui/qbrush.h"

# 1 "/usr/share/qt4/include/QtGui/qcolor.h"












































# 1 "/usr/share/qt4/include/QtGui/qrgb.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qrgb.h"


# 47 "/usr/share/qt4/include/QtGui/qrgb.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

typedef unsigned int QRgb; 

const QRgb RGB_MASK = 0x00ffffff; 

 inline int qRed(QRgb rgb) 
{ return ((rgb >> 16) & 0xff); }

 inline int qGreen(QRgb rgb) 
{ return ((rgb >> 8) & 0xff); }

 inline int qBlue(QRgb rgb) 
{ return (rgb & 0xff); }

 inline int qAlpha(QRgb rgb) 
{ return ((rgb >> 24) & 0xff); }

 inline QRgb qRgb(int r, int g, int b)
{ return (0xffu << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

 inline QRgb qRgba(int r, int g, int b, int a)
{ return ((a & 0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

 inline int qGray(int r, int g, int b)
{ return (r*11+g*16+b*5)/32; }

 inline int qGray(QRgb rgb) 
{ return qGray(qRed(rgb), qGreen(rgb), qBlue(rgb)); }

 inline bool qIsGray(QRgb rgb)
{ return qRed(rgb) == qGreen(rgb) && qRed(rgb) == qBlue(rgb); }






# 45 "/usr/share/qt4/include/QtGui/qcolor.h"

# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qcolor.h"

# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"



































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qcolor.h"


# 49 "/usr/share/qt4/include/QtGui/qcolor.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QColor;
class QColormap;
class QVariant;


# 60 "/usr/share/qt4/include/QtGui/qcolor.h"
 QDebug operator<<(QDebug, const QColor &);


# 63 "/usr/share/qt4/include/QtGui/qcolor.h"
 QDataStream &operator<<(QDataStream &, const QColor &);
 QDataStream &operator>>(QDataStream &, QColor &);


# 67 "/usr/share/qt4/include/QtGui/qcolor.h"
class  QColor
{
public:
enum Spec { Invalid, Rgb, Hsv, Cmyk, Hsl };

QColor();
QColor(Qt::GlobalColor color);
QColor(int r, int g, int b, int a = 255);
QColor(QRgb rgb);
QColor(const QString& name);
QColor(const char *name);
QColor(const QColor &color);
QColor(Spec spec);

bool isValid() const;

QString name() const;
void setNamedColor(const QString& name);

static QStringList colorNames();

inline Spec spec() const
{ return cspec; }

int alpha() const;
void setAlpha(int alpha);

qreal alphaF() const;
void setAlphaF(qreal alpha);

int red() const;
int green() const;
int blue() const;
void setRed(int red);
void setGreen(int green);
void setBlue(int blue);

qreal redF() const;
qreal greenF() const;
qreal blueF() const;
void setRedF(qreal red);
void setGreenF(qreal green);
void setBlueF(qreal blue);

void getRgb(int *r, int *g, int *b, int *a = 0) const;
void setRgb(int r, int g, int b, int a = 255);

void getRgbF(qreal *r, qreal *g, qreal *b, qreal *a = 0) const;
void setRgbF(qreal r, qreal g, qreal b, qreal a = 1.0);

QRgb rgba() const;
void setRgba(QRgb rgba);

QRgb rgb() const;
void setRgb(QRgb rgb);

int hue() const; 
int saturation() const;
int hsvHue() const; 
int hsvSaturation() const;
int value() const;

qreal hueF() const; 
qreal saturationF() const;
qreal hsvHueF() const; 
qreal hsvSaturationF() const;
qreal valueF() const;

void getHsv(int *h, int *s, int *v, int *a = 0) const;
void setHsv(int h, int s, int v, int a = 255);

void getHsvF(qreal *h, qreal *s, qreal *v, qreal *a = 0) const;
void setHsvF(qreal h, qreal s, qreal v, qreal a = 1.0);

int cyan() const;
int magenta() const;
int yellow() const;
int black() const;

qreal cyanF() const;
qreal magentaF() const;
qreal yellowF() const;
qreal blackF() const;

void getCmyk(int *c, int *m, int *y, int *k, int *a = 0);
void setCmyk(int c, int m, int y, int k, int a = 255);

void getCmykF(qreal *c, qreal *m, qreal *y, qreal *k, qreal *a = 0);
void setCmykF(qreal c, qreal m, qreal y, qreal k, qreal a = 1.0);

int hslHue() const; 
int hslSaturation() const;
int lightness() const;

qreal hslHueF() const; 
qreal hslSaturationF() const;
qreal lightnessF() const;

void getHsl(int *h, int *s, int *l, int *a = 0) const;
void setHsl(int h, int s, int l, int a = 255);

void getHslF(qreal *h, qreal *s, qreal *l, qreal *a = 0) const;
void setHslF(qreal h, qreal s, qreal l, qreal a = 1.0);

QColor toRgb() const;
QColor toHsv() const;
QColor toCmyk() const;
QColor toHsl() const;

QColor convertTo(Spec colorSpec) const;

static QColor fromRgb(QRgb rgb);
static QColor fromRgba(QRgb rgba);

static QColor fromRgb(int r, int g, int b, int a = 255);
static QColor fromRgbF(qreal r, qreal g, qreal b, qreal a = 1.0);

static QColor fromHsv(int h, int s, int v, int a = 255);
static QColor fromHsvF(qreal h, qreal s, qreal v, qreal a = 1.0);

static QColor fromCmyk(int c, int m, int y, int k, int a = 255);
static QColor fromCmykF(qreal c, qreal m, qreal y, qreal k, qreal a = 1.0);

static QColor fromHsl(int h, int s, int l, int a = 255);
static QColor fromHslF(qreal h, qreal s, qreal l, qreal a = 1.0);

QColor light(int f = 150) const;
QColor lighter(int f = 150) const;
QColor dark(int f = 200) const;
QColor darker(int f = 200) const;

QColor &operator=(const QColor &);
QColor &operator=(Qt::GlobalColor color);

bool operator==(const QColor &c) const;
bool operator!=(const QColor &c) const;

operator QVariant() const;























# 228 "/usr/share/qt4/include/QtGui/qcolor.h"
private:

# 230 "/usr/share/qt4/include/QtGui/qcolor.h"

QColor(int, int, int, Spec);


# 234 "/usr/share/qt4/include/QtGui/qcolor.h"
void invalidate();

Spec cspec;
union {
struct {
ushort alpha;
ushort red;
ushort green;
ushort blue;
ushort pad;
} argb;
struct {
ushort alpha;
ushort hue;
ushort saturation;
ushort value;
ushort pad;
} ahsv;
struct {
ushort alpha;
ushort cyan;
ushort magenta;
ushort yellow;
ushort black;
} acmyk;
struct {
ushort alpha;
ushort hue;
ushort saturation;
ushort lightness;
ushort pad;
} ahsl;
ushort array[5];
} ct;

friend class QColormap;

# 271 "/usr/share/qt4/include/QtGui/qcolor.h"
friend  QDataStream &operator<<(QDataStream &, const QColor &);
friend  QDataStream &operator>>(QDataStream &, QColor &);

# 274 "/usr/share/qt4/include/QtGui/qcolor.h"
};

inline QColor::QColor()
{ invalidate(); }

inline QColor::QColor(int r, int g, int b, int a)
{ setRgb(r, g, b, a); }

inline QColor::QColor(const char *aname)
{ setNamedColor(QLatin1String(aname)); }

inline QColor::QColor(const QString& aname)
{ setNamedColor(aname); }

inline QColor::QColor(const QColor &acolor)
: cspec(acolor.cspec)
{ ct.argb = acolor.ct.argb; }

inline bool QColor::isValid() const
{ return cspec != Invalid; }

inline QColor QColor::lighter(int f) const 
{ return light(f); }

inline QColor QColor::darker(int f) const 
{ return dark(f); }






# 49 "/usr/share/qt4/include/QtGui/qbrush.h"

# 1 "/usr/share/qt4/include/QtGui/qmatrix.h"












































# 1 "/usr/share/qt4/include/QtGui/qpolygon.h"












































# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qpolygon.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qpolygon.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qpolygon.h"


# 49 "/usr/share/qt4/include/QtGui/qpolygon.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QMatrix;
class QTransform;
class QRect;
class QVariant;

class  QPolygon : public QVector<QPoint>
{
public:
inline QPolygon() {}
inline ~QPolygon() {}
inline QPolygon(int size);
inline QPolygon(const QPolygon &a) : QVector<QPoint>(a) {}
inline QPolygon(const QVector<QPoint> &v) : QVector<QPoint>(v) {}
QPolygon(const QRect &r, bool closed=false);
QPolygon(int nPoints, const int *points);
operator QVariant() const;

void translate(int dx, int dy);
void translate(const QPoint &offset);

QPolygon translated(int dx, int dy) const;
inline QPolygon translated(const QPoint &offset) const;

QRect boundingRect() const;

void point(int i, int *x, int *y) const;
QPoint point(int i) const;
void setPoint(int index, int x, int y);
void setPoint(int index, const QPoint &p);
void setPoints(int nPoints, const int *points);
void setPoints(int nPoints, int firstx, int firsty, ...);
void putPoints(int index, int nPoints, const int *points);
void putPoints(int index, int nPoints, int firstx, int firsty, ...);
void putPoints(int index, int nPoints, const QPolygon & from, int fromIndex=0);

bool containsPoint(const QPoint &pt, Qt::FillRule fillRule) const;

QPolygon united(const QPolygon &r) const;
QPolygon intersected(const QPolygon &r) const;
QPolygon subtracted(const QPolygon &r) const;
};

inline QPolygon::QPolygon(int asize) : QVector<QPoint>(asize) {}


# 100 "/usr/share/qt4/include/QtGui/qpolygon.h"
 QDebug operator<<(QDebug, const QPolygon &);


# 103 "/usr/share/qt4/include/QtGui/qpolygon.h"




# 107 "/usr/share/qt4/include/QtGui/qpolygon.h"
 QDataStream &operator<<(QDataStream &stream, const QPolygon &polygon);
 QDataStream &operator>>(QDataStream &stream, QPolygon &polygon);


# 111 "/usr/share/qt4/include/QtGui/qpolygon.h"




inline void QPolygon::setPoint(int index, const QPoint &pt)
{ (*this)[index] = pt; }

inline void QPolygon::setPoint(int index, int x, int y)
{ (*this)[index] = QPoint(x, y); }

inline QPoint QPolygon::point(int index) const
{ return at(index); }

inline void QPolygon::translate(const QPoint &offset)
{ translate(offset.x(), offset.y()); }

inline QPolygon QPolygon::translated(const QPoint &offset) const
{ return translated(offset.x(), offset.y()); }

class QRectF;

class  QPolygonF : public QVector<QPointF>
{
public:
inline QPolygonF() {}
inline ~QPolygonF() {}
inline QPolygonF(int size);
inline QPolygonF(const QPolygonF &a) : QVector<QPointF>(a) {}
inline QPolygonF(const QVector<QPointF> &v) : QVector<QPointF>(v) {}
QPolygonF(const QRectF &r);
QPolygonF(const QPolygon &a);

inline void translate(qreal dx, qreal dy);
void translate(const QPointF &offset);

inline QPolygonF translated(qreal dx, qreal dy) const;
QPolygonF translated(const QPointF &offset) const;

QPolygon toPolygon() const;

bool isClosed() const { return !isEmpty() && first() == last(); }

QRectF boundingRect() const;

bool containsPoint(const QPointF &pt, Qt::FillRule fillRule) const;

QPolygonF united(const QPolygonF &r) const;
QPolygonF intersected(const QPolygonF &r) const;
QPolygonF subtracted(const QPolygonF &r) const;
};

inline QPolygonF::QPolygonF(int asize) : QVector<QPointF>(asize) {}


# 165 "/usr/share/qt4/include/QtGui/qpolygon.h"
 QDebug operator<<(QDebug, const QPolygonF &);


# 168 "/usr/share/qt4/include/QtGui/qpolygon.h"




# 172 "/usr/share/qt4/include/QtGui/qpolygon.h"
 QDataStream &operator<<(QDataStream &stream, const QPolygonF &array);
 QDataStream &operator>>(QDataStream &stream, QPolygonF &array);


# 176 "/usr/share/qt4/include/QtGui/qpolygon.h"
inline void QPolygonF::translate(qreal dx, qreal dy)
{ translate(QPointF(dx, dy)); }

inline QPolygonF QPolygonF::translated(qreal dx, qreal dy) const
{ return translated(QPointF(dx, dy)); }






# 45 "/usr/share/qt4/include/QtGui/qmatrix.h"

# 1 "/usr/share/qt4/include/QtGui/qregion.h"












































# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 45 "/usr/share/qt4/include/QtGui/qregion.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qregion.h"

# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"












































# 1 "/usr/share/qt4/include/QtCore/qobjectdefs.h"































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qwindowdefs.h"

# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qwindowdefs.h"


# 48 "/usr/share/qt4/include/QtGui/qwindowdefs.h"



typedef QtValidLicenseForGuiModule QtGuiModule;



class QPaintDevice;
class QWidget;
class QDialog;
class QColor;
class QPalette;



# 63 "/usr/share/qt4/include/QtGui/qwindowdefs.h"
class QCursor;
class QPoint;
class QSize;
class QRect;
class QPolygon;
class QPainter;
class QRegion;
class QFont;
class QFontMetrics;
class QFontInfo;
class QPen;
class QBrush;
class QMatrix;
class QPixmap;
class QBitmap;
class QMovie;
class QImage;
class QPicture;
class QPrinter;
class QTimer;
class QTime;
class QClipboard;
class QString;
class QByteArray;
class QApplication;

template<typename T> class QList;
typedef QList<QWidget *> QWidgetList;
















































# 139 "/usr/share/qt4/include/QtGui/qwindowdefs.h"



template<class K, class V> class QHash;
typedef QHash<WId, QWidget *> QWidgetMapper;

template<class V> class QSet;
typedef QSet<QWidget *> QWidgetSet;








# 155 "/usr/share/qt4/include/QtGui/qwindowdefs.h"



# 47 "/usr/share/qt4/include/QtGui/qregion.h"



# 1 "/usr/share/qt4/include/QtCore/qdatastream.h"


















































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qregion.h"



# 53 "/usr/share/qt4/include/QtGui/qregion.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

template <class T> class QVector;
class QVariant;





# 66 "/usr/share/qt4/include/QtGui/qregion.h"
class QBitmap;

class  QRegion
{
public:
enum RegionType { Rectangle, Ellipse };

QRegion();
QRegion(int x, int y, int w, int h, RegionType t = Rectangle);
QRegion(const QRect &r, RegionType t = Rectangle);
QRegion(const QPolygon &pa, Qt::FillRule fillRule = Qt::OddEvenFill);



# 80 "/usr/share/qt4/include/QtGui/qregion.h"
QRegion(const QRegion &region);
QRegion(const QBitmap &bitmap);
~QRegion();
QRegion &operator=(const QRegion &);




# 88 "/usr/share/qt4/include/QtGui/qregion.h"
bool isEmpty() const;

bool contains(const QPoint &p) const;
bool contains(const QRect &r) const;

void translate(int dx, int dy);
inline void translate(const QPoint &p) { translate(p.x(), p.y()); }
QRegion translated(int dx, int dy) const;
inline QRegion translated(const QPoint &p) const { return translated(p.x(), p.y()); }


QRegion unite(const QRegion &r) const;
QRegion unite(const QRect &r) const;
QRegion intersect(const QRegion &r) const;
QRegion intersect(const QRect &r) const;
QRegion subtract(const QRegion &r) const;
QRegion eor(const QRegion &r) const;

inline QRegion united(const QRegion &r) const { return unite(r); }
inline QRegion united(const QRect &r) const { return unite(r); }
inline QRegion intersected(const QRegion &r) const { return intersect(r); }
inline QRegion intersected(const QRect &r) const { return intersect(r); }
inline QRegion subtracted(const QRegion &r) const { return subtract(r); }
inline QRegion xored(const QRegion &r) const { return eor(r); }

bool intersects(const QRegion &r) const;
bool intersects(const QRect &r) const;

QRect boundingRect() const;
QVector<QRect> rects() const;
void setRects(const QRect *rect, int num);

# 120 "/usr/share/qt4/include/QtGui/qregion.h"
 int numRects() const;

# 122 "/usr/share/qt4/include/QtGui/qregion.h"
int rectCount() const;

const QRegion operator|(const QRegion &r) const;
const QRegion operator+(const QRegion &r) const;
const QRegion operator+(const QRect &r) const;
const QRegion operator&(const QRegion &r) const;
const QRegion operator&(const QRect &r) const;
const QRegion operator-(const QRegion &r) const;
const QRegion operator^(const QRegion &r) const;
QRegion& operator|=(const QRegion &r);
QRegion& operator+=(const QRegion &r);
QRegion& operator+=(const QRect &r);
QRegion& operator&=(const QRegion &r);
QRegion& operator&=(const QRect &r);
QRegion& operator-=(const QRegion &r);
QRegion& operator^=(const QRegion &r);

bool operator==(const QRegion &r) const;
inline bool operator!=(const QRegion &r) const { return !(operator==(r)); }
operator QVariant() const;






























# 172 "/usr/share/qt4/include/QtGui/qregion.h"
friend  QDataStream &operator<<(QDataStream &, const QRegion &);
friend  QDataStream &operator>>(QDataStream &, QRegion &);

# 175 "/usr/share/qt4/include/QtGui/qregion.h"
private:
QRegion copy() const; 
void detach();











# 189 "/usr/share/qt4/include/QtGui/qregion.h"
friend bool qt_region_strictContains(const QRegion &region,
const QRect &rect);
friend struct QRegionPrivate;


# 194 "/usr/share/qt4/include/QtGui/qregion.h"
void exec(const QByteArray &ba, int ver = 0, QDataStream::ByteOrder byteOrder = QDataStream::BigEndian);

# 196 "/usr/share/qt4/include/QtGui/qregion.h"
struct QRegionData {
QBasicAtomicInt ref;











# 209 "/usr/share/qt4/include/QtGui/qregion.h"
};



# 213 "/usr/share/qt4/include/QtGui/qregion.h"
struct QRegionData *d;
static struct QRegionData shared_empty;
static void cleanUp(QRegionData *x);
};






# 223 "/usr/share/qt4/include/QtGui/qregion.h"
 QDataStream &operator<<(QDataStream &, const QRegion &);
 QDataStream &operator>>(QDataStream &, QRegion &);



# 228 "/usr/share/qt4/include/QtGui/qregion.h"
 QDebug operator<<(QDebug, const QRegion &);


# 231 "/usr/share/qt4/include/QtGui/qregion.h"





# 46 "/usr/share/qt4/include/QtGui/qmatrix.h"

# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 47 "/usr/share/qt4/include/QtGui/qmatrix.h"

# 1 "/usr/share/qt4/include/QtCore/qline.h"
































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qmatrix.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qmatrix.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qmatrix.h"


# 52 "/usr/share/qt4/include/QtGui/qmatrix.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QPainterPath;
class QVariant;

class  QMatrix 
{
public:
inline explicit QMatrix(Qt::Initialization) {}
QMatrix();
QMatrix(qreal m11, qreal m12, qreal m21, qreal m22,
qreal dx, qreal dy);
QMatrix(const QMatrix &matrix);

void setMatrix(qreal m11, qreal m12, qreal m21, qreal m22,
qreal dx, qreal dy);

qreal m11() const { return _m11; }
qreal m12() const { return _m12; }
qreal m21() const { return _m21; }
qreal m22() const { return _m22; }
qreal dx() const { return _dx; }
qreal dy() const { return _dy; }

void map(int x, int y, int *tx, int *ty) const;
void map(qreal x, qreal y, qreal *tx, qreal *ty) const;
QRect mapRect(const QRect &) const;
QRectF mapRect(const QRectF &) const;

QPoint map(const QPoint &p) const;
QPointF map(const QPointF&p) const;
QLine map(const QLine &l) const;
QLineF map(const QLineF &l) const;
QPolygonF map(const QPolygonF &a) const;
QPolygon map(const QPolygon &a) const;
QRegion map(const QRegion &r) const;
QPainterPath map(const QPainterPath &p) const;
QPolygon mapToPolygon(const QRect &r) const;

void reset();
inline bool isIdentity() const;

QMatrix &translate(qreal dx, qreal dy);
QMatrix &scale(qreal sx, qreal sy);
QMatrix &shear(qreal sh, qreal sv);
QMatrix &rotate(qreal a);

bool isInvertible() const { return !qFuzzyIsNull(_m11*_m22 - _m12*_m21); }
qreal determinant() const { return _m11*_m22 - _m12*_m21; }

# 106 "/usr/share/qt4/include/QtGui/qmatrix.h"
 qreal det() const { return _m11*_m22 - _m12*_m21; }


# 109 "/usr/share/qt4/include/QtGui/qmatrix.h"
QMatrix inverted(bool *invertible = 0) const;

bool operator==(const QMatrix &) const;
bool operator!=(const QMatrix &) const;

QMatrix &operator*=(const QMatrix &);
QMatrix operator*(const QMatrix &o) const;

QMatrix &operator=(const QMatrix &);

operator QVariant() const;







# 127 "/usr/share/qt4/include/QtGui/qmatrix.h"
private:
inline QMatrix(bool)
: _m11(1.)
, _m12(0.)
, _m21(0.)
, _m22(1.)
, _dx(0.)
, _dy(0.) {}
inline QMatrix(qreal am11, qreal am12, qreal am21, qreal am22, qreal adx, qreal ady, bool)
: _m11(am11)
, _m12(am12)
, _m21(am21)
, _m22(am22)
, _dx(adx)
, _dy(ady) {}
friend class QTransform;
qreal _m11, _m12;
qreal _m21, _m22;
qreal _dx, _dy;
};
template <> class QTypeInfo<QMatrix > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMatrix)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QMatrix"; } };


 inline QPoint operator*(const QPoint &p, const QMatrix &m)
{ return m.map(p); }
 inline QPointF operator*(const QPointF &p, const QMatrix &m)
{ return m.map(p); }
 inline QLineF operator*(const QLineF &l, const QMatrix &m)
{ return m.map(l); }
 inline QLine operator*(const QLine &l, const QMatrix &m)
{ return m.map(l); }
 inline QPolygon operator *(const QPolygon &a, const QMatrix &m)
{ return m.map(a); }
 inline QPolygonF operator *(const QPolygonF &a, const QMatrix &m)
{ return m.map(a); }
 inline QRegion operator *(const QRegion &r, const QMatrix &m)
{ return m.map(r); }
 QPainterPath operator *(const QPainterPath &p, const QMatrix &m);

inline bool QMatrix::isIdentity() const
{
return qFuzzyIsNull(_m11 - 1) && qFuzzyIsNull(_m22 - 1) && qFuzzyIsNull(_m12)
&& qFuzzyIsNull(_m21) && qFuzzyIsNull(_dx) && qFuzzyIsNull(_dy);
}

inline bool qFuzzyCompare(const QMatrix& m1, const QMatrix& m2)
{
return qFuzzyCompare(m1.m11(), m2.m11())
&& qFuzzyCompare(m1.m12(), m2.m12())
&& qFuzzyCompare(m1.m21(), m2.m21())
&& qFuzzyCompare(m1.m22(), m2.m22())
&& qFuzzyCompare(m1.dx(), m2.dx())
&& qFuzzyCompare(m1.dy(), m2.dy());
}







# 188 "/usr/share/qt4/include/QtGui/qmatrix.h"
 QDataStream &operator<<(QDataStream &, const QMatrix &);
 QDataStream &operator>>(QDataStream &, QMatrix &);



# 193 "/usr/share/qt4/include/QtGui/qmatrix.h"
 QDebug operator<<(QDebug, const QMatrix &);








# 202 "/usr/share/qt4/include/QtGui/qmatrix.h"





# 50 "/usr/share/qt4/include/QtGui/qbrush.h"

# 1 "/usr/share/qt4/include/QtGui/qtransform.h"











































# 1 "/usr/share/qt4/include/QtGui/qmatrix.h"












































































































































































































# 44 "/usr/share/qt4/include/QtGui/qtransform.h"

# 1 "/usr/share/qt4/include/QtGui/qpainterpath.h"












































# 1 "/usr/share/qt4/include/QtGui/qmatrix.h"












































































































































































































# 45 "/usr/share/qt4/include/QtGui/qpainterpath.h"

# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qpainterpath.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qpainterpath.h"

# 1 "/usr/share/qt4/include/QtCore/qline.h"
































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qpainterpath.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qpainterpath.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 50 "/usr/share/qt4/include/QtGui/qpainterpath.h"


# 52 "/usr/share/qt4/include/QtGui/qpainterpath.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QFont;
class QPainterPathPrivate;
struct QPainterPathPrivateDeleter;
class QPainterPathData;
class QPainterPathStrokerPrivate;
class QPolygonF;
class QRegion;
class QVectorPath;

class  QPainterPath
{
public:
enum ElementType {
MoveToElement,
LineToElement,
CurveToElement,
CurveToDataElement
};

class Element {
public:
qreal x;
qreal y;
ElementType type;

bool isMoveTo() const { return type == MoveToElement; }
bool isLineTo() const { return type == LineToElement; }
bool isCurveTo() const { return type == CurveToElement; }

operator QPointF () const { return QPointF(x, y); }

bool operator==(const Element &e) const { return qFuzzyCompare(x, e.x)
&& qFuzzyCompare(y, e.y) && type == e.type; }
inline bool operator!=(const Element &e) const { return !operator==(e); }
};

QPainterPath();
explicit QPainterPath(const QPointF &startPoint);
QPainterPath(const QPainterPath &other);
QPainterPath &operator=(const QPainterPath &other);
~QPainterPath();

void closeSubpath();

void moveTo(const QPointF &p);
inline void moveTo(qreal x, qreal y);

void lineTo(const QPointF &p);
inline void lineTo(qreal x, qreal y);

void arcMoveTo(const QRectF &rect, qreal angle);
inline void arcMoveTo(qreal x, qreal y, qreal w, qreal h, qreal angle);

void arcTo(const QRectF &rect, qreal startAngle, qreal arcLength);
inline void arcTo(qreal x, qreal y, qreal w, qreal h, qreal startAngle, qreal arcLength);

void cubicTo(const QPointF &ctrlPt1, const QPointF &ctrlPt2, const QPointF &endPt);
inline void cubicTo(qreal ctrlPt1x, qreal ctrlPt1y, qreal ctrlPt2x, qreal ctrlPt2y,
qreal endPtx, qreal endPty);
void quadTo(const QPointF &ctrlPt, const QPointF &endPt);
inline void quadTo(qreal ctrlPtx, qreal ctrlPty, qreal endPtx, qreal endPty);

QPointF currentPosition() const;

void addRect(const QRectF &rect);
inline void addRect(qreal x, qreal y, qreal w, qreal h);
void addEllipse(const QRectF &rect);
inline void addEllipse(qreal x, qreal y, qreal w, qreal h);
inline void addEllipse(const QPointF &center, qreal rx, qreal ry);
void addPolygon(const QPolygonF &polygon);
void addText(const QPointF &point, const QFont &f, const QString &text);
inline void addText(qreal x, qreal y, const QFont &f, const QString &text);
void addPath(const QPainterPath &path);
void addRegion(const QRegion &region);

void addRoundedRect(const QRectF &rect, qreal xRadius, qreal yRadius,
Qt::SizeMode mode = Qt::AbsoluteSize);
inline void addRoundedRect(qreal x, qreal y, qreal w, qreal h,
qreal xRadius, qreal yRadius,
Qt::SizeMode mode = Qt::AbsoluteSize);

void addRoundRect(const QRectF &rect, int xRnd, int yRnd);
inline void addRoundRect(qreal x, qreal y, qreal w, qreal h,
int xRnd, int yRnd);
inline void addRoundRect(const QRectF &rect, int roundness);
inline void addRoundRect(qreal x, qreal y, qreal w, qreal h,
int roundness);

void connectPath(const QPainterPath &path);

bool contains(const QPointF &pt) const;
bool contains(const QRectF &rect) const;
bool intersects(const QRectF &rect) const;

void translate(qreal dx, qreal dy);
inline void translate(const QPointF &offset);

QPainterPath translated(qreal dx, qreal dy) const;
inline QPainterPath translated(const QPointF &offset) const;

QRectF boundingRect() const;
QRectF controlPointRect() const;

Qt::FillRule fillRule() const;
void setFillRule(Qt::FillRule fillRule);

inline bool isEmpty() const;

QPainterPath toReversed() const;
QList<QPolygonF> toSubpathPolygons(const QMatrix &matrix = QMatrix()) const;
QList<QPolygonF> toFillPolygons(const QMatrix &matrix = QMatrix()) const;
QPolygonF toFillPolygon(const QMatrix &matrix = QMatrix()) const;
QList<QPolygonF> toSubpathPolygons(const QTransform &matrix) const;
QList<QPolygonF> toFillPolygons(const QTransform &matrix) const;
QPolygonF toFillPolygon(const QTransform &matrix) const;

inline int elementCount() const;
inline const QPainterPath::Element &elementAt(int i) const;
inline void setElementPositionAt(int i, qreal x, qreal y);

qreal length() const;
qreal percentAtLength(qreal t) const;
QPointF pointAtPercent(qreal t) const;
qreal angleAtPercent(qreal t) const;
qreal slopeAtPercent(qreal t) const;

bool intersects(const QPainterPath &p) const;
bool contains(const QPainterPath &p) const;
QPainterPath united(const QPainterPath &r) const;
QPainterPath intersected(const QPainterPath &r) const;
QPainterPath subtracted(const QPainterPath &r) const;
QPainterPath subtractedInverted(const QPainterPath &r) const;

QPainterPath simplified() const;

bool operator==(const QPainterPath &other) const;
bool operator!=(const QPainterPath &other) const;

QPainterPath operator&(const QPainterPath &other) const;
QPainterPath operator|(const QPainterPath &other) const;
QPainterPath operator+(const QPainterPath &other) const;
QPainterPath operator-(const QPainterPath &other) const;
QPainterPath &operator&=(const QPainterPath &other);
QPainterPath &operator|=(const QPainterPath &other);
QPainterPath &operator+=(const QPainterPath &other);
QPainterPath &operator-=(const QPainterPath &other);

private:
QScopedPointer<QPainterPathPrivate, QPainterPathPrivateDeleter> d_ptr;

inline void ensureData() { if (!d_ptr) ensureData_helper(); }
void ensureData_helper();
inline void detach();
void detach_helper();
void setDirty(bool);
void computeBoundingRect() const;
void computeControlPointRect() const;

QPainterPathData *d_func() const { return reinterpret_cast<QPainterPathData *>(d_ptr.data()); }

friend class QPainterPathData;
friend class QPainterPathStroker;
friend class QPainterPathStrokerPrivate;
friend class QMatrix;
friend class QTransform;
friend class QVectorPath;
friend  const QVectorPath &qtVectorPathForPath(const QPainterPath &);


# 227 "/usr/share/qt4/include/QtGui/qpainterpath.h"
friend  QDataStream &operator<<(QDataStream &, const QPainterPath &);
friend  QDataStream &operator>>(QDataStream &, QPainterPath &);

# 230 "/usr/share/qt4/include/QtGui/qpainterpath.h"
};

class QPainterPathPrivate
{
public:
friend class QPainterPath;
friend class QPainterPathData;
friend class QPainterPathStroker;
friend class QPainterPathStrokerPrivate;
friend class QMatrix;
friend class QTransform;
friend class QVectorPath;
friend struct QPainterPathPrivateDeleter;

# 244 "/usr/share/qt4/include/QtGui/qpainterpath.h"
friend  QDataStream &operator<<(QDataStream &, const QPainterPath &);
friend  QDataStream &operator>>(QDataStream &, QPainterPath &);

# 247 "/usr/share/qt4/include/QtGui/qpainterpath.h"
private:
QAtomicInt ref;
QVector<QPainterPath::Element> elements;
};

template <> class QTypeInfo<QPainterPath::Element > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPainterPath::Element)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QPainterPath::Element"; } };


# 255 "/usr/share/qt4/include/QtGui/qpainterpath.h"
 QDataStream &operator<<(QDataStream &, const QPainterPath &);
 QDataStream &operator>>(QDataStream &, QPainterPath &);


# 259 "/usr/share/qt4/include/QtGui/qpainterpath.h"
class  QPainterPathStroker
{
inline QPainterPathStrokerPrivate* d_func() { return reinterpret_cast<QPainterPathStrokerPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPainterPathStrokerPrivate* d_func() const { return reinterpret_cast<const QPainterPathStrokerPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPainterPathStrokerPrivate;
public:
QPainterPathStroker();
~QPainterPathStroker();

void setWidth(qreal width);
qreal width() const;

void setCapStyle(Qt::PenCapStyle style);
Qt::PenCapStyle capStyle() const;

void setJoinStyle(Qt::PenJoinStyle style);
Qt::PenJoinStyle joinStyle() const;

void setMiterLimit(qreal length);
qreal miterLimit() const;

void setCurveThreshold(qreal threshold);
qreal curveThreshold() const;

void setDashPattern(Qt::PenStyle);
void setDashPattern(const QVector<qreal> &dashPattern);
QVector<qreal> dashPattern() const;

void setDashOffset(qreal offset);
qreal dashOffset() const;

QPainterPath createStroke(const QPainterPath &path) const;

private:
friend class QX11PaintEngine;

QScopedPointer<QPainterPathStrokerPrivate> d_ptr;
};

inline void QPainterPath::moveTo(qreal x, qreal y)
{
moveTo(QPointF(x, y));
}

inline void QPainterPath::lineTo(qreal x, qreal y)
{
lineTo(QPointF(x, y));
}

inline void QPainterPath::arcTo(qreal x, qreal y, qreal w, qreal h, qreal startAngle, qreal arcLength)
{
arcTo(QRectF(x, y, w, h), startAngle, arcLength);
}

inline void QPainterPath::arcMoveTo(qreal x, qreal y, qreal w, qreal h, qreal angle)
{
arcMoveTo(QRectF(x, y, w, h), angle);
}

inline void QPainterPath::cubicTo(qreal ctrlPt1x, qreal ctrlPt1y, qreal ctrlPt2x, qreal ctrlPt2y,
qreal endPtx, qreal endPty)
{
cubicTo(QPointF(ctrlPt1x, ctrlPt1y), QPointF(ctrlPt2x, ctrlPt2y),
QPointF(endPtx, endPty));
}

inline void QPainterPath::quadTo(qreal ctrlPtx, qreal ctrlPty, qreal endPtx, qreal endPty)
{
quadTo(QPointF(ctrlPtx, ctrlPty), QPointF(endPtx, endPty));
}

inline void QPainterPath::addEllipse(qreal x, qreal y, qreal w, qreal h)
{
addEllipse(QRectF(x, y, w, h));
}

inline void QPainterPath::addEllipse(const QPointF &center, qreal rx, qreal ry)
{
addEllipse(QRectF(center.x() - rx, center.y() - ry, 2 * rx, 2 * ry));
}

inline void QPainterPath::addRect(qreal x, qreal y, qreal w, qreal h)
{
addRect(QRectF(x, y, w, h));
}

inline void QPainterPath::addRoundedRect(qreal x, qreal y, qreal w, qreal h,
qreal xRadius, qreal yRadius,
Qt::SizeMode mode)
{
addRoundedRect(QRectF(x, y, w, h), xRadius, yRadius, mode);
}

inline void QPainterPath::addRoundRect(qreal x, qreal y, qreal w, qreal h,
int xRnd, int yRnd)
{
addRoundRect(QRectF(x, y, w, h), xRnd, yRnd);
}

inline void QPainterPath::addRoundRect(const QRectF &rect,
int roundness)
{
int xRnd = roundness;
int yRnd = roundness;
if (rect.width() > rect.height())
xRnd = int(roundness * rect.height()/rect.width());
else
yRnd = int(roundness * rect.width()/rect.height());
addRoundRect(rect, xRnd, yRnd);
}

inline void QPainterPath::addRoundRect(qreal x, qreal y, qreal w, qreal h,
int roundness)
{
addRoundRect(QRectF(x, y, w, h), roundness);
}

inline void QPainterPath::addText(qreal x, qreal y, const QFont &f, const QString &text)
{
addText(QPointF(x, y), f, text);
}

inline void QPainterPath::translate(const QPointF &offset)
{ translate(offset.x(), offset.y()); }

inline QPainterPath QPainterPath::translated(const QPointF &offset) const
{ return translated(offset.x(), offset.y()); }

inline bool QPainterPath::isEmpty() const
{
return !d_ptr || (d_ptr->elements.size() == 1 && d_ptr->elements.first().type == MoveToElement);
}

inline int QPainterPath::elementCount() const
{
return d_ptr ? d_ptr->elements.size() : 0;
}

inline const QPainterPath::Element &QPainterPath::elementAt(int i) const
{
qt_noop();
qt_noop();
return d_ptr->elements.at(i);
}

inline void QPainterPath::setElementPositionAt(int i, qreal x, qreal y)
{
qt_noop();
qt_noop();
detach();
QPainterPath::Element &e = d_ptr->elements[i];
e.x = x;
e.y = y;
}


inline void QPainterPath::detach()
{
if (d_ptr->ref != 1)
detach_helper();
setDirty(true);
}


# 421 "/usr/share/qt4/include/QtGui/qpainterpath.h"
 QDebug operator<<(QDebug, const QPainterPath &);


# 424 "/usr/share/qt4/include/QtGui/qpainterpath.h"





# 45 "/usr/share/qt4/include/QtGui/qtransform.h"

# 1 "/usr/share/qt4/include/QtGui/qpolygon.h"




















































































































































































# 46 "/usr/share/qt4/include/QtGui/qtransform.h"

# 1 "/usr/share/qt4/include/QtGui/qregion.h"









































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qtransform.h"

# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 48 "/usr/share/qt4/include/QtGui/qtransform.h"

# 1 "/usr/share/qt4/include/QtCore/qline.h"
































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qtransform.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qtransform.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 51 "/usr/share/qt4/include/QtGui/qtransform.h"






# 57 "/usr/share/qt4/include/QtGui/qtransform.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QVariant;

class  QTransform
{
Q_ENUMS(TransformationType)
public:
enum TransformationType {
TxNone = 0x00,
TxTranslate = 0x01,
TxScale = 0x02,
TxRotate = 0x04,
TxShear = 0x08,
TxProject = 0x10
};

inline explicit QTransform(Qt::Initialization) : affine(Qt::Uninitialized) {}
QTransform();
QTransform(qreal h11, qreal h12, qreal h13,
qreal h21, qreal h22, qreal h23,
qreal h31, qreal h32, qreal h33 = 1.0);
QTransform(qreal h11, qreal h12, qreal h21,
qreal h22, qreal dx, qreal dy);
explicit QTransform(const QMatrix &mtx);

bool isAffine() const;
bool isIdentity() const;
bool isInvertible() const;
bool isScaling() const;
bool isRotating() const;
bool isTranslating() const;

TransformationType type() const;

inline qreal determinant() const;
qreal det() const;

qreal m11() const;
qreal m12() const;
qreal m13() const;
qreal m21() const;
qreal m22() const;
qreal m23() const;
qreal m31() const;
qreal m32() const;
qreal m33() const;
qreal dx() const;
qreal dy() const;

void setMatrix(qreal m11, qreal m12, qreal m13,
qreal m21, qreal m22, qreal m23,
qreal m31, qreal m32, qreal m33);

QTransform inverted(bool *invertible = 0) const;
QTransform adjoint() const;
QTransform transposed() const;

QTransform &translate(qreal dx, qreal dy);
QTransform &scale(qreal sx, qreal sy);
QTransform &shear(qreal sh, qreal sv);
QTransform &rotate(qreal a, Qt::Axis axis = Qt::ZAxis);
QTransform &rotateRadians(qreal a, Qt::Axis axis = Qt::ZAxis);

static bool squareToQuad(const QPolygonF &square, QTransform &result);
static bool quadToSquare(const QPolygonF &quad, QTransform &result);
static bool quadToQuad(const QPolygonF &one,
const QPolygonF &two,
QTransform &result);

bool operator==(const QTransform &) const;
bool operator!=(const QTransform &) const;

QTransform &operator*=(const QTransform &);
QTransform operator*(const QTransform &o) const;

QTransform &operator=(const QTransform &);

operator QVariant() const;

void reset();
QPoint map(const QPoint &p) const;
QPointF map(const QPointF &p) const;
QLine map(const QLine &l) const;
QLineF map(const QLineF &l) const;
QPolygonF map(const QPolygonF &a) const;
QPolygon map(const QPolygon &a) const;
QRegion map(const QRegion &r) const;
QPainterPath map(const QPainterPath &p) const;
QPolygon mapToPolygon(const QRect &r) const;
QRect mapRect(const QRect &) const;
QRectF mapRect(const QRectF &) const;
void map(int x, int y, int *tx, int *ty) const;
void map(qreal x, qreal y, qreal *tx, qreal *ty) const;

const QMatrix &toAffine() const;

QTransform &operator*=(qreal div);
QTransform &operator/=(qreal div);
QTransform &operator+=(qreal div);
QTransform &operator-=(qreal div);

static QTransform fromTranslate(qreal dx, qreal dy);
static QTransform fromScale(qreal dx, qreal dy);

private:
inline QTransform(qreal h11, qreal h12, qreal h13,
qreal h21, qreal h22, qreal h23,
qreal h31, qreal h32, qreal h33, bool)
: affine(h11, h12, h21, h22, h31, h32, true)
, m_13(h13), m_23(h23), m_33(h33)
, m_type(TxNone)
, m_dirty(TxProject) {}
inline QTransform(bool)
: affine(true)
, m_13(0), m_23(0), m_33(1)
, m_type(TxNone)
, m_dirty(TxNone) {}
inline TransformationType inline_type() const;
QMatrix affine;
qreal m_13;
qreal m_23;
qreal m_33;

mutable uint m_type : 5;
mutable uint m_dirty : 5;

class Private;
Private *d;
};
template <> class QTypeInfo<QTransform > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTransform)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTransform"; } };


inline QTransform::TransformationType QTransform::inline_type() const
{
if (m_dirty == TxNone)
return static_cast<TransformationType>(m_type);
return type();
}

inline bool QTransform::isAffine() const
{
return inline_type() < TxProject;
}
inline bool QTransform::isIdentity() const
{
return inline_type() == TxNone;
}

inline bool QTransform::isInvertible() const
{
return !qFuzzyIsNull(determinant());
}

inline bool QTransform::isScaling() const
{
return type() >= TxScale;
}
inline bool QTransform::isRotating() const
{
return inline_type() >= TxRotate;
}

inline bool QTransform::isTranslating() const
{
return inline_type() >= TxTranslate;
}

inline qreal QTransform::determinant() const
{
return affine._m11*(m_33*affine._m22-affine._dy*m_23) -
affine._m21*(m_33*affine._m12-affine._dy*m_13)+affine._dx*(m_23*affine._m12-affine._m22*m_13);
}
inline qreal QTransform::det() const
{
return determinant();
}
inline qreal QTransform::m11() const
{
return affine._m11;
}
inline qreal QTransform::m12() const
{
return affine._m12;
}
inline qreal QTransform::m13() const
{
return m_13;
}
inline qreal QTransform::m21() const
{
return affine._m21;
}
inline qreal QTransform::m22() const
{
return affine._m22;
}
inline qreal QTransform::m23() const
{
return m_23;
}
inline qreal QTransform::m31() const
{
return affine._dx;
}
inline qreal QTransform::m32() const
{
return affine._dy;
}
inline qreal QTransform::m33() const
{
return m_33;
}
inline qreal QTransform::dx() const
{
return affine._dx;
}
inline qreal QTransform::dy() const
{
return affine._dy;
}

inline QTransform &QTransform::operator*=(qreal num)
{
if (num == 1.)
return *this;
affine._m11 *= num;
affine._m12 *= num;
m_13 *= num;
affine._m21 *= num;
affine._m22 *= num;
m_23 *= num;
affine._dx *= num;
affine._dy *= num;
m_33 *= num;
m_dirty |= TxScale;
return *this;
}
inline QTransform &QTransform::operator/=(qreal div)
{
if (div == 0)
return *this;
div = 1/div;
return operator*=(div);
}
inline QTransform &QTransform::operator+=(qreal num)
{
if (num == 0)
return *this;
affine._m11 += num;
affine._m12 += num;
m_13 += num;
affine._m21 += num;
affine._m22 += num;
m_23 += num;
affine._dx += num;
affine._dy += num;
m_33 += num;
m_dirty |= TxProject;
return *this;
}
inline QTransform &QTransform::operator-=(qreal num)
{
if (num == 0)
return *this;
affine._m11 -= num;
affine._m12 -= num;
m_13 -= num;
affine._m21 -= num;
affine._m22 -= num;
m_23 -= num;
affine._dx -= num;
affine._dy -= num;
m_33 -= num;
m_dirty |= TxProject;
return *this;
}

inline bool qFuzzyCompare(const QTransform& t1, const QTransform& t2)
{
return qFuzzyCompare(t1.m11(), t2.m11())
&& qFuzzyCompare(t1.m12(), t2.m12())
&& qFuzzyCompare(t1.m13(), t2.m13())
&& qFuzzyCompare(t1.m21(), t2.m21())
&& qFuzzyCompare(t1.m22(), t2.m22())
&& qFuzzyCompare(t1.m23(), t2.m23())
&& qFuzzyCompare(t1.m31(), t2.m31())
&& qFuzzyCompare(t1.m32(), t2.m32())
&& qFuzzyCompare(t1.m33(), t2.m33());
}




# 355 "/usr/share/qt4/include/QtGui/qtransform.h"
 QDataStream &operator<<(QDataStream &, const QTransform &);
 QDataStream &operator>>(QDataStream &, QTransform &);



# 360 "/usr/share/qt4/include/QtGui/qtransform.h"
 QDebug operator<<(QDebug, const QTransform &);

# 362 "/usr/share/qt4/include/QtGui/qtransform.h"



 inline QPoint operator*(const QPoint &p, const QTransform &m)
{ return m.map(p); }
 inline QPointF operator*(const QPointF &p, const QTransform &m)
{ return m.map(p); }
 inline QLineF operator*(const QLineF &l, const QTransform &m)
{ return m.map(l); }
 inline QLine operator*(const QLine &l, const QTransform &m)
{ return m.map(l); }
 inline QPolygon operator *(const QPolygon &a, const QTransform &m)
{ return m.map(a); }
 inline QPolygonF operator *(const QPolygonF &a, const QTransform &m)
{ return m.map(a); }
 inline QRegion operator *(const QRegion &r, const QTransform &m)
{ return m.map(r); }
 inline QPainterPath operator *(const QPainterPath &p, const QTransform &m)
{ return m.map(p); }

 inline QTransform operator *(const QTransform &a, qreal n)
{ QTransform t(a); t *= n; return t; }
 inline QTransform operator /(const QTransform &a, qreal n)
{ QTransform t(a); t /= n; return t; }
 inline QTransform operator +(const QTransform &a, qreal n)
{ QTransform t(a); t += n; return t; }
 inline QTransform operator -(const QTransform &a, qreal n)
{ QTransform t(a); t -= n; return t; }






# 51 "/usr/share/qt4/include/QtGui/qbrush.h"

# 1 "/usr/share/qt4/include/QtGui/qimage.h"












































# 1 "/usr/share/qt4/include/QtGui/qtransform.h"











































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qimage.h"

# 1 "/usr/share/qt4/include/QtGui/qpaintdevice.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 45 "/usr/share/qt4/include/QtGui/qpaintdevice.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qpaintdevice.h"


# 48 "/usr/share/qt4/include/QtGui/qpaintdevice.h"




typedef QtValidLicenseForGuiModule QtGuiModule;





# 58 "/usr/share/qt4/include/QtGui/qpaintdevice.h"
class QPaintEngine;

class  QPaintDevice 
{
public:
enum PaintDeviceMetric {
PdmWidth = 1,
PdmHeight,
PdmWidthMM,
PdmHeightMM,
PdmNumColors,
PdmDepth,
PdmDpiX,
PdmDpiY,
PdmPhysicalDpiX,
PdmPhysicalDpiY
};

virtual ~QPaintDevice();

virtual int devType() const;
bool paintingActive() const;
virtual QPaintEngine *paintEngine() const = 0;










# 91 "/usr/share/qt4/include/QtGui/qpaintdevice.h"
int width() const { return metric(PdmWidth); }
int height() const { return metric(PdmHeight); }
int widthMM() const { return metric(PdmWidthMM); }
int heightMM() const { return metric(PdmHeightMM); }
int logicalDpiX() const { return metric(PdmDpiX); }
int logicalDpiY() const { return metric(PdmDpiY); }
int physicalDpiX() const { return metric(PdmPhysicalDpiX); }
int physicalDpiY() const { return metric(PdmPhysicalDpiY); }

# 100 "/usr/share/qt4/include/QtGui/qpaintdevice.h"
 int numColors() const { return metric(PdmNumColors); }

# 102 "/usr/share/qt4/include/QtGui/qpaintdevice.h"
int colorCount() const { return metric(PdmNumColors); }
int depth() const { return metric(PdmDepth); }

protected:
QPaintDevice();
virtual int metric(PaintDeviceMetric metric) const;

ushort painters; 

private:
QPaintDevice(const QPaintDevice &); QPaintDevice &operator=(const QPaintDevice &);



























# 140 "/usr/share/qt4/include/QtGui/qpaintdevice.h"
friend class QPainter;
friend class QFontEngineMac;
friend class QX11PaintEngine;
friend  int qt_paint_device_metric(const QPaintDevice *device, PaintDeviceMetric metric);
};


















# 163 "/usr/share/qt4/include/QtGui/qpaintdevice.h"




inline int QPaintDevice::devType() const
{ return QInternal::UnknownDevice; }

inline bool QPaintDevice::paintingActive() const
{ return painters != 0; }






# 46 "/usr/share/qt4/include/QtGui/qimage.h"

# 1 "/usr/share/qt4/include/QtGui/qrgb.h"
























































































# 47 "/usr/share/qt4/include/QtGui/qimage.h"

# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qimage.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qimage.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qimage.h"


# 52 "/usr/share/qt4/include/QtGui/qimage.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QIODevice;
class QStringList;
class QMatrix;
class QTransform;
class QVariant;
template <class T> class QList;
template <class T> class QVector;

struct QImageData;
class QImageDataMisc; 

# 69 "/usr/share/qt4/include/QtGui/qimage.h"
class  QImageTextKeyLang {
public:
QImageTextKeyLang(const char* k, const char* l) : key(k), lang(l) { }
QImageTextKeyLang() { }

QByteArray key;
QByteArray lang;

bool operator< (const QImageTextKeyLang& other) const
{ return key < other.key || (key==other.key && lang < other.lang); }
bool operator== (const QImageTextKeyLang& other) const
{ return key==other.key && lang==other.lang; }
inline bool operator!= (const QImageTextKeyLang &other) const
{ return !operator==(other); }
};



# 87 "/usr/share/qt4/include/QtGui/qimage.h"
class  QImage : public QPaintDevice
{
public:
enum InvertMode { InvertRgb, InvertRgba };
enum Format {
Format_Invalid,
Format_Mono,
Format_MonoLSB,
Format_Indexed8,
Format_RGB32,
Format_ARGB32,
Format_ARGB32_Premultiplied,
Format_RGB16,
Format_ARGB8565_Premultiplied,
Format_RGB666,
Format_ARGB6666_Premultiplied,
Format_RGB555,
Format_ARGB8555_Premultiplied,
Format_RGB888,
Format_RGB444,
Format_ARGB4444_Premultiplied,











# 119 "/usr/share/qt4/include/QtGui/qimage.h"
NImageFormats

# 121 "/usr/share/qt4/include/QtGui/qimage.h"
};

QImage();
QImage(const QSize &size, Format format);
QImage(int width, int height, Format format);
QImage(uchar *data, int width, int height, Format format);
QImage(const uchar *data, int width, int height, Format format);
QImage(uchar *data, int width, int height, int bytesPerLine, Format format);
QImage(const uchar *data, int width, int height, int bytesPerLine, Format format);


# 132 "/usr/share/qt4/include/QtGui/qimage.h"
explicit QImage(const char * const xpm[]);

# 134 "/usr/share/qt4/include/QtGui/qimage.h"
explicit QImage(const QString &fileName, const char *format = 0);

# 136 "/usr/share/qt4/include/QtGui/qimage.h"
explicit QImage(const char *fileName, const char *format = 0);


# 139 "/usr/share/qt4/include/QtGui/qimage.h"
QImage(const QImage &);
~QImage();

QImage &operator=(const QImage &);
bool isNull() const;

int devType() const;

bool operator==(const QImage &) const;
bool operator!=(const QImage &) const;
operator QVariant() const;
void detach();
bool isDetached() const;

QImage copy(const QRect &rect = QRect()) const;
inline QImage copy(int x, int y, int w, int h) const
{ return copy(QRect(x, y, w, h)); }

Format format() const;

QImage convertToFormat(Format f, Qt::ImageConversionFlags flags = Qt::AutoColor) const ;
QImage convertToFormat(Format f, const QVector<QRgb> &colorTable, Qt::ImageConversionFlags flags = Qt::AutoColor) const ;

int width() const;
int height() const;
QSize size() const;
QRect rect() const;

int depth() const;

# 169 "/usr/share/qt4/include/QtGui/qimage.h"
 int numColors() const;

# 171 "/usr/share/qt4/include/QtGui/qimage.h"
int colorCount() const;

QRgb color(int i) const;
void setColor(int i, QRgb c);

# 176 "/usr/share/qt4/include/QtGui/qimage.h"
 void setNumColors(int);

# 178 "/usr/share/qt4/include/QtGui/qimage.h"
void setColorCount(int);

bool allGray() const;
bool isGrayscale() const;

uchar *bits();
const uchar *bits() const;

# 186 "/usr/share/qt4/include/QtGui/qimage.h"
 int numBytes() const;

# 188 "/usr/share/qt4/include/QtGui/qimage.h"
int byteCount() const;

uchar *scanLine(int);
const uchar *scanLine(int) const;
int bytesPerLine() const;

bool valid(int x, int y) const;
bool valid(const QPoint &pt) const;

int pixelIndex(int x, int y) const;
int pixelIndex(const QPoint &pt) const;

QRgb pixel(int x, int y) const;
QRgb pixel(const QPoint &pt) const;

void setPixel(int x, int y, uint index_or_rgb);
void setPixel(const QPoint &pt, uint index_or_rgb);

QVector<QRgb> colorTable() const;
void setColorTable(const QVector<QRgb> colors);

void fill(uint pixel);

bool hasAlphaChannel() const;
void setAlphaChannel(const QImage &alphaChannel);
QImage alphaChannel() const;
QImage createAlphaMask(Qt::ImageConversionFlags flags = Qt::AutoColor) const;

# 216 "/usr/share/qt4/include/QtGui/qimage.h"
QImage createHeuristicMask(bool clipTight = true) const;

# 218 "/usr/share/qt4/include/QtGui/qimage.h"
QImage createMaskFromColor(QRgb color, Qt::MaskMode mode = Qt::MaskInColor) const;

inline QImage scaled(int w, int h, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,
Qt::TransformationMode mode = Qt::FastTransformation) const
{ return scaled(QSize(w, h), aspectMode, mode); }
QImage scaled(const QSize &s, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,
Qt::TransformationMode mode = Qt::FastTransformation) const;
QImage scaledToWidth(int w, Qt::TransformationMode mode = Qt::FastTransformation) const;
QImage scaledToHeight(int h, Qt::TransformationMode mode = Qt::FastTransformation) const;
QImage transformed(const QMatrix &matrix, Qt::TransformationMode mode = Qt::FastTransformation) const;
static QMatrix trueMatrix(const QMatrix &, int w, int h);
QImage transformed(const QTransform &matrix, Qt::TransformationMode mode = Qt::FastTransformation) const;
static QTransform trueMatrix(const QTransform &, int w, int h);
QImage mirrored(bool horizontally = false, bool vertically = true) const;
QImage rgbSwapped() const;
void invertPixels(InvertMode = InvertRgb);


bool load(QIODevice *device, const char* format);
bool load(const QString &fileName, const char* format=0);
bool loadFromData(const uchar *buf, int len, const char *format = 0);
inline bool loadFromData(const QByteArray &data, const char* aformat=0)
{ return loadFromData(reinterpret_cast<const uchar *>(data.constData()), data.size(), aformat); }

bool save(const QString &fileName, const char* format=0, int quality=-1) const;
bool save(QIODevice *device, const char* format=0, int quality=-1) const;

static QImage fromData(const uchar *data, int size, const char *format = 0);
inline static QImage fromData(const QByteArray &data, const char *format = 0)
{ return fromData(reinterpret_cast<const uchar *>(data.constData()), data.size(), format); }

int serialNumber() const;
qint64 cacheKey() const;

QPaintEngine *paintEngine() const;


int dotsPerMeterX() const;
int dotsPerMeterY() const;
void setDotsPerMeterX(int);
void setDotsPerMeterY(int);
QPoint offset() const;
void setOffset(const QPoint&);

# 262 "/usr/share/qt4/include/QtGui/qimage.h"
QStringList textKeys() const;
QString text(const QString &key = QString()) const;
void setText(const QString &key, const QString &value);


QString text(const char* key, const char* lang=0) const;
QList<QImageTextKeyLang> textList() const;
QStringList textLanguages() const;
QString text(const QImageTextKeyLang&) const;
void setText(const char* key, const char* lang, const QString&);














































# 318 "/usr/share/qt4/include/QtGui/qimage.h"
protected:
virtual int metric(PaintDeviceMetric metric) const;

private:
friend class QWSOnScreenSurface;
QImageData *d;

friend class QRasterPixmapData;
friend class QPixmapCacheEntry;
friend  qint64 qt_image_id(const QImage &image);
friend const QVector<QRgb> *qt_image_colortable(const QImage &image);

public:
typedef QImageData * DataPtr;
inline DataPtr &data_ptr() { return d; }
};

template <> inline bool qIsDetached<QImage>(QImage &t) { return t.isDetached(); } template <> inline void qSwap<QImage>(QImage &value1, QImage &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }
template <> class QTypeInfo<QImage > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QImage)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QImage"; } };



 inline bool QImage::valid(const QPoint &pt) const { return valid(pt.x(), pt.y()); }
 inline int QImage::pixelIndex(const QPoint &pt) const { return pixelIndex(pt.x(), pt.y());}
 inline QRgb QImage::pixel(const QPoint &pt) const { return pixel(pt.x(), pt.y()); }
 inline void QImage::setPixel(const QPoint &pt, uint index_or_rgb) { setPixel(pt.x(), pt.y(), index_or_rgb); }




# 348 "/usr/share/qt4/include/QtGui/qimage.h"
 QDataStream &operator<<(QDataStream &, const QImage &);
 QDataStream &operator>>(QDataStream &, QImage &);







# 357 "/usr/share/qt4/include/QtGui/qimage.h"





# 52 "/usr/share/qt4/include/QtGui/qbrush.h"

# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"












































# 1 "/usr/share/qt4/include/QtGui/qpaintdevice.h"















































































































































































# 45 "/usr/share/qt4/include/QtGui/qpixmap.h"

# 1 "/usr/share/qt4/include/QtGui/qcolor.h"

















































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qpixmap.h"

# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qpixmap.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qpixmap.h"

# 1 "/usr/share/qt4/include/QtCore/qsharedpointer.h"



























































































































































# 49 "/usr/share/qt4/include/QtGui/qpixmap.h"

# 1 "/usr/share/qt4/include/QtGui/qimage.h"









































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qpixmap.h"

# 1 "/usr/share/qt4/include/QtGui/qtransform.h"











































































































































































































































































































































































































# 51 "/usr/share/qt4/include/QtGui/qpixmap.h"


# 53 "/usr/share/qt4/include/QtGui/qpixmap.h"







# 60 "/usr/share/qt4/include/QtGui/qpixmap.h"


typedef QtValidLicenseForGuiModule QtGuiModule;

class QImageWriter;
class QColor;
class QVariant;
class QX11Info;
class QPixmapData;

class  QPixmap : public QPaintDevice
{
public:
QPixmap();
explicit QPixmap(QPixmapData *data);
QPixmap(int w, int h);
QPixmap(const QSize &);
QPixmap(const QString& fileName, const char *format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);

# 79 "/usr/share/qt4/include/QtGui/qpixmap.h"
QPixmap(const char * const xpm[]);

# 81 "/usr/share/qt4/include/QtGui/qpixmap.h"
QPixmap(const QPixmap &);
~QPixmap();

QPixmap &operator=(const QPixmap &);
operator QVariant() const;

bool isNull() const; 
int devType() const;

int width() const; 
int height() const; 
QSize size() const;
QRect rect() const;
int depth() const;

static int defaultDepth();

void fill(const QColor &fillColor = Qt::white);
void fill(const QWidget *widget, const QPoint &ofs);
inline void fill(const QWidget *widget, int xofs, int yofs) { fill(widget, QPoint(xofs, yofs)); }

QBitmap mask() const;
void setMask(const QBitmap &);

QPixmap alphaChannel() const;
void setAlphaChannel(const QPixmap &);

bool hasAlpha() const;
bool hasAlphaChannel() const;


# 112 "/usr/share/qt4/include/QtGui/qpixmap.h"
QBitmap createHeuristicMask(bool clipTight = true) const;

# 114 "/usr/share/qt4/include/QtGui/qpixmap.h"
QBitmap createMaskFromColor(const QColor &maskColor) const; 
QBitmap createMaskFromColor(const QColor &maskColor, Qt::MaskMode mode) const;

static QPixmap grabWindow(WId, int x=0, int y=0, int w=-1, int h=-1);
static QPixmap grabWidget(QWidget *widget, const QRect &rect);
static inline QPixmap grabWidget(QWidget *widget, int x=0, int y=0, int w=-1, int h=-1)
{ return grabWidget(widget, QRect(x, y, w, h)); }


inline QPixmap scaled(int w, int h, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,
Qt::TransformationMode mode = Qt::FastTransformation) const
{ return scaled(QSize(w, h), aspectMode, mode); }
QPixmap scaled(const QSize &s, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,
Qt::TransformationMode mode = Qt::FastTransformation) const;
QPixmap scaledToWidth(int w, Qt::TransformationMode mode = Qt::FastTransformation) const;
QPixmap scaledToHeight(int h, Qt::TransformationMode mode = Qt::FastTransformation) const;
QPixmap transformed(const QMatrix &, Qt::TransformationMode mode = Qt::FastTransformation) const;
static QMatrix trueMatrix(const QMatrix &m, int w, int h);
QPixmap transformed(const QTransform &, Qt::TransformationMode mode = Qt::FastTransformation) const;
static QTransform trueMatrix(const QTransform &m, int w, int h);

QImage toImage() const;
static QPixmap fromImage(const QImage &image, Qt::ImageConversionFlags flags = Qt::AutoColor);

bool load(const QString& fileName, const char *format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
bool loadFromData(const uchar *buf, uint len, const char* format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
inline bool loadFromData(const QByteArray &data, const char* format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
bool save(const QString& fileName, const char* format = 0, int quality = -1) const;
bool save(QIODevice* device, const char* format = 0, int quality = -1) const;



























# 170 "/usr/share/qt4/include/QtGui/qpixmap.h"
inline QPixmap copy(int x, int y, int width, int height) const;
QPixmap copy(const QRect &rect = QRect()) const;

inline void scroll(int dx, int dy, int x, int y, int width, int height, QRegion *exposed = 0);
void scroll(int dx, int dy, const QRect &rect, QRegion *exposed = 0);

int serialNumber() const;
qint64 cacheKey() const;

bool isDetached() const;
void detach();

bool isQBitmap() const;



























# 210 "/usr/share/qt4/include/QtGui/qpixmap.h"
QPaintEngine *paintEngine() const;

inline bool operator!() const { return isNull(); }

protected:
int metric(PaintDeviceMetric) const;























# 239 "/usr/share/qt4/include/QtGui/qpixmap.h"
private:
QExplicitlySharedDataPointer<QPixmapData> data;

bool doImageIO(QImageWriter *io, int quality) const;


enum Type { PixmapType, BitmapType }; 
QPixmap(const QSize &s, Type);
void init(int, int, Type = PixmapType);

QPixmap(const QSize &s, int type);
void init(int, int, int);
void deref();



# 255 "/usr/share/qt4/include/QtGui/qpixmap.h"








# 263 "/usr/share/qt4/include/QtGui/qpixmap.h"
friend class QPixmapData;
friend class QX11PixmapData;
friend class QMacPixmapData;
friend class QS60PixmapData;
friend class QBitmap;
friend class QPaintDevice;
friend class QPainter;
friend class QGLWidget;
friend class QX11PaintEngine;
friend class QCoreGraphicsPaintEngine;
friend class QWidgetPrivate;
friend class QRasterPaintEngine;
friend class QRasterBuffer;
friend class QPixmapCacheEntry;

# 278 "/usr/share/qt4/include/QtGui/qpixmap.h"
friend  QDataStream &operator>>(QDataStream &, QPixmap &);

# 280 "/usr/share/qt4/include/QtGui/qpixmap.h"
friend  qint64 qt_pixmap_id(const QPixmap &pixmap);

public:
QPixmapData* pixmapData() const;

public:
typedef QExplicitlySharedDataPointer<QPixmapData> DataPtr;
inline DataPtr &data_ptr() { return data; }
};

template <> inline bool qIsDetached<QPixmap>(QPixmap &t) { return t.isDetached(); } template <> inline void qSwap<QPixmap>(QPixmap &value1, QPixmap &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }

inline QPixmap QPixmap::copy(int ax, int ay, int awidth, int aheight) const
{
return copy(QRect(ax, ay, awidth, aheight));
}

inline void QPixmap::scroll(int dx, int dy, int ax, int ay, int awidth, int aheight, QRegion *exposed)
{
scroll(dx, dy, QRect(ax, ay, awidth, aheight), exposed);
}

inline bool QPixmap::loadFromData(const QByteArray &buf, const char *format,
Qt::ImageConversionFlags flags)
{
return loadFromData(reinterpret_cast<const uchar *>(buf.constData()), buf.size(), format, flags);
}






# 313 "/usr/share/qt4/include/QtGui/qpixmap.h"
 QDataStream &operator<<(QDataStream &, const QPixmap &);
 QDataStream &operator>>(QDataStream &, QPixmap &);


# 317 "/usr/share/qt4/include/QtGui/qpixmap.h"








# 325 "/usr/share/qt4/include/QtGui/qpixmap.h"





# 53 "/usr/share/qt4/include/QtGui/qbrush.h"











# 64 "/usr/share/qt4/include/QtGui/qbrush.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

struct QBrushData;
class QPixmap;
class QGradient;
class QVariant;
struct QBrushDataPointerDeleter;

class  QBrush
{
public:
QBrush();
QBrush(Qt::BrushStyle bs);
QBrush(const QColor &color, Qt::BrushStyle bs=Qt::SolidPattern);
QBrush(Qt::GlobalColor color, Qt::BrushStyle bs=Qt::SolidPattern);

QBrush(const QColor &color, const QPixmap &pixmap);
QBrush(Qt::GlobalColor color, const QPixmap &pixmap);
QBrush(const QPixmap &pixmap);
QBrush(const QImage &image);

QBrush(const QBrush &brush);

QBrush(const QGradient &gradient);

~QBrush();
QBrush &operator=(const QBrush &brush);
operator QVariant() const;

inline Qt::BrushStyle style() const;
void setStyle(Qt::BrushStyle);

inline const QMatrix &matrix() const;
void setMatrix(const QMatrix &mat);

inline QTransform transform() const;
void setTransform(const QTransform &);

QPixmap texture() const;
void setTexture(const QPixmap &pixmap);

QImage textureImage() const;
void setTextureImage(const QImage &image);

inline const QColor &color() const;
void setColor(const QColor &color);
inline void setColor(Qt::GlobalColor color);

const QGradient *gradient() const;

bool isOpaque() const;

bool operator==(const QBrush &b) const;
inline bool operator!=(const QBrush &b) const { return !(operator==(b)); }







# 129 "/usr/share/qt4/include/QtGui/qbrush.h"
private:



# 133 "/usr/share/qt4/include/QtGui/qbrush.h"
friend class QRasterPaintEngine;
friend class QRasterPaintEnginePrivate;
friend struct QSpanData;
friend class QPainter;
friend bool  qHasPixmapTexture(const QBrush& brush);
void detach(Qt::BrushStyle newStyle);
void init(const QColor &color, Qt::BrushStyle bs);
QScopedPointer<QBrushData, QBrushDataPointerDeleter> d;
void cleanUp(QBrushData *x);

public:
inline bool isDetached() const;
typedef QScopedPointer<QBrushData, QBrushDataPointerDeleter> DataPtr;
inline DataPtr &data_ptr() { return d; }
};

inline void QBrush::setColor(Qt::GlobalColor acolor)
{ setColor(QColor(acolor)); }

template <> class QTypeInfo<QBrush > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QBrush)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QBrush"; } };
template <> inline bool qIsDetached<QBrush>(QBrush &t) { return t.isDetached(); } template <> inline void qSwap<QBrush>(QBrush &value1, QBrush &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }






# 160 "/usr/share/qt4/include/QtGui/qbrush.h"
 QDataStream &operator<<(QDataStream &, const QBrush &);
 QDataStream &operator>>(QDataStream &, QBrush &);



# 165 "/usr/share/qt4/include/QtGui/qbrush.h"
 QDebug operator<<(QDebug, const QBrush &);


# 168 "/usr/share/qt4/include/QtGui/qbrush.h"
struct QBrushData
{
QAtomicInt ref;
Qt::BrushStyle style;
QColor color;
QTransform transform;
};

inline Qt::BrushStyle QBrush::style() const { return d->style; }
inline const QColor &QBrush::color() const { return d->color; }
inline const QMatrix &QBrush::matrix() const { return d->transform.toAffine(); }
inline QTransform QBrush::transform() const { return d->transform; }
inline bool QBrush::isDetached() const { return d->ref == 1; }






# 187 "/usr/share/qt4/include/QtGui/qbrush.h"



class QGradientPrivate;

typedef QPair<qreal, QColor> QGradientStop;
typedef QVector<QGradientStop> QGradientStops;

class  QGradient
{

Q_ENUMS(Type Spread CoordinateMode)
public:
enum Type {
LinearGradient,
RadialGradient,
ConicalGradient,
NoGradient
};

enum Spread {
PadSpread,
ReflectSpread,
RepeatSpread
};

enum CoordinateMode {
LogicalMode,
StretchToDeviceMode,
ObjectBoundingMode
};

enum InterpolationMode {
ColorInterpolation,
ComponentInterpolation
};

QGradient();

Type type() const { return m_type; }

inline void setSpread(Spread spread);
Spread spread() const { return m_spread; }

void setColorAt(qreal pos, const QColor &color);

void setStops(const QGradientStops &stops);
QGradientStops stops() const;

CoordinateMode coordinateMode() const;
void setCoordinateMode(CoordinateMode mode);

InterpolationMode interpolationMode() const;
void setInterpolationMode(InterpolationMode mode);

bool operator==(const QGradient &gradient) const;
inline bool operator!=(const QGradient &other) const
{ return !operator==(other); }

bool operator==(const QGradient &gradient); 

private:
friend class QLinearGradient;
friend class QRadialGradient;
friend class QConicalGradient;

Type m_type;
Spread m_spread;
QGradientStops m_stops;
union {
struct {
qreal x1, y1, x2, y2;
} linear;
struct {
qreal cx, cy, fx, fy, radius;
} radial;
struct {
qreal cx, cy, angle;
} conical;
} m_data;
void *dummy;
};

inline void QGradient::setSpread(Spread aspread)
{ m_spread = aspread; }

class  QLinearGradient : public QGradient
{
public:
QLinearGradient();
QLinearGradient(const QPointF &start, const QPointF &finalStop);
QLinearGradient(qreal xStart, qreal yStart, qreal xFinalStop, qreal yFinalStop);

QPointF start() const;
void setStart(const QPointF &start);
inline void setStart(qreal x, qreal y) { setStart(QPointF(x, y)); }

QPointF finalStop() const;
void setFinalStop(const QPointF &stop);
inline void setFinalStop(qreal x, qreal y) { setFinalStop(QPointF(x, y)); }
};


class  QRadialGradient : public QGradient
{
public:
QRadialGradient();
QRadialGradient(const QPointF &center, qreal radius, const QPointF &focalPoint);
QRadialGradient(qreal cx, qreal cy, qreal radius, qreal fx, qreal fy);

QRadialGradient(const QPointF &center, qreal radius);
QRadialGradient(qreal cx, qreal cy, qreal radius);

QPointF center() const;
void setCenter(const QPointF &center);
inline void setCenter(qreal x, qreal y) { setCenter(QPointF(x, y)); }

QPointF focalPoint() const;
void setFocalPoint(const QPointF &focalPoint);
inline void setFocalPoint(qreal x, qreal y) { setFocalPoint(QPointF(x, y)); }

qreal radius() const;
void setRadius(qreal radius);
};


class  QConicalGradient : public QGradient
{
public:
QConicalGradient();
QConicalGradient(const QPointF &center, qreal startAngle);
QConicalGradient(qreal cx, qreal cy, qreal startAngle);

QPointF center() const;
void setCenter(const QPointF &center);
inline void setCenter(qreal x, qreal y) { setCenter(QPointF(x, y)); }

qreal angle() const;
void setAngle(qreal angle);
};






# 4 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcolor.h"

















































































































































































































































































































# 5 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcolormap.h"












































# 1 "/usr/share/qt4/include/QtCore/qatomic.h"























































































































































































































# 45 "/usr/share/qt4/include/QtGui/qcolormap.h"

# 1 "/usr/share/qt4/include/QtGui/qrgb.h"
























































































# 46 "/usr/share/qt4/include/QtGui/qcolormap.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qcolormap.h"

# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 48 "/usr/share/qt4/include/QtGui/qcolormap.h"


# 50 "/usr/share/qt4/include/QtGui/qcolormap.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QColor;
class QColormapPrivate;

class  QColormap
{
public:
enum Mode { Direct, Indexed, Gray };

static void initialize();
static void cleanup();

static QColormap instance(int screen = -1);

QColormap(const QColormap &colormap);
~QColormap();

QColormap &operator=(const QColormap &colormap);

Mode mode() const;

int depth() const;
int size() const;

uint pixel(const QColor &color) const;
const QColor colorAt(uint pixel) const;

const QVector<QColor> colormap() const;





# 88 "/usr/share/qt4/include/QtGui/qcolormap.h"
private:
QColormap();
QColormapPrivate *d;
};






# 6 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qdrawutil.h"












































# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qdrawutil.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qdrawutil.h"

# 1 "/usr/share/qt4/include/QtCore/qmargins.h"

















































































































































# 47 "/usr/share/qt4/include/QtGui/qdrawutil.h"

# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qdrawutil.h"

# 49 "/usr/share/qt4/include/QtGui/qdrawutil.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QPainter;

# 57 "/usr/share/qt4/include/QtGui/qdrawutil.h"
class QColorGroup;

# 59 "/usr/share/qt4/include/QtGui/qdrawutil.h"
class QPalette;
class QPoint;
class QColor;
class QBrush;
class QRect;





 void qDrawShadeLine(QPainter *p, int x1, int y1, int x2, int y2,
const QPalette &pal, bool sunken = true,
int lineWidth = 1, int midLineWidth = 0);

 void qDrawShadeLine(QPainter *p, const QPoint &p1, const QPoint &p2,
const QPalette &pal, bool sunken = true,
int lineWidth = 1, int midLineWidth = 0);

 void qDrawShadeRect(QPainter *p, int x, int y, int w, int h,
const QPalette &pal, bool sunken = false,
int lineWidth = 1, int midLineWidth = 0,
const QBrush *fill = 0);

 void qDrawShadeRect(QPainter *p, const QRect &r,
const QPalette &pal, bool sunken = false,
int lineWidth = 1, int midLineWidth = 0,
const QBrush *fill = 0);

 void qDrawShadePanel(QPainter *p, int x, int y, int w, int h,
const QPalette &pal, bool sunken = false,
int lineWidth = 1, const QBrush *fill = 0);

 void qDrawShadePanel(QPainter *p, const QRect &r,
const QPalette &pal, bool sunken = false,
int lineWidth = 1, const QBrush *fill = 0);

 void qDrawWinButton(QPainter *p, int x, int y, int w, int h,
const QPalette &pal, bool sunken = false,
const QBrush *fill = 0);

 void qDrawWinButton(QPainter *p, const QRect &r,
const QPalette &pal, bool sunken = false,
const QBrush *fill = 0);

 void qDrawWinPanel(QPainter *p, int x, int y, int w, int h,
const QPalette &pal, bool sunken = false,
const QBrush *fill = 0);

 void qDrawWinPanel(QPainter *p, const QRect &r,
const QPalette &pal, bool sunken = false,
const QBrush *fill = 0);

 void qDrawPlainRect(QPainter *p, int x, int y, int w, int h, const QColor &,
int lineWidth = 1, const QBrush *fill = 0);

 void qDrawPlainRect(QPainter *p, const QRect &r, const QColor &,
int lineWidth = 1, const QBrush *fill = 0);




















# 136 "/usr/share/qt4/include/QtGui/qdrawutil.h"
struct QTileRules
{
inline QTileRules(Qt::TileRule horizontalRule, Qt::TileRule verticalRule)
: horizontal(horizontalRule), vertical(verticalRule) {}
inline QTileRules(Qt::TileRule rule = Qt::StretchTile)
: horizontal(rule), vertical(rule) {}
Qt::TileRule horizontal;
Qt::TileRule vertical;
};


# 147 "/usr/share/qt4/include/QtGui/qdrawutil.h"

namespace QDrawBorderPixmap
{
enum DrawingHint
{
OpaqueTopLeft = 0x0001,
OpaqueTop = 0x0002,
OpaqueTopRight = 0x0004,
OpaqueLeft = 0x0008,
OpaqueCenter = 0x0010,
OpaqueRight = 0x0020,
OpaqueBottomLeft = 0x0040,
OpaqueBottom = 0x0080,
OpaqueBottomRight = 0x0100,
OpaqueCorners = OpaqueTopLeft | OpaqueTopRight | OpaqueBottomLeft | OpaqueBottomRight,
OpaqueEdges = OpaqueTop | OpaqueLeft | OpaqueRight | OpaqueBottom,
OpaqueFrame = OpaqueCorners | OpaqueEdges,
OpaqueAll = OpaqueCenter | OpaqueFrame
};

typedef QFlags<DrawingHint> DrawingHints;
}


# 171 "/usr/share/qt4/include/QtGui/qdrawutil.h"
 void qDrawBorderPixmap(QPainter *painter,
const QRect &targetRect,
const QMargins &targetMargins,
const QPixmap &pixmap,
const QRect &sourceRect,
const QMargins &sourceMargins,
const QTileRules &rules = QTileRules()

# 179 "/usr/share/qt4/include/QtGui/qdrawutil.h"
, QDrawBorderPixmap::DrawingHints hints = 0

# 181 "/usr/share/qt4/include/QtGui/qdrawutil.h"
);

inline void qDrawBorderPixmap(QPainter *painter,
const QRect &target,
const QMargins &margins,
const QPixmap &pixmap)
{
qDrawBorderPixmap(painter, target, margins, pixmap, pixmap.rect(), margins);
}


namespace QDrawPixmaps
{
struct Data
{
QPointF point;
QRectF source;
qreal scaleX;
qreal scaleY;
qreal rotation;
qreal opacity;
};

enum DrawingHint
{
OpaqueHint = 0x01
};

typedef QFlags<DrawingHint> DrawingHints;
}


 void qDrawPixmaps(QPainter *painter, const QDrawPixmaps::Data *drawingData,
int dataCount, const QPixmap &pixmap, QDrawPixmaps::DrawingHints hints = 0);






# 7 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmatrix.h"












































































































































































































# 8 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpaintdevice.h"















































































































































































# 9 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpaintengine.h"












































# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qpaintengine.h"

# 1 "/usr/share/qt4/include/QtCore/qobjectdefs.h"































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qpaintengine.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 47 "/usr/share/qt4/include/QtGui/qpaintengine.h"

# 1 "/usr/share/qt4/include/QtGui/qpainter.h"












































# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 48 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtGui/qimage.h"









































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtGui/qtextoption.h"












































# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtextoption.h"

# 1 "/usr/share/qt4/include/QtCore/qchar.h"













































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qtextoption.h"

# 1 "/usr/share/qt4/include/QtCore/qmetatype.h"































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qtextoption.h"



# 50 "/usr/share/qt4/include/QtGui/qtextoption.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

template <typename T> class QList;
struct QTextOptionPrivate;

class  QTextOption
{
public:
enum TabType {
LeftTab,
RightTab,
CenterTab,
DelimiterTab
};

struct  Tab {
inline Tab() : position(80), type(QTextOption::LeftTab) { }

inline bool operator==(const Tab &other) const {
return type == other.type
&& qFuzzyCompare(position, other.position)
&& delimiter == other.delimiter;
}

inline bool operator!=(const Tab &other) const {
return !operator==(other);
}

qreal position;
TabType type;
QChar delimiter;
};

QTextOption();
QTextOption(Qt::Alignment alignment);
~QTextOption();

QTextOption(const QTextOption &o);
QTextOption &operator=(const QTextOption &o);

inline void setAlignment(Qt::Alignment alignment);
inline Qt::Alignment alignment() const { return Qt::Alignment(align); }

inline void setTextDirection(Qt::LayoutDirection aDirection) { this->direction = aDirection; }
inline Qt::LayoutDirection textDirection() const { return Qt::LayoutDirection(direction); }

enum WrapMode {
NoWrap,
WordWrap,
ManualWrap,
WrapAnywhere,
WrapAtWordBoundaryOrAnywhere
};
inline void setWrapMode(WrapMode wrap) { wordWrap = wrap; }
inline WrapMode wrapMode() const { return static_cast<WrapMode>(wordWrap); }

enum Flag {
ShowTabsAndSpaces = 0x1,
ShowLineAndParagraphSeparators = 0x2,
AddSpaceForLineAndParagraphSeparators = 0x4,
SuppressColors = 0x8,
IncludeTrailingSpaces = 0x80000000
};
typedef QFlags<Flag> Flags;
inline void setFlags(Flags flags);
inline Flags flags() const { return Flags(f); }

inline void setTabStop(qreal tabStop);
inline qreal tabStop() const { return tab; }

void setTabArray(QList<qreal> tabStops);
QList<qreal> tabArray() const;

void setTabs(QList<Tab> tabStops);
QList<Tab> tabs() const;

void setUseDesignMetrics(bool b) { design = b; }
bool useDesignMetrics() const { return design; }

private:
uint align : 8;
uint wordWrap : 4;
uint design : 1;
uint direction : 1;
uint unused : 19;
uint f;
qreal tab;
QTextOptionPrivate *d;
};

inline QFlags<QTextOption::Flags::enum_type> operator|(QTextOption::Flags::enum_type f1, QTextOption::Flags::enum_type f2) { return QFlags<QTextOption::Flags::enum_type>(f1) | f2; } inline QFlags<QTextOption::Flags::enum_type> operator|(QTextOption::Flags::enum_type f1, QFlags<QTextOption::Flags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTextOption::Flags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

inline void QTextOption::setAlignment(Qt::Alignment aalignment)
{ align = aalignment; }

inline void QTextOption::setFlags(Flags aflags)
{ f = aflags; }

inline void QTextOption::setTabStop(qreal atabStop)
{ tab = atabStop; }



 template <> struct QMetaTypeId< QTextOption::Tab  > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QTextOption::Tab  >("QTextOption::Tab "); return metatype_id; } }; 




# 51 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtGui/qdrawutil.h"




























































































































































































































# 52 "/usr/share/qt4/include/QtGui/qpainter.h"



# 1 "/usr/share/qt4/include/QtGui/qpolygon.h"




















































































































































































# 55 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtGui/qpen.h"












































# 1 "/usr/share/qt4/include/QtGui/qcolor.h"

















































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qpen.h"

# 1 "/usr/share/qt4/include/QtGui/qbrush.h"








































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qpen.h"


# 48 "/usr/share/qt4/include/QtGui/qpen.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QVariant;
class QPenPrivate;
class QBrush;
class QPen;


# 60 "/usr/share/qt4/include/QtGui/qpen.h"
 QDataStream &operator<<(QDataStream &, const QPen &);
 QDataStream &operator>>(QDataStream &, QPen &);


# 64 "/usr/share/qt4/include/QtGui/qpen.h"
class  QPen
{
public:
QPen();
QPen(Qt::PenStyle);
QPen(const QColor &color);
QPen(const QBrush &brush, qreal width, Qt::PenStyle s = Qt::SolidLine,
Qt::PenCapStyle c = Qt::SquareCap, Qt::PenJoinStyle j = Qt::BevelJoin);
QPen(const QPen &pen);

~QPen();

QPen &operator=(const QPen &pen);

Qt::PenStyle style() const;
void setStyle(Qt::PenStyle);

QVector<qreal> dashPattern() const;
void setDashPattern(const QVector<qreal> &pattern);

qreal dashOffset() const;
void setDashOffset(qreal doffset);

qreal miterLimit() const;
void setMiterLimit(qreal limit);

qreal widthF() const;
void setWidthF(qreal width);

int width() const;
void setWidth(int width);

QColor color() const;
void setColor(const QColor &color);

QBrush brush() const;
void setBrush(const QBrush &brush);

bool isSolid() const;

Qt::PenCapStyle capStyle() const;
void setCapStyle(Qt::PenCapStyle pcs);

Qt::PenJoinStyle joinStyle() const;
void setJoinStyle(Qt::PenJoinStyle pcs);

bool isCosmetic() const;
void setCosmetic(bool cosmetic);

bool operator==(const QPen &p) const;
inline bool operator!=(const QPen &p) const { return !(operator==(p)); }
operator QVariant() const;

bool isDetached();
private:
friend  QDataStream &operator>>(QDataStream &, QPen &);
friend  QDataStream &operator<<(QDataStream &, const QPen &);

void detach();
class QPenPrivate *d;

public:
typedef QPenPrivate * DataPtr;
inline DataPtr &data_ptr() { return d; }
};
template <> class QTypeInfo<QPen > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPen)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QPen"; } };
template <> inline bool qIsDetached<QPen>(QPen &t) { return t.isDetached(); } template <> inline void qSwap<QPen>(QPen &value1, QPen &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }


# 133 "/usr/share/qt4/include/QtGui/qpen.h"
 QDebug operator<<(QDebug, const QPen &);


# 136 "/usr/share/qt4/include/QtGui/qpen.h"





# 56 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtGui/qbrush.h"








































































































































































































































































































































# 57 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtGui/qmatrix.h"












































































































































































































# 58 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtGui/qtransform.h"











































































































































































































































































































































































































# 59 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtGui/qfontinfo.h"












































# 1 "/usr/share/qt4/include/QtGui/qfont.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 45 "/usr/share/qt4/include/QtGui/qfont.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qfont.h"

# 1 "/usr/share/qt4/include/QtCore/qsharedpointer.h"



























































































































































# 47 "/usr/share/qt4/include/QtGui/qfont.h"






# 53 "/usr/share/qt4/include/QtGui/qfont.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QFontPrivate; 
class QStringList;
class QVariant;
class Q3TextFormatCollection;

class  QFont
{

Q_ENUMS(StyleStrategy)
public:
enum StyleHint {
Helvetica, SansSerif = Helvetica,
Times, Serif = Times,
Courier, TypeWriter = Courier,
OldEnglish, Decorative = OldEnglish,
System,
AnyStyle
};

enum StyleStrategy {
PreferDefault = 0x0001,
PreferBitmap = 0x0002,
PreferDevice = 0x0004,
PreferOutline = 0x0008,
ForceOutline = 0x0010,
PreferMatch = 0x0020,
PreferQuality = 0x0040,
PreferAntialias = 0x0080,
NoAntialias = 0x0100,
OpenGLCompatible = 0x0200,
NoFontMerging = 0x8000
};

enum Weight {
Light = 25,
Normal = 50,
DemiBold = 63,
Bold = 75,
Black = 87
};

enum Style {
StyleNormal,
StyleItalic,
StyleOblique
};

enum Stretch {
UltraCondensed = 50,
ExtraCondensed = 62,
Condensed = 75,
SemiCondensed = 87,
Unstretched = 100,
SemiExpanded = 112,
Expanded = 125,
ExtraExpanded = 150,
UltraExpanded = 200
};

enum Capitalization {
MixedCase,
AllUppercase,
AllLowercase,
SmallCaps,
Capitalize
};

enum SpacingType {
PercentageSpacing,
AbsoluteSpacing
};

enum ResolveProperties {
FamilyResolved = 0x0001,
SizeResolved = 0x0002,
StyleHintResolved = 0x0004,
StyleStrategyResolved = 0x0008,
WeightResolved = 0x0010,
StyleResolved = 0x0020,
UnderlineResolved = 0x0040,
OverlineResolved = 0x0080,
StrikeOutResolved = 0x0100,
FixedPitchResolved = 0x0200,
StretchResolved = 0x0400,
KerningResolved = 0x0800,
CapitalizationResolved = 0x1000,
LetterSpacingResolved = 0x2000,
WordSpacingResolved = 0x4000,
AllPropertiesResolved = 0x7fff
};

QFont();
QFont(const QString &family, int pointSize = -1, int weight = -1, bool italic = false);
QFont(const QFont &, QPaintDevice *pd);
QFont(const QFont &);
~QFont();

QString family() const;
void setFamily(const QString &);

int pointSize() const;
void setPointSize(int);
qreal pointSizeF() const;
void setPointSizeF(qreal);

int pixelSize() const;
void setPixelSize(int);

int weight() const;
void setWeight(int);

inline bool bold() const;
inline void setBold(bool);

void setStyle(Style style);
Style style() const;

inline bool italic() const;
inline void setItalic(bool b);

bool underline() const;
void setUnderline(bool);

bool overline() const;
void setOverline(bool);

bool strikeOut() const;
void setStrikeOut(bool);

bool fixedPitch() const;
void setFixedPitch(bool);

bool kerning() const;
void setKerning(bool);

StyleHint styleHint() const;
StyleStrategy styleStrategy() const;
void setStyleHint(StyleHint, StyleStrategy = PreferDefault);
void setStyleStrategy(StyleStrategy s);

int stretch() const;
void setStretch(int);

qreal letterSpacing() const;
SpacingType letterSpacingType() const;
void setLetterSpacing(SpacingType type, qreal spacing);

qreal wordSpacing() const;
void setWordSpacing(qreal spacing);

void setCapitalization(Capitalization);
Capitalization capitalization() const;


bool rawMode() const;
void setRawMode(bool);


bool exactMatch() const;

QFont &operator=(const QFont &);
bool operator==(const QFont &) const;
bool operator!=(const QFont &) const;
bool operator<(const QFont &) const;
operator QVariant() const;
bool isCopyOf(const QFont &) const;





# 230 "/usr/share/qt4/include/QtGui/qfont.h"
Qt::HANDLE handle() const;








# 239 "/usr/share/qt4/include/QtGui/qfont.h"

void setRawName(const QString &);
QString rawName() const;

QString key() const;

QString toString() const;
bool fromString(const QString &);

static QString substitute(const QString &);
static QStringList substitutes(const QString &);
static QStringList substitutions();
static void insertSubstitution(const QString&, const QString &);
static void insertSubstitutions(const QString&, const QStringList &);
static void removeSubstitution(const QString &);
static void initialize();
static void cleanup();

# 257 "/usr/share/qt4/include/QtGui/qfont.h"
static void cacheStatistics();


# 260 "/usr/share/qt4/include/QtGui/qfont.h"
QString defaultFamily() const;
QString lastResortFamily() const;
QString lastResortFont() const;

QFont resolve(const QFont &) const;
inline uint resolve() const { return resolve_mask; }
inline void resolve(uint mask) { resolve_mask = mask; }









# 276 "/usr/share/qt4/include/QtGui/qfont.h"
private:
QFont(QFontPrivate *);

void detach();








# 288 "/usr/share/qt4/include/QtGui/qfont.h"
friend class QFontPrivate;
friend class QFontDialogPrivate;
friend class QFontMetrics;
friend class QFontMetricsF;
friend class QFontInfo;
friend class QPainter;
friend class QPSPrintEngineFont;
friend class QApplication;
friend class QWidget;
friend class QWidgetPrivate;
friend class Q3TextFormatCollection;
friend class QTextLayout;
friend class QTextEngine;
friend class QStackTextEngine;
friend class QTextLine;
friend struct QScriptLine;
friend class QGLContext;
friend class QWin32PaintEngine;
friend class QAlphaPaintEngine;
friend class QPainterPath;
friend class QTextItemInt;
friend class QPicturePaintEngine;
friend class QPainterReplayer;
friend class QPaintBufferEngine;
friend class QCommandLinkButtonPrivate;


# 315 "/usr/share/qt4/include/QtGui/qfont.h"
friend  QDataStream &operator<<(QDataStream &, const QFont &);
friend  QDataStream &operator>>(QDataStream &, QFont &);


# 319 "/usr/share/qt4/include/QtGui/qfont.h"
QExplicitlySharedDataPointer<QFontPrivate> d;
uint resolve_mask;
};


inline bool QFont::bold() const
{ return weight() > Normal; }


inline void QFont::setBold(bool enable)
{ setWeight(enable ? Bold : Normal); }

inline bool QFont::italic() const
{
return (style() != StyleNormal);
}

inline void QFont::setItalic(bool b) {
setStyle(b ? StyleItalic : StyleNormal);
}







# 346 "/usr/share/qt4/include/QtGui/qfont.h"
 QDataStream &operator<<(QDataStream &, const QFont &);
 QDataStream &operator>>(QDataStream &, QFont &);



# 351 "/usr/share/qt4/include/QtGui/qfont.h"
 QDebug operator<<(QDebug, const QFont &);


# 354 "/usr/share/qt4/include/QtGui/qfont.h"





# 45 "/usr/share/qt4/include/QtGui/qfontinfo.h"

# 1 "/usr/share/qt4/include/QtCore/qsharedpointer.h"



























































































































































# 46 "/usr/share/qt4/include/QtGui/qfontinfo.h"


# 48 "/usr/share/qt4/include/QtGui/qfontinfo.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class  QFontInfo
{
public:
QFontInfo(const QFont &);
QFontInfo(const QFontInfo &);
~QFontInfo();

QFontInfo &operator=(const QFontInfo &);

QString family() const;
int pixelSize() const;
int pointSize() const;
qreal pointSizeF() const;
bool italic() const;
QFont::Style style() const;
int weight() const;
inline bool bold() const { return weight() > QFont::Normal; }
bool underline() const;
bool overline() const;
bool strikeOut() const;
bool fixedPitch() const;
QFont::StyleHint styleHint() const;
bool rawMode() const;

bool exactMatch() const;

private:
QExplicitlySharedDataPointer<QFontPrivate> d;
};






# 60 "/usr/share/qt4/include/QtGui/qpainter.h"

# 1 "/usr/share/qt4/include/QtGui/qfontmetrics.h"












































# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qfontmetrics.h"

# 1 "/usr/share/qt4/include/QtCore/qsharedpointer.h"



























































































































































# 46 "/usr/share/qt4/include/QtGui/qfontmetrics.h"


# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qfontmetrics.h"



# 51 "/usr/share/qt4/include/QtGui/qfontmetrics.h"




typedef QtValidLicenseForGuiModule QtGuiModule;





# 61 "/usr/share/qt4/include/QtGui/qfontmetrics.h"
class QTextCodec;
class QRect;


class  QFontMetrics
{
public:
QFontMetrics(const QFont &);
QFontMetrics(const QFont &, QPaintDevice *pd);
QFontMetrics(const QFontMetrics &);
~QFontMetrics();

QFontMetrics &operator=(const QFontMetrics &);

int ascent() const;
int descent() const;
int height() const;
int leading() const;
int lineSpacing() const;
int minLeftBearing() const;
int minRightBearing() const;
int maxWidth() const;

int xHeight() const;
int averageCharWidth() const;

bool inFont(QChar) const;

int leftBearing(QChar) const;
int rightBearing(QChar) const;
int width(const QString &, int len = -1) const;

int width(QChar) const;
int charWidth(const QString &str, int pos) const;

QRect boundingRect(QChar) const;

QRect boundingRect(const QString &text) const;
QRect boundingRect(const QRect &r, int flags, const QString &text, int tabstops=0, int *tabarray=0) const;
inline QRect boundingRect(int x, int y, int w, int h, int flags, const QString &text,
int tabstops=0, int *tabarray=0) const
{ return boundingRect(QRect(x, y, w, h), flags, text, tabstops, tabarray); }
QSize size(int flags, const QString& str, int tabstops=0, int *tabarray=0) const;

QRect tightBoundingRect(const QString &text) const;

QString elidedText(const QString &text, Qt::TextElideMode mode, int width, int flags = 0) const;

int underlinePos() const;
int overlinePos() const;
int strikeOutPos() const;
int lineWidth() const;

bool operator==(const QFontMetrics &other); 
bool operator==(const QFontMetrics &other) const;
inline bool operator !=(const QFontMetrics &other) { return !operator==(other); } 
inline bool operator !=(const QFontMetrics &other) const { return !operator==(other); }










# 128 "/usr/share/qt4/include/QtGui/qfontmetrics.h"
private:



# 132 "/usr/share/qt4/include/QtGui/qfontmetrics.h"
friend class QFontMetricsF;
friend class QStackTextEngine;

QExplicitlySharedDataPointer<QFontPrivate> d;
};


class  QFontMetricsF
{
public:
QFontMetricsF(const QFont &);
QFontMetricsF(const QFont &, QPaintDevice *pd);
QFontMetricsF(const QFontMetrics &);
QFontMetricsF(const QFontMetricsF &);
~QFontMetricsF();

QFontMetricsF &operator=(const QFontMetricsF &);
QFontMetricsF &operator=(const QFontMetrics &);

qreal ascent() const;
qreal descent() const;
qreal height() const;
qreal leading() const;
qreal lineSpacing() const;
qreal minLeftBearing() const;
qreal minRightBearing() const;
qreal maxWidth() const;

qreal xHeight() const;
qreal averageCharWidth() const;

bool inFont(QChar) const;

qreal leftBearing(QChar) const;
qreal rightBearing(QChar) const;
qreal width(const QString &string) const;

qreal width(QChar) const;

QRectF boundingRect(const QString &string) const;
QRectF boundingRect(QChar) const;
QRectF boundingRect(const QRectF &r, int flags, const QString& string, int tabstops=0, int *tabarray=0) const;
QSizeF size(int flags, const QString& str, int tabstops=0, int *tabarray=0) const;

QRectF tightBoundingRect(const QString &text) const;

QString elidedText(const QString &text, Qt::TextElideMode mode, qreal width, int flags = 0) const;

qreal underlinePos() const;
qreal overlinePos() const;
qreal strikeOutPos() const;
qreal lineWidth() const;

bool operator==(const QFontMetricsF &other); 
bool operator==(const QFontMetricsF &other) const;
inline bool operator !=(const QFontMetricsF &other) { return !operator==(other); } 
inline bool operator !=(const QFontMetricsF &other) const { return !operator==(other); }

private:
QExplicitlySharedDataPointer<QFontPrivate> d;
};






# 61 "/usr/share/qt4/include/QtGui/qpainter.h"



# 64 "/usr/share/qt4/include/QtGui/qpainter.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QBrush;
class QFontInfo;
class QFontMetrics;
class QPaintDevice;
class QPainterPath;
class QPainterPrivate;
class QPen;
class QPolygon;
class QTextItem;
class QMatrix;
class QTransform;

class QPainterPrivateDeleter;

class  QPainter
{
inline QPainterPrivate* d_func() { return reinterpret_cast<QPainterPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPainterPrivate* d_func() const { return reinterpret_cast<const QPainterPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPainterPrivate;



public:
enum RenderHint {
Antialiasing = 0x01,
TextAntialiasing = 0x02,
SmoothPixmapTransform = 0x04,
HighQualityAntialiasing = 0x08,
NonCosmeticDefaultPen = 0x10
};

typedef QFlags<RenderHint> RenderHints;

QPainter();
explicit QPainter(QPaintDevice *);
~QPainter();

QPaintDevice *device() const;

bool begin(QPaintDevice *);
bool end();
bool isActive() const;

void initFrom(const QWidget *widget);

enum CompositionMode {
CompositionMode_SourceOver,
CompositionMode_DestinationOver,
CompositionMode_Clear,
CompositionMode_Source,
CompositionMode_Destination,
CompositionMode_SourceIn,
CompositionMode_DestinationIn,
CompositionMode_SourceOut,
CompositionMode_DestinationOut,
CompositionMode_SourceAtop,
CompositionMode_DestinationAtop,
CompositionMode_Xor,


CompositionMode_Plus,
CompositionMode_Multiply,
CompositionMode_Screen,
CompositionMode_Overlay,
CompositionMode_Darken,
CompositionMode_Lighten,
CompositionMode_ColorDodge,
CompositionMode_ColorBurn,
CompositionMode_HardLight,
CompositionMode_SoftLight,
CompositionMode_Difference,
CompositionMode_Exclusion,


RasterOp_SourceOrDestination,
RasterOp_SourceAndDestination,
RasterOp_SourceXorDestination,
RasterOp_NotSourceAndNotDestination,
RasterOp_NotSourceOrNotDestination,
RasterOp_NotSourceXorDestination,
RasterOp_NotSource,
RasterOp_NotSourceAndDestination,
RasterOp_SourceAndNotDestination
};
void setCompositionMode(CompositionMode mode);
CompositionMode compositionMode() const;

const QFont &font() const;
void setFont(const QFont &f);

QFontMetrics fontMetrics() const;
QFontInfo fontInfo() const;

void setPen(const QColor &color);
void setPen(const QPen &pen);
void setPen(Qt::PenStyle style);
const QPen &pen() const;

void setBrush(const QBrush &brush);
void setBrush(Qt::BrushStyle style);
const QBrush &brush() const;


void setBackgroundMode(Qt::BGMode mode);
Qt::BGMode backgroundMode() const;

QPoint brushOrigin() const;
inline void setBrushOrigin(int x, int y);
inline void setBrushOrigin(const QPoint &);
void setBrushOrigin(const QPointF &);

void setBackground(const QBrush &bg);
const QBrush &background() const;

qreal opacity() const;
void setOpacity(qreal opacity);


QRegion clipRegion() const;
QPainterPath clipPath() const;

void setClipRect(const QRectF &, Qt::ClipOperation op = Qt::ReplaceClip);
void setClipRect(const QRect &, Qt::ClipOperation op = Qt::ReplaceClip);
inline void setClipRect(int x, int y, int w, int h, Qt::ClipOperation op = Qt::ReplaceClip);

void setClipRegion(const QRegion &, Qt::ClipOperation op = Qt::ReplaceClip);

void setClipPath(const QPainterPath &path, Qt::ClipOperation op = Qt::ReplaceClip);

void setClipping(bool enable);
bool hasClipping() const;

void save();
void restore();


void setMatrix(const QMatrix &matrix, bool combine = false);
const QMatrix &matrix() const;
const QMatrix &deviceMatrix() const;
void resetMatrix();

void setTransform(const QTransform &transform, bool combine = false);
const QTransform &transform() const;
const QTransform &deviceTransform() const;
void resetTransform();

void setWorldMatrix(const QMatrix &matrix, bool combine = false);
const QMatrix &worldMatrix() const;

void setWorldTransform(const QTransform &matrix, bool combine = false);
const QTransform &worldTransform() const;

QMatrix combinedMatrix() const;
QTransform combinedTransform() const;

void setMatrixEnabled(bool enabled);
bool matrixEnabled() const;

void setWorldMatrixEnabled(bool enabled);
bool worldMatrixEnabled() const;

void scale(qreal sx, qreal sy);
void shear(qreal sh, qreal sv);
void rotate(qreal a);

void translate(const QPointF &offset);
inline void translate(const QPoint &offset);
inline void translate(qreal dx, qreal dy);

QRect window() const;
void setWindow(const QRect &window);
inline void setWindow(int x, int y, int w, int h);

QRect viewport() const;
void setViewport(const QRect &viewport);
inline void setViewport(int x, int y, int w, int h);

void setViewTransformEnabled(bool enable);
bool viewTransformEnabled() const;


void strokePath(const QPainterPath &path, const QPen &pen);
void fillPath(const QPainterPath &path, const QBrush &brush);
void drawPath(const QPainterPath &path);

inline void drawPoint(const QPointF &pt);
inline void drawPoint(const QPoint &p);
inline void drawPoint(int x, int y);

void drawPoints(const QPointF *points, int pointCount);
inline void drawPoints(const QPolygonF &points);
void drawPoints(const QPoint *points, int pointCount);
inline void drawPoints(const QPolygon &points);

inline void drawLine(const QLineF &line);
inline void drawLine(const QLine &line);
inline void drawLine(int x1, int y1, int x2, int y2);
inline void drawLine(const QPoint &p1, const QPoint &p2);
inline void drawLine(const QPointF &p1, const QPointF &p2);

void drawLines(const QLineF *lines, int lineCount);
inline void drawLines(const QVector<QLineF> &lines);
void drawLines(const QPointF *pointPairs, int lineCount);
inline void drawLines(const QVector<QPointF> &pointPairs);
void drawLines(const QLine *lines, int lineCount);
inline void drawLines(const QVector<QLine> &lines);
void drawLines(const QPoint *pointPairs, int lineCount);
inline void drawLines(const QVector<QPoint> &pointPairs);

inline void drawRect(const QRectF &rect);
inline void drawRect(int x1, int y1, int w, int h);
inline void drawRect(const QRect &rect);

void drawRects(const QRectF *rects, int rectCount);
inline void drawRects(const QVector<QRectF> &rectangles);
void drawRects(const QRect *rects, int rectCount);
inline void drawRects(const QVector<QRect> &rectangles);

void drawEllipse(const QRectF &r);
void drawEllipse(const QRect &r);
inline void drawEllipse(int x, int y, int w, int h);

inline void drawEllipse(const QPointF &center, qreal rx, qreal ry);
inline void drawEllipse(const QPoint &center, int rx, int ry);

void drawPolyline(const QPointF *points, int pointCount);
inline void drawPolyline(const QPolygonF &polyline);
void drawPolyline(const QPoint *points, int pointCount);
inline void drawPolyline(const QPolygon &polygon);

void drawPolygon(const QPointF *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill);
inline void drawPolygon(const QPolygonF &polygon, Qt::FillRule fillRule = Qt::OddEvenFill);
void drawPolygon(const QPoint *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill);
inline void drawPolygon(const QPolygon &polygon, Qt::FillRule fillRule = Qt::OddEvenFill);

void drawConvexPolygon(const QPointF *points, int pointCount);
inline void drawConvexPolygon(const QPolygonF &polygon);
void drawConvexPolygon(const QPoint *points, int pointCount);
inline void drawConvexPolygon(const QPolygon &polygon);

void drawArc(const QRectF &rect, int a, int alen);
inline void drawArc(const QRect &, int a, int alen);
inline void drawArc(int x, int y, int w, int h, int a, int alen);

void drawPie(const QRectF &rect, int a, int alen);
inline void drawPie(int x, int y, int w, int h, int a, int alen);
inline void drawPie(const QRect &, int a, int alen);

void drawChord(const QRectF &rect, int a, int alen);
inline void drawChord(int x, int y, int w, int h, int a, int alen);
inline void drawChord(const QRect &, int a, int alen);

void drawRoundedRect(const QRectF &rect, qreal xRadius, qreal yRadius,
Qt::SizeMode mode = Qt::AbsoluteSize);
inline void drawRoundedRect(int x, int y, int w, int h, qreal xRadius, qreal yRadius,
Qt::SizeMode mode = Qt::AbsoluteSize);
inline void drawRoundedRect(const QRect &rect, qreal xRadius, qreal yRadius,
Qt::SizeMode mode = Qt::AbsoluteSize);

void drawRoundRect(const QRectF &r, int xround = 25, int yround = 25);
inline void drawRoundRect(int x, int y, int w, int h, int = 25, int = 25);
inline void drawRoundRect(const QRect &r, int xround = 25, int yround = 25);

void drawTiledPixmap(const QRectF &rect, const QPixmap &pm, const QPointF &offset = QPointF());
inline void drawTiledPixmap(int x, int y, int w, int h, const QPixmap &, int sx=0, int sy=0);
inline void drawTiledPixmap(const QRect &, const QPixmap &, const QPoint & = QPoint());

# 335 "/usr/share/qt4/include/QtGui/qpainter.h"
void drawPicture(const QPointF &p, const QPicture &picture);
inline void drawPicture(int x, int y, const QPicture &picture);
inline void drawPicture(const QPoint &p, const QPicture &picture);


# 340 "/usr/share/qt4/include/QtGui/qpainter.h"
void drawPixmap(const QRectF &targetRect, const QPixmap &pixmap, const QRectF &sourceRect);
inline void drawPixmap(const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect);
inline void drawPixmap(int x, int y, int w, int h, const QPixmap &pm,
int sx, int sy, int sw, int sh);
inline void drawPixmap(int x, int y, const QPixmap &pm,
int sx, int sy, int sw, int sh);
inline void drawPixmap(const QPointF &p, const QPixmap &pm, const QRectF &sr);
inline void drawPixmap(const QPoint &p, const QPixmap &pm, const QRect &sr);
void drawPixmap(const QPointF &p, const QPixmap &pm);
inline void drawPixmap(const QPoint &p, const QPixmap &pm);
inline void drawPixmap(int x, int y, const QPixmap &pm);
inline void drawPixmap(const QRect &r, const QPixmap &pm);
inline void drawPixmap(int x, int y, int w, int h, const QPixmap &pm);

void drawImage(const QRectF &targetRect, const QImage &image, const QRectF &sourceRect,
Qt::ImageConversionFlags flags = Qt::AutoColor);
inline void drawImage(const QRect &targetRect, const QImage &image, const QRect &sourceRect,
Qt::ImageConversionFlags flags = Qt::AutoColor);
inline void drawImage(const QPointF &p, const QImage &image, const QRectF &sr,
Qt::ImageConversionFlags flags = Qt::AutoColor);
inline void drawImage(const QPoint &p, const QImage &image, const QRect &sr,
Qt::ImageConversionFlags flags = Qt::AutoColor);
inline void drawImage(const QRectF &r, const QImage &image);
inline void drawImage(const QRect &r, const QImage &image);
void drawImage(const QPointF &p, const QImage &image);
inline void drawImage(const QPoint &p, const QImage &image);
inline void drawImage(int x, int y, const QImage &image, int sx = 0, int sy = 0,
int sw = -1, int sh = -1, Qt::ImageConversionFlags flags = Qt::AutoColor);

void setLayoutDirection(Qt::LayoutDirection direction);
Qt::LayoutDirection layoutDirection() const;

void drawText(const QPointF &p, const QString &s);
inline void drawText(const QPoint &p, const QString &s);
inline void drawText(int x, int y, const QString &s);

void drawText(const QPointF &p, const QString &str, int tf, int justificationPadding);

void drawText(const QRectF &r, int flags, const QString &text, QRectF *br=0);
void drawText(const QRect &r, int flags, const QString &text, QRect *br=0);
inline void drawText(int x, int y, int w, int h, int flags, const QString &text, QRect *br=0);

void drawText(const QRectF &r, const QString &text, const QTextOption &o = QTextOption());

QRectF boundingRect(const QRectF &rect, int flags, const QString &text);
QRect boundingRect(const QRect &rect, int flags, const QString &text);
inline QRect boundingRect(int x, int y, int w, int h, int flags, const QString &text);

QRectF boundingRect(const QRectF &rect, const QString &text, const QTextOption &o = QTextOption());

void drawTextItem(const QPointF &p, const QTextItem &ti);
inline void drawTextItem(int x, int y, const QTextItem &ti);
inline void drawTextItem(const QPoint &p, const QTextItem &ti);

void fillRect(const QRectF &, const QBrush &);
inline void fillRect(int x, int y, int w, int h, const QBrush &);
void fillRect(const QRect &, const QBrush &);

void fillRect(const QRectF &, const QColor &color);
inline void fillRect(int x, int y, int w, int h, const QColor &color);
void fillRect(const QRect &, const QColor &color);

inline void fillRect(int x, int y, int w, int h, Qt::GlobalColor c);
inline void fillRect(const QRect &r, Qt::GlobalColor c);
inline void fillRect(const QRectF &r, Qt::GlobalColor c);

inline void fillRect(int x, int y, int w, int h, Qt::BrushStyle style);
inline void fillRect(const QRect &r, Qt::BrushStyle style);
inline void fillRect(const QRectF &r, Qt::BrushStyle style);

void eraseRect(const QRectF &);
inline void eraseRect(int x, int y, int w, int h);
inline void eraseRect(const QRect &);

void setRenderHint(RenderHint hint, bool on = true);
void setRenderHints(RenderHints hints, bool on = true);
RenderHints renderHints() const;
inline bool testRenderHint(RenderHint hint) const { return renderHints() & hint; }

QPaintEngine *paintEngine() const;

static void setRedirected(const QPaintDevice *device, QPaintDevice *replacement,
const QPoint& offset = QPoint());
static QPaintDevice *redirected(const QPaintDevice *device, QPoint *offset = 0);
static void restoreRedirected(const QPaintDevice *device);

void beginNativePainting();
void endNativePainting();










































































# 502 "/usr/share/qt4/include/QtGui/qpainter.h"
private:
QPainter(const QPainter &); QPainter &operator=(const QPainter &);
friend class Q3Painter;

QScopedPointer<QPainterPrivate> d_ptr;

friend class QFontEngine;
friend class QFontEngineBox;
friend class QFontEngineFT;
friend class QFontEngineMac;
friend class QFontEngineWin;
friend class QFontEngineXLFD;
friend class QWSManager;
friend class QPaintEngine;
friend class QPaintEngineExPrivate;
friend class QOpenGLPaintEngine;
friend class QX11PaintEngine;
friend class QX11PaintEnginePrivate;
friend class QWin32PaintEngine;
friend class QWin32PaintEnginePrivate;
friend class QRasterPaintEngine;
friend class QAlphaPaintEngine;
friend class QPreviewPaintEngine;
};

inline QFlags<QPainter::RenderHints::enum_type> operator|(QPainter::RenderHints::enum_type f1, QPainter::RenderHints::enum_type f2) { return QFlags<QPainter::RenderHints::enum_type>(f1) | f2; } inline QFlags<QPainter::RenderHints::enum_type> operator|(QPainter::RenderHints::enum_type f1, QFlags<QPainter::RenderHints::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QPainter::RenderHints::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }




inline void QPainter::drawLine(const QLineF &l)
{
drawLines(&l, 1);
}

inline void QPainter::drawLine(const QLine &line)
{
drawLines(&line, 1);
}

inline void QPainter::drawLine(int x1, int y1, int x2, int y2)
{
QLine l(x1, y1, x2, y2);
drawLines(&l, 1);
}

inline void QPainter::drawLine(const QPoint &p1, const QPoint &p2)
{
QLine l(p1, p2);
drawLines(&l, 1);
}

inline void QPainter::drawLine(const QPointF &p1, const QPointF &p2)
{
drawLine(QLineF(p1, p2));
}

inline void QPainter::drawLines(const QVector<QLineF> &lines)
{
drawLines(lines.constData(), lines.size());
}

inline void QPainter::drawLines(const QVector<QLine> &lines)
{
drawLines(lines.constData(), lines.size());
}

inline void QPainter::drawLines(const QVector<QPointF> &pointPairs)
{
drawLines(pointPairs.constData(), pointPairs.size() / 2);
}

inline void QPainter::drawLines(const QVector<QPoint> &pointPairs)
{
drawLines(pointPairs.constData(), pointPairs.size() / 2);
}

inline void QPainter::drawPolyline(const QPolygonF &polyline)
{
drawPolyline(polyline.constData(), polyline.size());
}

inline void QPainter::drawPolyline(const QPolygon &polyline)
{
drawPolyline(polyline.constData(), polyline.size());
}

inline void QPainter::drawPolygon(const QPolygonF &polygon, Qt::FillRule fillRule)
{
drawPolygon(polygon.constData(), polygon.size(), fillRule);
}

inline void QPainter::drawPolygon(const QPolygon &polygon, Qt::FillRule fillRule)
{
drawPolygon(polygon.constData(), polygon.size(), fillRule);
}

inline void QPainter::drawConvexPolygon(const QPolygonF &poly)
{
drawConvexPolygon(poly.constData(), poly.size());
}

inline void QPainter::drawConvexPolygon(const QPolygon &poly)
{
drawConvexPolygon(poly.constData(), poly.size());
}

inline void QPainter::drawRect(const QRectF &rect)
{
drawRects(&rect, 1);
}

inline void QPainter::drawRect(int x, int y, int w, int h)
{
QRect r(x, y, w, h);
drawRects(&r, 1);
}

inline void QPainter::drawRect(const QRect &r)
{
drawRects(&r, 1);
}

inline void QPainter::drawRects(const QVector<QRectF> &rects)
{
drawRects(rects.constData(), rects.size());
}

inline void QPainter::drawRects(const QVector<QRect> &rects)
{
drawRects(rects.constData(), rects.size());
}

inline void QPainter::drawPoint(const QPointF &p)
{
drawPoints(&p, 1);
}

inline void QPainter::drawPoint(int x, int y)
{
QPoint p(x, y);
drawPoints(&p, 1);
}

inline void QPainter::drawPoint(const QPoint &p)
{
drawPoints(&p, 1);
}

inline void QPainter::drawPoints(const QPolygonF &points)
{
drawPoints(points.constData(), points.size());
}

inline void QPainter::drawPoints(const QPolygon &points)
{
drawPoints(points.constData(), points.size());
}

inline void QPainter::drawRoundRect(int x, int y, int w, int h, int xRnd, int yRnd)
{
drawRoundRect(QRectF(x, y, w, h), xRnd, yRnd);
}

inline void QPainter::drawRoundRect(const QRect &rect, int xRnd, int yRnd)
{
drawRoundRect(QRectF(rect), xRnd, yRnd);
}

inline void QPainter::drawRoundedRect(int x, int y, int w, int h, qreal xRadius, qreal yRadius,
Qt::SizeMode mode)
{
drawRoundedRect(QRectF(x, y, w, h), xRadius, yRadius, mode);
}

inline void QPainter::drawRoundedRect(const QRect &rect, qreal xRadius, qreal yRadius,
Qt::SizeMode mode)
{
drawRoundedRect(QRectF(rect), xRadius, yRadius, mode);
}

inline void QPainter::drawEllipse(int x, int y, int w, int h)
{
drawEllipse(QRect(x, y, w, h));
}

inline void QPainter::drawEllipse(const QPointF &center, qreal rx, qreal ry)
{
drawEllipse(QRectF(center.x() - rx, center.y() - ry, 2 * rx, 2 * ry));
}

inline void QPainter::drawEllipse(const QPoint &center, int rx, int ry)
{
drawEllipse(QRect(center.x() - rx, center.y() - ry, 2 * rx, 2 * ry));
}

inline void QPainter::drawArc(const QRect &r, int a, int alen)
{
drawArc(QRectF(r), a, alen);
}

inline void QPainter::drawArc(int x, int y, int w, int h, int a, int alen)
{
drawArc(QRectF(x, y, w, h), a, alen);
}

inline void QPainter::drawPie(const QRect &rect, int a, int alen)
{
drawPie(QRectF(rect), a, alen);
}

inline void QPainter::drawPie(int x, int y, int w, int h, int a, int alen)
{
drawPie(QRectF(x, y, w, h), a, alen);
}

inline void QPainter::drawChord(const QRect &rect, int a, int alen)
{
drawChord(QRectF(rect), a, alen);
}

inline void QPainter::drawChord(int x, int y, int w, int h, int a, int alen)
{
drawChord(QRectF(x, y, w, h), a, alen);
}

inline void QPainter::setClipRect(int x, int y, int w, int h, Qt::ClipOperation op)
{
setClipRect(QRect(x, y, w, h), op);
}

inline void QPainter::eraseRect(const QRect &rect)
{
eraseRect(QRectF(rect));
}

inline void QPainter::eraseRect(int x, int y, int w, int h)
{
eraseRect(QRectF(x, y, w, h));
}

inline void QPainter::fillRect(int x, int y, int w, int h, const QBrush &b)
{
fillRect(QRect(x, y, w, h), b);
}

inline void QPainter::fillRect(int x, int y, int w, int h, const QColor &b)
{
fillRect(QRect(x, y, w, h), b);
}

inline void QPainter::fillRect(int x, int y, int w, int h, Qt::GlobalColor c)
{
fillRect(QRect(x, y, w, h), QColor(c));
}

inline void QPainter::fillRect(const QRect &r, Qt::GlobalColor c)
{
fillRect(r, QColor(c));
}

inline void QPainter::fillRect(const QRectF &r, Qt::GlobalColor c)
{
fillRect(r, QColor(c));
}

inline void QPainter::fillRect(int x, int y, int w, int h, Qt::BrushStyle style)
{
fillRect(QRectF(x, y, w, h), QBrush(style));
}

inline void QPainter::fillRect(const QRect &r, Qt::BrushStyle style)
{
fillRect(QRectF(r), QBrush(style));
}

inline void QPainter::fillRect(const QRectF &r, Qt::BrushStyle style)
{
fillRect(r, QBrush(style));
}


inline void QPainter::setBrushOrigin(int x, int y)
{
setBrushOrigin(QPoint(x, y));
}

inline void QPainter::setBrushOrigin(const QPoint &p)
{
setBrushOrigin(QPointF(p));
}

inline void QPainter::drawTiledPixmap(const QRect &rect, const QPixmap &pm, const QPoint &offset)
{
drawTiledPixmap(QRectF(rect), pm, QPointF(offset));
}

inline void QPainter::drawTiledPixmap(int x, int y, int w, int h, const QPixmap &pm, int sx, int sy)
{
drawTiledPixmap(QRectF(x, y, w, h), pm, QPointF(sx, sy));
}

inline void QPainter::drawPixmap(const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect)
{
drawPixmap(QRectF(targetRect), pixmap, QRectF(sourceRect));
}

inline void QPainter::drawPixmap(const QPoint &p, const QPixmap &pm)
{
drawPixmap(QPointF(p), pm);
}

inline void QPainter::drawPixmap(const QRect &r, const QPixmap &pm)
{
drawPixmap(QRectF(r), pm, QRectF());
}

inline void QPainter::drawPixmap(int x, int y, const QPixmap &pm)
{
drawPixmap(QPointF(x, y), pm);
}

inline void QPainter::drawPixmap(int x, int y, int w, int h, const QPixmap &pm)
{
drawPixmap(QRectF(x, y, w, h), pm, QRectF());
}

inline void QPainter::drawPixmap(int x, int y, int w, int h, const QPixmap &pm,
int sx, int sy, int sw, int sh)
{
drawPixmap(QRectF(x, y, w, h), pm, QRectF(sx, sy, sw, sh));
}

inline void QPainter::drawPixmap(int x, int y, const QPixmap &pm,
int sx, int sy, int sw, int sh)
{
drawPixmap(QRectF(x, y, -1, -1), pm, QRectF(sx, sy, sw, sh));
}

inline void QPainter::drawPixmap(const QPointF &p, const QPixmap &pm, const QRectF &sr)
{
drawPixmap(QRectF(p.x(), p.y(), -1, -1), pm, sr);
}

inline void QPainter::drawPixmap(const QPoint &p, const QPixmap &pm, const QRect &sr)
{
drawPixmap(QRectF(p.x(), p.y(), -1, -1), pm, sr);
}

inline void QPainter::drawTextItem(int x, int y, const QTextItem &ti)
{
drawTextItem(QPointF(x, y), ti);
}

inline void QPainter::drawImage(const QRect &targetRect, const QImage &image, const QRect &sourceRect,
Qt::ImageConversionFlags flags)
{
drawImage(QRectF(targetRect), image, QRectF(sourceRect), flags);
}

inline void QPainter::drawImage(const QPointF &p, const QImage &image, const QRectF &sr,
Qt::ImageConversionFlags flags)
{
drawImage(QRectF(p.x(), p.y(), -1, -1), image, sr, flags);
}

inline void QPainter::drawImage(const QPoint &p, const QImage &image, const QRect &sr,
Qt::ImageConversionFlags flags)
{
drawImage(QRect(p.x(), p.y(), -1, -1), image, sr, flags);
}


inline void QPainter::drawImage(const QRectF &r, const QImage &image)
{
drawImage(r, image, QRect(0, 0, image.width(), image.height()));
}

inline void QPainter::drawImage(const QRect &r, const QImage &image)
{
drawImage(r, image, QRectF(0, 0, image.width(), image.height()));
}

inline void QPainter::drawImage(const QPoint &p, const QImage &image)
{
drawImage(QPointF(p), image);
}

inline void QPainter::drawImage(int x, int y, const QImage &image, int sx, int sy, int sw, int sh,
Qt::ImageConversionFlags flags)
{
if (sx == 0 && sy == 0 && sw == -1 && sh == -1 && flags == Qt::AutoColor)
drawImage(QPointF(x, y), image);
else
drawImage(QRectF(x, y, -1, -1), image, QRectF(sx, sy, sw, sh), flags);
}

inline void QPainter::drawTextItem(const QPoint &p, const QTextItem &ti)
{
drawTextItem(QPointF(p), ti);
}

inline void QPainter::drawText(const QPoint &p, const QString &s)
{
drawText(QPointF(p), s);
}

inline void QPainter::drawText(int x, int y, int w, int h, int flags, const QString &str, QRect *br)
{
drawText(QRect(x, y, w, h), flags, str, br);
}

inline void QPainter::drawText(int x, int y, const QString &s)
{
drawText(QPointF(x, y), s);
}

inline QRect QPainter::boundingRect(int x, int y, int w, int h, int flags, const QString &text)
{
return boundingRect(QRect(x, y, w, h), flags, text);
}

inline void QPainter::translate(qreal dx, qreal dy)
{
translate(QPointF(dx, dy));
}

inline void QPainter::translate(const QPoint &offset)
{
translate(offset.x(), offset.y());
}

inline void QPainter::setViewport(int x, int y, int w, int h)
{
setViewport(QRect(x, y, w, h));
}

inline void QPainter::setWindow(int x, int y, int w, int h)
{
setWindow(QRect(x, y, w, h));
}


# 945 "/usr/share/qt4/include/QtGui/qpainter.h"
inline void QPainter::drawPicture(int x, int y, const QPicture &p)
{
drawPicture(QPoint(x, y), p);
}

inline void QPainter::drawPicture(const QPoint &pt, const QPicture &p)
{
drawPicture(QPointF(pt), p);
}


# 956 "/usr/share/qt4/include/QtGui/qpainter.h"





# 48 "/usr/share/qt4/include/QtGui/qpaintengine.h"


# 50 "/usr/share/qt4/include/QtGui/qpaintengine.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QFontEngine;
class QLineF;
class QPaintDevice;
class QPaintEnginePrivate;
class QPainterPath;
class QPointF;
class QPolygonF;
class QRectF;
struct QGlyphLayout;
class QTextItemInt;
class QPaintEngineState;

class  QTextItem {
public:
enum RenderFlag {
RightToLeft = 0x1,
Overline = 0x10,
Underline = 0x20,
StrikeOut = 0x40,

Dummy = 0xffffffff
};
typedef QFlags<RenderFlag> RenderFlags;
qreal descent() const;
qreal ascent() const;
qreal width() const;

RenderFlags renderFlags() const;
QString text() const;
QFont font() const;
};
template <> class QTypeInfo<QTextItem > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextItem)>sizeof(void*)), isPointer = false, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTextItem"; } };


class  QPaintEngine
{
inline QPaintEnginePrivate* d_func() { return reinterpret_cast<QPaintEnginePrivate *>(qGetPtrHelper(d_ptr)); } inline const QPaintEnginePrivate* d_func() const { return reinterpret_cast<const QPaintEnginePrivate *>(qGetPtrHelper(d_ptr)); } friend class QPaintEnginePrivate;
public:
enum PaintEngineFeature {
PrimitiveTransform = 0x00000001, 
PatternTransform = 0x00000002, 
PixmapTransform = 0x00000004, 
PatternBrush = 0x00000008, 
LinearGradientFill = 0x00000010, 
RadialGradientFill = 0x00000020, 
ConicalGradientFill = 0x00000040, 
AlphaBlend = 0x00000080, 
PorterDuff = 0x00000100, 
PainterPaths = 0x00000200, 
Antialiasing = 0x00000400, 
BrushStroke = 0x00000800, 
ConstantOpacity = 0x00001000, 
MaskedBrush = 0x00002000, 
PerspectiveTransform = 0x00004000, 
BlendModes = 0x00008000, 
ObjectBoundingModeGradients = 0x00010000, 
RasterOpModes = 0x00020000, 
PaintOutsidePaintEvent = 0x20000000, 







AllFeatures = 0xffffffff 
};
typedef QFlags<PaintEngineFeature> PaintEngineFeatures;

enum DirtyFlag {
DirtyPen = 0x0001,
DirtyBrush = 0x0002,
DirtyBrushOrigin = 0x0004,
DirtyFont = 0x0008,
DirtyBackground = 0x0010,
DirtyBackgroundMode = 0x0020,
DirtyTransform = 0x0040,
DirtyClipRegion = 0x0080,
DirtyClipPath = 0x0100,
DirtyHints = 0x0200,
DirtyCompositionMode = 0x0400,
DirtyClipEnabled = 0x0800,
DirtyOpacity = 0x1000,

AllDirty = 0xffff
};
typedef QFlags<DirtyFlag> DirtyFlags;

enum PolygonDrawMode {
OddEvenMode,
WindingMode,
ConvexMode,
PolylineMode
};

explicit QPaintEngine(PaintEngineFeatures features=0);
virtual ~QPaintEngine();

bool isActive() const { return active; }
void setActive(bool newState) { active = newState; }

virtual bool begin(QPaintDevice *pdev) = 0;
virtual bool end() = 0;

virtual void updateState(const QPaintEngineState &state) = 0;

virtual void drawRects(const QRect *rects, int rectCount);
virtual void drawRects(const QRectF *rects, int rectCount);

virtual void drawLines(const QLine *lines, int lineCount);
virtual void drawLines(const QLineF *lines, int lineCount);

virtual void drawEllipse(const QRectF &r);
virtual void drawEllipse(const QRect &r);

virtual void drawPath(const QPainterPath &path);

virtual void drawPoints(const QPointF *points, int pointCount);
virtual void drawPoints(const QPoint *points, int pointCount);

virtual void drawPolygon(const QPointF *points, int pointCount, PolygonDrawMode mode);
virtual void drawPolygon(const QPoint *points, int pointCount, PolygonDrawMode mode);

virtual void drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr) = 0;
virtual void drawTextItem(const QPointF &p, const QTextItem &textItem);
virtual void drawTiledPixmap(const QRectF &r, const QPixmap &pixmap, const QPointF &s);
virtual void drawImage(const QRectF &r, const QImage &pm, const QRectF &sr,
Qt::ImageConversionFlags flags = Qt::AutoColor);

void setPaintDevice(QPaintDevice *device);
QPaintDevice *paintDevice() const;

void setSystemClip(const QRegion &baseClip);
QRegion systemClip() const;

void setSystemRect(const QRect &rect);
QRect systemRect() const;






# 199 "/usr/share/qt4/include/QtGui/qpaintengine.h"
virtual QPoint coordinateOffset() const;

enum Type {
X11,
Windows,
QuickDraw, CoreGraphics, MacPrinter,
QWindowSystem,
PostScript,
OpenGL,
Picture,
SVG,
Raster,
Direct3D,
Pdf,
OpenVG,
OpenGL2,
PaintBuffer,

User = 50, 
MaxUser = 100 
};
virtual Type type() const = 0;

inline void fix_neg_rect(int *x, int *y, int *w, int *h);

inline bool testDirty(DirtyFlags df);
inline void setDirty(DirtyFlags df);
inline void clearDirty(DirtyFlags df);

bool hasFeature(PaintEngineFeatures feature) const { return (gccaps & feature) != 0; }

QPainter *painter() const;

void syncState();
inline bool isExtended() const { return extended; }

protected:
QPaintEngine(QPaintEnginePrivate &data, PaintEngineFeatures devcaps=0);

QPaintEngineState *state;
PaintEngineFeatures gccaps;

uint active : 1;
uint selfDestruct : 1;
uint extended : 1;

QScopedPointer<QPaintEnginePrivate> d_ptr;

private:
void setAutoDestruct(bool autoDestr) { selfDestruct = autoDestr; }
bool autoDestruct() const { return selfDestruct; }
QPaintEngine(const QPaintEngine &); QPaintEngine &operator=(const QPaintEngine &);

friend class QPainterReplayer;
friend class QFontEngineBox;
friend class QFontEngineMac;
friend class QFontEngineWin;

# 257 "/usr/share/qt4/include/QtGui/qpaintengine.h"
friend class QFontEngineFT;


# 260 "/usr/share/qt4/include/QtGui/qpaintengine.h"
friend class QFontEngineQPF1;


# 263 "/usr/share/qt4/include/QtGui/qpaintengine.h"
friend class QFontEngineQPF;

# 265 "/usr/share/qt4/include/QtGui/qpaintengine.h"
friend class QPSPrintEngine;
friend class QMacPrintEngine;
friend class QMacPrintEnginePrivate;





# 273 "/usr/share/qt4/include/QtGui/qpaintengine.h"
friend class QPainter;
friend class QPainterPrivate;
friend class QWidget;
friend class QWidgetPrivate;
friend class QWin32PaintEngine;
friend class QWin32PaintEnginePrivate;
friend class QMacCGContext;
friend class QPreviewPaintEngine;
friend class QX11GLPixmapData;
};


class  QPaintEngineState
{
public:
QPaintEngine::DirtyFlags state() const { return dirtyFlags; }

QPen pen() const;
QBrush brush() const;
QPointF brushOrigin() const;
QBrush backgroundBrush() const;
Qt::BGMode backgroundMode() const;
QFont font() const;
QMatrix matrix() const;
QTransform transform() const;

Qt::ClipOperation clipOperation() const;
QRegion clipRegion() const;
QPainterPath clipPath() const;
bool isClipEnabled() const;

QPainter::RenderHints renderHints() const;
QPainter::CompositionMode compositionMode() const;
qreal opacity() const;

QPainter *painter() const;

bool brushNeedsResolving() const;
bool penNeedsResolving() const;

protected:
friend class QPaintEngine;
friend class QRasterPaintEngine;
friend class QWidget;
friend class QPainter;
friend class QPainterPrivate;
friend class QMacPrintEnginePrivate;

QPaintEngine::DirtyFlags dirtyFlags;
};





inline void QPaintEngine::fix_neg_rect(int *x, int *y, int *w, int *h)
{
if (*w < 0) {
*w = -*w;
*x -= *w - 1;
}
if (*h < 0) {
*h = -*h;
*y -= *h - 1;
}
}

inline bool QPaintEngine::testDirty(DirtyFlags df) {
qt_noop();
return ((state->dirtyFlags & df) != 0);
}

inline void QPaintEngine::setDirty(DirtyFlags df) {
qt_noop();
state->dirtyFlags |= df;
}

inline void QPaintEngine::clearDirty(DirtyFlags df)
{
qt_noop();
state->dirtyFlags &= ~static_cast<uint>(df);
}

inline QFlags<QTextItem::RenderFlags::enum_type> operator|(QTextItem::RenderFlags::enum_type f1, QTextItem::RenderFlags::enum_type f2) { return QFlags<QTextItem::RenderFlags::enum_type>(f1) | f2; } inline QFlags<QTextItem::RenderFlags::enum_type> operator|(QTextItem::RenderFlags::enum_type f1, QFlags<QTextItem::RenderFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTextItem::RenderFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<QPaintEngine::PaintEngineFeatures::enum_type> operator|(QPaintEngine::PaintEngineFeatures::enum_type f1, QPaintEngine::PaintEngineFeatures::enum_type f2) { return QFlags<QPaintEngine::PaintEngineFeatures::enum_type>(f1) | f2; } inline QFlags<QPaintEngine::PaintEngineFeatures::enum_type> operator|(QPaintEngine::PaintEngineFeatures::enum_type f1, QFlags<QPaintEngine::PaintEngineFeatures::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QPaintEngine::PaintEngineFeatures::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<QPaintEngine::DirtyFlags::enum_type> operator|(QPaintEngine::DirtyFlags::enum_type f1, QPaintEngine::DirtyFlags::enum_type f2) { return QFlags<QPaintEngine::DirtyFlags::enum_type>(f1) | f2; } inline QFlags<QPaintEngine::DirtyFlags::enum_type> operator|(QPaintEngine::DirtyFlags::enum_type f1, QFlags<QPaintEngine::DirtyFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QPaintEngine::DirtyFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }






# 10 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpainter.h"
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 11 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpainterpath.h"












































































































































































































































































































































































































































# 12 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpen.h"












































































































































# 13 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpolygon.h"




















































































































































































# 14 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qprintengine.h"












































# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qprintengine.h"

# 1 "/usr/share/qt4/include/QtGui/qprinter.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qprinter.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 46 "/usr/share/qt4/include/QtGui/qprinter.h"

# 1 "/usr/share/qt4/include/QtGui/qpaintdevice.h"















































































































































































# 47 "/usr/share/qt4/include/QtGui/qprinter.h"


# 49 "/usr/share/qt4/include/QtGui/qprinter.h"




typedef QtValidLicenseForGuiModule QtGuiModule;







# 61 "/usr/share/qt4/include/QtGui/qprinter.h"
class QPrinterPrivate;
class QPaintEngine;
class QPrintEngine;
class QPrinterInfo;

class  QPrinter : public QPaintDevice
{
inline QPrinterPrivate* d_func() { return reinterpret_cast<QPrinterPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPrinterPrivate* d_func() const { return reinterpret_cast<const QPrinterPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPrinterPrivate;
public:
enum PrinterMode { ScreenResolution, PrinterResolution, HighResolution };

explicit QPrinter(PrinterMode mode = ScreenResolution);
explicit QPrinter(const QPrinterInfo& printer, PrinterMode mode = ScreenResolution);
~QPrinter();

int devType() const;

enum Orientation { Portrait, Landscape };


# 81 "/usr/share/qt4/include/QtGui/qprinter.h"
enum PageSize { A4, B5, Letter, Legal, Executive,
A0, A1, A2, A3, A5, A6, A7, A8, A9, B0, B1,
B10, B2, B3, B4, B6, B7, B8, B9, C5E, Comm10E,
DLE, Folio, Ledger, Tabloid, Custom, NPageSize = Custom, NPaperSize = Custom };
typedef PageSize PaperSize;











# 97 "/usr/share/qt4/include/QtGui/qprinter.h"
enum PageOrder { FirstPageFirst,
LastPageFirst };

enum ColorMode { GrayScale,
Color };

enum PaperSource { OnlyOne,
Lower,
Middle,
Manual,
Envelope,
EnvelopeManual,
Auto,
Tractor,
SmallFormat,
LargeFormat,
LargeCapacity,
Cassette,
FormSource,
MaxPageSource
};

enum PrinterState { Idle,
Active,
Aborted,
Error };

enum OutputFormat { NativeFormat, PdfFormat, PostScriptFormat };


enum PrintRange { AllPages, Selection, PageRange };

enum Unit {
Millimeter,
Point,
Inch,
Pica,
Didot,
Cicero,
DevicePixel
};

enum DuplexMode {
DuplexNone = 0,
DuplexAuto,
DuplexLongSide,
DuplexShortSide
};





# 150 "/usr/share/qt4/include/QtGui/qprinter.h"
void setOutputFormat(OutputFormat format);
OutputFormat outputFormat() const;

void setPrinterName(const QString &);
QString printerName() const;

bool isValid() const;

void setOutputFileName(const QString &);
QString outputFileName()const;

void setPrintProgram(const QString &);
QString printProgram() const;

void setDocName(const QString &);
QString docName() const;

void setCreator(const QString &);
QString creator() const;

void setOrientation(Orientation);
Orientation orientation() const;

void setPageSize(PageSize);
PageSize pageSize() const;

void setPaperSize(PaperSize);
PaperSize paperSize() const;

void setPaperSize(const QSizeF &paperSize, Unit unit);
QSizeF paperSize(Unit unit) const;

void setPageOrder(PageOrder);
PageOrder pageOrder() const;

void setResolution(int);
int resolution() const;

void setColorMode(ColorMode);
ColorMode colorMode() const;

void setCollateCopies(bool collate);
bool collateCopies() const;

void setFullPage(bool);
bool fullPage() const;

void setNumCopies(int);
int numCopies() const;

int actualNumCopies() const;

void setPaperSource(PaperSource);
PaperSource paperSource() const;

void setDuplex(DuplexMode duplex);
DuplexMode duplex() const;

QList<int> supportedResolutions() const;





# 214 "/usr/share/qt4/include/QtGui/qprinter.h"
void setFontEmbeddingEnabled(bool enable);
bool fontEmbeddingEnabled() const;

void setDoubleSidedPrinting(bool enable);
bool doubleSidedPrinting() const;






# 225 "/usr/share/qt4/include/QtGui/qprinter.h"
QRect paperRect() const;
QRect pageRect() const;
QRectF paperRect(Unit) const;
QRectF pageRect(Unit) const;


# 231 "/usr/share/qt4/include/QtGui/qprinter.h"
QString printerSelectionOption() const;
void setPrinterSelectionOption(const QString &);


# 235 "/usr/share/qt4/include/QtGui/qprinter.h"
bool newPage();
bool abort();

PrinterState printerState() const;

QPaintEngine *paintEngine() const;
QPrintEngine *printEngine() const;






# 248 "/usr/share/qt4/include/QtGui/qprinter.h"
void setFromTo(int fromPage, int toPage);
int fromPage() const;
int toPage() const;

void setPrintRange(PrintRange range);
PrintRange printRange() const;

void setPageMargins(qreal left, qreal top, qreal right, qreal bottom, Unit unit);
void getPageMargins(qreal *left, qreal *top, qreal *right, qreal *bottom, Unit unit) const;




























# 285 "/usr/share/qt4/include/QtGui/qprinter.h"
protected:
int metric(PaintDeviceMetric) const;
void setEngines(QPrintEngine *printEngine, QPaintEngine *paintEngine);

private:
void init(PrinterMode mode);

QPrinter(const QPrinter &); QPrinter &operator=(const QPrinter &);

QScopedPointer<QPrinterPrivate> d_ptr;

friend class QPrintDialogPrivate;
friend class QAbstractPrintDialog;
friend class QAbstractPrintDialogPrivate;
friend class QPrintPreviewWidgetPrivate;
friend class QTextDocument;
friend class QPageSetupWidget;
};


























# 329 "/usr/share/qt4/include/QtGui/qprinter.h"





# 46 "/usr/share/qt4/include/QtGui/qprintengine.h"


# 48 "/usr/share/qt4/include/QtGui/qprintengine.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qprintengine.h"
class  QPrintEngine
{
public:
virtual ~QPrintEngine() {}
enum PrintEnginePropertyKey {
PPK_CollateCopies,
PPK_ColorMode,
PPK_Creator,
PPK_DocumentName,
PPK_FullPage,
PPK_NumberOfCopies,
PPK_Orientation,
PPK_OutputFileName,
PPK_PageOrder,
PPK_PageRect,
PPK_PageSize,
PPK_PaperRect,
PPK_PaperSource,
PPK_PrinterName,
PPK_PrinterProgram,
PPK_Resolution,
PPK_SelectionOption,
PPK_SupportedResolutions,

PPK_WindowsPageSize,
PPK_FontEmbedding,
PPK_SuppressSystemPrintStatus,

PPK_Duplex,

PPK_PaperSources,
PPK_CustomPaperSize,
PPK_PageMargins,
PPK_PaperSize = PPK_PageSize,

PPK_CustomBase = 0xff00
};

virtual void setProperty(PrintEnginePropertyKey key, const QVariant &value) = 0;
virtual QVariant property(PrintEnginePropertyKey key) const = 0;

virtual bool newPage() = 0;
virtual bool abort() = 0;

virtual int metric(QPaintDevice::PaintDeviceMetric) const = 0;

virtual QPrinter::PrinterState printerState() const = 0;






# 109 "/usr/share/qt4/include/QtGui/qprintengine.h"
};



# 113 "/usr/share/qt4/include/QtGui/qprintengine.h"





# 15 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qprinter.h"













































































































































































































































































































































# 16 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qprinterinfo.h"












































# 1 "/usr/share/qt4/include/QtGui/qprinter.h"













































































































































































































































































































































# 1 "/usr/share/qt4/include/QtGui/QPrinter"

# 45 "/usr/share/qt4/include/QtGui/qprinterinfo.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 1 "/usr/share/qt4/include/QtCore/QList"

# 46 "/usr/share/qt4/include/QtGui/qprinterinfo.h"


# 48 "/usr/share/qt4/include/QtGui/qprinterinfo.h"




typedef QtValidLicenseForGuiModule QtGuiModule;


# 55 "/usr/share/qt4/include/QtGui/qprinterinfo.h"
class QPrinterInfoPrivate;
class QPrinterInfoPrivateDeleter;
class  QPrinterInfo
{
inline QPrinterInfoPrivate* d_func() { return reinterpret_cast<QPrinterInfoPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPrinterInfoPrivate* d_func() const { return reinterpret_cast<const QPrinterInfoPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPrinterInfoPrivate;

public:
QPrinterInfo();
QPrinterInfo(const QPrinterInfo& src);
QPrinterInfo(const QPrinter& printer);
~QPrinterInfo();

QPrinterInfo& operator=(const QPrinterInfo& src);

QString printerName() const;
bool isNull() const;
bool isDefault() const;
QList<QPrinter::PaperSize> supportedPaperSizes() const;

static QList<QPrinterInfo> availablePrinters();
static QPrinterInfo defaultPrinter();

private:
QPrinterInfo(const QString& name);

QScopedPointer<QPrinterInfoPrivate, QPrinterInfoPrivateDeleter> d_ptr;
};



# 85 "/usr/share/qt4/include/QtGui/qprinterinfo.h"





# 17 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qregion.h"









































































































































































































































# 18 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qrgb.h"
























































































# 19 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qstylepainter.h"












































# 1 "/usr/share/qt4/include/QtGui/qpainter.h"
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qstylepainter.h"

# 1 "/usr/share/qt4/include/QtGui/qstyle.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qstyle.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qstyle.h"

# 1 "/usr/share/qt4/include/QtCore/qsize.h"








































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qstyle.h"

# 1 "/usr/share/qt4/include/QtGui/qicon.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qicon.h"

# 1 "/usr/share/qt4/include/QtCore/qsize.h"








































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qicon.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qicon.h"

# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qicon.h"


# 50 "/usr/share/qt4/include/QtGui/qicon.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QIconPrivate;
class QIconEngine;
class QIconEngineV2;

class  QIcon
{
public:
enum Mode { Normal, Disabled, Active, Selected };
enum State { On, Off };

QIcon();
QIcon(const QPixmap &pixmap);
QIcon(const QIcon &other);
explicit QIcon(const QString &fileName); 
explicit QIcon(QIconEngine *engine);
explicit QIcon(QIconEngineV2 *engine);
~QIcon();
QIcon &operator=(const QIcon &other);
operator QVariant() const;

QPixmap pixmap(const QSize &size, Mode mode = Normal, State state = Off) const;
inline QPixmap pixmap(int w, int h, Mode mode = Normal, State state = Off) const
{ return pixmap(QSize(w, h), mode, state); }
inline QPixmap pixmap(int extent, Mode mode = Normal, State state = Off) const
{ return pixmap(QSize(extent, extent), mode, state); }

QSize actualSize(const QSize &size, Mode mode = Normal, State state = Off) const;

void paint(QPainter *painter, const QRect &rect, Qt::Alignment alignment = Qt::AlignCenter, Mode mode = Normal, State state = Off) const;
inline void paint(QPainter *painter, int x, int y, int w, int h, Qt::Alignment alignment = Qt::AlignCenter, Mode mode = Normal, State state = Off) const
{ paint(painter, QRect(x, y, w, h), alignment, mode, state); }

bool isNull() const;
bool isDetached() const;
void detach();

int serialNumber() const;
qint64 cacheKey() const;

void addPixmap(const QPixmap &pixmap, Mode mode = Normal, State state = Off);
void addFile(const QString &fileName, const QSize &size = QSize(), Mode mode = Normal, State state = Off);

QList<QSize> availableSizes(Mode mode = Normal, State state = Off) const;

static QIcon fromTheme(const QString &name, const QIcon &fallback = QIcon());
static bool hasThemeIcon(const QString &name);

static QStringList themeSearchPaths();
static void setThemeSearchPaths(const QStringList &searchpath);

static QString themeName();
static void setThemeName(const QString &path);
















# 124 "/usr/share/qt4/include/QtGui/qicon.h"


private:
QIconPrivate *d;

# 129 "/usr/share/qt4/include/QtGui/qicon.h"
friend  QDataStream &operator<<(QDataStream &, const QIcon &);
friend  QDataStream &operator>>(QDataStream &, QIcon &);


# 133 "/usr/share/qt4/include/QtGui/qicon.h"
public:
typedef QIconPrivate * DataPtr;
inline DataPtr &data_ptr() { return d; }
};

template <> inline bool qIsDetached<QIcon>(QIcon &t) { return t.isDetached(); } template <> inline void qSwap<QIcon>(QIcon &value1, QIcon &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }
template <> class QTypeInfo<QIcon > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QIcon)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QIcon"; } };


# 142 "/usr/share/qt4/include/QtGui/qicon.h"
 QDataStream &operator<<(QDataStream &, const QIcon &);
 QDataStream &operator>>(QDataStream &, QIcon &);






# 150 "/usr/share/qt4/include/QtGui/qicon.h"





# 48 "/usr/share/qt4/include/QtGui/qstyle.h"

# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qstyle.h"

# 1 "/usr/share/qt4/include/QtGui/qpalette.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 45 "/usr/share/qt4/include/QtGui/qpalette.h"

# 1 "/usr/share/qt4/include/QtGui/qcolor.h"

















































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qpalette.h"

# 1 "/usr/share/qt4/include/QtGui/qbrush.h"








































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qpalette.h"


# 49 "/usr/share/qt4/include/QtGui/qpalette.h"




typedef QtValidLicenseForGuiModule QtGuiModule;




# 58 "/usr/share/qt4/include/QtGui/qpalette.h"
class QPalettePrivate;
class QVariant;

class  QPalette
{

Q_ENUMS(ColorGroup ColorRole)
public:
QPalette();
QPalette(const QColor &button);
QPalette(Qt::GlobalColor button);
QPalette(const QColor &button, const QColor &window);
QPalette(const QBrush &windowText, const QBrush &button, const QBrush &light,
const QBrush &dark, const QBrush &mid, const QBrush &text,
const QBrush &bright_text, const QBrush &base, const QBrush &window);
QPalette(const QColor &windowText, const QColor &window, const QColor &light,
const QColor &dark, const QColor &mid, const QColor &text, const QColor &base);



# 78 "/usr/share/qt4/include/QtGui/qpalette.h"
QPalette(const QPalette &palette);
~QPalette();
QPalette &operator=(const QPalette &palette);
operator QVariant() const;


enum ColorGroup { Active, Disabled, Inactive, NColorGroups, Current, All, Normal = Active };
enum ColorRole { WindowText, Button, Light, Midlight, Dark, Mid,
Text, BrightText, ButtonText, Base, Window, Shadow,
Highlight, HighlightedText,
Link, LinkVisited, 
AlternateBase,
NoRole, 
ToolTipBase, ToolTipText,
NColorRoles = ToolTipText + 1,
Foreground = WindowText, Background = Window 
};

inline ColorGroup currentColorGroup() const { return static_cast<ColorGroup>(current_group); }
inline void setCurrentColorGroup(ColorGroup cg) { current_group = cg; }

inline const QColor &color(ColorGroup cg, ColorRole cr) const
{ return brush(cg, cr).color(); }
const QBrush &brush(ColorGroup cg, ColorRole cr) const;
inline void setColor(ColorGroup cg, ColorRole cr, const QColor &color);
inline void setColor(ColorRole cr, const QColor &color);
inline void setBrush(ColorRole cr, const QBrush &brush);
bool isBrushSet(ColorGroup cg, ColorRole cr) const;
void setBrush(ColorGroup cg, ColorRole cr, const QBrush &brush);
void setColorGroup(ColorGroup cr, const QBrush &windowText, const QBrush &button,
const QBrush &light, const QBrush &dark, const QBrush &mid,
const QBrush &text, const QBrush &bright_text, const QBrush &base,
const QBrush &window);
bool isEqual(ColorGroup cr1, ColorGroup cr2) const;

inline const QColor &color(ColorRole cr) const { return color(Current, cr); }
inline const QBrush &brush(ColorRole cr) const { return brush(Current, cr); }
inline const QBrush &foreground() const { return brush(WindowText); }
inline const QBrush &windowText() const { return brush(WindowText); }
inline const QBrush &button() const { return brush(Button); }
inline const QBrush &light() const { return brush(Light); }
inline const QBrush &dark() const { return brush(Dark); }
inline const QBrush &mid() const { return brush(Mid); }
inline const QBrush &text() const { return brush(Text); }
inline const QBrush &base() const { return brush(Base); }
inline const QBrush &alternateBase() const { return brush(AlternateBase); }
inline const QBrush &toolTipBase() const { return brush(ToolTipBase); }
inline const QBrush &toolTipText() const { return brush(ToolTipText); }
inline const QBrush &background() const { return brush(Window); }
inline const QBrush &window() const { return brush(Window); }
inline const QBrush &midlight() const { return brush(Midlight); }
inline const QBrush &brightText() const { return brush(BrightText); }
inline const QBrush &buttonText() const { return brush(ButtonText); }
inline const QBrush &shadow() const { return brush(Shadow); }
inline const QBrush &highlight() const { return brush(Highlight); }
inline const QBrush &highlightedText() const { return brush(HighlightedText); }
inline const QBrush &link() const { return brush(Link); }
inline const QBrush &linkVisited() const { return brush(LinkVisited); }














# 150 "/usr/share/qt4/include/QtGui/qpalette.h"
bool operator==(const QPalette &p) const;
inline bool operator!=(const QPalette &p) const { return !(operator==(p)); }
bool isCopyOf(const QPalette &p) const;

int serialNumber() const;
qint64 cacheKey() const;

QPalette resolve(const QPalette &) const;
inline uint resolve() const { return resolve_mask; }
inline void resolve(uint mask) { resolve_mask = mask; }

private:
void setColorGroup(ColorGroup cr, const QBrush &windowText, const QBrush &button,
const QBrush &light, const QBrush &dark, const QBrush &mid,
const QBrush &text, const QBrush &bright_text,
const QBrush &base, const QBrush &alternate_base,
const QBrush &window, const QBrush &midlight,
const QBrush &button_text, const QBrush &shadow,
const QBrush &highlight, const QBrush &highlighted_text,
const QBrush &link, const QBrush &link_visited);
void setColorGroup(ColorGroup cr, const QBrush &windowText, const QBrush &button,
const QBrush &light, const QBrush &dark, const QBrush &mid,
const QBrush &text, const QBrush &bright_text,
const QBrush &base, const QBrush &alternate_base,
const QBrush &window, const QBrush &midlight,
const QBrush &button_text, const QBrush &shadow,
const QBrush &highlight, const QBrush &highlighted_text,
const QBrush &link, const QBrush &link_visited,
const QBrush &toolTipBase, const QBrush &toolTipText);





# 184 "/usr/share/qt4/include/QtGui/qpalette.h"
void init();
void detach();

QPalettePrivate *d;
uint current_group : 4;
uint resolve_mask : 28;
friend  QDataStream &operator<<(QDataStream &s, const QPalette &p);
};

inline void QPalette::setColor(ColorGroup acg, ColorRole acr,
const QColor &acolor)
{ setBrush(acg, acr, QBrush(acolor)); }
inline void QPalette::setColor(ColorRole acr, const QColor &acolor)
{ setColor(All, acr, acolor); }
inline void QPalette::setBrush(ColorRole acr, const QBrush &abrush)
{ setBrush(All, acr, abrush); }


















































# 250 "/usr/share/qt4/include/QtGui/qpalette.h"




# 254 "/usr/share/qt4/include/QtGui/qpalette.h"
 QDataStream &operator<<(QDataStream &ds, const QPalette &p);
 QDataStream &operator>>(QDataStream &ds, QPalette &p);


# 258 "/usr/share/qt4/include/QtGui/qpalette.h"





# 50 "/usr/share/qt4/include/QtGui/qstyle.h"

# 1 "/usr/share/qt4/include/QtGui/qsizepolicy.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qsizepolicy.h"


# 47 "/usr/share/qt4/include/QtGui/qsizepolicy.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QVariant;

class  QSizePolicy
{

Q_ENUMS(Policy)

private:
enum SizePolicyMasks {
HSize = 4,
HMask = 0x0f,
VMask = HMask << HSize,
CTShift = 9,
CTSize = 5,
WFHShift = CTShift + CTSize,
CTMask = ((0x1 << CTSize) - 1) << CTShift,
UnusedShift = CTShift + CTSize,
UnusedSize = 2
};

public:
enum PolicyFlag {
GrowFlag = 1,
ExpandFlag = 2,
ShrinkFlag = 4,
IgnoreFlag = 8
};

enum Policy {
Fixed = 0,
Minimum = GrowFlag,
Maximum = ShrinkFlag,
Preferred = GrowFlag | ShrinkFlag,
MinimumExpanding = GrowFlag | ExpandFlag,
Expanding = GrowFlag | ShrinkFlag | ExpandFlag,
Ignored = ShrinkFlag | GrowFlag | IgnoreFlag
};

enum ControlType {
DefaultType = 0x00000001,
ButtonBox = 0x00000002,
CheckBox = 0x00000004,
ComboBox = 0x00000008,
Frame = 0x00000010,
GroupBox = 0x00000020,
Label = 0x00000040,
Line = 0x00000080,
LineEdit = 0x00000100,
PushButton = 0x00000200,
RadioButton = 0x00000400,
Slider = 0x00000800,
SpinBox = 0x00001000,
TabWidget = 0x00002000,
ToolButton = 0x00004000
};
typedef QFlags<ControlType> ControlTypes;

QSizePolicy() : data(0) { }


QSizePolicy(Policy horizontal, Policy vertical)
: data(horizontal | (vertical << HSize)) { }
QSizePolicy(Policy horizontal, Policy vertical, ControlType type)
: data(horizontal | (vertical << HSize)) { setControlType(type); }

Policy horizontalPolicy() const { return static_cast<Policy>(data & HMask); }
Policy verticalPolicy() const { return static_cast<Policy>((data & VMask) >> HSize); }
ControlType controlType() const;

void setHorizontalPolicy(Policy d) { data = (data & ~HMask) | d; }
void setVerticalPolicy(Policy d) { data = (data & ~(HMask << HSize)) | (d << HSize); }
void setControlType(ControlType type);

Qt::Orientations expandingDirections() const {
Qt::Orientations result;
if (verticalPolicy() & ExpandFlag)
result |= Qt::Vertical;
if (horizontalPolicy() & ExpandFlag)
result |= Qt::Horizontal;
return result;
}

void setHeightForWidth(bool b) { data = b ? (data | (1 << 2*HSize)) : (data & ~(1 << 2*HSize)); }
bool hasHeightForWidth() const { return data & (1 << 2*HSize); }

bool operator==(const QSizePolicy& s) const { return data == s.data; }
bool operator!=(const QSizePolicy& s) const { return data != s.data; }
operator QVariant() const; 

int horizontalStretch() const { return data >> 24; }
int verticalStretch() const { return (data >> 16) & 0xff; }
void setHorizontalStretch(uchar stretchFactor) { data = (data&0x00ffffff) | (uint(stretchFactor)<<24); }
void setVerticalStretch(uchar stretchFactor) { data = (data&0xff00ffff) | (uint(stretchFactor)<<16); }

void transpose();















































# 195 "/usr/share/qt4/include/QtGui/qsizepolicy.h"
private:

# 197 "/usr/share/qt4/include/QtGui/qsizepolicy.h"
friend  QDataStream &operator<<(QDataStream &, const QSizePolicy &);
friend  QDataStream &operator>>(QDataStream &, QSizePolicy &);

# 200 "/usr/share/qt4/include/QtGui/qsizepolicy.h"
QSizePolicy(int i) : data(i) { }

quint32 data;











};

inline QFlags<QSizePolicy::ControlTypes::enum_type> operator|(QSizePolicy::ControlTypes::enum_type f1, QSizePolicy::ControlTypes::enum_type f2) { return QFlags<QSizePolicy::ControlTypes::enum_type>(f1) | f2; } inline QFlags<QSizePolicy::ControlTypes::enum_type> operator|(QSizePolicy::ControlTypes::enum_type f1, QFlags<QSizePolicy::ControlTypes::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QSizePolicy::ControlTypes::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 219 "/usr/share/qt4/include/QtGui/qsizepolicy.h"

 QDataStream &operator<<(QDataStream &, const QSizePolicy &);
 QDataStream &operator>>(QDataStream &, QSizePolicy &);


# 224 "/usr/share/qt4/include/QtGui/qsizepolicy.h"
inline void QSizePolicy::transpose() {
Policy hData = horizontalPolicy();
Policy vData = verticalPolicy();
uchar hStretch = uchar(horizontalStretch());
uchar vStretch = uchar(verticalStretch());
setHorizontalPolicy(vData);
setVerticalPolicy(hData);
setHorizontalStretch(vStretch);
setVerticalStretch(hStretch);
}






# 51 "/usr/share/qt4/include/QtGui/qstyle.h"


# 53 "/usr/share/qt4/include/QtGui/qstyle.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QAction;
class QDebug;
class QTab;
class QFontMetrics;
class QStyleHintReturn;
class QStyleOption;
class QStyleOptionComplex;
class QStylePrivate;

class  QStyle : public QObject
{
Q_OBJECT
inline QStylePrivate* d_func() { return reinterpret_cast<QStylePrivate *>(qGetPtrHelper(d_ptr)); } inline const QStylePrivate* d_func() const { return reinterpret_cast<const QStylePrivate *>(qGetPtrHelper(d_ptr)); } friend class QStylePrivate;

protected:
QStyle(QStylePrivate &dd);

public:
QStyle();
virtual ~QStyle();

virtual void polish(QWidget *);
virtual void unpolish(QWidget *);

virtual void polish(QApplication *);
virtual void unpolish(QApplication *);

virtual void polish(QPalette &);

virtual QRect itemTextRect(const QFontMetrics &fm, const QRect &r,
int flags, bool enabled,
const QString &text) const;

virtual QRect itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const;

virtual void drawItemText(QPainter *painter, const QRect &rect,
int flags, const QPalette &pal, bool enabled,
const QString &text, QPalette::ColorRole textRole = QPalette::NoRole) const;

virtual void drawItemPixmap(QPainter *painter, const QRect &rect,
int alignment, const QPixmap &pixmap) const;

virtual QPalette standardPalette() const;

enum StateFlag {
State_None = 0x00000000,



# 108 "/usr/share/qt4/include/QtGui/qstyle.h"
State_Enabled = 0x00000001,
State_Raised = 0x00000002,
State_Sunken = 0x00000004,
State_Off = 0x00000008,
State_NoChange = 0x00000010,
State_On = 0x00000020,
State_DownArrow = 0x00000040,
State_Horizontal = 0x00000080,
State_HasFocus = 0x00000100,
State_Top = 0x00000200,
State_Bottom = 0x00000400,
State_FocusAtBorder = 0x00000800,
State_AutoRaise = 0x00001000,
State_MouseOver = 0x00002000,
State_UpArrow = 0x00004000,
State_Selected = 0x00008000,
State_Active = 0x00010000,
State_Window = 0x00020000,
State_Open = 0x00040000,
State_Children = 0x00080000,
State_Item = 0x00100000,
State_Sibling = 0x00200000,
State_Editing = 0x00400000,
State_KeyboardFocusChange = 0x00800000,



# 135 "/usr/share/qt4/include/QtGui/qstyle.h"
State_ReadOnly = 0x02000000,
State_Small = 0x04000000,
State_Mini = 0x08000000
};
typedef QFlags<StateFlag> State;





# 145 "/usr/share/qt4/include/QtGui/qstyle.h"
enum PrimitiveElement {
PE_Q3CheckListController,
PE_Q3CheckListExclusiveIndicator,
PE_Q3CheckListIndicator,
PE_Q3DockWindowSeparator,
PE_Q3Separator,

PE_Frame,
PE_FrameDefaultButton,
PE_FrameDockWidget,
PE_FrameFocusRect,
PE_FrameGroupBox,
PE_FrameLineEdit,
PE_FrameMenu,
PE_FrameStatusBar, 
PE_FrameStatusBarItem = PE_FrameStatusBar,
PE_FrameTabWidget,
PE_FrameWindow,
PE_FrameButtonBevel,
PE_FrameButtonTool,
PE_FrameTabBarBase,

PE_PanelButtonCommand,
PE_PanelButtonBevel,
PE_PanelButtonTool,
PE_PanelMenuBar,
PE_PanelToolBar,
PE_PanelLineEdit,

PE_IndicatorArrowDown,
PE_IndicatorArrowLeft,
PE_IndicatorArrowRight,
PE_IndicatorArrowUp,
PE_IndicatorBranch,
PE_IndicatorButtonDropDown,
PE_IndicatorViewItemCheck,
PE_IndicatorItemViewItemCheck = PE_IndicatorViewItemCheck,
PE_IndicatorCheckBox,
PE_IndicatorDockWidgetResizeHandle,
PE_IndicatorHeaderArrow,
PE_IndicatorMenuCheckMark,
PE_IndicatorProgressChunk,
PE_IndicatorRadioButton,
PE_IndicatorSpinDown,
PE_IndicatorSpinMinus,
PE_IndicatorSpinPlus,
PE_IndicatorSpinUp,
PE_IndicatorToolBarHandle,
PE_IndicatorToolBarSeparator,
PE_PanelTipLabel,
PE_IndicatorTabTear,
PE_PanelScrollAreaCorner,

PE_Widget,

PE_IndicatorColumnViewArrow,
PE_IndicatorItemViewItemDrop,

PE_PanelItemViewItem,
PE_PanelItemViewRow, 

PE_PanelStatusBar,

PE_IndicatorTabClose,
PE_PanelMenu,


PE_CustomBase = 0xf000000
};

virtual void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
const QWidget *w = 0) const = 0;
enum ControlElement {
CE_PushButton,
CE_PushButtonBevel,
CE_PushButtonLabel,

CE_CheckBox,
CE_CheckBoxLabel,

CE_RadioButton,
CE_RadioButtonLabel,

CE_TabBarTab,
CE_TabBarTabShape,
CE_TabBarTabLabel,

CE_ProgressBar,
CE_ProgressBarGroove,
CE_ProgressBarContents,
CE_ProgressBarLabel,

CE_MenuItem,
CE_MenuScroller,
CE_MenuVMargin,
CE_MenuHMargin,
CE_MenuTearoff,
CE_MenuEmptyArea,

CE_MenuBarItem,
CE_MenuBarEmptyArea,

CE_ToolButtonLabel,

CE_Header,
CE_HeaderSection,
CE_HeaderLabel,

CE_Q3DockWindowEmptyArea,
CE_ToolBoxTab,
CE_SizeGrip,
CE_Splitter,
CE_RubberBand,
CE_DockWidgetTitle,

CE_ScrollBarAddLine,
CE_ScrollBarSubLine,
CE_ScrollBarAddPage,
CE_ScrollBarSubPage,
CE_ScrollBarSlider,
CE_ScrollBarFirst,
CE_ScrollBarLast,

CE_FocusFrame,
CE_ComboBoxLabel,

CE_ToolBar,
CE_ToolBoxTabShape,
CE_ToolBoxTabLabel,
CE_HeaderEmptyArea,

CE_ColumnViewGrip,

CE_ItemViewItem,

CE_ShapedFrame,


CE_CustomBase = 0xf0000000
};

virtual void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
const QWidget *w = 0) const = 0;

enum SubElement {
SE_PushButtonContents,
SE_PushButtonFocusRect,

SE_CheckBoxIndicator,
SE_CheckBoxContents,
SE_CheckBoxFocusRect,
SE_CheckBoxClickRect,

SE_RadioButtonIndicator,
SE_RadioButtonContents,
SE_RadioButtonFocusRect,
SE_RadioButtonClickRect,

SE_ComboBoxFocusRect,

SE_SliderFocusRect,

SE_Q3DockWindowHandleRect,

SE_ProgressBarGroove,
SE_ProgressBarContents,
SE_ProgressBarLabel,


SE_DialogButtonAccept,
SE_DialogButtonReject,
SE_DialogButtonApply,
SE_DialogButtonHelp,
SE_DialogButtonAll,
SE_DialogButtonAbort,
SE_DialogButtonIgnore,
SE_DialogButtonRetry,
SE_DialogButtonCustom,

SE_ToolBoxTabContents,

SE_HeaderLabel,
SE_HeaderArrow,

SE_TabWidgetTabBar,
SE_TabWidgetTabPane,
SE_TabWidgetTabContents,
SE_TabWidgetLeftCorner,
SE_TabWidgetRightCorner,

SE_ViewItemCheckIndicator,
SE_ItemViewItemCheckIndicator = SE_ViewItemCheckIndicator,

SE_TabBarTearIndicator,

SE_TreeViewDisclosureItem,

SE_LineEditContents,
SE_FrameContents,

SE_DockWidgetCloseButton,
SE_DockWidgetFloatButton,
SE_DockWidgetTitleBarText,
SE_DockWidgetIcon,

SE_CheckBoxLayoutItem,
SE_ComboBoxLayoutItem,
SE_DateTimeEditLayoutItem,
SE_DialogButtonBoxLayoutItem, 
SE_LabelLayoutItem,
SE_ProgressBarLayoutItem,
SE_PushButtonLayoutItem,
SE_RadioButtonLayoutItem,
SE_SliderLayoutItem,
SE_SpinBoxLayoutItem,
SE_ToolButtonLayoutItem,

SE_FrameLayoutItem,
SE_GroupBoxLayoutItem,
SE_TabWidgetLayoutItem,

SE_ItemViewItemDecoration,
SE_ItemViewItemText,
SE_ItemViewItemFocusRect,

SE_TabBarTabLeftButton,
SE_TabBarTabRightButton,
SE_TabBarTabText,

SE_ShapedFrameContents,

SE_ToolBarHandle,


SE_CustomBase = 0xf0000000
};

virtual QRect subElementRect(SubElement subElement, const QStyleOption *option,
const QWidget *widget = 0) const = 0;


enum ComplexControl {
CC_SpinBox,
CC_ComboBox,
CC_ScrollBar,
CC_Slider,
CC_ToolButton,
CC_TitleBar,
CC_Q3ListView,
CC_Dial,
CC_GroupBox,
CC_MdiControls,


CC_CustomBase = 0xf0000000
};

enum SubControl {
SC_None = 0x00000000,

SC_ScrollBarAddLine = 0x00000001,
SC_ScrollBarSubLine = 0x00000002,
SC_ScrollBarAddPage = 0x00000004,
SC_ScrollBarSubPage = 0x00000008,
SC_ScrollBarFirst = 0x00000010,
SC_ScrollBarLast = 0x00000020,
SC_ScrollBarSlider = 0x00000040,
SC_ScrollBarGroove = 0x00000080,

SC_SpinBoxUp = 0x00000001,
SC_SpinBoxDown = 0x00000002,
SC_SpinBoxFrame = 0x00000004,
SC_SpinBoxEditField = 0x00000008,

SC_ComboBoxFrame = 0x00000001,
SC_ComboBoxEditField = 0x00000002,
SC_ComboBoxArrow = 0x00000004,
SC_ComboBoxListBoxPopup = 0x00000008,

SC_SliderGroove = 0x00000001,
SC_SliderHandle = 0x00000002,
SC_SliderTickmarks = 0x00000004,

SC_ToolButton = 0x00000001,
SC_ToolButtonMenu = 0x00000002,

SC_TitleBarSysMenu = 0x00000001,
SC_TitleBarMinButton = 0x00000002,
SC_TitleBarMaxButton = 0x00000004,
SC_TitleBarCloseButton = 0x00000008,
SC_TitleBarNormalButton = 0x00000010,
SC_TitleBarShadeButton = 0x00000020,
SC_TitleBarUnshadeButton = 0x00000040,
SC_TitleBarContextHelpButton = 0x00000080,
SC_TitleBarLabel = 0x00000100,

SC_Q3ListView = 0x00000001,
SC_Q3ListViewBranch = 0x00000002,
SC_Q3ListViewExpand = 0x00000004,

SC_DialGroove = 0x00000001,
SC_DialHandle = 0x00000002,
SC_DialTickmarks = 0x00000004,

SC_GroupBoxCheckBox = 0x00000001,
SC_GroupBoxLabel = 0x00000002,
SC_GroupBoxContents = 0x00000004,
SC_GroupBoxFrame = 0x00000008,

SC_MdiMinButton = 0x00000001,
SC_MdiNormalButton = 0x00000002,
SC_MdiCloseButton = 0x00000004,

SC_CustomBase = 0xf0000000,
SC_All = 0xffffffff
};
typedef QFlags<SubControl> SubControls;





# 467 "/usr/share/qt4/include/QtGui/qstyle.h"
virtual void drawComplexControl(ComplexControl cc, const QStyleOptionComplex *opt, QPainter *p,
const QWidget *widget = 0) const = 0;
virtual SubControl hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
const QPoint &pt, const QWidget *widget = 0) const = 0;
virtual QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
SubControl sc, const QWidget *widget = 0) const = 0;

enum PixelMetric {
PM_ButtonMargin,
PM_ButtonDefaultIndicator,
PM_MenuButtonIndicator,
PM_ButtonShiftHorizontal,
PM_ButtonShiftVertical,

PM_DefaultFrameWidth,
PM_SpinBoxFrameWidth,
PM_ComboBoxFrameWidth,

PM_MaximumDragDistance,

PM_ScrollBarExtent,
PM_ScrollBarSliderMin,

PM_SliderThickness, 
PM_SliderControlThickness, 
PM_SliderLength, 
PM_SliderTickmarkOffset, 
PM_SliderSpaceAvailable, 

PM_DockWidgetSeparatorExtent,
PM_DockWidgetHandleExtent,
PM_DockWidgetFrameWidth,

PM_TabBarTabOverlap,
PM_TabBarTabHSpace,
PM_TabBarTabVSpace,
PM_TabBarBaseHeight,
PM_TabBarBaseOverlap,

PM_ProgressBarChunkWidth,

PM_SplitterWidth,
PM_TitleBarHeight,

PM_MenuScrollerHeight,
PM_MenuHMargin,
PM_MenuVMargin,
PM_MenuPanelWidth,
PM_MenuTearoffHeight,
PM_MenuDesktopFrameWidth,

PM_MenuBarPanelWidth,
PM_MenuBarItemSpacing,
PM_MenuBarVMargin,
PM_MenuBarHMargin,

PM_IndicatorWidth,
PM_IndicatorHeight,
PM_ExclusiveIndicatorWidth,
PM_ExclusiveIndicatorHeight,
PM_CheckListButtonSize,
PM_CheckListControllerSize,

PM_DialogButtonsSeparator,
PM_DialogButtonsButtonWidth,
PM_DialogButtonsButtonHeight,

PM_MdiSubWindowFrameWidth,
PM_MDIFrameWidth = PM_MdiSubWindowFrameWidth, 
PM_MdiSubWindowMinimizedWidth,
PM_MDIMinimizedWidth = PM_MdiSubWindowMinimizedWidth, 

PM_HeaderMargin,
PM_HeaderMarkSize,
PM_HeaderGripMargin,
PM_TabBarTabShiftHorizontal,
PM_TabBarTabShiftVertical,
PM_TabBarScrollButtonWidth,

PM_ToolBarFrameWidth,
PM_ToolBarHandleExtent,
PM_ToolBarItemSpacing,
PM_ToolBarItemMargin,
PM_ToolBarSeparatorExtent,
PM_ToolBarExtensionExtent,

PM_SpinBoxSliderHeight,

PM_DefaultTopLevelMargin,
PM_DefaultChildMargin,
PM_DefaultLayoutSpacing,

PM_ToolBarIconSize,
PM_ListViewIconSize,
PM_IconViewIconSize,
PM_SmallIconSize,
PM_LargeIconSize,

PM_FocusFrameVMargin,
PM_FocusFrameHMargin,

PM_ToolTipLabelFrameWidth,
PM_CheckBoxLabelSpacing,
PM_TabBarIconSize,
PM_SizeGripSize,
PM_DockWidgetTitleMargin,
PM_MessageBoxIconSize,
PM_ButtonIconSize,

PM_DockWidgetTitleBarButtonMargin,

PM_RadioButtonLabelSpacing,
PM_LayoutLeftMargin,
PM_LayoutTopMargin,
PM_LayoutRightMargin,
PM_LayoutBottomMargin,
PM_LayoutHorizontalSpacing,
PM_LayoutVerticalSpacing,
PM_TabBar_ScrollButtonOverlap,

PM_TextCursorWidth,

PM_TabCloseIndicatorWidth,
PM_TabCloseIndicatorHeight,

PM_ScrollView_ScrollBarSpacing,
PM_SubMenuOverlap,


PM_CustomBase = 0xf0000000
};

virtual int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
const QWidget *widget = 0) const = 0;

enum ContentsType {
CT_PushButton,
CT_CheckBox,
CT_RadioButton,
CT_ToolButton,
CT_ComboBox,
CT_Splitter,
CT_Q3DockWindow,
CT_ProgressBar,
CT_MenuItem,
CT_MenuBarItem,
CT_MenuBar,
CT_Menu,
CT_TabBarTab,
CT_Slider,
CT_ScrollBar,
CT_Q3Header,
CT_LineEdit,
CT_SpinBox,
CT_SizeGrip,
CT_TabWidget,
CT_DialogButtons,
CT_HeaderSection,
CT_GroupBox,
CT_MdiControls,
CT_ItemViewItem,

CT_CustomBase = 0xf0000000
};

virtual QSize sizeFromContents(ContentsType ct, const QStyleOption *opt,
const QSize &contentsSize, const QWidget *w = 0) const = 0;

enum RequestSoftwareInputPanel {
RSIP_OnMouseClickAndAlreadyFocused,
RSIP_OnMouseClick
};

enum StyleHint {
SH_EtchDisabledText,
SH_DitherDisabledText,
SH_ScrollBar_MiddleClickAbsolutePosition,
SH_ScrollBar_ScrollWhenPointerLeavesControl,
SH_TabBar_SelectMouseType,
SH_TabBar_Alignment,
SH_Header_ArrowAlignment,
SH_Slider_SnapToValue,
SH_Slider_SloppyKeyEvents,
SH_ProgressDialog_CenterCancelButton,
SH_ProgressDialog_TextLabelAlignment,
SH_PrintDialog_RightAlignButtons,
SH_MainWindow_SpaceBelowMenuBar,
SH_FontDialog_SelectAssociatedText,
SH_Menu_AllowActiveAndDisabled,
SH_Menu_SpaceActivatesItem,
SH_Menu_SubMenuPopupDelay,
SH_ScrollView_FrameOnlyAroundContents,
SH_MenuBar_AltKeyNavigation,
SH_ComboBox_ListMouseTracking,
SH_Menu_MouseTracking,
SH_MenuBar_MouseTracking,
SH_ItemView_ChangeHighlightOnFocus,
SH_Widget_ShareActivation,
SH_Workspace_FillSpaceOnMaximize,
SH_ComboBox_Popup,
SH_TitleBar_NoBorder,
SH_Slider_StopMouseOverSlider,
SH_ScrollBar_StopMouseOverSlider = SH_Slider_StopMouseOverSlider, 
SH_BlinkCursorWhenTextSelected,
SH_RichText_FullWidthSelection,
SH_Menu_Scrollable,
SH_GroupBox_TextLabelVerticalAlignment,
SH_GroupBox_TextLabelColor,
SH_Menu_SloppySubMenus,
SH_Table_GridLineColor,
SH_LineEdit_PasswordCharacter,
SH_DialogButtons_DefaultButton,
SH_ToolBox_SelectedPageTitleBold,
SH_TabBar_PreferNoArrows,
SH_ScrollBar_LeftClickAbsolutePosition,
SH_Q3ListViewExpand_SelectMouseType,
SH_UnderlineShortcut,
SH_SpinBox_AnimateButton,
SH_SpinBox_KeyPressAutoRepeatRate,
SH_SpinBox_ClickAutoRepeatRate,
SH_Menu_FillScreenWithScroll,
SH_ToolTipLabel_Opacity,
SH_DrawMenuBarSeparator,
SH_TitleBar_ModifyNotification,
SH_Button_FocusPolicy,
SH_MenuBar_DismissOnSecondClick,
SH_MessageBox_UseBorderForButtonSpacing,
SH_TitleBar_AutoRaise,
SH_ToolButton_PopupDelay,
SH_FocusFrame_Mask,
SH_RubberBand_Mask,
SH_WindowFrame_Mask,
SH_SpinControls_DisableOnBounds,
SH_Dial_BackgroundRole,
SH_ComboBox_LayoutDirection,
SH_ItemView_EllipsisLocation,
SH_ItemView_ShowDecorationSelected,
SH_ItemView_ActivateItemOnSingleClick,
SH_ScrollBar_ContextMenu,
SH_ScrollBar_RollBetweenButtons,
SH_Slider_AbsoluteSetButtons,
SH_Slider_PageSetButtons,
SH_Menu_KeyboardSearch,
SH_TabBar_ElideMode,
SH_DialogButtonLayout,
SH_ComboBox_PopupFrameStyle,
SH_MessageBox_TextInteractionFlags,
SH_DialogButtonBox_ButtonsHaveIcons,
SH_SpellCheckUnderlineStyle,
SH_MessageBox_CenterButtons,
SH_Menu_SelectionWrap,
SH_ItemView_MovementWithoutUpdatingSelection,
SH_ToolTip_Mask,
SH_FocusFrame_AboveWidget,
SH_TextControl_FocusIndicatorTextCharFormat,
SH_WizardStyle,
SH_ItemView_ArrowKeysNavigateIntoChildren,
SH_Menu_Mask,
SH_Menu_FlashTriggeredItem,
SH_Menu_FadeOutOnHide,
SH_SpinBox_ClickAutoRepeatThreshold,
SH_ItemView_PaintAlternatingRowColorsForEmptyArea,
SH_FormLayoutWrapPolicy,
SH_TabWidget_DefaultTabPosition,
SH_ToolBar_Movable,
SH_FormLayoutFieldGrowthPolicy,
SH_FormLayoutFormAlignment,
SH_FormLayoutLabelAlignment,
SH_ItemView_DrawDelegateFrame,
SH_TabBar_CloseButtonPosition,
SH_DockWidget_ButtonsHaveFrame,
SH_ToolButtonStyle,
SH_RequestSoftwareInputPanel,









# 749 "/usr/share/qt4/include/QtGui/qstyle.h"
SH_CustomBase = 0xf0000000
};

virtual int styleHint(StyleHint stylehint, const QStyleOption *opt = 0,
const QWidget *widget = 0, QStyleHintReturn* returnData = 0) const = 0;

enum StandardPixmap {
SP_TitleBarMenuButton,
SP_TitleBarMinButton,
SP_TitleBarMaxButton,
SP_TitleBarCloseButton,
SP_TitleBarNormalButton,
SP_TitleBarShadeButton,
SP_TitleBarUnshadeButton,
SP_TitleBarContextHelpButton,
SP_DockWidgetCloseButton,
SP_MessageBoxInformation,
SP_MessageBoxWarning,
SP_MessageBoxCritical,
SP_MessageBoxQuestion,
SP_DesktopIcon,
SP_TrashIcon,
SP_ComputerIcon,
SP_DriveFDIcon,
SP_DriveHDIcon,
SP_DriveCDIcon,
SP_DriveDVDIcon,
SP_DriveNetIcon,
SP_DirOpenIcon,
SP_DirClosedIcon,
SP_DirLinkIcon,
SP_FileIcon,
SP_FileLinkIcon,
SP_ToolBarHorizontalExtensionButton,
SP_ToolBarVerticalExtensionButton,
SP_FileDialogStart,
SP_FileDialogEnd,
SP_FileDialogToParent,
SP_FileDialogNewFolder,
SP_FileDialogDetailedView,
SP_FileDialogInfoView,
SP_FileDialogContentsView,
SP_FileDialogListView,
SP_FileDialogBack,
SP_DirIcon,
SP_DialogOkButton,
SP_DialogCancelButton,
SP_DialogHelpButton,
SP_DialogOpenButton,
SP_DialogSaveButton,
SP_DialogCloseButton,
SP_DialogApplyButton,
SP_DialogResetButton,
SP_DialogDiscardButton,
SP_DialogYesButton,
SP_DialogNoButton,
SP_ArrowUp,
SP_ArrowDown,
SP_ArrowLeft,
SP_ArrowRight,
SP_ArrowBack,
SP_ArrowForward,
SP_DirHomeIcon,
SP_CommandLink,
SP_VistaShield,
SP_BrowserReload,
SP_BrowserStop,
SP_MediaPlay,
SP_MediaStop,
SP_MediaPause,
SP_MediaSkipForward,
SP_MediaSkipBackward,
SP_MediaSeekForward,
SP_MediaSeekBackward,
SP_MediaVolume,
SP_MediaVolumeMuted,

SP_CustomBase = 0xf0000000
};

virtual QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt = 0,
const QWidget *widget = 0) const = 0;

QIcon standardIcon(StandardPixmap standardIcon, const QStyleOption *option = 0,
const QWidget *widget = 0) const;

virtual QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
const QStyleOption *opt) const = 0;

static QRect visualRect(Qt::LayoutDirection direction, const QRect &boundingRect,
const QRect &logicalRect);
static QPoint visualPos(Qt::LayoutDirection direction, const QRect &boundingRect,
const QPoint &logicalPos);
static int sliderPositionFromValue(int min, int max, int val, int space,
bool upsideDown = false);
static int sliderValueFromPosition(int min, int max, int pos, int space,
bool upsideDown = false);
static Qt::Alignment visualAlignment(Qt::LayoutDirection direction, Qt::Alignment alignment);
static QRect alignedRect(Qt::LayoutDirection direction, Qt::Alignment alignment,
const QSize &size, const QRect &rectangle);

int layoutSpacing(QSizePolicy::ControlType control1,
QSizePolicy::ControlType control2, Qt::Orientation orientation,
const QStyleOption *option = 0, const QWidget *widget = 0) const;
int combinedLayoutSpacing(QSizePolicy::ControlTypes controls1,
QSizePolicy::ControlTypes controls2, Qt::Orientation orientation,
QStyleOption *option = 0, QWidget *widget = 0) const;

const QStyle * proxy() const;

protected slots:
QIcon standardIconImplementation(StandardPixmap standardIcon, const QStyleOption *opt = 0,
const QWidget *widget = 0) const;
int layoutSpacingImplementation(QSizePolicy::ControlType control1,
QSizePolicy::ControlType control2,
Qt::Orientation orientation,
const QStyleOption *option = 0,
const QWidget *widget = 0) const;

private:
QStyle(const QStyle &); QStyle &operator=(const QStyle &);
friend class QWidget;
friend class QWidgetPrivate;
friend class QApplication;
friend class QProxyStyle;
friend class QProxyStylePrivate;
void setProxy(QStyle *style);
};

inline QFlags<QStyle::State::enum_type> operator|(QStyle::State::enum_type f1, QStyle::State::enum_type f2) { return QFlags<QStyle::State::enum_type>(f1) | f2; } inline QFlags<QStyle::State::enum_type> operator|(QStyle::State::enum_type f1, QFlags<QStyle::State::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QStyle::State::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<QStyle::SubControls::enum_type> operator|(QStyle::SubControls::enum_type f1, QStyle::SubControls::enum_type f2) { return QFlags<QStyle::SubControls::enum_type>(f1) | f2; } inline QFlags<QStyle::SubControls::enum_type> operator|(QStyle::SubControls::enum_type f1, QFlags<QStyle::SubControls::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QStyle::SubControls::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

 QDebug operator<<(QDebug debug, QStyle::State state);






# 46 "/usr/share/qt4/include/QtGui/qstylepainter.h"

# 1 "/usr/share/qt4/include/QtGui/qwidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 45 "/usr/share/qt4/include/QtGui/qwidget.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qwidget.h"

# 1 "/usr/share/qt4/include/QtCore/qmargins.h"

















































































































































# 47 "/usr/share/qt4/include/QtGui/qwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qpaintdevice.h"















































































































































































# 48 "/usr/share/qt4/include/QtGui/qwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qpalette.h"




































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qfontmetrics.h"






































































































































































































# 51 "/usr/share/qt4/include/QtGui/qwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qfontinfo.h"
























































































# 52 "/usr/share/qt4/include/QtGui/qwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qsizepolicy.h"






































































































































































































































# 53 "/usr/share/qt4/include/QtGui/qwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qregion.h"









































































































































































































































# 54 "/usr/share/qt4/include/QtGui/qwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qbrush.h"








































































































































































































































































































































# 55 "/usr/share/qt4/include/QtGui/qwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qcursor.h"












































# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qcursor.h"

# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 46 "/usr/share/qt4/include/QtGui/qcursor.h"


# 48 "/usr/share/qt4/include/QtGui/qcursor.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QVariant;




















# 75 "/usr/share/qt4/include/QtGui/qcursor.h"
class QCursorData;
class QBitmap;
class QPixmap;











# 89 "/usr/share/qt4/include/QtGui/qcursor.h"
class  QCursor
{
public:
QCursor();
QCursor(Qt::CursorShape shape);
QCursor(const QBitmap &bitmap, const QBitmap &mask, int hotX=-1, int hotY=-1);
QCursor(const QPixmap &pixmap, int hotX=-1, int hotY=-1);
QCursor(const QCursor &cursor);
~QCursor();
QCursor &operator=(const QCursor &cursor);
operator QVariant() const;

Qt::CursorShape shape() const;
void setShape(Qt::CursorShape newShape);

const QBitmap *bitmap() const;
const QBitmap *mask() const;
QPixmap pixmap() const;
QPoint hotSpot() const;

static QPoint pos();
static void setPos(int x, int y);
inline static void setPos(const QPoint &p) { setPos(p.x(), p.y()); }
























# 136 "/usr/share/qt4/include/QtGui/qcursor.h"
private:
QCursorData *d;










# 148 "/usr/share/qt4/include/QtGui/qcursor.h"
};













# 162 "/usr/share/qt4/include/QtGui/qcursor.h"




# 166 "/usr/share/qt4/include/QtGui/qcursor.h"
 QDataStream &operator<<(QDataStream &outS, const QCursor &cursor);
 QDataStream &operator>>(QDataStream &inS, QCursor &cursor);



# 171 "/usr/share/qt4/include/QtGui/qcursor.h"





# 56 "/usr/share/qt4/include/QtGui/qwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qkeysequence.h"












































# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qkeysequence.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qkeysequence.h"


# 48 "/usr/share/qt4/include/QtGui/qkeysequence.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qkeysequence.h"




# 60 "/usr/share/qt4/include/QtGui/qkeysequence.h"
class QKeySequence;
 QDataStream &operator<<(QDataStream &in, const QKeySequence &ks);
 QDataStream &operator>>(QDataStream &out, QKeySequence &ks);






# 69 "/usr/share/qt4/include/QtGui/qkeysequence.h"
class QVariant;
class QKeySequencePrivate;

class  QKeySequence
{
public:
enum StandardKey {
UnknownKey,
HelpContents,
WhatsThis,
Open,
Close,
Save,
New,
Delete,
Cut,
Copy,
Paste,
Undo,
Redo,
Back,
Forward,
Refresh,
ZoomIn,
ZoomOut,
Print,
AddTab,
NextChild,
PreviousChild,
Find,
FindNext,
FindPrevious,
Replace,
SelectAll,
Bold,
Italic,
Underline,
MoveToNextChar,
MoveToPreviousChar,
MoveToNextWord,
MoveToPreviousWord,
MoveToNextLine,
MoveToPreviousLine,
MoveToNextPage,
MoveToPreviousPage,
MoveToStartOfLine,
MoveToEndOfLine,
MoveToStartOfBlock,
MoveToEndOfBlock,
MoveToStartOfDocument,
MoveToEndOfDocument,
SelectNextChar,
SelectPreviousChar,
SelectNextWord,
SelectPreviousWord,
SelectNextLine,
SelectPreviousLine,
SelectNextPage,
SelectPreviousPage,
SelectStartOfLine,
SelectEndOfLine,
SelectStartOfBlock,
SelectEndOfBlock,
SelectStartOfDocument,
SelectEndOfDocument,
DeleteStartOfWord,
DeleteEndOfWord,
DeleteEndOfLine,
InsertParagraphSeparator,
InsertLineSeparator,
SaveAs,
Preferences,
Quit
};

QKeySequence();
QKeySequence(const QString &key);
QKeySequence(int k1, int k2 = 0, int k3 = 0, int k4 = 0);
QKeySequence(const QKeySequence &ks);
QKeySequence(StandardKey key);
~QKeySequence();

uint count() const; 
bool isEmpty() const;

enum SequenceMatch {
NoMatch,
PartialMatch,
ExactMatch



# 161 "/usr/share/qt4/include/QtGui/qkeysequence.h"
};

enum SequenceFormat {
NativeText,
PortableText
};

QString toString(SequenceFormat format = PortableText) const;
static QKeySequence fromString(const QString &str, SequenceFormat format = PortableText);

SequenceMatch matches(const QKeySequence &seq) const;
static QKeySequence mnemonic(const QString &text);
static QList<QKeySequence> keyBindings(StandardKey key);


operator QString() const;
operator QVariant() const;
operator int() const;
int operator[](uint i) const;
QKeySequence &operator=(const QKeySequence &other);
bool operator==(const QKeySequence &other) const;
inline bool operator!= (const QKeySequence &other) const
{ return !(*this == other); }
bool operator< (const QKeySequence &ks) const;
inline bool operator> (const QKeySequence &other) const
{ return other < *this; }
inline bool operator<= (const QKeySequence &other) const
{ return !(other < *this); }
inline bool operator>= (const QKeySequence &other) const
{ return !(*this < other); }

bool isDetached() const;
private:
static int decodeString(const QString &ks);
static QString encodeString(int key);
int assign(const QString &str);
void setKey(int key, int index);

QKeySequencePrivate *d;

friend  QDataStream &operator<<(QDataStream &in, const QKeySequence &ks);
friend  QDataStream &operator>>(QDataStream &in, QKeySequence &ks);
friend class Q3AccelManager;
friend class QShortcutMap;
friend class QShortcut;

public:
typedef QKeySequencePrivate * DataPtr;
inline DataPtr &data_ptr() { return d; }
};
template <> class QTypeInfo<QKeySequence > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QKeySequence)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QKeySequence"; } };
template <> inline bool qIsDetached<QKeySequence>(QKeySequence &t) { return t.isDetached(); } template <> inline void qSwap<QKeySequence>(QKeySequence &value1, QKeySequence &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }


# 215 "/usr/share/qt4/include/QtGui/qkeysequence.h"
 QDebug operator<<(QDebug, const QKeySequence &);













# 229 "/usr/share/qt4/include/QtGui/qkeysequence.h"





# 57 "/usr/share/qt4/include/QtGui/qwidget.h"






# 63 "/usr/share/qt4/include/QtGui/qwidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QLayout;
class QWSRegionManager;
class QStyle;
class QAction;
class QVariant;

class QActionEvent;
class QMouseEvent;
class QWheelEvent;
class QHoverEvent;
class QKeyEvent;
class QFocusEvent;
class QPaintEvent;
class QMoveEvent;
class QResizeEvent;
class QCloseEvent;
class QContextMenuEvent;
class QInputMethodEvent;
class QTabletEvent;
class QDragEnterEvent;
class QDragMoveEvent;
class QDragLeaveEvent;
class QDropEvent;
class QShowEvent;
class QHideEvent;
class QInputContext;
class QIcon;
class QWindowSurface;
class QLocale;
class QGraphicsProxyWidget;
class QGraphicsEffect;




# 104 "/usr/share/qt4/include/QtGui/qwidget.h"
class QWidgetData
{
public:
WId winid;
uint widget_attributes;
Qt::WindowFlags window_flags;
uint window_state : 4;
uint focus_policy : 4;
uint sizehint_forced :1;
uint is_closing :1;
uint in_show : 1;
uint in_set_window_state : 1;
mutable uint fstrut_dirty : 1;
uint context_menu_policy : 3;
uint window_modality : 2;
uint in_destructor : 1;
uint unused : 13;
QRect crect;
mutable QPalette pal;
QFont fnt;











# 135 "/usr/share/qt4/include/QtGui/qwidget.h"
QRect wrect;
};

class QWidgetPrivate;

class  QWidget : public QObject, public QPaintDevice
{
Q_OBJECT
inline QWidgetPrivate* d_func() { return reinterpret_cast<QWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QWidgetPrivate* d_func() const { return reinterpret_cast<const QWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QWidgetPrivate;

Q_PROPERTY(bool modal READ isModal)
Q_PROPERTY(Qt::WindowModality windowModality READ windowModality WRITE setWindowModality)
Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled)
Q_PROPERTY(QRect geometry READ geometry WRITE setGeometry)
Q_PROPERTY(QRect frameGeometry READ frameGeometry)
Q_PROPERTY(QRect normalGeometry READ normalGeometry)
Q_PROPERTY(int x READ x)
Q_PROPERTY(int y READ y)
Q_PROPERTY(QPoint pos READ pos WRITE move DESIGNABLE false STORED false)
Q_PROPERTY(QSize frameSize READ frameSize)
Q_PROPERTY(QSize size READ size WRITE resize DESIGNABLE false STORED false)
Q_PROPERTY(int width READ width)
Q_PROPERTY(int height READ height)
Q_PROPERTY(QRect rect READ rect)
Q_PROPERTY(QRect childrenRect READ childrenRect)
Q_PROPERTY(QRegion childrenRegion READ childrenRegion)
Q_PROPERTY(QSizePolicy sizePolicy READ sizePolicy WRITE setSizePolicy)
Q_PROPERTY(QSize minimumSize READ minimumSize WRITE setMinimumSize)
Q_PROPERTY(QSize maximumSize READ maximumSize WRITE setMaximumSize)
Q_PROPERTY(int minimumWidth READ minimumWidth WRITE setMinimumWidth STORED false DESIGNABLE false)
Q_PROPERTY(int minimumHeight READ minimumHeight WRITE setMinimumHeight STORED false DESIGNABLE false)
Q_PROPERTY(int maximumWidth READ maximumWidth WRITE setMaximumWidth STORED false DESIGNABLE false)
Q_PROPERTY(int maximumHeight READ maximumHeight WRITE setMaximumHeight STORED false DESIGNABLE false)
Q_PROPERTY(QSize sizeIncrement READ sizeIncrement WRITE setSizeIncrement)
Q_PROPERTY(QSize baseSize READ baseSize WRITE setBaseSize)
Q_PROPERTY(QPalette palette READ palette WRITE setPalette)
Q_PROPERTY(QFont font READ font WRITE setFont)

# 173 "/usr/share/qt4/include/QtGui/qwidget.h"
Q_PROPERTY(QCursor cursor READ cursor WRITE setCursor RESET unsetCursor)

# 175 "/usr/share/qt4/include/QtGui/qwidget.h"
Q_PROPERTY(bool mouseTracking READ hasMouseTracking WRITE setMouseTracking)
Q_PROPERTY(bool isActiveWindow READ isActiveWindow)
Q_PROPERTY(Qt::FocusPolicy focusPolicy READ focusPolicy WRITE setFocusPolicy)
Q_PROPERTY(bool focus READ hasFocus)
Q_PROPERTY(Qt::ContextMenuPolicy contextMenuPolicy READ contextMenuPolicy WRITE setContextMenuPolicy)
Q_PROPERTY(bool updatesEnabled READ updatesEnabled WRITE setUpdatesEnabled DESIGNABLE false)
Q_PROPERTY(bool visible READ isVisible WRITE setVisible DESIGNABLE false)
Q_PROPERTY(bool minimized READ isMinimized)
Q_PROPERTY(bool maximized READ isMaximized)
Q_PROPERTY(bool fullScreen READ isFullScreen)
Q_PROPERTY(QSize sizeHint READ sizeHint)
Q_PROPERTY(QSize minimumSizeHint READ minimumSizeHint)
Q_PROPERTY(bool acceptDrops READ acceptDrops WRITE setAcceptDrops)
Q_PROPERTY(QString windowTitle READ windowTitle WRITE setWindowTitle DESIGNABLE isWindow)
Q_PROPERTY(QIcon windowIcon READ windowIcon WRITE setWindowIcon DESIGNABLE isWindow)
Q_PROPERTY(QString windowIconText READ windowIconText WRITE setWindowIconText DESIGNABLE isWindow)
Q_PROPERTY(double windowOpacity READ windowOpacity WRITE setWindowOpacity DESIGNABLE isWindow)
Q_PROPERTY(bool windowModified READ isWindowModified WRITE setWindowModified DESIGNABLE isWindow)

# 194 "/usr/share/qt4/include/QtGui/qwidget.h"
Q_PROPERTY(QString toolTip READ toolTip WRITE setToolTip)


# 197 "/usr/share/qt4/include/QtGui/qwidget.h"
Q_PROPERTY(QString statusTip READ statusTip WRITE setStatusTip)


# 200 "/usr/share/qt4/include/QtGui/qwidget.h"
Q_PROPERTY(QString whatsThis READ whatsThis WRITE setWhatsThis)


# 203 "/usr/share/qt4/include/QtGui/qwidget.h"
Q_PROPERTY(QString accessibleName READ accessibleName WRITE setAccessibleName)
Q_PROPERTY(QString accessibleDescription READ accessibleDescription WRITE setAccessibleDescription)

# 206 "/usr/share/qt4/include/QtGui/qwidget.h"
Q_PROPERTY(Qt::LayoutDirection layoutDirection READ layoutDirection WRITE setLayoutDirection RESET unsetLayoutDirection)

Q_PROPERTY(bool autoFillBackground READ autoFillBackground WRITE setAutoFillBackground)

# 210 "/usr/share/qt4/include/QtGui/qwidget.h"
Q_PROPERTY(QString styleSheet READ styleSheet WRITE setStyleSheet)

# 212 "/usr/share/qt4/include/QtGui/qwidget.h"
Q_PROPERTY(QLocale locale READ locale WRITE setLocale RESET unsetLocale)
Q_PROPERTY(QString windowFilePath READ windowFilePath WRITE setWindowFilePath DESIGNABLE isWindow)
Q_PROPERTY(Qt::InputMethodHints inputMethodHints READ inputMethodHints WRITE setInputMethodHints)

public:
enum RenderFlag {
DrawWindowBackground = 0x1,
DrawChildren = 0x2,
IgnoreMask = 0x4
};
typedef QFlags<RenderFlag> RenderFlags;

explicit QWidget(QWidget* parent = 0, Qt::WindowFlags f = 0);



# 228 "/usr/share/qt4/include/QtGui/qwidget.h"
~QWidget();

int devType() const;

WId winId() const;
void createWinId(); 
inline WId internalWinId() const { return data->winid; }
WId effectiveWinId() const;


QStyle *style() const;
void setStyle(QStyle *);


bool isTopLevel() const;
bool isWindow() const;

bool isModal() const;
Qt::WindowModality windowModality() const;
void setWindowModality(Qt::WindowModality windowModality);

bool isEnabled() const;
bool isEnabledTo(QWidget*) const;
bool isEnabledToTLW() const;

public slots:
void setEnabled(bool);
void setDisabled(bool);
void setWindowModified(bool);



public:
QRect frameGeometry() const;
const QRect &geometry() const;
QRect normalGeometry() const;

int x() const;
int y() const;
QPoint pos() const;
QSize frameSize() const;
QSize size() const;
inline int width() const;
inline int height() const;
inline QRect rect() const;
QRect childrenRect() const;
QRegion childrenRegion() const;

QSize minimumSize() const;
QSize maximumSize() const;
int minimumWidth() const;
int minimumHeight() const;
int maximumWidth() const;
int maximumHeight() const;
void setMinimumSize(const QSize &);
void setMinimumSize(int minw, int minh);
void setMaximumSize(const QSize &);
void setMaximumSize(int maxw, int maxh);
void setMinimumWidth(int minw);
void setMinimumHeight(int minh);
void setMaximumWidth(int maxw);
void setMaximumHeight(int maxh);





# 295 "/usr/share/qt4/include/QtGui/qwidget.h"
QSize sizeIncrement() const;
void setSizeIncrement(const QSize &);
void setSizeIncrement(int w, int h);
QSize baseSize() const;
void setBaseSize(const QSize &);
void setBaseSize(int basew, int baseh);

void setFixedSize(const QSize &);
void setFixedSize(int w, int h);
void setFixedWidth(int w);
void setFixedHeight(int h);



QPoint mapToGlobal(const QPoint &) const;
QPoint mapFromGlobal(const QPoint &) const;
QPoint mapToParent(const QPoint &) const;
QPoint mapFromParent(const QPoint &) const;
QPoint mapTo(QWidget *, const QPoint &) const;
QPoint mapFrom(QWidget *, const QPoint &) const;

QWidget *window() const;
QWidget *nativeParentWidget() const;
inline QWidget *topLevelWidget() const { return window(); }


const QPalette &palette() const;
void setPalette(const QPalette &);

void setBackgroundRole(QPalette::ColorRole);
QPalette::ColorRole backgroundRole() const;

void setForegroundRole(QPalette::ColorRole);
QPalette::ColorRole foregroundRole() const;

const QFont &font() const;
void setFont(const QFont &);
QFontMetrics fontMetrics() const;
QFontInfo fontInfo() const;


# 336 "/usr/share/qt4/include/QtGui/qwidget.h"
QCursor cursor() const;
void setCursor(const QCursor &);
void unsetCursor();


# 341 "/usr/share/qt4/include/QtGui/qwidget.h"
void setMouseTracking(bool enable);
bool hasMouseTracking() const;
bool underMouse() const;

void setMask(const QBitmap &);
void setMask(const QRegion &);
QRegion mask() const;
void clearMask();

void render(QPaintDevice *target, const QPoint &targetOffset = QPoint(),
const QRegion &sourceRegion = QRegion(),
RenderFlags renderFlags = RenderFlags(DrawWindowBackground | DrawChildren));

void render(QPainter *painter, const QPoint &targetOffset = QPoint(),
const QRegion &sourceRegion = QRegion(),
RenderFlags renderFlags = RenderFlags(DrawWindowBackground | DrawChildren));


# 359 "/usr/share/qt4/include/QtGui/qwidget.h"
QGraphicsEffect *graphicsEffect() const;
void setGraphicsEffect(QGraphicsEffect *effect);


# 363 "/usr/share/qt4/include/QtGui/qwidget.h"
void grabGesture(Qt::GestureType type, Qt::GestureFlags flags = Qt::GestureFlags());
void ungrabGesture(Qt::GestureType type);

public slots:
void setWindowTitle(const QString &);

# 369 "/usr/share/qt4/include/QtGui/qwidget.h"
void setStyleSheet(const QString& styleSheet);

# 371 "/usr/share/qt4/include/QtGui/qwidget.h"
public:

# 373 "/usr/share/qt4/include/QtGui/qwidget.h"
QString styleSheet() const;

# 375 "/usr/share/qt4/include/QtGui/qwidget.h"
QString windowTitle() const;
void setWindowIcon(const QIcon &icon);
QIcon windowIcon() const;
void setWindowIconText(const QString &);
QString windowIconText() const;
void setWindowRole(const QString &);
QString windowRole() const;
void setWindowFilePath(const QString &filePath);
QString windowFilePath() const;

void setWindowOpacity(qreal level);
qreal windowOpacity() const;

bool isWindowModified() const;

# 390 "/usr/share/qt4/include/QtGui/qwidget.h"
void setToolTip(const QString &);
QString toolTip() const;


# 394 "/usr/share/qt4/include/QtGui/qwidget.h"
void setStatusTip(const QString &);
QString statusTip() const;


# 398 "/usr/share/qt4/include/QtGui/qwidget.h"
void setWhatsThis(const QString &);
QString whatsThis() const;


# 402 "/usr/share/qt4/include/QtGui/qwidget.h"
QString accessibleName() const;
void setAccessibleName(const QString &name);
QString accessibleDescription() const;
void setAccessibleDescription(const QString &description);


# 408 "/usr/share/qt4/include/QtGui/qwidget.h"
void setLayoutDirection(Qt::LayoutDirection direction);
Qt::LayoutDirection layoutDirection() const;
void unsetLayoutDirection();

void setLocale(const QLocale &locale);
QLocale locale() const;
void unsetLocale();

inline bool isRightToLeft() const { return layoutDirection() == Qt::RightToLeft; }
inline bool isLeftToRight() const { return layoutDirection() == Qt::LeftToRight; }

public slots:
inline void setFocus() { setFocus(Qt::OtherFocusReason); }

public:
bool isActiveWindow() const;
void activateWindow();
void clearFocus();

void setFocus(Qt::FocusReason reason);
Qt::FocusPolicy focusPolicy() const;
void setFocusPolicy(Qt::FocusPolicy policy);
bool hasFocus() const;
static void setTabOrder(QWidget *, QWidget *);
void setFocusProxy(QWidget *);
QWidget *focusProxy() const;
Qt::ContextMenuPolicy contextMenuPolicy() const;
void setContextMenuPolicy(Qt::ContextMenuPolicy policy);


void grabMouse();

# 440 "/usr/share/qt4/include/QtGui/qwidget.h"
void grabMouse(const QCursor &);

# 442 "/usr/share/qt4/include/QtGui/qwidget.h"
void releaseMouse();
void grabKeyboard();
void releaseKeyboard();

# 446 "/usr/share/qt4/include/QtGui/qwidget.h"
int grabShortcut(const QKeySequence &key, Qt::ShortcutContext context = Qt::WindowShortcut);
void releaseShortcut(int id);
void setShortcutEnabled(int id, bool enable = true);
void setShortcutAutoRepeat(int id, bool enable = true);

# 451 "/usr/share/qt4/include/QtGui/qwidget.h"
static QWidget *mouseGrabber();
static QWidget *keyboardGrabber();


inline bool updatesEnabled() const;
void setUpdatesEnabled(bool enable);






# 463 "/usr/share/qt4/include/QtGui/qwidget.h"
QGraphicsProxyWidget *graphicsProxyWidget() const;


# 466 "/usr/share/qt4/include/QtGui/qwidget.h"
public slots:
void update();
void repaint();

public:
inline void update(int x, int y, int w, int h);
void update(const QRect&);
void update(const QRegion&);

void repaint(int x, int y, int w, int h);
void repaint(const QRect &);
void repaint(const QRegion &);

public slots:


virtual void setVisible(bool visible);
inline void setHidden(bool hidden) { setVisible(!hidden); }

# 485 "/usr/share/qt4/include/QtGui/qwidget.h"
inline void show() { setVisible(true); }



# 489 "/usr/share/qt4/include/QtGui/qwidget.h"
inline void hide() { setVisible(false); }
inline  void setShown(bool shown) { setVisible(shown); }

void showMinimized();
void showMaximized();
void showFullScreen();
void showNormal();

bool close();
void raise();
void lower();

public:
void stackUnder(QWidget*);
void move(int x, int y);
void move(const QPoint &);
void resize(int w, int h);
void resize(const QSize &);
inline void setGeometry(int x, int y, int w, int h);
void setGeometry(const QRect &);
QByteArray saveGeometry() const;
bool restoreGeometry(const QByteArray &geometry);
void adjustSize();
bool isVisible() const;
bool isVisibleTo(QWidget*) const;

inline bool isHidden() const;

bool isMinimized() const;
bool isMaximized() const;
bool isFullScreen() const;

Qt::WindowStates windowState() const;
void setWindowState(Qt::WindowStates state);
void overrideWindowState(Qt::WindowStates state);

virtual QSize sizeHint() const;
virtual QSize minimumSizeHint() const;

QSizePolicy sizePolicy() const;
void setSizePolicy(QSizePolicy);
inline void setSizePolicy(QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical);
virtual int heightForWidth(int) const;

QRegion visibleRegion() const;

void setContentsMargins(int left, int top, int right, int bottom);
void setContentsMargins(const QMargins &margins);
void getContentsMargins(int *left, int *top, int *right, int *bottom) const;
QMargins contentsMargins() const;

QRect contentsRect() const;

public:
QLayout *layout() const;
void setLayout(QLayout *);
void updateGeometry();

void setParent(QWidget *parent);
void setParent(QWidget *parent, Qt::WindowFlags f);

void scroll(int dx, int dy);
void scroll(int dx, int dy, const QRect&);



QWidget *focusWidget() const;
QWidget *nextInFocusChain() const;
QWidget *previousInFocusChain() const;


bool acceptDrops() const;
void setAcceptDrops(bool on);


# 564 "/usr/share/qt4/include/QtGui/qwidget.h"

void addAction(QAction *action);
void addActions(QList<QAction*> actions);
void insertAction(QAction *before, QAction *action);
void insertActions(QAction *before, QList<QAction*> actions);
void removeAction(QAction *action);
QList<QAction*> actions() const;


# 573 "/usr/share/qt4/include/QtGui/qwidget.h"
QWidget *parentWidget() const;

void setWindowFlags(Qt::WindowFlags type);
inline Qt::WindowFlags windowFlags() const;
void overrideWindowFlags(Qt::WindowFlags type);

inline Qt::WindowType windowType() const;

static QWidget *find(WId);



# 585 "/usr/share/qt4/include/QtGui/qwidget.h"
inline QWidget *childAt(int x, int y) const;
QWidget *childAt(const QPoint &p) const;















# 602 "/usr/share/qt4/include/QtGui/qwidget.h"
Qt::HANDLE handle() const;


# 605 "/usr/share/qt4/include/QtGui/qwidget.h"
void setAttribute(Qt::WidgetAttribute, bool on = true);
inline bool testAttribute(Qt::WidgetAttribute) const;

QPaintEngine *paintEngine() const;

void ensurePolished() const;

QInputContext *inputContext();
void setInputContext(QInputContext *);

bool isAncestorOf(const QWidget *child) const;






# 622 "/usr/share/qt4/include/QtGui/qwidget.h"
bool autoFillBackground() const;
void setAutoFillBackground(bool enabled);

void setWindowSurface(QWindowSurface *surface);
QWindowSurface *windowSurface() const;

signals:
void customContextMenuRequested(const QPoint &pos);

protected:

bool event(QEvent *);
virtual void mousePressEvent(QMouseEvent *);
virtual void mouseReleaseEvent(QMouseEvent *);
virtual void mouseDoubleClickEvent(QMouseEvent *);
virtual void mouseMoveEvent(QMouseEvent *);

# 639 "/usr/share/qt4/include/QtGui/qwidget.h"
virtual void wheelEvent(QWheelEvent *);

# 641 "/usr/share/qt4/include/QtGui/qwidget.h"
virtual void keyPressEvent(QKeyEvent *);
virtual void keyReleaseEvent(QKeyEvent *);
virtual void focusInEvent(QFocusEvent *);
virtual void focusOutEvent(QFocusEvent *);
virtual void enterEvent(QEvent *);
virtual void leaveEvent(QEvent *);
virtual void paintEvent(QPaintEvent *);
virtual void moveEvent(QMoveEvent *);
virtual void resizeEvent(QResizeEvent *);
virtual void closeEvent(QCloseEvent *);

# 652 "/usr/share/qt4/include/QtGui/qwidget.h"
virtual void contextMenuEvent(QContextMenuEvent *);


# 655 "/usr/share/qt4/include/QtGui/qwidget.h"
virtual void tabletEvent(QTabletEvent *);


# 658 "/usr/share/qt4/include/QtGui/qwidget.h"
virtual void actionEvent(QActionEvent *);



# 662 "/usr/share/qt4/include/QtGui/qwidget.h"
virtual void dragEnterEvent(QDragEnterEvent *);
virtual void dragMoveEvent(QDragMoveEvent *);
virtual void dragLeaveEvent(QDragLeaveEvent *);
virtual void dropEvent(QDropEvent *);


# 668 "/usr/share/qt4/include/QtGui/qwidget.h"
virtual void showEvent(QShowEvent *);
virtual void hideEvent(QHideEvent *);














# 684 "/usr/share/qt4/include/QtGui/qwidget.h"

virtual void changeEvent(QEvent *);

int metric(PaintDeviceMetric) const;

virtual void inputMethodEvent(QInputMethodEvent *);
public:
virtual QVariant inputMethodQuery(Qt::InputMethodQuery) const;

Qt::InputMethodHints inputMethodHints() const;
void setInputMethodHints(Qt::InputMethodHints hints);

protected:
void resetInputContext();
protected slots:
void updateMicroFocus();
protected:

void create(WId = 0, bool initializeWindow = true,
bool destroyOldWindow = true);
void destroy(bool destroyWindow = true,
bool destroySubWindows = true);

virtual bool focusNextPrevChild(bool next);
inline bool focusNextChild() { return focusNextPrevChild(true); }
inline bool focusPreviousChild() { return focusNextPrevChild(false); }

protected:
QWidget(QWidgetPrivate &d, QWidget* parent, Qt::WindowFlags f);
private:

bool testAttribute_helper(Qt::WidgetAttribute) const;

QLayout *takeLayout();

friend class QBackingStoreDevice;
friend class QWidgetBackingStore;
friend class QApplication;
friend class QApplicationPrivate;
friend class QBaseApplication;
friend class QPainter;
friend class QPainterPrivate;
friend class QPixmap; 
friend class QFontMetrics;
friend class QFontInfo;
friend class QETWidget;
friend class QLayout;
friend class QWidgetItem;
friend class QWidgetItemV2;
friend class QGLContext;
friend class QGLWidget;
friend class QGLWindowSurface;
friend class QX11PaintEngine;
friend class QWin32PaintEngine;
friend class QShortcutPrivate;
friend class QShortcutMap;
friend class QWindowSurface;
friend class QGraphicsProxyWidget;
friend class QGraphicsProxyWidgetPrivate;
friend class QStyleSheetStyle;
friend struct QWidgetExceptionCleaner;
friend class QGestureManager;
friend class QWinNativePanGestureRecognizer;
friend class QWidgetEffectSourcePrivate;






























# 778 "/usr/share/qt4/include/QtGui/qwidget.h"
friend  QWidgetData *qt_qwidget_data(QWidget *widget);
friend  QWidgetPrivate *qt_widget_private(QWidget *widget);

private:
QWidget(const QWidget &); QWidget &operator=(const QWidget &);





# 788 "/usr/share/qt4/include/QtGui/qwidget.h"
QWidgetData *data;
































































































# 885 "/usr/share/qt4/include/QtGui/qwidget.h"
protected:
virtual void styleChange(QStyle&); 
virtual void enabledChange(bool); 
virtual void paletteChange(const QPalette &); 
virtual void fontChange(const QFont &); 
virtual void windowActivationChange(bool); 
virtual void languageChange(); 
};

inline QFlags<QWidget::RenderFlags::enum_type> operator|(QWidget::RenderFlags::enum_type f1, QWidget::RenderFlags::enum_type f2) { return QFlags<QWidget::RenderFlags::enum_type>(f1) | f2; } inline QFlags<QWidget::RenderFlags::enum_type> operator|(QWidget::RenderFlags::enum_type f1, QFlags<QWidget::RenderFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QWidget::RenderFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }








# 903 "/usr/share/qt4/include/QtGui/qwidget.h"
template <> inline QWidget *qobject_cast<QWidget*>(QObject *o)
{
if (!o || !o->isWidgetType()) return 0;
return static_cast<QWidget*>(o);
}
template <> inline const QWidget *qobject_cast<const QWidget*>(const QObject *o)
{
if (!o || !o->isWidgetType()) return 0;
return static_cast<const QWidget*>(o);
}


# 915 "/usr/share/qt4/include/QtGui/qwidget.h"
inline QWidget *QWidget::childAt(int ax, int ay) const
{ return childAt(QPoint(ax, ay)); }

inline Qt::WindowType QWidget::windowType() const
{ return static_cast<Qt::WindowType>(int(data->window_flags & Qt::WindowType_Mask)); }
inline Qt::WindowFlags QWidget::windowFlags() const
{ return data->window_flags; }

inline bool QWidget::isTopLevel() const
{ return (windowType() & Qt::Window); }

inline bool QWidget::isWindow() const
{ return (windowType() & Qt::Window); }

inline bool QWidget::isEnabled() const
{ return !testAttribute(Qt::WA_Disabled); }

inline bool QWidget::isModal() const
{ return data->window_modality != Qt::NonModal; }

inline bool QWidget::isEnabledToTLW() const
{ return isEnabled(); }

inline int QWidget::minimumWidth() const
{ return minimumSize().width(); }

inline int QWidget::minimumHeight() const
{ return minimumSize().height(); }

inline int QWidget::maximumWidth() const
{ return maximumSize().width(); }

inline int QWidget::maximumHeight() const
{ return maximumSize().height(); }

inline void QWidget::setMinimumSize(const QSize &s)
{ setMinimumSize(s.width(),s.height()); }

inline void QWidget::setMaximumSize(const QSize &s)
{ setMaximumSize(s.width(),s.height()); }

inline void QWidget::setSizeIncrement(const QSize &s)
{ setSizeIncrement(s.width(),s.height()); }

inline void QWidget::setBaseSize(const QSize &s)
{ setBaseSize(s.width(),s.height()); }

inline const QFont &QWidget::font() const
{ return data->fnt; }

inline QFontMetrics QWidget::fontMetrics() const
{ return QFontMetrics(data->fnt); }

inline QFontInfo QWidget::fontInfo() const
{ return QFontInfo(data->fnt); }

inline void QWidget::setMouseTracking(bool enable)
{ setAttribute(Qt::WA_MouseTracking, enable); }

inline bool QWidget::hasMouseTracking() const
{ return testAttribute(Qt::WA_MouseTracking); }

inline bool QWidget::underMouse() const
{ return testAttribute(Qt::WA_UnderMouse); }

inline bool QWidget::updatesEnabled() const
{ return !testAttribute(Qt::WA_UpdatesDisabled); }

inline void QWidget::update(int ax, int ay, int aw, int ah)
{ update(QRect(ax, ay, aw, ah)); }

inline bool QWidget::isVisible() const
{ return testAttribute(Qt::WA_WState_Visible); }

inline bool QWidget::isHidden() const
{ return testAttribute(Qt::WA_WState_Hidden); }

inline void QWidget::move(int ax, int ay)
{ move(QPoint(ax, ay)); }

inline void QWidget::resize(int w, int h)
{ resize(QSize(w, h)); }

inline void QWidget::setGeometry(int ax, int ay, int aw, int ah)
{ setGeometry(QRect(ax, ay, aw, ah)); }

inline QRect QWidget::rect() const
{ return QRect(0,0,data->crect.width(),data->crect.height()); }

inline const QRect &QWidget::geometry() const
{ return data->crect; }

inline QSize QWidget::size() const
{ return data->crect.size(); }

inline int QWidget::width() const
{ return data->crect.width(); }

inline int QWidget::height() const
{ return data->crect.height(); }

inline QWidget *QWidget::parentWidget() const
{ return static_cast<QWidget *>(QObject::parent()); }

inline void QWidget::setSizePolicy(QSizePolicy::Policy hor, QSizePolicy::Policy ver)
{ setSizePolicy(QSizePolicy(hor, ver)); }

inline bool QWidget::testAttribute(Qt::WidgetAttribute attribute) const
{
if (attribute < int(8*sizeof(uint)))
return data->widget_attributes & (1<<attribute);
return testAttribute_helper(attribute);
}










































# 1070 "/usr/share/qt4/include/QtGui/qwidget.h"





# 47 "/usr/share/qt4/include/QtGui/qstylepainter.h"


# 49 "/usr/share/qt4/include/QtGui/qstylepainter.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QStylePainter : public QPainter
{
public:
inline QStylePainter() : QPainter(), widget(0), wstyle(0) {}
inline explicit QStylePainter(QWidget *w) { begin(w, w); }
inline QStylePainter(QPaintDevice *pd, QWidget *w) { begin(pd, w); }
inline bool begin(QWidget *w) { return begin(w, w); }
inline bool begin(QPaintDevice *pd, QWidget *w) {
qt_noop();
widget = w;
wstyle = w->style();
return QPainter::begin(pd);
};
inline void drawPrimitive(QStyle::PrimitiveElement pe, const QStyleOption &opt);
inline void drawControl(QStyle::ControlElement ce, const QStyleOption &opt);
inline void drawComplexControl(QStyle::ComplexControl cc, const QStyleOptionComplex &opt);
inline void drawItemText(const QRect &r, int flags, const QPalette &pal, bool enabled,
const QString &text, QPalette::ColorRole textRole = QPalette::NoRole);
inline void drawItemPixmap(const QRect &r, int flags, const QPixmap &pixmap);
inline QStyle *style() const { return wstyle; }

private:
QWidget *widget;
QStyle *wstyle;
QStylePainter(const QStylePainter &); QStylePainter &operator=(const QStylePainter &);
};

void QStylePainter::drawPrimitive(QStyle::PrimitiveElement pe, const QStyleOption &opt)
{
wstyle->drawPrimitive(pe, &opt, this, widget);
}

void QStylePainter::drawControl(QStyle::ControlElement ce, const QStyleOption &opt)
{
wstyle->drawControl(ce, &opt, this, widget);
}

void QStylePainter::drawComplexControl(QStyle::ComplexControl cc, const QStyleOptionComplex &opt)
{
wstyle->drawComplexControl(cc, &opt, this, widget);
}

void QStylePainter::drawItemText(const QRect &r, int flags, const QPalette &pal, bool enabled,
const QString &text, QPalette::ColorRole textRole)
{
wstyle->drawItemText(this, r, flags, pal, enabled, text, textRole);
}

void QStylePainter::drawItemPixmap(const QRect &r, int flags, const QPixmap &pixmap)
{
wstyle->drawItemPixmap(this, r, flags, pixmap);
}






# 20 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtransform.h"











































































































































































































































































































































































































# 21 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qwmatrix.h"












































# 1 "/usr/share/qt4/include/QtGui/qmatrix.h"












































































































































































































# 45 "/usr/share/qt4/include/QtGui/qwmatrix.h"


# 47 "/usr/share/qt4/include/QtGui/qwmatrix.h"




typedef QtValidLicenseForGuiModule QtGuiModule;





# 57 "/usr/share/qt4/include/QtGui/qwmatrix.h"





# 22 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qabstracttextdocumentlayout.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qabstracttextdocumentlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qtextlayout.h"











































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 44 "/usr/share/qt4/include/QtGui/qtextlayout.h"

# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtextlayout.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qtextlayout.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qtextlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qcolor.h"

















































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qtextlayout.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qtextlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qevent.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 45 "/usr/share/qt4/include/QtGui/qevent.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qevent.h"

# 1 "/usr/share/qt4/include/QtGui/qregion.h"









































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qevent.h"

# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qevent.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qevent.h"

# 1 "/usr/share/qt4/include/QtGui/qkeysequence.h"







































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qevent.h"

# 1 "/usr/share/qt4/include/QtCore/qcoreevent.h"
































































































































































































































































































































































































# 51 "/usr/share/qt4/include/QtGui/qevent.h"

# 1 "/usr/share/qt4/include/QtGui/qmime.h"












































# 1 "/usr/share/qt4/include/QtCore/qmimedata.h"








































































































# 45 "/usr/share/qt4/include/QtGui/qmime.h"


# 47 "/usr/share/qt4/include/QtGui/qmime.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class  QMimeSource
{
public:
virtual ~QMimeSource();
virtual const char* format(int n = 0) const = 0;
virtual bool provides(const char*) const;
virtual QByteArray encodedData(const char*) const = 0;
};







































































































# 172 "/usr/share/qt4/include/QtGui/qmime.h"





# 52 "/usr/share/qt4/include/QtGui/qevent.h"

# 1 "/usr/share/qt4/include/QtGui/qdrag.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qdrag.h"


# 47 "/usr/share/qt4/include/QtGui/qdrag.h"




typedef QtValidLicenseForGuiModule QtGuiModule;


# 54 "/usr/share/qt4/include/QtGui/qdrag.h"
class QMimeData;
class QDragPrivate;
class QWidget;
class QPixmap;
class QPoint;
class QDragManager;

class  QDrag : public QObject
{
Q_OBJECT
inline QDragPrivate* d_func() { return reinterpret_cast<QDragPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDragPrivate* d_func() const { return reinterpret_cast<const QDragPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDragPrivate;
public:
explicit QDrag(QWidget *dragSource);
~QDrag();

void setMimeData(QMimeData *data);
QMimeData *mimeData() const;

void setPixmap(const QPixmap &);
QPixmap pixmap() const;

void setHotSpot(const QPoint &hotspot);
QPoint hotSpot() const;

QWidget *source() const;
QWidget *target() const;

Qt::DropAction start(Qt::DropActions supportedActions = Qt::CopyAction);
Qt::DropAction exec(Qt::DropActions supportedActions = Qt::MoveAction);
Qt::DropAction exec(Qt::DropActions supportedActions, Qt::DropAction defaultAction);

void setDragCursor(const QPixmap &cursor, Qt::DropAction action);

signals:
void actionChanged(Qt::DropAction action);
void targetChanged(QWidget *newTarget);

private:



# 95 "/usr/share/qt4/include/QtGui/qdrag.h"
friend class QDragManager;
QDrag(const QDrag &); QDrag &operator=(const QDrag &);
};



# 101 "/usr/share/qt4/include/QtGui/qdrag.h"





# 53 "/usr/share/qt4/include/QtGui/qevent.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 54 "/usr/share/qt4/include/QtGui/qevent.h"

# 1 "/usr/share/qt4/include/QtCore/qmap.h"




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 55 "/usr/share/qt4/include/QtGui/qevent.h"

# 1 "/usr/share/qt4/include/QtCore/qset.h"














































































































































































































































































































































































# 56 "/usr/share/qt4/include/QtGui/qevent.h"


# 58 "/usr/share/qt4/include/QtGui/qevent.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QAction;
class QGesture;

class  QInputEvent : public QEvent
{
public:
QInputEvent(Type type, Qt::KeyboardModifiers modifiers = Qt::NoModifier);
~QInputEvent();
inline Qt::KeyboardModifiers modifiers() const { return modState; }
inline void setModifiers(Qt::KeyboardModifiers amodifiers) { modState = amodifiers; }
protected:
Qt::KeyboardModifiers modState;
};

class  QMouseEvent : public QInputEvent
{
public:
QMouseEvent(Type type, const QPoint &pos, Qt::MouseButton button,
Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers);
QMouseEvent(Type type, const QPoint &pos, const QPoint &globalPos,
Qt::MouseButton button, Qt::MouseButtons buttons,
Qt::KeyboardModifiers modifiers);
~QMouseEvent();

inline const QPoint &pos() const { return p; }
inline const QPoint &globalPos() const { return g; }
inline int x() const { return p.x(); }
inline int y() const { return p.y(); }
inline int globalX() const { return g.x(); }
inline int globalY() const { return g.y(); }
inline Qt::MouseButton button() const { return b; }
inline Qt::MouseButtons buttons() const { return mouseState; }

static QMouseEvent *createExtendedMouseEvent(Type type, const QPointF &pos,
const QPoint &globalPos, Qt::MouseButton button,
Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers);
inline bool hasExtendedInfo() const { return reinterpret_cast<const QMouseEvent *>(d) == this; }
QPointF posF() const;










# 112 "/usr/share/qt4/include/QtGui/qevent.h"
protected:
QPoint p, g;
Qt::MouseButton b;
Qt::MouseButtons mouseState;
};

class  QHoverEvent : public QEvent
{
public:
QHoverEvent(Type type, const QPoint &pos, const QPoint &oldPos);
~QHoverEvent();

inline const QPoint &pos() const { return p; }
inline const QPoint &oldPos() const { return op; }

protected:
QPoint p, op;
};


# 132 "/usr/share/qt4/include/QtGui/qevent.h"
class  QWheelEvent : public QInputEvent
{
public:
QWheelEvent(const QPoint &pos, int delta,
Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers,
Qt::Orientation orient = Qt::Vertical);
QWheelEvent(const QPoint &pos, const QPoint& globalPos, int delta,
Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers,
Qt::Orientation orient = Qt::Vertical);
~QWheelEvent();

inline int delta() const { return d; }
inline const QPoint &pos() const { return p; }
inline const QPoint &globalPos() const { return g; }
inline int x() const { return p.x(); }
inline int y() const { return p.y(); }
inline int globalX() const { return g.x(); }
inline int globalY() const { return g.y(); }

inline Qt::MouseButtons buttons() const { return mouseState; }
Qt::Orientation orientation() const { return o; }









# 162 "/usr/share/qt4/include/QtGui/qevent.h"
protected:
QPoint p;
QPoint g;
int d;
Qt::MouseButtons mouseState;
Qt::Orientation o;
};



# 172 "/usr/share/qt4/include/QtGui/qevent.h"
class  QTabletEvent : public QInputEvent
{
public:
enum TabletDevice { NoDevice, Puck, Stylus, Airbrush, FourDMouse,
XFreeEraser , RotationStylus };
enum PointerType { UnknownPointer, Pen, Cursor, Eraser };
QTabletEvent(Type t, const QPoint &pos, const QPoint &globalPos, const QPointF &hiResGlobalPos,
int device, int pointerType, qreal pressure, int xTilt, int yTilt,
qreal tangentialPressure, qreal rotation, int z,
Qt::KeyboardModifiers keyState, qint64 uniqueID);
~QTabletEvent();

inline const QPoint &pos() const { return mPos; }
inline const QPoint &globalPos() const { return mGPos; }
inline const QPointF &hiResGlobalPos() const { return mHiResGlobalPos; }
inline int x() const { return mPos.x(); }
inline int y() const { return mPos.y(); }
inline int globalX() const { return mGPos.x(); }
inline int globalY() const { return mGPos.y(); }
inline qreal hiResGlobalX() const { return mHiResGlobalPos.x(); }
inline qreal hiResGlobalY() const { return mHiResGlobalPos.y(); }
inline TabletDevice device() const { return TabletDevice(mDev); }
inline PointerType pointerType() const { return PointerType(mPointerType); }
inline qint64 uniqueId() const { return mUnique; }
inline qreal pressure() const { return mPress; }
inline int z() const { return mZ; }
inline qreal tangentialPressure() const { return mTangential; }
inline qreal rotation() const { return mRot; }
inline int xTilt() const { return mXT; }
inline int yTilt() const { return mYT; }

protected:
QPoint mPos, mGPos;
QPointF mHiResGlobalPos;
int mDev, mPointerType, mXT, mYT, mZ;
qreal mPress, mTangential, mRot;
qint64 mUnique;




void *mExtra;
};


# 217 "/usr/share/qt4/include/QtGui/qevent.h"
class  QKeyEvent : public QInputEvent
{
public:
QKeyEvent(Type type, int key, Qt::KeyboardModifiers modifiers, const QString& text = QString(),
bool autorep = false, ushort count = 1);
~QKeyEvent();

int key() const { return k; }

# 226 "/usr/share/qt4/include/QtGui/qevent.h"
bool matches(QKeySequence::StandardKey key) const;

# 228 "/usr/share/qt4/include/QtGui/qevent.h"
Qt::KeyboardModifiers modifiers() const;
inline QString text() const { return txt; }
inline bool isAutoRepeat() const { return autor; }
inline int count() const { return int(c); }


static QKeyEvent *createExtendedKeyEvent(Type type, int key, Qt::KeyboardModifiers modifiers,
quint32 nativeScanCode, quint32 nativeVirtualKey,
quint32 nativeModifiers,
const QString& text = QString(), bool autorep = false,
ushort count = 1);
inline bool hasExtendedInfo() const { return reinterpret_cast<const QKeyEvent*>(d) == this; }
quint32 nativeScanCode() const;
quint32 nativeVirtualKey() const;
quint32 nativeModifiers() const;

















# 260 "/usr/share/qt4/include/QtGui/qevent.h"
protected:
QString txt;
int k;
ushort c;
uint autor:1;
};


class  QFocusEvent : public QEvent
{
public:
QFocusEvent(Type type, Qt::FocusReason reason=Qt::OtherFocusReason);
~QFocusEvent();

inline bool gotFocus() const { return type() == FocusIn; }
inline bool lostFocus() const { return type() == FocusOut; }







# 283 "/usr/share/qt4/include/QtGui/qevent.h"
Qt::FocusReason reason();
Qt::FocusReason reason() const;

private:
Qt::FocusReason m_reason;
};


class  QPaintEvent : public QEvent
{
public:
QPaintEvent(const QRegion& paintRegion);
QPaintEvent(const QRect &paintRect);
~QPaintEvent();

inline const QRect &rect() const { return m_rect; }
inline const QRegion &region() const { return m_region; }







# 307 "/usr/share/qt4/include/QtGui/qevent.h"
protected:
friend class QApplication;
friend class QCoreApplication;
QRect m_rect;
QRegion m_region;
bool m_erased;
};

class QUpdateLaterEvent : public QEvent
{
public:
QUpdateLaterEvent(const QRegion& paintRegion);
~QUpdateLaterEvent();

inline const QRegion &region() const { return m_region; }

protected:
QRegion m_region;
};

class  QMoveEvent : public QEvent
{
public:
QMoveEvent(const QPoint &pos, const QPoint &oldPos);
~QMoveEvent();

inline const QPoint &pos() const { return p; }
inline const QPoint &oldPos() const { return oldp;}
protected:
QPoint p, oldp;
friend class QApplication;
friend class QCoreApplication;
};


class  QResizeEvent : public QEvent
{
public:
QResizeEvent(const QSize &size, const QSize &oldSize);
~QResizeEvent();

inline const QSize &size() const { return s; }
inline const QSize &oldSize()const { return olds;}
protected:
QSize s, olds;
friend class QApplication;
friend class QCoreApplication;
};


class  QCloseEvent : public QEvent
{
public:
QCloseEvent();
~QCloseEvent();
};


class  QIconDragEvent : public QEvent
{
public:
QIconDragEvent();
~QIconDragEvent();
};


class  QShowEvent : public QEvent
{
public:
QShowEvent();
~QShowEvent();
};


class  QHideEvent : public QEvent
{
public:
QHideEvent();
~QHideEvent();
};


# 389 "/usr/share/qt4/include/QtGui/qevent.h"
class  QContextMenuEvent : public QInputEvent
{
public:
enum Reason { Mouse, Keyboard, Other };

QContextMenuEvent(Reason reason, const QPoint &pos, const QPoint &globalPos,
Qt::KeyboardModifiers modifiers);
QContextMenuEvent(Reason reason, const QPoint &pos, const QPoint &globalPos);
QContextMenuEvent(Reason reason, const QPoint &pos);
~QContextMenuEvent();

inline int x() const { return p.x(); }
inline int y() const { return p.y(); }
inline int globalX() const { return gp.x(); }
inline int globalY() const { return gp.y(); }

inline const QPoint& pos() const { return p; }
inline const QPoint& globalPos() const { return gp; }

inline Reason reason() const { return Reason(reas); }







# 416 "/usr/share/qt4/include/QtGui/qevent.h"
protected:
QPoint p;
QPoint gp;
uint reas : 8;
};



# 424 "/usr/share/qt4/include/QtGui/qevent.h"
class  QInputMethodEvent : public QEvent
{
public:
enum AttributeType {
TextFormat,
Cursor,
Language,
Ruby,
Selection
};
class Attribute {
public:
Attribute(AttributeType t, int s, int l, QVariant val) : type(t), start(s), length(l), value(val) {}
AttributeType type;

int start;
int length;
QVariant value;
};
QInputMethodEvent();
QInputMethodEvent(const QString &preeditText, const QList<Attribute> &attributes);
void setCommitString(const QString &commitString, int replaceFrom = 0, int replaceLength = 0);

inline const QList<Attribute> &attributes() const { return attrs; }
inline const QString &preeditString() const { return preedit; }

inline const QString &commitString() const { return commit; }
inline int replacementStart() const { return replace_from; }
inline int replacementLength() const { return replace_length; }

QInputMethodEvent(const QInputMethodEvent &other);

private:
QString preedit;
QList<Attribute> attrs;
QString commit;
int replace_from;
int replace_length;
};




# 467 "/usr/share/qt4/include/QtGui/qevent.h"
class QMimeData;

class  QDropEvent : public QEvent

, public QMimeSource

{
public:
QDropEvent(const QPoint& pos, Qt::DropActions actions, const QMimeData *data,
Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Type type = Drop);
~QDropEvent();

inline const QPoint &pos() const { return p; }
inline Qt::MouseButtons mouseButtons() const { return mouseState; }
inline Qt::KeyboardModifiers keyboardModifiers() const { return modState; }

inline Qt::DropActions possibleActions() const { return act; }
inline Qt::DropAction proposedAction() const { return default_action; }
inline void acceptProposedAction() { drop_action = default_action; accept(); }

inline Qt::DropAction dropAction() const { return drop_action; }
void setDropAction(Qt::DropAction action);

QWidget* source() const;
inline const QMimeData *mimeData() const { return mdata; }


const char* format(int n = 0) const;
QByteArray encodedData(const char*) const;
bool provides(const char*) const;













# 510 "/usr/share/qt4/include/QtGui/qevent.h"
protected:
friend class QApplication;
QPoint p;
Qt::MouseButtons mouseState;
Qt::KeyboardModifiers modState;
Qt::DropActions act;
Qt::DropAction drop_action;
Qt::DropAction default_action;
const QMimeData *mdata;
mutable QList<QByteArray> fmts; 
};


class  QDragMoveEvent : public QDropEvent
{
public:
QDragMoveEvent(const QPoint &pos, Qt::DropActions actions, const QMimeData *data,
Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Type type = DragMove);
~QDragMoveEvent();

inline QRect answerRect() const { return rect; }

inline void accept() { QDropEvent::accept(); }
inline void ignore() { QDropEvent::ignore(); }

inline void accept(const QRect & r) { accept(); rect = r; }
inline void ignore(const QRect & r) { ignore(); rect = r; }





# 542 "/usr/share/qt4/include/QtGui/qevent.h"
protected:
friend class QApplication;
QRect rect;
};


class  QDragEnterEvent : public QDragMoveEvent
{
public:
QDragEnterEvent(const QPoint &pos, Qt::DropActions actions, const QMimeData *data,
Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers);
~QDragEnterEvent();
};



class  QDragResponseEvent : public QEvent
{
public:
QDragResponseEvent(bool accepted);
~QDragResponseEvent();

inline bool dragAccepted() const { return a; }
protected:
bool a;
};


class  QDragLeaveEvent : public QEvent
{
public:
QDragLeaveEvent();
~QDragLeaveEvent();
};



# 579 "/usr/share/qt4/include/QtGui/qevent.h"
class  QHelpEvent : public QEvent
{
public:
QHelpEvent(Type type, const QPoint &pos, const QPoint &globalPos);
~QHelpEvent();

inline int x() const { return p.x(); }
inline int y() const { return p.y(); }
inline int globalX() const { return gp.x(); }
inline int globalY() const { return gp.y(); }

inline const QPoint& pos() const { return p; }
inline const QPoint& globalPos() const { return gp; }

private:
QPoint p;
QPoint gp;
};


# 599 "/usr/share/qt4/include/QtGui/qevent.h"
class  QStatusTipEvent : public QEvent
{
public:
QStatusTipEvent(const QString &tip);
~QStatusTipEvent();

inline QString tip() const { return s; }
private:
QString s;
};



# 612 "/usr/share/qt4/include/QtGui/qevent.h"
class  QWhatsThisClickedEvent : public QEvent
{
public:
QWhatsThisClickedEvent(const QString &href);
~QWhatsThisClickedEvent();

inline QString href() const { return s; }
private:
QString s;
};



# 625 "/usr/share/qt4/include/QtGui/qevent.h"
class  QActionEvent : public QEvent
{
QAction *act, *bef;
public:
QActionEvent(int type, QAction *action, QAction *before = 0);
~QActionEvent();

inline QAction *action() const { return act; }
inline QAction *before() const { return bef; }
};


# 637 "/usr/share/qt4/include/QtGui/qevent.h"
class  QFileOpenEvent : public QEvent
{
public:
QFileOpenEvent(const QString &file);
QFileOpenEvent(const QUrl &url);
~QFileOpenEvent();

inline QString file() const { return f; }
QUrl url() const;
private:
QString f;
};


# 651 "/usr/share/qt4/include/QtGui/qevent.h"
class  QToolBarChangeEvent : public QEvent
{
public:
QToolBarChangeEvent(bool t);
~QToolBarChangeEvent();

inline bool toggle() const { return tog; }
private:
uint tog : 1;
};



# 664 "/usr/share/qt4/include/QtGui/qevent.h"
class  QShortcutEvent : public QEvent
{
public:
QShortcutEvent(const QKeySequence &key, int id, bool ambiguous = false);
~QShortcutEvent();

inline const QKeySequence &key() { return sequence; }
inline const QKeySequence &key() const { return sequence; }
inline int shortcutId() { return sid; }
inline int shortcutId() const { return sid; }
inline bool isAmbiguous() { return ambig; }
inline bool isAmbiguous() const { return ambig; }
protected:
QKeySequence sequence;
bool ambig;
int sid;
};



# 684 "/usr/share/qt4/include/QtGui/qevent.h"
class  QClipboardEvent : public QEvent
{
public:
QClipboardEvent(QEventPrivate *data);
~QClipboardEvent();

QEventPrivate *data() { return d; }
};


# 694 "/usr/share/qt4/include/QtGui/qevent.h"
class  QWindowStateChangeEvent: public QEvent
{
public:
QWindowStateChangeEvent(Qt::WindowStates aOldState);
QWindowStateChangeEvent(Qt::WindowStates aOldState, bool isOverride);
~QWindowStateChangeEvent();

inline Qt::WindowStates oldState() const { return ostate; }
bool isOverride() const;

private:
Qt::WindowStates ostate;
};














# 721 "/usr/share/qt4/include/QtGui/qevent.h"
 QDebug operator<<(QDebug, const QEvent *);



# 725 "/usr/share/qt4/include/QtGui/qevent.h"
inline bool operator==(QKeyEvent *e, QKeySequence::StandardKey key){return (e ? e->matches(key) : false);}
inline bool operator==(QKeySequence::StandardKey key, QKeyEvent *e){return (e ? e->matches(key) : false);}


# 729 "/usr/share/qt4/include/QtGui/qevent.h"
class QTouchEventTouchPointPrivate;
class  QTouchEvent : public QInputEvent
{
public:
class  TouchPoint
{
public:
TouchPoint(int id = -1);
TouchPoint(const QTouchEvent::TouchPoint &other);
~TouchPoint();

int id() const;

Qt::TouchPointState state() const;
bool isPrimary() const;

QPointF pos() const;
QPointF startPos() const;
QPointF lastPos() const;

QPointF scenePos() const;
QPointF startScenePos() const;
QPointF lastScenePos() const;

QPointF screenPos() const;
QPointF startScreenPos() const;
QPointF lastScreenPos() const;

QPointF normalizedPos() const;
QPointF startNormalizedPos() const;
QPointF lastNormalizedPos() const;

QRectF rect() const;
QRectF sceneRect() const;
QRectF screenRect() const;

qreal pressure() const;


void setId(int id);
void setState(Qt::TouchPointStates state);
void setPos(const QPointF &pos);
void setScenePos(const QPointF &scenePos);
void setScreenPos(const QPointF &screenPos);
void setNormalizedPos(const QPointF &normalizedPos);
void setStartPos(const QPointF &startPos);
void setStartScenePos(const QPointF &startScenePos);
void setStartScreenPos(const QPointF &startScreenPos);
void setStartNormalizedPos(const QPointF &startNormalizedPos);
void setLastPos(const QPointF &lastPos);
void setLastScenePos(const QPointF &lastScenePos);
void setLastScreenPos(const QPointF &lastScreenPos);
void setLastNormalizedPos(const QPointF &lastNormalizedPos);
void setRect(const QRectF &rect);
void setSceneRect(const QRectF &sceneRect);
void setScreenRect(const QRectF &screenRect);
void setPressure(qreal pressure);
QTouchEvent::TouchPoint &operator=(const QTouchEvent::TouchPoint &other);

private:
QTouchEventTouchPointPrivate *d;
friend class QApplication;
friend class QApplicationPrivate;
};

enum DeviceType {
TouchScreen,
TouchPad
};

QTouchEvent(QEvent::Type eventType,
QTouchEvent::DeviceType deviceType = TouchScreen,
Qt::KeyboardModifiers modifiers = Qt::NoModifier,
Qt::TouchPointStates touchPointStates = 0,
const QList<QTouchEvent::TouchPoint> &touchPoints = QList<QTouchEvent::TouchPoint>());
~QTouchEvent();

inline QWidget *widget() const { return _widget; }
inline QTouchEvent::DeviceType deviceType() const { return _deviceType; }
inline Qt::TouchPointStates touchPointStates() const { return _touchPointStates; }
inline const QList<QTouchEvent::TouchPoint> &touchPoints() const { return _touchPoints; }


inline void setWidget(QWidget *awidget) { _widget = awidget; }
inline void setDeviceType(DeviceType adeviceType) { _deviceType = adeviceType; }
inline void setTouchPointStates(Qt::TouchPointStates aTouchPointStates) { _touchPointStates = aTouchPointStates; }
inline void setTouchPoints(const QList<QTouchEvent::TouchPoint> &atouchPoints) { _touchPoints = atouchPoints; }

protected:
QWidget *_widget;
QTouchEvent::DeviceType _deviceType;
Qt::TouchPointStates _touchPointStates;
QList<QTouchEvent::TouchPoint> _touchPoints;

friend class QApplication;
friend class QApplicationPrivate;
};

class QGesture;
class QGestureEventPrivate;
class  QGestureEvent : public QEvent
{
public:
QGestureEvent(const QList<QGesture *> &gestures);
~QGestureEvent();

QList<QGesture *> gestures() const;
QGesture *gesture(Qt::GestureType type) const;

QList<QGesture *> activeGestures() const;
QList<QGesture *> canceledGestures() const;


# 842 "/usr/share/qt4/include/QtGui/qevent.h"
inline void setAccepted(bool accepted) { QEvent::setAccepted(accepted); }
inline bool isAccepted() const { return QEvent::isAccepted(); }

inline void accept() { QEvent::accept(); }
inline void ignore() { QEvent::ignore(); }







# 854 "/usr/share/qt4/include/QtGui/qevent.h"
void setAccepted(QGesture *, bool);
void accept(QGesture *);
void ignore(QGesture *);
bool isAccepted(QGesture *) const;

void setAccepted(Qt::GestureType, bool);
void accept(Qt::GestureType);
void ignore(Qt::GestureType);
bool isAccepted(Qt::GestureType) const;

void setWidget(QWidget *widget);
QWidget *widget() const;


# 868 "/usr/share/qt4/include/QtGui/qevent.h"
QPointF mapToGraphicsScene(const QPointF &gesturePoint) const;


# 871 "/usr/share/qt4/include/QtGui/qevent.h"
private:
QGestureEventPrivate *d_func();
const QGestureEventPrivate *d_func() const;

friend class QApplication;
friend class QGestureManager;
};






# 50 "/usr/share/qt4/include/QtGui/qtextlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qtextformat.h"












































# 1 "/usr/share/qt4/include/QtGui/qcolor.h"

















































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtextformat.h"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qtextformat.h"

# 1 "/usr/share/qt4/include/QtCore/qshareddata.h"




































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qtextformat.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qtextformat.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qtextformat.h"

# 1 "/usr/share/qt4/include/QtGui/qpen.h"












































































































































# 50 "/usr/share/qt4/include/QtGui/qtextformat.h"

# 1 "/usr/share/qt4/include/QtGui/qbrush.h"








































































































































































































































































































































# 51 "/usr/share/qt4/include/QtGui/qtextformat.h"

# 1 "/usr/share/qt4/include/QtGui/qtextoption.h"

































































































































































# 52 "/usr/share/qt4/include/QtGui/qtextformat.h"


# 54 "/usr/share/qt4/include/QtGui/qtextformat.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QString;
class QVariant;
class QFont;

class QTextFormatCollection;
class QTextFormatPrivate;
class QTextBlockFormat;
class QTextCharFormat;
class QTextListFormat;
class QTextTableFormat;
class QTextFrameFormat;
class QTextImageFormat;
class QTextTableCellFormat;
class QTextFormat;
class QTextObject;
class QTextCursor;
class QTextDocument;
class QTextLength;


# 80 "/usr/share/qt4/include/QtGui/qtextformat.h"
 QDataStream &operator<<(QDataStream &, const QTextLength &);
 QDataStream &operator>>(QDataStream &, QTextLength &);


# 84 "/usr/share/qt4/include/QtGui/qtextformat.h"
class  QTextLength
{
public:
enum Type { VariableLength = 0, FixedLength, PercentageLength };

inline QTextLength() : lengthType(VariableLength), fixedValueOrPercentage(0) {}

inline explicit QTextLength(Type type, qreal value);

inline Type type() const { return lengthType; }
inline qreal value(qreal maximumLength) const
{
switch (lengthType) {
case FixedLength: return fixedValueOrPercentage;
case VariableLength: return maximumLength;
case PercentageLength: return fixedValueOrPercentage * maximumLength / qreal(100);
}
return -1;
}

inline qreal rawValue() const { return fixedValueOrPercentage; }

inline bool operator==(const QTextLength &other) const
{ return lengthType == other.lengthType
&& qFuzzyCompare(fixedValueOrPercentage, other.fixedValueOrPercentage); }
inline bool operator!=(const QTextLength &other) const
{ return lengthType != other.lengthType
|| !qFuzzyCompare(fixedValueOrPercentage, other.fixedValueOrPercentage); }
operator QVariant() const;

private:
Type lengthType;
qreal fixedValueOrPercentage;
friend  QDataStream &operator<<(QDataStream &, const QTextLength &);
friend  QDataStream &operator>>(QDataStream &, QTextLength &);
};

inline QTextLength::QTextLength(Type atype, qreal avalue)
: lengthType(atype), fixedValueOrPercentage(avalue) {}


# 125 "/usr/share/qt4/include/QtGui/qtextformat.h"
 QDataStream &operator<<(QDataStream &, const QTextFormat &);
 QDataStream &operator>>(QDataStream &, QTextFormat &);


# 129 "/usr/share/qt4/include/QtGui/qtextformat.h"
class  QTextFormat
{

Q_ENUMS(FormatType Property ObjectTypes)
public:
enum FormatType {
InvalidFormat = -1,
BlockFormat = 1,
CharFormat = 2,
ListFormat = 3,
TableFormat = 4,
FrameFormat = 5,

UserFormat = 100
};

enum Property {
ObjectIndex = 0x0,


CssFloat = 0x0800,
LayoutDirection = 0x0801,

OutlinePen = 0x810,
BackgroundBrush = 0x820,
ForegroundBrush = 0x821,

BackgroundImageUrl = 0x823,


BlockAlignment = 0x1010,
BlockTopMargin = 0x1030,
BlockBottomMargin = 0x1031,
BlockLeftMargin = 0x1032,
BlockRightMargin = 0x1033,
TextIndent = 0x1034,
TabPositions = 0x1035,
BlockIndent = 0x1040,
BlockNonBreakableLines = 0x1050,
BlockTrailingHorizontalRulerWidth = 0x1060,


FirstFontProperty = 0x1FE0,
FontCapitalization = FirstFontProperty,
FontLetterSpacing = 0x1FE1,
FontWordSpacing = 0x1FE2,
FontStyleHint = 0x1FE3,
FontStyleStrategy = 0x1FE4,
FontKerning = 0x1FE5,
FontFamily = 0x2000,
FontPointSize = 0x2001,
FontSizeAdjustment = 0x2002,
FontSizeIncrement = FontSizeAdjustment, 
FontWeight = 0x2003,
FontItalic = 0x2004,
FontUnderline = 0x2005, 
FontOverline = 0x2006,
FontStrikeOut = 0x2007,
FontFixedPitch = 0x2008,
FontPixelSize = 0x2009,
LastFontProperty = FontPixelSize,

TextUnderlineColor = 0x2010,
TextVerticalAlignment = 0x2021,
TextOutline = 0x2022,
TextUnderlineStyle = 0x2023,
TextToolTip = 0x2024,

IsAnchor = 0x2030,
AnchorHref = 0x2031,
AnchorName = 0x2032,
ObjectType = 0x2f00,


ListStyle = 0x3000,
ListIndent = 0x3001,


FrameBorder = 0x4000,
FrameMargin = 0x4001,
FramePadding = 0x4002,
FrameWidth = 0x4003,
FrameHeight = 0x4004,
FrameTopMargin = 0x4005,
FrameBottomMargin = 0x4006,
FrameLeftMargin = 0x4007,
FrameRightMargin = 0x4008,
FrameBorderBrush = 0x4009,
FrameBorderStyle = 0x4010,

TableColumns = 0x4100,
TableColumnWidthConstraints = 0x4101,
TableCellSpacing = 0x4102,
TableCellPadding = 0x4103,
TableHeaderRowCount = 0x4104,


TableCellRowSpan = 0x4810,
TableCellColumnSpan = 0x4811,

TableCellTopPadding = 0x4812,
TableCellBottomPadding = 0x4813,
TableCellLeftPadding = 0x4814,
TableCellRightPadding = 0x4815,


ImageName = 0x5000,
ImageWidth = 0x5010,
ImageHeight = 0x5011,








FullWidthSelection = 0x06000,


PageBreakPolicy = 0x7000,


UserProperty = 0x100000
};

enum ObjectTypes {
NoObject,
ImageObject,
TableObject,
TableCellObject,

UserObject = 0x1000
};

enum PageBreakFlag {
PageBreak_Auto = 0,
PageBreak_AlwaysBefore = 0x001,
PageBreak_AlwaysAfter = 0x010

};
typedef QFlags<PageBreakFlag> PageBreakFlags;

QTextFormat();

explicit QTextFormat(int type);

QTextFormat(const QTextFormat &rhs);
QTextFormat &operator=(const QTextFormat &rhs);
~QTextFormat();

void merge(const QTextFormat &other);

inline bool isValid() const { return type() != InvalidFormat; }

int type() const;

int objectIndex() const;
void setObjectIndex(int object);

QVariant property(int propertyId) const;
void setProperty(int propertyId, const QVariant &value);
void clearProperty(int propertyId);
bool hasProperty(int propertyId) const;

bool boolProperty(int propertyId) const;
int intProperty(int propertyId) const;
qreal doubleProperty(int propertyId) const;
QString stringProperty(int propertyId) const;
QColor colorProperty(int propertyId) const;
QPen penProperty(int propertyId) const;
QBrush brushProperty(int propertyId) const;
QTextLength lengthProperty(int propertyId) const;
QVector<QTextLength> lengthVectorProperty(int propertyId) const;

void setProperty(int propertyId, const QVector<QTextLength> &lengths);

QMap<int, QVariant> properties() const;
int propertyCount() const;

inline void setObjectType(int type);
inline int objectType() const
{ return intProperty(ObjectType); }

inline bool isCharFormat() const { return type() == CharFormat; }
inline bool isBlockFormat() const { return type() == BlockFormat; }
inline bool isListFormat() const { return type() == ListFormat; }
inline bool isFrameFormat() const { return type() == FrameFormat; }
inline bool isImageFormat() const { return type() == CharFormat && objectType() == ImageObject; }
inline bool isTableFormat() const { return type() == FrameFormat && objectType() == TableObject; }
inline bool isTableCellFormat() const { return type() == CharFormat && objectType() == TableCellObject; }

QTextBlockFormat toBlockFormat() const;
QTextCharFormat toCharFormat() const;
QTextListFormat toListFormat() const;
QTextTableFormat toTableFormat() const;
QTextFrameFormat toFrameFormat() const;
QTextImageFormat toImageFormat() const;
QTextTableCellFormat toTableCellFormat() const;

bool operator==(const QTextFormat &rhs) const;
inline bool operator!=(const QTextFormat &rhs) const { return !operator==(rhs); }
operator QVariant() const;

inline void setLayoutDirection(Qt::LayoutDirection direction)
{ setProperty(QTextFormat::LayoutDirection, direction); }
inline Qt::LayoutDirection layoutDirection() const
{ return Qt::LayoutDirection(intProperty(QTextFormat::LayoutDirection)); }

inline void setBackground(const QBrush &brush)
{ setProperty(BackgroundBrush, brush); }
inline QBrush background() const
{ return brushProperty(BackgroundBrush); }
inline void clearBackground()
{ clearProperty(BackgroundBrush); }

inline void setForeground(const QBrush &brush)
{ setProperty(ForegroundBrush, brush); }
inline QBrush foreground() const
{ return brushProperty(ForegroundBrush); }
inline void clearForeground()
{ clearProperty(ForegroundBrush); }

private:
QSharedDataPointer<QTextFormatPrivate> d;
qint32 format_type;

friend class QTextFormatCollection;
friend class QTextCharFormat;
friend  QDataStream &operator<<(QDataStream &, const QTextFormat &);
friend  QDataStream &operator>>(QDataStream &, QTextFormat &);
};

inline void QTextFormat::setObjectType(int atype)
{ setProperty(ObjectType, atype); }

inline QFlags<QTextFormat::PageBreakFlags::enum_type> operator|(QTextFormat::PageBreakFlags::enum_type f1, QTextFormat::PageBreakFlags::enum_type f2) { return QFlags<QTextFormat::PageBreakFlags::enum_type>(f1) | f2; } inline QFlags<QTextFormat::PageBreakFlags::enum_type> operator|(QTextFormat::PageBreakFlags::enum_type f1, QFlags<QTextFormat::PageBreakFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTextFormat::PageBreakFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class  QTextCharFormat : public QTextFormat
{
public:
enum VerticalAlignment {
AlignNormal = 0,
AlignSuperScript,
AlignSubScript,
AlignMiddle,
AlignTop,
AlignBottom
};
enum UnderlineStyle { 
NoUnderline,
SingleUnderline,
DashUnderline,
DotLine,
DashDotLine,
DashDotDotLine,
WaveUnderline,
SpellCheckUnderline
};

QTextCharFormat();

bool isValid() const { return isCharFormat(); }
void setFont(const QFont &font);
QFont font() const;

inline void setFontFamily(const QString &family)
{ setProperty(FontFamily, family); }
inline QString fontFamily() const
{ return stringProperty(FontFamily); }

inline void setFontPointSize(qreal size)
{ setProperty(FontPointSize, size); }
inline qreal fontPointSize() const
{ return doubleProperty(FontPointSize); }

inline void setFontWeight(int weight)
{ if (weight == QFont::Normal) weight = 0; setProperty(FontWeight, weight); }
inline int fontWeight() const
{ int weight = intProperty(FontWeight); if (weight == 0) weight = QFont::Normal; return weight; }
inline void setFontItalic(bool italic)
{ setProperty(FontItalic, italic); }
inline bool fontItalic() const
{ return boolProperty(FontItalic); }
inline void setFontCapitalization(QFont::Capitalization capitalization)
{ setProperty(FontCapitalization, capitalization); }
inline QFont::Capitalization fontCapitalization() const
{ return static_cast<QFont::Capitalization>(intProperty(FontCapitalization)); }
inline void setFontLetterSpacing(qreal spacing)
{ setProperty(FontLetterSpacing, spacing); }
inline qreal fontLetterSpacing() const
{ return doubleProperty(FontLetterSpacing); }
inline void setFontWordSpacing(qreal spacing)
{ setProperty(FontWordSpacing, spacing); }
inline qreal fontWordSpacing() const
{ return doubleProperty(FontWordSpacing); }

inline void setFontUnderline(bool underline)
{ setProperty(TextUnderlineStyle, underline ? SingleUnderline : NoUnderline); }
bool fontUnderline() const;

inline void setFontOverline(bool overline)
{ setProperty(FontOverline, overline); }
inline bool fontOverline() const
{ return boolProperty(FontOverline); }

inline void setFontStrikeOut(bool strikeOut)
{ setProperty(FontStrikeOut, strikeOut); }
inline bool fontStrikeOut() const
{ return boolProperty(FontStrikeOut); }

inline void setUnderlineColor(const QColor &color)
{ setProperty(TextUnderlineColor, color); }
inline QColor underlineColor() const
{ return colorProperty(TextUnderlineColor); }

inline void setFontFixedPitch(bool fixedPitch)
{ setProperty(FontFixedPitch, fixedPitch); }
inline bool fontFixedPitch() const
{ return boolProperty(FontFixedPitch); }

inline void setFontStyleHint(QFont::StyleHint hint, QFont::StyleStrategy strategy = QFont::PreferDefault)
{ setProperty(FontStyleHint, hint); setProperty(FontStyleStrategy, strategy); }
inline void setFontStyleStrategy(QFont::StyleStrategy strategy)
{ setProperty(FontStyleStrategy, strategy); }
QFont::StyleHint fontStyleHint() const
{ return static_cast<QFont::StyleHint>(intProperty(FontStyleHint)); }
QFont::StyleStrategy fontStyleStrategy() const
{ return static_cast<QFont::StyleStrategy>(intProperty(FontStyleStrategy)); }

inline void setFontKerning(bool enable)
{ setProperty(FontKerning, enable); }
inline bool fontKerning() const
{ return boolProperty(FontKerning); }

void setUnderlineStyle(UnderlineStyle style);
inline UnderlineStyle underlineStyle() const
{ return static_cast<UnderlineStyle>(intProperty(TextUnderlineStyle)); }

inline void setVerticalAlignment(VerticalAlignment alignment)
{ setProperty(TextVerticalAlignment, alignment); }
inline VerticalAlignment verticalAlignment() const
{ return static_cast<VerticalAlignment>(intProperty(TextVerticalAlignment)); }

inline void setTextOutline(const QPen &pen)
{ setProperty(TextOutline, pen); }
inline QPen textOutline() const
{ return penProperty(TextOutline); }

inline void setToolTip(const QString &tip)
{ setProperty(TextToolTip, tip); }
inline QString toolTip() const
{ return stringProperty(TextToolTip); }

inline void setAnchor(bool anchor)
{ setProperty(IsAnchor, anchor); }
inline bool isAnchor() const
{ return boolProperty(IsAnchor); }

inline void setAnchorHref(const QString &value)
{ setProperty(AnchorHref, value); }
inline QString anchorHref() const
{ return stringProperty(AnchorHref); }

inline void setAnchorName(const QString &name)
{ setAnchorNames(QStringList(name)); }
QString anchorName() const;

inline void setAnchorNames(const QStringList &names)
{ setProperty(AnchorName, names); }
QStringList anchorNames() const;

inline void setTableCellRowSpan(int tableCellRowSpan);
inline int tableCellRowSpan() const
{ int s = intProperty(TableCellRowSpan); if (s == 0) s = 1; return s; }
inline void setTableCellColumnSpan(int tableCellColumnSpan);
inline int tableCellColumnSpan() const
{ int s = intProperty(TableCellColumnSpan); if (s == 0) s = 1; return s; }

protected:
explicit QTextCharFormat(const QTextFormat &fmt);
friend class QTextFormat;
};

inline void QTextCharFormat::setTableCellRowSpan(int _tableCellRowSpan)
{
if (_tableCellRowSpan <= 1)
clearProperty(TableCellRowSpan); 
else
setProperty(TableCellRowSpan, _tableCellRowSpan);
}

inline void QTextCharFormat::setTableCellColumnSpan(int _tableCellColumnSpan)
{
if (_tableCellColumnSpan <= 1)
clearProperty(TableCellColumnSpan); 
else
setProperty(TableCellColumnSpan, _tableCellColumnSpan);
}

class  QTextBlockFormat : public QTextFormat
{
public:
QTextBlockFormat();

bool isValid() const { return isBlockFormat(); }

inline void setAlignment(Qt::Alignment alignment);
inline Qt::Alignment alignment() const
{ int a = intProperty(BlockAlignment); if (a == 0) a = Qt::AlignLeft; return QFlag(a); }

inline void setTopMargin(qreal margin)
{ setProperty(BlockTopMargin, margin); }
inline qreal topMargin() const
{ return doubleProperty(BlockTopMargin); }

inline void setBottomMargin(qreal margin)
{ setProperty(BlockBottomMargin, margin); }
inline qreal bottomMargin() const
{ return doubleProperty(BlockBottomMargin); }

inline void setLeftMargin(qreal margin)
{ setProperty(BlockLeftMargin, margin); }
inline qreal leftMargin() const
{ return doubleProperty(BlockLeftMargin); }

inline void setRightMargin(qreal margin)
{ setProperty(BlockRightMargin, margin); }
inline qreal rightMargin() const
{ return doubleProperty(BlockRightMargin); }

inline void setTextIndent(qreal aindent)
{ setProperty(TextIndent, aindent); }
inline qreal textIndent() const
{ return doubleProperty(TextIndent); }

inline void setIndent(int indent);
inline int indent() const
{ return intProperty(BlockIndent); }

inline void setNonBreakableLines(bool b)
{ setProperty(BlockNonBreakableLines, b); }
inline bool nonBreakableLines() const
{ return boolProperty(BlockNonBreakableLines); }

inline void setPageBreakPolicy(PageBreakFlags flags)
{ setProperty(PageBreakPolicy, int(flags)); }
inline PageBreakFlags pageBreakPolicy() const
{ return PageBreakFlags(intProperty(PageBreakPolicy)); }

void setTabPositions(const QList<QTextOption::Tab> &tabs);
QList<QTextOption::Tab> tabPositions() const;

protected:
explicit QTextBlockFormat(const QTextFormat &fmt);
friend class QTextFormat;
};

inline void QTextBlockFormat::setAlignment(Qt::Alignment aalignment)
{ setProperty(BlockAlignment, int(aalignment)); }

inline void QTextBlockFormat::setIndent(int aindent)
{ setProperty(BlockIndent, aindent); }

class  QTextListFormat : public QTextFormat
{
public:
QTextListFormat();

bool isValid() const { return isListFormat(); }

enum Style {
ListDisc = -1,
ListCircle = -2,
ListSquare = -3,
ListDecimal = -4,
ListLowerAlpha = -5,
ListUpperAlpha = -6,
ListLowerRoman = -7,
ListUpperRoman = -8,
ListStyleUndefined = 0
};

inline void setStyle(Style style);
inline Style style() const
{ return static_cast<Style>(intProperty(ListStyle)); }

inline void setIndent(int indent);
inline int indent() const
{ return intProperty(ListIndent); }

protected:
explicit QTextListFormat(const QTextFormat &fmt);
friend class QTextFormat;
};

inline void QTextListFormat::setStyle(Style astyle)
{ setProperty(ListStyle, astyle); }

inline void QTextListFormat::setIndent(int aindent)
{ setProperty(ListIndent, aindent); }

class  QTextImageFormat : public QTextCharFormat
{
public:
QTextImageFormat();

bool isValid() const { return isImageFormat(); }

inline void setName(const QString &name);
inline QString name() const
{ return stringProperty(ImageName); }

inline void setWidth(qreal width);
inline qreal width() const
{ return doubleProperty(ImageWidth); }

inline void setHeight(qreal height);
inline qreal height() const
{ return doubleProperty(ImageHeight); }

protected:
explicit QTextImageFormat(const QTextFormat &format);
friend class QTextFormat;
};

inline void QTextImageFormat::setName(const QString &aname)
{ setProperty(ImageName, aname); }

inline void QTextImageFormat::setWidth(qreal awidth)
{ setProperty(ImageWidth, awidth); }

inline void QTextImageFormat::setHeight(qreal aheight)
{ setProperty(ImageHeight, aheight); }

class  QTextFrameFormat : public QTextFormat
{
public:
QTextFrameFormat();

bool isValid() const { return isFrameFormat(); }

enum Position {
InFlow,
FloatLeft,
FloatRight


};

enum BorderStyle {
BorderStyle_None,
BorderStyle_Dotted,
BorderStyle_Dashed,
BorderStyle_Solid,
BorderStyle_Double,
BorderStyle_DotDash,
BorderStyle_DotDotDash,
BorderStyle_Groove,
BorderStyle_Ridge,
BorderStyle_Inset,
BorderStyle_Outset
};

inline void setPosition(Position f)
{ setProperty(CssFloat, f); }
inline Position position() const
{ return static_cast<Position>(intProperty(CssFloat)); }

inline void setBorder(qreal border);
inline qreal border() const
{ return doubleProperty(FrameBorder); }

inline void setBorderBrush(const QBrush &brush)
{ setProperty(FrameBorderBrush, brush); }
inline QBrush borderBrush() const
{ return brushProperty(FrameBorderBrush); }

inline void setBorderStyle(BorderStyle style)
{ setProperty(FrameBorderStyle, style); }
inline BorderStyle borderStyle() const
{ return static_cast<BorderStyle>(intProperty(FrameBorderStyle)); }

void setMargin(qreal margin);
inline qreal margin() const
{ return doubleProperty(FrameMargin); }

inline void setTopMargin(qreal margin);
qreal topMargin() const;

inline void setBottomMargin(qreal margin);
qreal bottomMargin() const;

inline void setLeftMargin(qreal margin);
qreal leftMargin() const;

inline void setRightMargin(qreal margin);
qreal rightMargin() const;

inline void setPadding(qreal padding);
inline qreal padding() const
{ return doubleProperty(FramePadding); }

inline void setWidth(qreal width);
inline void setWidth(const QTextLength &length)
{ setProperty(FrameWidth, length); }
inline QTextLength width() const
{ return lengthProperty(FrameWidth); }

inline void setHeight(qreal height);
inline void setHeight(const QTextLength &height);
inline QTextLength height() const
{ return lengthProperty(FrameHeight); }

inline void setPageBreakPolicy(PageBreakFlags flags)
{ setProperty(PageBreakPolicy, int(flags)); }
inline PageBreakFlags pageBreakPolicy() const
{ return PageBreakFlags(intProperty(PageBreakPolicy)); }

protected:
explicit QTextFrameFormat(const QTextFormat &fmt);
friend class QTextFormat;
};

inline void QTextFrameFormat::setBorder(qreal aborder)
{ setProperty(FrameBorder, aborder); }

inline void QTextFrameFormat::setPadding(qreal apadding)
{ setProperty(FramePadding, apadding); }

inline void QTextFrameFormat::setWidth(qreal awidth)
{ setProperty(FrameWidth, QTextLength(QTextLength::FixedLength, awidth)); }

inline void QTextFrameFormat::setHeight(qreal aheight)
{ setProperty(FrameHeight, QTextLength(QTextLength::FixedLength, aheight)); }
inline void QTextFrameFormat::setHeight(const QTextLength &aheight)
{ setProperty(FrameHeight, aheight); }

inline void QTextFrameFormat::setTopMargin(qreal amargin)
{ setProperty(FrameTopMargin, amargin); }

inline void QTextFrameFormat::setBottomMargin(qreal amargin)
{ setProperty(FrameBottomMargin, amargin); }

inline void QTextFrameFormat::setLeftMargin(qreal amargin)
{ setProperty(FrameLeftMargin, amargin); }

inline void QTextFrameFormat::setRightMargin(qreal amargin)
{ setProperty(FrameRightMargin, amargin); }

class  QTextTableFormat : public QTextFrameFormat
{
public:
QTextTableFormat();

inline bool isValid() const { return isTableFormat(); }

inline int columns() const
{ int cols = intProperty(TableColumns); if (cols == 0) cols = 1; return cols; }
inline void setColumns(int columns);

inline void setColumnWidthConstraints(const QVector<QTextLength> &constraints)
{ setProperty(TableColumnWidthConstraints, constraints); }

inline QVector<QTextLength> columnWidthConstraints() const
{ return lengthVectorProperty(TableColumnWidthConstraints); }

inline void clearColumnWidthConstraints()
{ clearProperty(TableColumnWidthConstraints); }

inline qreal cellSpacing() const
{ return doubleProperty(TableCellSpacing); }
inline void setCellSpacing(qreal spacing)
{ setProperty(TableCellSpacing, spacing); }

inline qreal cellPadding() const
{ return doubleProperty(TableCellPadding); }
inline void setCellPadding(qreal padding);

inline void setAlignment(Qt::Alignment alignment);
inline Qt::Alignment alignment() const
{ return QFlag(intProperty(BlockAlignment)); }

inline void setHeaderRowCount(int count)
{ setProperty(TableHeaderRowCount, count); }
inline int headerRowCount() const
{ return intProperty(TableHeaderRowCount); }

protected:
explicit QTextTableFormat(const QTextFormat &fmt);
friend class QTextFormat;
};

inline void QTextTableFormat::setColumns(int acolumns)
{
if (acolumns == 1)
acolumns = 0;
setProperty(TableColumns, acolumns);
}

inline void QTextTableFormat::setCellPadding(qreal apadding)
{ setProperty(TableCellPadding, apadding); }

inline void QTextTableFormat::setAlignment(Qt::Alignment aalignment)
{ setProperty(BlockAlignment, int(aalignment)); }

class  QTextTableCellFormat : public QTextCharFormat
{
public:
QTextTableCellFormat();

inline bool isValid() const { return isTableCellFormat(); }

inline void setTopPadding(qreal padding);
inline qreal topPadding() const;

inline void setBottomPadding(qreal padding);
inline qreal bottomPadding() const;

inline void setLeftPadding(qreal padding);
inline qreal leftPadding() const;

inline void setRightPadding(qreal padding);
inline qreal rightPadding() const;

inline void setPadding(qreal padding);

protected:
explicit QTextTableCellFormat(const QTextFormat &fmt);
friend class QTextFormat;
};

inline void QTextTableCellFormat::setTopPadding(qreal padding)
{
setProperty(TableCellTopPadding, padding);
}

inline qreal QTextTableCellFormat::topPadding() const
{
return doubleProperty(TableCellTopPadding);
}

inline void QTextTableCellFormat::setBottomPadding(qreal padding)
{
setProperty(TableCellBottomPadding, padding);
}

inline qreal QTextTableCellFormat::bottomPadding() const
{
return doubleProperty(TableCellBottomPadding);
}

inline void QTextTableCellFormat::setLeftPadding(qreal padding)
{
setProperty(TableCellLeftPadding, padding);
}

inline qreal QTextTableCellFormat::leftPadding() const
{
return doubleProperty(TableCellLeftPadding);
}

inline void QTextTableCellFormat::setRightPadding(qreal padding)
{
setProperty(TableCellRightPadding, padding);
}

inline qreal QTextTableCellFormat::rightPadding() const
{
return doubleProperty(TableCellRightPadding);
}

inline void QTextTableCellFormat::setPadding(qreal padding)
{
setTopPadding(padding);
setBottomPadding(padding);
setLeftPadding(padding);
setRightPadding(padding);
}







# 51 "/usr/share/qt4/include/QtGui/qtextlayout.h"


# 53 "/usr/share/qt4/include/QtGui/qtextlayout.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextEngine;
class QFont;
class QRect;
class QRegion;
class QTextFormat;
class QPalette;
class QPainter;

class  QTextInlineObject
{
public:
QTextInlineObject(int i, QTextEngine *e) : itm(i), eng(e) {}
inline QTextInlineObject() : itm(0), eng(0) {}
inline bool isValid() const { return eng; }

QRectF rect() const;
qreal width() const;
qreal ascent() const;
qreal descent() const;
qreal height() const;

Qt::LayoutDirection textDirection() const;

void setWidth(qreal w);
void setAscent(qreal a);
void setDescent(qreal d);

int textPosition() const;

int formatIndex() const;
QTextFormat format() const;

private:
friend class QTextLayout;
int itm;
QTextEngine *eng;
};

class QPaintDevice;
class QTextFormat;
class QTextLine;
class QTextBlock;
class QTextOption;

class  QTextLayout
{
public:

QTextLayout();
QTextLayout(const QString& text);
QTextLayout(const QString& text, const QFont &font, QPaintDevice *paintdevice = 0);
QTextLayout(const QTextBlock &b);
~QTextLayout();

void setFont(const QFont &f);
QFont font() const;

void setText(const QString& string);
QString text() const;

void setTextOption(const QTextOption &option);
QTextOption textOption() const;

void setPreeditArea(int position, const QString &text);
int preeditAreaPosition() const;
QString preeditAreaText() const;

struct FormatRange {
int start;
int length;
QTextCharFormat format;
};
void setAdditionalFormats(const QList<FormatRange> &overrides);
QList<FormatRange> additionalFormats() const;
void clearAdditionalFormats();

void setCacheEnabled(bool enable);
bool cacheEnabled() const;

void beginLayout();
void endLayout();
void clearLayout();

QTextLine createLine();

int lineCount() const;
QTextLine lineAt(int i) const;
QTextLine lineForTextPosition(int pos) const;

enum CursorMode {
SkipCharacters,
SkipWords
};
bool isValidCursorPosition(int pos) const;
int nextCursorPosition(int oldPos, CursorMode mode = SkipCharacters) const;
int previousCursorPosition(int oldPos, CursorMode mode = SkipCharacters) const;

void draw(QPainter *p, const QPointF &pos, const QVector<FormatRange> &selections = QVector<FormatRange>(),
const QRectF &clip = QRectF()) const;
void drawCursor(QPainter *p, const QPointF &pos, int cursorPosition) const;
void drawCursor(QPainter *p, const QPointF &pos, int cursorPosition, int width) const;

QPointF position() const;
void setPosition(const QPointF &p);

QRectF boundingRect() const;

qreal minimumWidth() const;
qreal maximumWidth() const;

QTextEngine *engine() const { return d; }
void setFlags(int flags);
private:
QTextLayout(QTextEngine *e) : d(e) {}
QTextLayout(const QTextLayout &); QTextLayout &operator=(const QTextLayout &);

friend class QPainter;
friend class QPSPrinter;
friend class QGraphicsSimpleTextItemPrivate;
friend class QGraphicsSimpleTextItem;
friend void qt_format_text(const QFont &font, const QRectF &_r, int tf, const QTextOption *, const QString& str,
QRectF *brect, int tabstops, int* tabarray, int tabarraylen,
QPainter *painter);
QTextEngine *d;
};


class  QTextLine
{
public:
inline QTextLine() : i(0), eng(0) {}
inline bool isValid() const { return eng; }

QRectF rect() const;
qreal x() const;
qreal y() const;
qreal width() const;
qreal ascent() const;
qreal descent() const;
qreal height() const;
qreal leading() const;

void setLeadingIncluded(bool included);
bool leadingIncluded() const;

qreal naturalTextWidth() const;
QRectF naturalTextRect() const;

enum Edge {
Leading,
Trailing
};
enum CursorPosition {
CursorBetweenCharacters,
CursorOnCharacter
};


qreal cursorToX(int *cursorPos, Edge edge = Leading) const;
inline qreal cursorToX(int cursorPos, Edge edge = Leading) const { return cursorToX(&cursorPos, edge); }
int xToCursor(qreal x, CursorPosition = CursorBetweenCharacters) const;

void setLineWidth(qreal width);
void setNumColumns(int columns);
void setNumColumns(int columns, qreal alignmentWidth);

void setPosition(const QPointF &pos);
QPointF position() const;

int textStart() const;
int textLength() const;

int lineNumber() const { return i; }

void draw(QPainter *p, const QPointF &point, const QTextLayout::FormatRange *selection = 0) const;

private:
QTextLine(int line, QTextEngine *e) : i(line), eng(e) {}
void layout_helper(int numGlyphs);
friend class QTextLayout;
int i;
QTextEngine *eng;
};






# 46 "/usr/share/qt4/include/QtGui/qabstracttextdocumentlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qtextdocument.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtextdocument.h"

# 1 "/usr/share/qt4/include/QtCore/qsize.h"








































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qtextdocument.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qtextdocument.h"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qtextdocument.h"


# 50 "/usr/share/qt4/include/QtGui/qtextdocument.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextFormatCollection;
class QTextListFormat;
class QRect;
class QPainter;
class QPrinter;
class QAbstractTextDocumentLayout;
class QPoint;
class QTextCursor;
class QTextObject;
class QTextFormat;
class QTextFrame;
class QTextBlock;
class QTextCodec;
class QUrl;
class QVariant;
class QRectF;
class QTextOption;

template<typename T> class QVector;

namespace Qt
{
enum HitTestAccuracy { ExactHit, FuzzyHit };
enum WhiteSpaceMode {
WhiteSpaceNormal,
WhiteSpacePre,
WhiteSpaceNoWrap,
WhiteSpaceModeUndefined = -1
};

 bool mightBeRichText(const QString&);
 QString escape(const QString& plain);
 QString convertFromPlainText(const QString &plain, WhiteSpaceMode mode = WhiteSpacePre);


# 91 "/usr/share/qt4/include/QtGui/qtextdocument.h"
 QTextCodec *codecForHtml(const QByteArray &ba);

# 93 "/usr/share/qt4/include/QtGui/qtextdocument.h"
}

class  QAbstractUndoItem
{
public:
virtual ~QAbstractUndoItem() = 0;
virtual void undo() = 0;
virtual void redo() = 0;
};

inline QAbstractUndoItem::~QAbstractUndoItem()
{
}

class QTextDocumentPrivate;

class  QTextDocument : public QObject
{
Q_OBJECT

Q_PROPERTY(bool undoRedoEnabled READ isUndoRedoEnabled WRITE setUndoRedoEnabled)
Q_PROPERTY(bool modified READ isModified WRITE setModified DESIGNABLE false)
Q_PROPERTY(QSizeF pageSize READ pageSize WRITE setPageSize)
Q_PROPERTY(QFont defaultFont READ defaultFont WRITE setDefaultFont)
Q_PROPERTY(bool useDesignMetrics READ useDesignMetrics WRITE setUseDesignMetrics)
Q_PROPERTY(QSizeF size READ size)
Q_PROPERTY(qreal textWidth READ textWidth WRITE setTextWidth)
Q_PROPERTY(int blockCount READ blockCount)
Q_PROPERTY(qreal indentWidth READ indentWidth WRITE setIndentWidth)

# 123 "/usr/share/qt4/include/QtGui/qtextdocument.h"
Q_PROPERTY(QString defaultStyleSheet READ defaultStyleSheet WRITE setDefaultStyleSheet)

# 125 "/usr/share/qt4/include/QtGui/qtextdocument.h"
Q_PROPERTY(int maximumBlockCount READ maximumBlockCount WRITE setMaximumBlockCount)
Q_PROPERTY(qreal documentMargin READ documentMargin WRITE setDocumentMargin)


public:
explicit QTextDocument(QObject *parent = 0);
explicit QTextDocument(const QString &text, QObject *parent = 0);
~QTextDocument();

QTextDocument *clone(QObject *parent = 0) const;

bool isEmpty() const;
virtual void clear();

void setUndoRedoEnabled(bool enable);
bool isUndoRedoEnabled() const;

bool isUndoAvailable() const;
bool isRedoAvailable() const;

int availableUndoSteps() const;
int availableRedoSteps() const;

int revision() const;

void setDocumentLayout(QAbstractTextDocumentLayout *layout);
QAbstractTextDocumentLayout *documentLayout() const;

enum MetaInformation {
DocumentTitle,
DocumentUrl
};
void setMetaInformation(MetaInformation info, const QString &);
QString metaInformation(MetaInformation info) const;


# 161 "/usr/share/qt4/include/QtGui/qtextdocument.h"
QString toHtml(const QByteArray &encoding = QByteArray()) const;
void setHtml(const QString &html);


# 165 "/usr/share/qt4/include/QtGui/qtextdocument.h"
QString toPlainText() const;
void setPlainText(const QString &text);

QChar characterAt(int pos) const;

enum FindFlag
{
FindBackward = 0x00001,
FindCaseSensitively = 0x00002,
FindWholeWords = 0x00004
};
typedef QFlags<FindFlag> FindFlags;

QTextCursor find(const QString &subString, int from = 0, FindFlags options = 0) const;
QTextCursor find(const QString &subString, const QTextCursor &from, FindFlags options = 0) const;

QTextCursor find(const QRegExp &expr, int from = 0, FindFlags options = 0) const;
QTextCursor find(const QRegExp &expr, const QTextCursor &from, FindFlags options = 0) const;

QTextFrame *frameAt(int pos) const;
QTextFrame *rootFrame() const;

QTextObject *object(int objectIndex) const;
QTextObject *objectForFormat(const QTextFormat &) const;

QTextBlock findBlock(int pos) const;
QTextBlock findBlockByNumber(int blockNumber) const;
QTextBlock findBlockByLineNumber(int blockNumber) const;
QTextBlock begin() const;
QTextBlock end() const;

QTextBlock firstBlock() const;
QTextBlock lastBlock() const;

void setPageSize(const QSizeF &size);
QSizeF pageSize() const;

void setDefaultFont(const QFont &font);
QFont defaultFont() const;

int pageCount() const;

bool isModified() const;


# 210 "/usr/share/qt4/include/QtGui/qtextdocument.h"
void print(QPrinter *printer) const;


# 213 "/usr/share/qt4/include/QtGui/qtextdocument.h"
enum ResourceType {
HtmlResource = 1,
ImageResource = 2,
StyleSheetResource = 3,

UserResource = 100
};

QVariant resource(int type, const QUrl &name) const;
void addResource(int type, const QUrl &name, const QVariant &resource);

QVector<QTextFormat> allFormats() const;

void markContentsDirty(int from, int length);

void setUseDesignMetrics(bool b);
bool useDesignMetrics() const;

void drawContents(QPainter *painter, const QRectF &rect = QRectF());

void setTextWidth(qreal width);
qreal textWidth() const;

qreal idealWidth() const;

qreal indentWidth() const;
void setIndentWidth(qreal width);

qreal documentMargin() const;
void setDocumentMargin(qreal margin);

void adjustSize();
QSizeF size() const;

int blockCount() const;
int lineCount() const;
int characterCount() const;


# 252 "/usr/share/qt4/include/QtGui/qtextdocument.h"
void setDefaultStyleSheet(const QString &sheet);
QString defaultStyleSheet() const;


# 256 "/usr/share/qt4/include/QtGui/qtextdocument.h"
void undo(QTextCursor *cursor);
void redo(QTextCursor *cursor);

int maximumBlockCount() const;
void setMaximumBlockCount(int maximum);

QTextOption defaultTextOption() const;
void setDefaultTextOption(const QTextOption &option);

signals:
void contentsChange(int from, int charsRemoves, int charsAdded);
void contentsChanged();
void undoAvailable(bool);
void redoAvailable(bool);
void undoCommandAdded();
void modificationChanged(bool m);
void cursorPositionChanged(const QTextCursor &cursor);
void blockCountChanged(int newBlockCount);

void documentLayoutChanged();

public slots:
void undo();
void redo();
void appendUndoItem(QAbstractUndoItem *);
void setModified(bool m = true);

protected:
virtual QTextObject *createObject(const QTextFormat &f);
virtual QVariant loadResource(int type, const QUrl &name);

QTextDocument(QTextDocumentPrivate &dd, QObject *parent);
public:
QTextDocumentPrivate *docHandle() const;
private:
QTextDocument(const QTextDocument &); QTextDocument &operator=(const QTextDocument &);
inline QTextDocumentPrivate* d_func() { return reinterpret_cast<QTextDocumentPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTextDocumentPrivate* d_func() const { return reinterpret_cast<const QTextDocumentPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTextDocumentPrivate;
friend class QTextObjectPrivate;
};

inline QFlags<QTextDocument::FindFlags::enum_type> operator|(QTextDocument::FindFlags::enum_type f1, QTextDocument::FindFlags::enum_type f2) { return QFlags<QTextDocument::FindFlags::enum_type>(f1) | f2; } inline QFlags<QTextDocument::FindFlags::enum_type> operator|(QTextDocument::FindFlags::enum_type f1, QFlags<QTextDocument::FindFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTextDocument::FindFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }






# 47 "/usr/share/qt4/include/QtGui/qabstracttextdocumentlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qtextcursor.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtextcursor.h"

# 1 "/usr/share/qt4/include/QtCore/qshareddata.h"




































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qtextcursor.h"

# 1 "/usr/share/qt4/include/QtGui/qtextformat.h"















































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qtextcursor.h"


# 49 "/usr/share/qt4/include/QtGui/qtextcursor.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextDocument;
class QTextCursorPrivate;
class QTextDocumentFragment;
class QTextCharFormat;
class QTextBlockFormat;
class QTextListFormat;
class QTextTableFormat;
class QTextFrameFormat;
class QTextImageFormat;
class QTextDocumentPrivate;
class QTextList;
class QTextTable;
class QTextFrame;
class QTextBlock;

class  QTextCursor
{
public:
QTextCursor();
explicit QTextCursor(QTextDocument *document);
QTextCursor(QTextDocumentPrivate *p, int pos);
explicit QTextCursor(QTextFrame *frame);
explicit QTextCursor(const QTextBlock &block);
explicit QTextCursor(QTextCursorPrivate *d);
QTextCursor(const QTextCursor &cursor);
QTextCursor &operator=(const QTextCursor &other);
~QTextCursor();

bool isNull() const;

enum MoveMode {
MoveAnchor,
KeepAnchor
};

void setPosition(int pos, MoveMode mode = MoveAnchor);
int position() const;

int anchor() const;

void insertText(const QString &text);
void insertText(const QString &text, const QTextCharFormat &format);

enum MoveOperation {
NoMove,

Start,
Up,
StartOfLine,
StartOfBlock,
StartOfWord,
PreviousBlock,
PreviousCharacter,
PreviousWord,
Left,
WordLeft,

End,
Down,
EndOfLine,
EndOfWord,
EndOfBlock,
NextBlock,
NextCharacter,
NextWord,
Right,
WordRight,

NextCell,
PreviousCell,
NextRow,
PreviousRow
};

bool movePosition(MoveOperation op, MoveMode = MoveAnchor, int n = 1);

bool visualNavigation() const;
void setVisualNavigation(bool b);

void deleteChar();
void deletePreviousChar();

enum SelectionType {
WordUnderCursor,
LineUnderCursor,
BlockUnderCursor,
Document
};
void select(SelectionType selection);

bool hasSelection() const;
bool hasComplexSelection() const;
void removeSelectedText();
void clearSelection();
int selectionStart() const;
int selectionEnd() const;

QString selectedText() const;
QTextDocumentFragment selection() const;
void selectedTableCells(int *firstRow, int *numRows, int *firstColumn, int *numColumns) const;

QTextBlock block() const;

QTextCharFormat charFormat() const;
void setCharFormat(const QTextCharFormat &format);
void mergeCharFormat(const QTextCharFormat &modifier);

QTextBlockFormat blockFormat() const;
void setBlockFormat(const QTextBlockFormat &format);
void mergeBlockFormat(const QTextBlockFormat &modifier);

QTextCharFormat blockCharFormat() const;
void setBlockCharFormat(const QTextCharFormat &format);
void mergeBlockCharFormat(const QTextCharFormat &modifier);

bool atBlockStart() const;
bool atBlockEnd() const;
bool atStart() const;
bool atEnd() const;

void insertBlock();
void insertBlock(const QTextBlockFormat &format);
void insertBlock(const QTextBlockFormat &format, const QTextCharFormat &charFormat);

QTextList *insertList(const QTextListFormat &format);
QTextList *insertList(QTextListFormat::Style style);

QTextList *createList(const QTextListFormat &format);
QTextList *createList(QTextListFormat::Style style);
QTextList *currentList() const;

QTextTable *insertTable(int rows, int cols, const QTextTableFormat &format);
QTextTable *insertTable(int rows, int cols);
QTextTable *currentTable() const;

QTextFrame *insertFrame(const QTextFrameFormat &format);
QTextFrame *currentFrame() const;

void insertFragment(const QTextDocumentFragment &fragment);


# 196 "/usr/share/qt4/include/QtGui/qtextcursor.h"
void insertHtml(const QString &html);


# 199 "/usr/share/qt4/include/QtGui/qtextcursor.h"
void insertImage(const QTextImageFormat &format, QTextFrameFormat::Position alignment);
void insertImage(const QTextImageFormat &format);
void insertImage(const QString &name);
void insertImage(const QImage &image, const QString &name = QString());

void beginEditBlock();
void joinPreviousEditBlock();
void endEditBlock();

bool operator!=(const QTextCursor &rhs) const;
bool operator<(const QTextCursor &rhs) const;
bool operator<=(const QTextCursor &rhs) const;
bool operator==(const QTextCursor &rhs) const;
bool operator>=(const QTextCursor &rhs) const;
bool operator>(const QTextCursor &rhs) const;

bool isCopyOf(const QTextCursor &other) const;

int blockNumber() const;
int columnNumber() const;

QTextDocument *document() const;

private:
QSharedDataPointer<QTextCursorPrivate> d;
friend class QTextDocumentFragmentPrivate;
friend class QTextCopyHelper;
};






# 48 "/usr/share/qt4/include/QtGui/qabstracttextdocumentlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qpalette.h"




































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qabstracttextdocumentlayout.h"


# 51 "/usr/share/qt4/include/QtGui/qabstracttextdocumentlayout.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QAbstractTextDocumentLayoutPrivate;
class QTextBlock;
class QTextObjectInterface;
class QTextFrame;

class  QAbstractTextDocumentLayout : public QObject
{
Q_OBJECT
inline QAbstractTextDocumentLayoutPrivate* d_func() { return reinterpret_cast<QAbstractTextDocumentLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractTextDocumentLayoutPrivate* d_func() const { return reinterpret_cast<const QAbstractTextDocumentLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractTextDocumentLayoutPrivate;

public:
explicit QAbstractTextDocumentLayout(QTextDocument *doc);
~QAbstractTextDocumentLayout();

struct Selection
{
QTextCursor cursor;
QTextCharFormat format;
};

struct PaintContext
{
PaintContext()
: cursorPosition(-1)
{}
int cursorPosition;
QPalette palette;
QRectF clip;
QVector<Selection> selections;
};

virtual void draw(QPainter *painter, const PaintContext &context) = 0;
virtual int hitTest(const QPointF &point, Qt::HitTestAccuracy accuracy) const = 0;
QString anchorAt(const QPointF& pos) const;

virtual int pageCount() const = 0;
virtual QSizeF documentSize() const = 0;

virtual QRectF frameBoundingRect(QTextFrame *frame) const = 0;
virtual QRectF blockBoundingRect(const QTextBlock &block) const = 0;

void setPaintDevice(QPaintDevice *device);
QPaintDevice *paintDevice() const;

QTextDocument *document() const;

void registerHandler(int objectType, QObject *component);
QTextObjectInterface *handlerForObject(int objectType) const;

signals:
void update(const QRectF & = QRectF(0., 0., 1000000000., 1000000000.));
void updateBlock(const QTextBlock &block);
void documentSizeChanged(const QSizeF &newSize);
void pageCountChanged(int newPages);

protected:
QAbstractTextDocumentLayout(QAbstractTextDocumentLayoutPrivate &, QTextDocument *);

virtual void documentChanged(int from, int charsRemoved, int charsAdded) = 0;

virtual void resizeInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format);
virtual void positionInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format);
virtual void drawInlineObject(QPainter *painter, const QRectF &rect, QTextInlineObject object, int posInDocument, const QTextFormat &format);

int formatIndex(int pos);
QTextCharFormat format(int pos);

private:
friend class QTextControl;
friend class QTextDocument;
friend class QTextDocumentPrivate;
friend class QTextEngine;
friend class QTextLayout;
friend class QTextLine;



};

class  QTextObjectInterface
{
public:
virtual ~QTextObjectInterface() {}
virtual QSizeF intrinsicSize(QTextDocument *doc, int posInDocument, const QTextFormat &format) = 0;
virtual void drawObject(QPainter *painter, const QRectF &rect, QTextDocument *doc, int posInDocument, const QTextFormat &format) = 0;
};

template <> inline const char *qobject_interface_iid<QTextObjectInterface *>() { return "com.trolltech.Qt.QTextObjectInterface"; } template <> inline QTextObjectInterface *qobject_cast<QTextObjectInterface *>(QObject *object) { return reinterpret_cast<QTextObjectInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QTextObjectInterface") : 0)); } template <> inline QTextObjectInterface *qobject_cast<QTextObjectInterface *>(const QObject *object) { return reinterpret_cast<QTextObjectInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QTextObjectInterface") : 0)); }






# 23 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 24 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qfontdatabase.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 45 "/usr/share/qt4/include/QtGui/qfontdatabase.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qfontdatabase.h"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qfontdatabase.h"






# 53 "/usr/share/qt4/include/QtGui/qfontdatabase.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QStringList;
template <class T> class QList;
struct QFontDef;
class QFontEngine;

class QFontDatabasePrivate;

class  QFontDatabase
{

Q_ENUMS(WritingSystem)
public:


enum WritingSystem {
Any,

Latin,
Greek,
Cyrillic,
Armenian,
Hebrew,
Arabic,
Syriac,
Thaana,
Devanagari,
Bengali,
Gurmukhi,
Gujarati,
Oriya,
Tamil,
Telugu,
Kannada,
Malayalam,
Sinhala,
Thai,
Lao,
Tibetan,
Myanmar,
Georgian,
Khmer,
SimplifiedChinese,
TraditionalChinese,
Japanese,
Korean,
Vietnamese,

Symbol,
Other = Symbol,

Ogham,
Runic,
Nko,

WritingSystemsCount
};

static QList<int> standardSizes();

QFontDatabase();

QList<WritingSystem> writingSystems() const;
QList<WritingSystem> writingSystems(const QString &family) const;

QStringList families(WritingSystem writingSystem = Any) const;
QStringList styles(const QString &family) const;
QList<int> pointSizes(const QString &family, const QString &style = QString());
QList<int> smoothSizes(const QString &family, const QString &style);
QString styleString(const QFont &font);
QString styleString(const QFontInfo &fontInfo);

QFont font(const QString &family, const QString &style, int pointSize) const;

bool isBitmapScalable(const QString &family, const QString &style = QString()) const;
bool isSmoothlyScalable(const QString &family, const QString &style = QString()) const;
bool isScalable(const QString &family, const QString &style = QString()) const;
bool isFixedPitch(const QString &family, const QString &style = QString()) const;

bool italic(const QString &family, const QString &style) const;
bool bold(const QString &family, const QString &style) const;
int weight(const QString &family, const QString &style) const;

static QString writingSystemName(WritingSystem writingSystem);
static QString writingSystemSample(WritingSystem writingSystem);

static int addApplicationFont(const QString &fileName);
static int addApplicationFontFromData(const QByteArray &fontData);
static QStringList applicationFontFamilies(int id);
static bool removeApplicationFont(int id);
static bool removeAllApplicationFonts();

static bool supportsThreadedFontRendering();

private:
static void createDatabase();
static void parseFontName(const QString &name, QString &foundry, QString &family);



# 158 "/usr/share/qt4/include/QtGui/qfontdatabase.h"
static void load(const QFontPrivate *d, int script);




# 163 "/usr/share/qt4/include/QtGui/qfontdatabase.h"
friend struct QFontDef;
friend class QFontPrivate;
friend class QFontDialog;
friend class QFontDialogPrivate;
friend class QFontEngineMultiXLFD;
friend class QFontEngineMultiQWS;
friend class QFontEngineMultiS60;

QFontDatabasePrivate *d;
};






# 25 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qfontinfo.h"
























































































# 26 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qfontmetrics.h"






































































































































































































# 27 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qsyntaxhighlighter.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qsyntaxhighlighter.h"




# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qsyntaxhighlighter.h"

# 1 "/usr/share/qt4/include/QtGui/qtextobject.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtextobject.h"

# 1 "/usr/share/qt4/include/QtGui/qtextformat.h"















































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qtextobject.h"


# 48 "/usr/share/qt4/include/QtGui/qtextobject.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextObjectPrivate;
class QTextDocument;
class QTextDocumentPrivate;
class QTextCursor;
class QTextBlock;
class QTextFragment;
class QTextLayout;
class QTextList;

class  QTextObject : public QObject
{
Q_OBJECT

protected:
explicit QTextObject(QTextDocument *doc);
~QTextObject();

void setFormat(const QTextFormat &format);

public:
QTextFormat format() const;
int formatIndex() const;

QTextDocument *document() const;

int objectIndex() const;

QTextDocumentPrivate *docHandle() const;

protected:
QTextObject(QTextObjectPrivate &p, QTextDocument *doc);

private:
inline QTextObjectPrivate* d_func() { return reinterpret_cast<QTextObjectPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTextObjectPrivate* d_func() const { return reinterpret_cast<const QTextObjectPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTextObjectPrivate;
QTextObject(const QTextObject &); QTextObject &operator=(const QTextObject &);
friend class QTextDocumentPrivate;
};

class QTextBlockGroupPrivate;
class  QTextBlockGroup : public QTextObject
{
Q_OBJECT

protected:
explicit QTextBlockGroup(QTextDocument *doc);
~QTextBlockGroup();

virtual void blockInserted(const QTextBlock &block);
virtual void blockRemoved(const QTextBlock &block);
virtual void blockFormatChanged(const QTextBlock &block);

QList<QTextBlock> blockList() const;

protected:
QTextBlockGroup(QTextBlockGroupPrivate &p, QTextDocument *doc);
private:
inline QTextBlockGroupPrivate* d_func() { return reinterpret_cast<QTextBlockGroupPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTextBlockGroupPrivate* d_func() const { return reinterpret_cast<const QTextBlockGroupPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTextBlockGroupPrivate;
QTextBlockGroup(const QTextBlockGroup &); QTextBlockGroup &operator=(const QTextBlockGroup &);
friend class QTextDocumentPrivate;
};

class  QTextFrameLayoutData {
public:
virtual ~QTextFrameLayoutData();
};

class QTextFramePrivate;
class  QTextFrame : public QTextObject
{
Q_OBJECT

public:
explicit QTextFrame(QTextDocument *doc);
~QTextFrame();

inline void setFrameFormat(const QTextFrameFormat &format);
QTextFrameFormat frameFormat() const { return QTextObject::format().toFrameFormat(); }

QTextCursor firstCursorPosition() const;
QTextCursor lastCursorPosition() const;
int firstPosition() const;
int lastPosition() const;

QTextFrameLayoutData *layoutData() const;
void setLayoutData(QTextFrameLayoutData *data);

QList<QTextFrame *> childFrames() const;
QTextFrame *parentFrame() const;

class  iterator {
QTextFrame *f;
int b;
int e;
QTextFrame *cf;
int cb;

friend class QTextFrame;
friend class QTextTableCell;
friend class QTextDocumentLayoutPrivate;
iterator(QTextFrame *frame, int block, int begin, int end);
public:
iterator();
iterator(const iterator &o);
iterator &operator=(const iterator &o);

QTextFrame *parentFrame() const { return f; }

QTextFrame *currentFrame() const;
QTextBlock currentBlock() const;

bool atEnd() const { return !cf && cb == e; }

inline bool operator==(const iterator &o) const { return f == o.f && cf == o.cf && cb == o.cb; }
inline bool operator!=(const iterator &o) const { return f != o.f || cf != o.cf || cb != o.cb; }
iterator &operator++();
inline iterator operator++(int) { iterator tmp = *this; operator++(); return tmp; }
iterator &operator--();
inline iterator operator--(int) { iterator tmp = *this; operator--(); return tmp; }
};

friend class iterator;

typedef iterator Iterator;

iterator begin() const;
iterator end() const;

protected:
QTextFrame(QTextFramePrivate &p, QTextDocument *doc);
private:
friend class QTextDocumentPrivate;
inline QTextFramePrivate* d_func() { return reinterpret_cast<QTextFramePrivate *>(qGetPtrHelper(d_ptr)); } inline const QTextFramePrivate* d_func() const { return reinterpret_cast<const QTextFramePrivate *>(qGetPtrHelper(d_ptr)); } friend class QTextFramePrivate;
QTextFrame(const QTextFrame &); QTextFrame &operator=(const QTextFrame &);
};
template <> class QTypeInfo<QTextFrame::iterator > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextFrame::iterator)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTextFrame::iterator"; } };

inline void QTextFrame::setFrameFormat(const QTextFrameFormat &aformat)
{ QTextObject::setFormat(aformat); }

class  QTextBlockUserData {
public:
virtual ~QTextBlockUserData();
};

class  QTextBlock
{
friend class QSyntaxHighlighter;
public:
inline QTextBlock(QTextDocumentPrivate *priv, int b) : p(priv), n(b) {}
inline QTextBlock() : p(0), n(0) {}
inline QTextBlock(const QTextBlock &o) : p(o.p), n(o.n) {}
inline QTextBlock &operator=(const QTextBlock &o) { p = o.p; n = o.n; return *this; }

inline bool isValid() const { return p != 0 && n != 0; }

inline bool operator==(const QTextBlock &o) const { return p == o.p && n == o.n; }
inline bool operator!=(const QTextBlock &o) const { return p != o.p || n != o.n; }
inline bool operator<(const QTextBlock &o) const { return position() < o.position(); }

int position() const;
int length() const;
bool contains(int position) const;

QTextLayout *layout() const;
void clearLayout();
QTextBlockFormat blockFormat() const;
int blockFormatIndex() const;
QTextCharFormat charFormat() const;
int charFormatIndex() const;

QString text() const;

const QTextDocument *document() const;

QTextList *textList() const;

QTextBlockUserData *userData() const;
void setUserData(QTextBlockUserData *data);

int userState() const;
void setUserState(int state);

int revision() const;
void setRevision(int rev);

bool isVisible() const;
void setVisible(bool visible);

int blockNumber() const;
int firstLineNumber() const;

void setLineCount(int count);
int lineCount() const;

class  iterator {
const QTextDocumentPrivate *p;
int b;
int e;
int n;
friend class QTextBlock;
iterator(const QTextDocumentPrivate *priv, int begin, int end, int f) : p(priv), b(begin), e(end), n(f) {}
public:
iterator() : p(0), b(0), e(0), n(0) {}
iterator(const iterator &o) : p(o.p), b(o.b), e(o.e), n(o.n) {}

QTextFragment fragment() const;

bool atEnd() const { return n == e; }

inline bool operator==(const iterator &o) const { return p == o.p && n == o.n; }
inline bool operator!=(const iterator &o) const { return p != o.p || n != o.n; }
iterator &operator++();
inline iterator operator++(int) { iterator tmp = *this; operator++(); return tmp; }
iterator &operator--();
inline iterator operator--(int) { iterator tmp = *this; operator--(); return tmp; }
};


typedef iterator Iterator;

iterator begin() const;
iterator end() const;

QTextBlock next() const;
QTextBlock previous() const;

inline QTextDocumentPrivate *docHandle() const { return p; }
inline int fragmentIndex() const { return n; }

private:
QTextDocumentPrivate *p;
int n;
friend class QTextDocumentPrivate;
friend class QTextLayout;
};

template <> class QTypeInfo<QTextBlock > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextBlock)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTextBlock"; } };
template <> class QTypeInfo<QTextBlock::iterator > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextBlock::iterator)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTextBlock::iterator"; } };


class  QTextFragment
{
public:
inline QTextFragment(const QTextDocumentPrivate *priv, int f, int fe) : p(priv), n(f), ne(fe) {}
inline QTextFragment() : p(0), n(0), ne(0) {}
inline QTextFragment(const QTextFragment &o) : p(o.p), n(o.n), ne(o.ne) {}
inline QTextFragment &operator=(const QTextFragment &o) { p = o.p; n = o.n; ne = o.ne; return *this; }

inline bool isValid() const { return p && n; }

inline bool operator==(const QTextFragment &o) const { return p == o.p && n == o.n; }
inline bool operator!=(const QTextFragment &o) const { return p != o.p || n != o.n; }
inline bool operator<(const QTextFragment &o) const { return position() < o.position(); }

int position() const;
int length() const;
bool contains(int position) const;

QTextCharFormat charFormat() const;
int charFormatIndex() const;
QString text() const;

private:
const QTextDocumentPrivate *p;
int n;
int ne;
};

template <> class QTypeInfo<QTextFragment > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextFragment)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QTextFragment"; } };






# 50 "/usr/share/qt4/include/QtGui/qsyntaxhighlighter.h"


# 52 "/usr/share/qt4/include/QtGui/qsyntaxhighlighter.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextDocument;
class QSyntaxHighlighterPrivate;
class QTextCharFormat;
class QFont;
class QColor;
class QTextBlockUserData;
class QTextEdit;

class  QSyntaxHighlighter : public QObject
{
Q_OBJECT
inline QSyntaxHighlighterPrivate* d_func() { return reinterpret_cast<QSyntaxHighlighterPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSyntaxHighlighterPrivate* d_func() const { return reinterpret_cast<const QSyntaxHighlighterPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSyntaxHighlighterPrivate;
public:
QSyntaxHighlighter(QObject *parent);
QSyntaxHighlighter(QTextDocument *parent);
QSyntaxHighlighter(QTextEdit *parent);
virtual ~QSyntaxHighlighter();

void setDocument(QTextDocument *doc);
QTextDocument *document() const;

public slots:
void rehighlight();
void rehighlightBlock(const QTextBlock &block);

protected:
virtual void highlightBlock(const QString &text) = 0;

void setFormat(int start, int count, const QTextCharFormat &format);
void setFormat(int start, int count, const QColor &color);
void setFormat(int start, int count, const QFont &font);
QTextCharFormat format(int pos) const;

int previousBlockState() const;
int currentBlockState() const;
void setCurrentBlockState(int newState);

void setCurrentBlockUserData(QTextBlockUserData *data);
QTextBlockUserData *currentBlockUserData() const;

QTextBlock currentBlock() const;

private:
QSyntaxHighlighter(const QSyntaxHighlighter &); QSyntaxHighlighter &operator=(const QSyntaxHighlighter &);


};








# 28 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtextcursor.h"








































































































































































































































# 29 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtextdocument.h"














































































































































































































































































































# 30 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtextdocumentfragment.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtextdocumentfragment.h"


# 47 "/usr/share/qt4/include/QtGui/qtextdocumentfragment.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextStream;
class QTextDocument;
class QTextDocumentFragmentPrivate;
class QTextCursor;

class  QTextDocumentFragment
{
public:
QTextDocumentFragment();
explicit QTextDocumentFragment(const QTextDocument *document);
explicit QTextDocumentFragment(const QTextCursor &range);
QTextDocumentFragment(const QTextDocumentFragment &rhs);
QTextDocumentFragment &operator=(const QTextDocumentFragment &rhs);
~QTextDocumentFragment();

bool isEmpty() const;

QString toPlainText() const;

# 72 "/usr/share/qt4/include/QtGui/qtextdocumentfragment.h"
QString toHtml() const;
QString toHtml(const QByteArray &encoding) const;


# 76 "/usr/share/qt4/include/QtGui/qtextdocumentfragment.h"
static QTextDocumentFragment fromPlainText(const QString &plainText);

# 78 "/usr/share/qt4/include/QtGui/qtextdocumentfragment.h"
static QTextDocumentFragment fromHtml(const QString &html);
static QTextDocumentFragment fromHtml(const QString &html, const QTextDocument *resourceProvider);


# 82 "/usr/share/qt4/include/QtGui/qtextdocumentfragment.h"
private:
QTextDocumentFragmentPrivate *d;
friend class QTextCursor;
friend class QTextDocumentWriter;
};






# 31 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtextdocumentwriter.h"











































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 44 "/usr/share/qt4/include/QtGui/qtextdocumentwriter.h"


# 46 "/usr/share/qt4/include/QtGui/qtextdocumentwriter.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextDocumentWriterPrivate;
class QIODevice;
class QByteArray;
class QTextDocument;
class QTextDocumentFragment;

class  QTextDocumentWriter
{
public:
QTextDocumentWriter();
QTextDocumentWriter(QIODevice *device, const QByteArray &format);
QTextDocumentWriter(const QString &fileName, const QByteArray &format = QByteArray());
~QTextDocumentWriter();

void setFormat (const QByteArray &format);
QByteArray format () const;

void setDevice (QIODevice *device);
QIODevice *device () const;
void setFileName (const QString &fileName);
QString fileName () const;

bool write(const QTextDocument *document);
bool write(const QTextDocumentFragment &fragment);


# 78 "/usr/share/qt4/include/QtGui/qtextdocumentwriter.h"
void setCodec(QTextCodec *codec);
QTextCodec *codec() const;


# 82 "/usr/share/qt4/include/QtGui/qtextdocumentwriter.h"
static QList<QByteArray> supportedDocumentFormats();

private:
QTextDocumentWriter(const QTextDocumentWriter &); QTextDocumentWriter &operator=(const QTextDocumentWriter &);
QTextDocumentWriterPrivate *d;
};






# 32 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtextformat.h"















































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 33 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtextlayout.h"























































































































































































































































# 34 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtextlist.h"












































# 1 "/usr/share/qt4/include/QtGui/qtextobject.h"








































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtextlist.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qtextlist.h"


# 48 "/usr/share/qt4/include/QtGui/qtextlist.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextListPrivate;
class QTextCursor;

class  QTextList : public QTextBlockGroup
{
Q_OBJECT
public:
explicit QTextList(QTextDocument *doc);
~QTextList();

int count() const;

inline bool isEmpty() const
{ return count() == 0; }

QTextBlock item(int i) const;

int itemNumber(const QTextBlock &) const;
QString itemText(const QTextBlock &) const;

void removeItem(int i);
void remove(const QTextBlock &);

void add(const QTextBlock &block);

inline void setFormat(const QTextListFormat &format);
QTextListFormat format() const { return QTextObject::format().toListFormat(); }

private:
QTextList(const QTextList &); QTextList &operator=(const QTextList &);
inline QTextListPrivate* d_func() { return reinterpret_cast<QTextListPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTextListPrivate* d_func() const { return reinterpret_cast<const QTextListPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTextListPrivate;
};

inline void QTextList::setFormat(const QTextListFormat &aformat)
{ QTextObject::setFormat(aformat); }






# 35 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtextobject.h"








































































































































































































































































































































# 36 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtextoption.h"

































































































































































# 37 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtexttable.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtexttable.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qtexttable.h"

# 1 "/usr/share/qt4/include/QtGui/qtextobject.h"








































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qtexttable.h"


# 49 "/usr/share/qt4/include/QtGui/qtexttable.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QTextCursor;
class QTextTable;
class QTextTablePrivate;

class  QTextTableCell
{
public:
QTextTableCell() : table(0) {}
~QTextTableCell() {}
QTextTableCell(const QTextTableCell &o) : table(o.table), fragment(o.fragment) {}
QTextTableCell &operator=(const QTextTableCell &o)
{ table = o.table; fragment = o.fragment; return *this; }

void setFormat(const QTextCharFormat &format);
QTextCharFormat format() const;

int row() const;
int column() const;

int rowSpan() const;
int columnSpan() const;

inline bool isValid() const { return table != 0; }

QTextCursor firstCursorPosition() const;
QTextCursor lastCursorPosition() const;
int firstPosition() const;
int lastPosition() const;

inline bool operator==(const QTextTableCell &other) const
{ return table == other.table && fragment == other.fragment; }
inline bool operator!=(const QTextTableCell &other) const
{ return !operator==(other); }

QTextFrame::iterator begin() const;
QTextFrame::iterator end() const;

int tableCellFormatIndex() const;

private:
friend class QTextTable;
QTextTableCell(const QTextTable *t, int f)
: table(t), fragment(f) {}

const QTextTable *table;
int fragment;
};

class  QTextTable : public QTextFrame
{
Q_OBJECT
public:
explicit QTextTable(QTextDocument *doc);
~QTextTable();

void resize(int rows, int cols);
void insertRows(int pos, int num);
void insertColumns(int pos, int num);
void appendRows(int count);
void appendColumns(int count);
void removeRows(int pos, int num);
void removeColumns(int pos, int num);

void mergeCells(int row, int col, int numRows, int numCols);
void mergeCells(const QTextCursor &cursor);
void splitCell(int row, int col, int numRows, int numCols);

int rows() const;
int columns() const;

QTextTableCell cellAt(int row, int col) const;
QTextTableCell cellAt(int position) const;
QTextTableCell cellAt(const QTextCursor &c) const;

QTextCursor rowStart(const QTextCursor &c) const;
QTextCursor rowEnd(const QTextCursor &c) const;

void setFormat(const QTextTableFormat &format);
QTextTableFormat format() const { return QTextObject::format().toTableFormat(); }

private:
QTextTable(const QTextTable &); QTextTable &operator=(const QTextTable &);
inline QTextTablePrivate* d_func() { return reinterpret_cast<QTextTablePrivate *>(qGetPtrHelper(d_ptr)); } inline const QTextTablePrivate* d_func() const { return reinterpret_cast<const QTextTablePrivate *>(qGetPtrHelper(d_ptr)); } friend class QTextTablePrivate;
friend class QTextTableCell;
};






# 38 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qsymbianevent.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qsymbianevent.h"




























































# 39 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qabstractitemdelegate.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qabstractitemdelegate.h"

# 1 "/usr/share/qt4/include/QtGui/qstyleoption.h"












































# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qstyleoption.h"

# 1 "/usr/share/qt4/include/QtGui/qabstractspinbox.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qabstractspinbox.h"

# 1 "/usr/share/qt4/include/QtGui/qvalidator.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qvalidator.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qvalidator.h"

# 1 "/usr/share/qt4/include/QtCore/qregexp.h"




































































































































































# 47 "/usr/share/qt4/include/QtGui/qvalidator.h"

# 1 "/usr/share/qt4/include/QtCore/qlocale.h"




































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qvalidator.h"


# 50 "/usr/share/qt4/include/QtGui/qvalidator.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 58 "/usr/share/qt4/include/QtGui/qvalidator.h"
class QValidatorPrivate;

class  QValidator : public QObject
{
Q_OBJECT
public:
explicit QValidator(QObject * parent = 0);
~QValidator();

enum State {
Invalid,
Intermediate,
Acceptable




# 75 "/usr/share/qt4/include/QtGui/qvalidator.h"
};

void setLocale(const QLocale &locale);
QLocale locale() const;

virtual State validate(QString &, int &) const = 0;
virtual void fixup(QString &) const;





# 87 "/usr/share/qt4/include/QtGui/qvalidator.h"
protected:
QValidator(QObjectPrivate &d, QObject *parent);
QValidator(QValidatorPrivate &d, QObject *parent);

private:
QValidator(const QValidator &); QValidator &operator=(const QValidator &);
inline QValidatorPrivate* d_func() { return reinterpret_cast<QValidatorPrivate *>(qGetPtrHelper(d_ptr)); } inline const QValidatorPrivate* d_func() const { return reinterpret_cast<const QValidatorPrivate *>(qGetPtrHelper(d_ptr)); } friend class QValidatorPrivate;
};

class  QIntValidator : public QValidator
{
Q_OBJECT
Q_PROPERTY(int bottom READ bottom WRITE setBottom)
Q_PROPERTY(int top READ top WRITE setTop)

public:
explicit QIntValidator(QObject * parent = 0);
QIntValidator(int bottom, int top, QObject * parent);
~QIntValidator();

QValidator::State validate(QString &, int &) const;

void setBottom(int);
void setTop(int);
virtual void setRange(int bottom, int top);

int bottom() const { return b; }
int top() const { return t; }







# 122 "/usr/share/qt4/include/QtGui/qvalidator.h"
private:
QIntValidator(const QIntValidator &); QIntValidator &operator=(const QIntValidator &);

int b;
int t;
};



# 131 "/usr/share/qt4/include/QtGui/qvalidator.h"
class QDoubleValidatorPrivate;

class  QDoubleValidator : public QValidator
{
Q_OBJECT
Q_PROPERTY(double bottom READ bottom WRITE setBottom)
Q_PROPERTY(double top READ top WRITE setTop)
Q_PROPERTY(int decimals READ decimals WRITE setDecimals)
Q_PROPERTY(Notation notation READ notation WRITE setNotation)

public:
explicit QDoubleValidator(QObject * parent);
QDoubleValidator(double bottom, double top, int decimals, QObject * parent);
~QDoubleValidator();

enum Notation {
StandardNotation,
ScientificNotation
};

QValidator::State validate(QString &, int &) const;

virtual void setRange(double bottom, double top, int decimals = 0);
void setBottom(double);
void setTop(double);
void setDecimals(int);
void setNotation(Notation);

double bottom() const { return b; }
double top() const { return t; }
int decimals() const { return dec; }
Notation notation() const;







# 170 "/usr/share/qt4/include/QtGui/qvalidator.h"
private:
inline QDoubleValidatorPrivate* d_func() { return reinterpret_cast<QDoubleValidatorPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDoubleValidatorPrivate* d_func() const { return reinterpret_cast<const QDoubleValidatorPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDoubleValidatorPrivate;
QDoubleValidator(const QDoubleValidator &); QDoubleValidator &operator=(const QDoubleValidator &);

double b;
double t;
int dec;
};


class  QRegExpValidator : public QValidator
{
Q_OBJECT
Q_PROPERTY(QRegExp regExp READ regExp WRITE setRegExp)

public:
explicit QRegExpValidator(QObject *parent);
QRegExpValidator(const QRegExp& rx, QObject *parent);
~QRegExpValidator();

virtual QValidator::State validate(QString& input, int& pos) const;

void setRegExp(const QRegExp& rx);
const QRegExp& regExp() const { return r; } 







# 201 "/usr/share/qt4/include/QtGui/qvalidator.h"
private:
QRegExpValidator(const QRegExpValidator &); QRegExpValidator &operator=(const QRegExpValidator &);

QRegExp r;
};





# 211 "/usr/share/qt4/include/QtGui/qvalidator.h"





# 46 "/usr/share/qt4/include/QtGui/qabstractspinbox.h"


# 48 "/usr/share/qt4/include/QtGui/qabstractspinbox.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qabstractspinbox.h"
class QLineEdit;

class QAbstractSpinBoxPrivate;
class QStyleOptionSpinBox;

class  QAbstractSpinBox : public QWidget
{
Q_OBJECT

Q_ENUMS(ButtonSymbols)
Q_ENUMS(CorrectionMode)
Q_PROPERTY(bool wrapping READ wrapping WRITE setWrapping)
Q_PROPERTY(bool frame READ hasFrame WRITE setFrame)
Q_PROPERTY(Qt::Alignment alignment READ alignment WRITE setAlignment)
Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly)
Q_PROPERTY(ButtonSymbols buttonSymbols READ buttonSymbols WRITE setButtonSymbols)
Q_PROPERTY(QString specialValueText READ specialValueText WRITE setSpecialValueText)
Q_PROPERTY(QString text READ text)
Q_PROPERTY(bool accelerated READ isAccelerated WRITE setAccelerated)
Q_PROPERTY(CorrectionMode correctionMode READ correctionMode WRITE setCorrectionMode)
Q_PROPERTY(bool acceptableInput READ hasAcceptableInput)
Q_PROPERTY(bool keyboardTracking READ keyboardTracking WRITE setKeyboardTracking)
public:
explicit QAbstractSpinBox(QWidget *parent = 0);
~QAbstractSpinBox();

enum StepEnabledFlag { StepNone = 0x00, StepUpEnabled = 0x01,
StepDownEnabled = 0x02 };
typedef QFlags<StepEnabledFlag> StepEnabled;

enum ButtonSymbols { UpDownArrows, PlusMinus, NoButtons };

ButtonSymbols buttonSymbols() const;
void setButtonSymbols(ButtonSymbols bs);

enum CorrectionMode { CorrectToPreviousValue, CorrectToNearestValue };

void setCorrectionMode(CorrectionMode cm);
CorrectionMode correctionMode() const;

bool hasAcceptableInput() const;
QString text() const;

QString specialValueText() const;
void setSpecialValueText(const QString &txt);

bool wrapping() const;
void setWrapping(bool w);

void setReadOnly(bool r);
bool isReadOnly() const;

void setKeyboardTracking(bool kt);
bool keyboardTracking() const;

void setAlignment(Qt::Alignment flag);
Qt::Alignment alignment() const;

void setFrame(bool);
bool hasFrame() const;

void setAccelerated(bool on);
bool isAccelerated() const;

QSize sizeHint() const;
QSize minimumSizeHint() const;
void interpretText();
bool event(QEvent *event);

QVariant inputMethodQuery(Qt::InputMethodQuery) const;

virtual QValidator::State validate(QString &input, int &pos) const;
virtual void fixup(QString &input) const;

virtual void stepBy(int steps);
public slots:
void stepUp();
void stepDown();
void selectAll();
virtual void clear();
protected:
void resizeEvent(QResizeEvent *event);
void keyPressEvent(QKeyEvent *event);
void keyReleaseEvent(QKeyEvent *event);
void wheelEvent(QWheelEvent *event);
void focusInEvent(QFocusEvent *event);
void focusOutEvent(QFocusEvent *event);
void contextMenuEvent(QContextMenuEvent *event);
void changeEvent(QEvent *event);
void closeEvent(QCloseEvent *event);
void hideEvent(QHideEvent *event);
void mousePressEvent(QMouseEvent *event);
void mouseReleaseEvent(QMouseEvent *event);
void mouseMoveEvent(QMouseEvent *event);
void timerEvent(QTimerEvent *event);
void paintEvent(QPaintEvent *event);
void showEvent(QShowEvent *event);
void initStyleOption(QStyleOptionSpinBox *option) const;

QLineEdit *lineEdit() const;
void setLineEdit(QLineEdit *edit);

virtual StepEnabled stepEnabled() const;
signals:
void editingFinished();
protected:
QAbstractSpinBox(QAbstractSpinBoxPrivate &dd, QWidget *parent = 0);

private:



inline QAbstractSpinBoxPrivate* d_func() { return reinterpret_cast<QAbstractSpinBoxPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractSpinBoxPrivate* d_func() const { return reinterpret_cast<const QAbstractSpinBoxPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractSpinBoxPrivate;
QAbstractSpinBox(const QAbstractSpinBox &); QAbstractSpinBox &operator=(const QAbstractSpinBox &);
};
inline QFlags<QAbstractSpinBox::StepEnabled::enum_type> operator|(QAbstractSpinBox::StepEnabled::enum_type f1, QAbstractSpinBox::StepEnabled::enum_type f2) { return QFlags<QAbstractSpinBox::StepEnabled::enum_type>(f1) | f2; } inline QFlags<QAbstractSpinBox::StepEnabled::enum_type> operator|(QAbstractSpinBox::StepEnabled::enum_type f1, QFlags<QAbstractSpinBox::StepEnabled::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QAbstractSpinBox::StepEnabled::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 175 "/usr/share/qt4/include/QtGui/qabstractspinbox.h"





# 46 "/usr/share/qt4/include/QtGui/qstyleoption.h"

# 1 "/usr/share/qt4/include/QtGui/qicon.h"


























































































































































# 47 "/usr/share/qt4/include/QtGui/qstyleoption.h"

# 1 "/usr/share/qt4/include/QtGui/qmatrix.h"












































































































































































































# 48 "/usr/share/qt4/include/QtGui/qstyleoption.h"

# 1 "/usr/share/qt4/include/QtGui/qslider.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractslider.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qabstractslider.h"


# 47 "/usr/share/qt4/include/QtGui/qabstractslider.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QAbstractSliderPrivate;

class  QAbstractSlider : public QWidget
{
Q_OBJECT

Q_PROPERTY(int minimum READ minimum WRITE setMinimum)
Q_PROPERTY(int maximum READ maximum WRITE setMaximum)
Q_PROPERTY(int singleStep READ singleStep WRITE setSingleStep)
Q_PROPERTY(int pageStep READ pageStep WRITE setPageStep)
Q_PROPERTY(int value READ value WRITE setValue NOTIFY valueChanged USER true)
Q_PROPERTY(int sliderPosition READ sliderPosition WRITE setSliderPosition NOTIFY sliderMoved)
Q_PROPERTY(bool tracking READ hasTracking WRITE setTracking)
Q_PROPERTY(Qt::Orientation orientation READ orientation WRITE setOrientation)
Q_PROPERTY(bool invertedAppearance READ invertedAppearance WRITE setInvertedAppearance)
Q_PROPERTY(bool invertedControls READ invertedControls WRITE setInvertedControls)
Q_PROPERTY(bool sliderDown READ isSliderDown WRITE setSliderDown DESIGNABLE false)

public:
explicit QAbstractSlider(QWidget *parent=0);
~QAbstractSlider();

Qt::Orientation orientation() const;

void setMinimum(int);
int minimum() const;

void setMaximum(int);
int maximum() const;

void setRange(int min, int max);

void setSingleStep(int);
int singleStep() const;

void setPageStep(int);
int pageStep() const;

void setTracking(bool enable);
bool hasTracking() const;

void setSliderDown(bool);
bool isSliderDown() const;

void setSliderPosition(int);
int sliderPosition() const;

void setInvertedAppearance(bool);
bool invertedAppearance() const;

void setInvertedControls(bool);
bool invertedControls() const;

enum SliderAction {
SliderNoAction,
SliderSingleStepAdd,
SliderSingleStepSub,
SliderPageStepAdd,
SliderPageStepSub,
SliderToMinimum,
SliderToMaximum,
SliderMove
};

int value() const;

void triggerAction(SliderAction action);

public slots:
void setValue(int);
void setOrientation(Qt::Orientation);

signals:
void valueChanged(int value);

void sliderPressed();
void sliderMoved(int position);
void sliderReleased();

void rangeChanged(int min, int max);

void actionTriggered(int action);

protected:
bool event(QEvent *e);

void setRepeatAction(SliderAction action, int thresholdTime = 500, int repeatTime = 50);
SliderAction repeatAction() const;

enum SliderChange {
SliderRangeChange,
SliderOrientationChange,
SliderStepsChange,
SliderValueChange
};
virtual void sliderChange(SliderChange change);

void keyPressEvent(QKeyEvent *ev);
void timerEvent(QTimerEvent *);

# 153 "/usr/share/qt4/include/QtGui/qabstractslider.h"
void wheelEvent(QWheelEvent *e);

# 155 "/usr/share/qt4/include/QtGui/qabstractslider.h"
void changeEvent(QEvent *e);
















# 172 "/usr/share/qt4/include/QtGui/qabstractslider.h"
protected:
QAbstractSlider(QAbstractSliderPrivate &dd, QWidget *parent=0);

private:
QAbstractSlider(const QAbstractSlider &); QAbstractSlider &operator=(const QAbstractSlider &);
inline QAbstractSliderPrivate* d_func() { return reinterpret_cast<QAbstractSliderPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractSliderPrivate* d_func() const { return reinterpret_cast<const QAbstractSliderPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractSliderPrivate;
};






# 45 "/usr/share/qt4/include/QtGui/qslider.h"


# 47 "/usr/share/qt4/include/QtGui/qslider.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qslider.h"
class QSliderPrivate;
class QStyleOptionSlider;
class  QSlider : public QAbstractSlider
{
Q_OBJECT

Q_ENUMS(TickPosition)
Q_PROPERTY(TickPosition tickPosition READ tickPosition WRITE setTickPosition)
Q_PROPERTY(int tickInterval READ tickInterval WRITE setTickInterval)

public:
enum TickPosition {
NoTicks = 0,
TicksAbove = 1,
TicksLeft = TicksAbove,
TicksBelow = 2,
TicksRight = TicksBelow,
TicksBothSides = 3









# 82 "/usr/share/qt4/include/QtGui/qslider.h"
};

explicit QSlider(QWidget *parent = 0);
explicit QSlider(Qt::Orientation orientation, QWidget *parent = 0);

~QSlider();

QSize sizeHint() const;
QSize minimumSizeHint() const;

void setTickPosition(TickPosition position);
TickPosition tickPosition() const;

void setTickInterval(int ti);
int tickInterval() const;

bool event(QEvent *event);

protected:
void paintEvent(QPaintEvent *ev);
void mousePressEvent(QMouseEvent *ev);
void mouseReleaseEvent(QMouseEvent *ev);
void mouseMoveEvent(QMouseEvent *ev);
void initStyleOption(QStyleOptionSlider *option) const;















# 121 "/usr/share/qt4/include/QtGui/qslider.h"
private:
friend  QStyleOptionSlider qt_qsliderStyleOption(QSlider *slider);

QSlider(const QSlider &); QSlider &operator=(const QSlider &);
inline QSliderPrivate* d_func() { return reinterpret_cast<QSliderPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSliderPrivate* d_func() const { return reinterpret_cast<const QSliderPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSliderPrivate;
};



# 130 "/usr/share/qt4/include/QtGui/qslider.h"





# 49 "/usr/share/qt4/include/QtGui/qstyleoption.h"

# 1 "/usr/share/qt4/include/QtGui/qstyle.h"























































































































































































































































































































































































































































































































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qstyleoption.h"

# 1 "/usr/share/qt4/include/QtGui/qtabbar.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtabbar.h"


# 47 "/usr/share/qt4/include/QtGui/qtabbar.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qtabbar.h"
class QIcon;
class QTabBarPrivate;
class QStyleOptionTab;

class  QTabBar: public QWidget
{
Q_OBJECT

Q_ENUMS(Shape)
Q_PROPERTY(Shape shape READ shape WRITE setShape)
Q_PROPERTY(int currentIndex READ currentIndex WRITE setCurrentIndex NOTIFY currentChanged)
Q_PROPERTY(int count READ count)
Q_PROPERTY(bool drawBase READ drawBase WRITE setDrawBase)
Q_PROPERTY(QSize iconSize READ iconSize WRITE setIconSize)
Q_PROPERTY(Qt::TextElideMode elideMode READ elideMode WRITE setElideMode)
Q_PROPERTY(bool usesScrollButtons READ usesScrollButtons WRITE setUsesScrollButtons)
Q_PROPERTY(bool tabsClosable READ tabsClosable WRITE setTabsClosable)
Q_PROPERTY(SelectionBehavior selectionBehaviorOnRemove READ selectionBehaviorOnRemove WRITE setSelectionBehaviorOnRemove)
Q_PROPERTY(bool expanding READ expanding WRITE setExpanding)
Q_PROPERTY(bool movable READ isMovable WRITE setMovable)
Q_PROPERTY(bool documentMode READ documentMode WRITE setDocumentMode)

public:
explicit QTabBar(QWidget* parent=0);
~QTabBar();

enum Shape { RoundedNorth, RoundedSouth, RoundedWest, RoundedEast,
TriangularNorth, TriangularSouth, TriangularWest, TriangularEast




# 87 "/usr/share/qt4/include/QtGui/qtabbar.h"
};

enum ButtonPosition {
LeftSide,
RightSide
};

enum SelectionBehavior {
SelectLeftTab,
SelectRightTab,
SelectPreviousTab
};

Shape shape() const;
void setShape(Shape shape);

int addTab(const QString &text);
int addTab(const QIcon &icon, const QString &text);

int insertTab(int index, const QString &text);
int insertTab(int index, const QIcon&icon, const QString &text);

void removeTab(int index);
void moveTab(int from, int to);

bool isTabEnabled(int index) const;
void setTabEnabled(int index, bool);

QString tabText(int index) const;
void setTabText(int index, const QString &text);

QColor tabTextColor(int index) const;
void setTabTextColor(int index, const QColor &color);

QIcon tabIcon(int index) const;
void setTabIcon(int index, const QIcon &icon);

Qt::TextElideMode elideMode() const;
void setElideMode(Qt::TextElideMode);


# 128 "/usr/share/qt4/include/QtGui/qtabbar.h"
void setTabToolTip(int index, const QString &tip);
QString tabToolTip(int index) const;



# 133 "/usr/share/qt4/include/QtGui/qtabbar.h"
void setTabWhatsThis(int index, const QString &text);
QString tabWhatsThis(int index) const;


# 137 "/usr/share/qt4/include/QtGui/qtabbar.h"
void setTabData(int index, const QVariant &data);
QVariant tabData(int index) const;

QRect tabRect(int index) const;
int tabAt(const QPoint &pos) const;

int currentIndex() const;
int count() const;

QSize sizeHint() const;
QSize minimumSizeHint() const;

void setDrawBase(bool drawTheBase);
bool drawBase() const;

QSize iconSize() const;
void setIconSize(const QSize &size);

bool usesScrollButtons() const;
void setUsesScrollButtons(bool useButtons);

bool tabsClosable() const;
void setTabsClosable(bool closable);

void setTabButton(int index, ButtonPosition position, QWidget *widget);
QWidget *tabButton(int index, ButtonPosition position) const;

SelectionBehavior selectionBehaviorOnRemove() const;
void setSelectionBehaviorOnRemove(SelectionBehavior behavior);

bool expanding() const;
void setExpanding(bool enabled);

bool isMovable() const;
void setMovable(bool movable);

bool documentMode() const;
void setDocumentMode(bool set);

public slots:
void setCurrentIndex(int index);

signals:
void currentChanged(int index);
void tabCloseRequested(int index);
void tabMoved(int from, int to);

protected:
virtual QSize tabSizeHint(int index) const;
virtual void tabInserted(int index);
virtual void tabRemoved(int index);
virtual void tabLayoutChange();

bool event(QEvent *);
void resizeEvent(QResizeEvent *);
void showEvent(QShowEvent *);
void hideEvent(QHideEvent *);
void paintEvent(QPaintEvent *);
void mousePressEvent (QMouseEvent *);
void mouseMoveEvent (QMouseEvent *);
void mouseReleaseEvent (QMouseEvent *);

# 199 "/usr/share/qt4/include/QtGui/qtabbar.h"
void wheelEvent(QWheelEvent *event);

# 201 "/usr/share/qt4/include/QtGui/qtabbar.h"
void keyPressEvent(QKeyEvent *);
void changeEvent(QEvent *);
void initStyleOption(QStyleOptionTab *option, int tabIndex) const;








# 212 "/usr/share/qt4/include/QtGui/qtabbar.h"
friend class QAccessibleTabBar;
private:
QTabBar(const QTabBar &); QTabBar &operator=(const QTabBar &);
inline QTabBarPrivate* d_func() { return reinterpret_cast<QTabBarPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTabBarPrivate* d_func() const { return reinterpret_cast<const QTabBarPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTabBarPrivate;


};



# 222 "/usr/share/qt4/include/QtGui/qtabbar.h"





# 51 "/usr/share/qt4/include/QtGui/qstyleoption.h"

# 1 "/usr/share/qt4/include/QtGui/qtabwidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtabwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qicon.h"


























































































































































# 46 "/usr/share/qt4/include/QtGui/qtabwidget.h"


# 48 "/usr/share/qt4/include/QtGui/qtabwidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qtabwidget.h"
class QTabBar;
class QTabWidgetPrivate;
class QStyleOptionTabWidgetFrame;

class  QTabWidget : public QWidget
{
Q_OBJECT
Q_ENUMS(TabPosition TabShape)
Q_PROPERTY(TabPosition tabPosition READ tabPosition WRITE setTabPosition)
Q_PROPERTY(TabShape tabShape READ tabShape WRITE setTabShape)
Q_PROPERTY(int currentIndex READ currentIndex WRITE setCurrentIndex NOTIFY currentChanged)
Q_PROPERTY(int count READ count)
Q_PROPERTY(QSize iconSize READ iconSize WRITE setIconSize)
Q_PROPERTY(Qt::TextElideMode elideMode READ elideMode WRITE setElideMode)
Q_PROPERTY(bool usesScrollButtons READ usesScrollButtons WRITE setUsesScrollButtons)
Q_PROPERTY(bool documentMode READ documentMode WRITE setDocumentMode)
Q_PROPERTY(bool tabsClosable READ tabsClosable WRITE setTabsClosable)
Q_PROPERTY(bool movable READ isMovable WRITE setMovable)

public:
explicit QTabWidget(QWidget *parent = 0);
~QTabWidget();

int addTab(QWidget *widget, const QString &);
int addTab(QWidget *widget, const QIcon& icon, const QString &label);

int insertTab(int index, QWidget *widget, const QString &);
int insertTab(int index, QWidget *widget, const QIcon& icon, const QString &label);

void removeTab(int index);

bool isTabEnabled(int index) const;
void setTabEnabled(int index, bool);

QString tabText(int index) const;
void setTabText(int index, const QString &);

QIcon tabIcon(int index) const;
void setTabIcon(int index, const QIcon & icon);


# 97 "/usr/share/qt4/include/QtGui/qtabwidget.h"
void setTabToolTip(int index, const QString & tip);
QString tabToolTip(int index) const;



# 102 "/usr/share/qt4/include/QtGui/qtabwidget.h"
void setTabWhatsThis(int index, const QString &text);
QString tabWhatsThis(int index) const;


# 106 "/usr/share/qt4/include/QtGui/qtabwidget.h"
int currentIndex() const;
QWidget *currentWidget() const;
QWidget *widget(int index) const;
int indexOf(QWidget *widget) const;
int count() const;

enum TabPosition { North, South, West, East



# 116 "/usr/share/qt4/include/QtGui/qtabwidget.h"
};
TabPosition tabPosition() const;
void setTabPosition(TabPosition);

bool tabsClosable() const;
void setTabsClosable(bool closeable);

bool isMovable() const;
void setMovable(bool movable);

enum TabShape { Rounded, Triangular };
TabShape tabShape() const;
void setTabShape(TabShape s);

QSize sizeHint() const;
QSize minimumSizeHint() const;

void setCornerWidget(QWidget * w, Qt::Corner corner = Qt::TopRightCorner);
QWidget * cornerWidget(Qt::Corner corner = Qt::TopRightCorner) const;

Qt::TextElideMode elideMode() const;
void setElideMode(Qt::TextElideMode);

QSize iconSize() const;
void setIconSize(const QSize &size);

bool usesScrollButtons() const;
void setUsesScrollButtons(bool useButtons);

bool documentMode() const;
void setDocumentMode(bool set);

void clear();

public slots:
void setCurrentIndex(int index);
void setCurrentWidget(QWidget *widget);

signals:
void currentChanged(int index);
void tabCloseRequested(int index);

protected:
virtual void tabInserted(int index);
virtual void tabRemoved(int index);

void showEvent(QShowEvent *);
void resizeEvent(QResizeEvent *);
void keyPressEvent(QKeyEvent *);
void paintEvent(QPaintEvent *);
void setTabBar(QTabBar *);
QTabBar* tabBar() const;
void changeEvent(QEvent *);
bool event(QEvent *);
void initStyleOption(QStyleOptionTabWidgetFrame *option) const;

































































# 236 "/usr/share/qt4/include/QtGui/qtabwidget.h"
private:
inline QTabWidgetPrivate* d_func() { return reinterpret_cast<QTabWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTabWidgetPrivate* d_func() const { return reinterpret_cast<const QTabWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTabWidgetPrivate;
QTabWidget(const QTabWidget &); QTabWidget &operator=(const QTabWidget &);



void setUpLayout(bool = false);
friend class Q3TabDialog;
};



# 248 "/usr/share/qt4/include/QtGui/qtabwidget.h"





# 52 "/usr/share/qt4/include/QtGui/qstyleoption.h"

# 1 "/usr/share/qt4/include/QtGui/qrubberband.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qrubberband.h"


# 47 "/usr/share/qt4/include/QtGui/qrubberband.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qrubberband.h"
class QRubberBandPrivate;
class QStyleOptionRubberBand;

class  QRubberBand : public QWidget
{
Q_OBJECT

public:
enum Shape { Line, Rectangle };
explicit QRubberBand(Shape, QWidget * =0);
~QRubberBand();

Shape shape() const;

void setGeometry(const QRect &r);

inline void setGeometry(int x, int y, int w, int h);
inline void move(int x, int y);
inline void move(const QPoint &p)
{ move(p.x(), p.y()); }
inline void resize(int w, int h)
{ setGeometry(geometry().x(), geometry().y(), w, h); }
inline void resize(const QSize &s)
{ resize(s.width(), s.height()); }

protected:
bool event(QEvent *e);
void paintEvent(QPaintEvent *);
void changeEvent(QEvent *);
void showEvent(QShowEvent *);
void resizeEvent(QResizeEvent *);
void moveEvent(QMoveEvent *);
void initStyleOption(QStyleOptionRubberBand *option) const;

private:
inline QRubberBandPrivate* d_func() { return reinterpret_cast<QRubberBandPrivate *>(qGetPtrHelper(d_ptr)); } inline const QRubberBandPrivate* d_func() const { return reinterpret_cast<const QRubberBandPrivate *>(qGetPtrHelper(d_ptr)); } friend class QRubberBandPrivate;
};

inline void QRubberBand::setGeometry(int ax, int ay, int aw, int ah)
{ setGeometry(QRect(ax, ay, aw, ah)); }
inline void QRubberBand::move(int ax, int ay)
{ setGeometry(ax, ay, width(), height()); }



# 100 "/usr/share/qt4/include/QtGui/qrubberband.h"





# 53 "/usr/share/qt4/include/QtGui/qstyleoption.h"

# 1 "/usr/share/qt4/include/QtGui/qframe.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qframe.h"


# 47 "/usr/share/qt4/include/QtGui/qframe.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QFramePrivate;

class  QFrame : public QWidget
{
Q_OBJECT

Q_ENUMS(Shape Shadow)
Q_PROPERTY(Shape frameShape READ frameShape WRITE setFrameShape)
Q_PROPERTY(Shadow frameShadow READ frameShadow WRITE setFrameShadow)
Q_PROPERTY(int lineWidth READ lineWidth WRITE setLineWidth)
Q_PROPERTY(int midLineWidth READ midLineWidth WRITE setMidLineWidth)
Q_PROPERTY(int frameWidth READ frameWidth)
Q_PROPERTY(QRect frameRect READ frameRect WRITE setFrameRect DESIGNABLE false)

public:
explicit QFrame(QWidget* parent = 0, Qt::WindowFlags f = 0);
~QFrame();

int frameStyle() const;
void setFrameStyle(int);

int frameWidth() const;

QSize sizeHint() const;

enum Shape {
NoFrame = 0, 
Box = 0x0001, 
Panel = 0x0002, 
WinPanel = 0x0003, 
HLine = 0x0004, 
VLine = 0x0005, 
StyledPanel = 0x0006 









# 95 "/usr/share/qt4/include/QtGui/qframe.h"
};
enum Shadow {
Plain = 0x0010, 
Raised = 0x0020, 
Sunken = 0x0030 
};

enum StyleMask {
Shadow_Mask = 0x00f0, 
Shape_Mask = 0x000f 




# 109 "/usr/share/qt4/include/QtGui/qframe.h"
};

Shape frameShape() const;
void setFrameShape(Shape);
Shadow frameShadow() const;
void setFrameShadow(Shadow);

int lineWidth() const;
void setLineWidth(int);

int midLineWidth() const;
void setMidLineWidth(int);

QRect frameRect() const;
void setFrameRect(const QRect &);

protected:
bool event(QEvent *e);
void paintEvent(QPaintEvent *);
void changeEvent(QEvent *);
void drawFrame(QPainter *);






# 136 "/usr/share/qt4/include/QtGui/qframe.h"
protected:
QFrame(QFramePrivate &dd, QWidget* parent = 0, Qt::WindowFlags f = 0);

private:
QFrame(const QFrame &); QFrame &operator=(const QFrame &);
inline QFramePrivate* d_func() { return reinterpret_cast<QFramePrivate *>(qGetPtrHelper(d_ptr)); } inline const QFramePrivate* d_func() const { return reinterpret_cast<const QFramePrivate *>(qGetPtrHelper(d_ptr)); } friend class QFramePrivate;
};






# 54 "/usr/share/qt4/include/QtGui/qstyleoption.h"


# 1 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"


























































































































































































































































































































































































































# 56 "/usr/share/qt4/include/QtGui/qstyleoption.h"



# 59 "/usr/share/qt4/include/QtGui/qstyleoption.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QDebug;

class  QStyleOption
{
public:
enum OptionType {
SO_Default, SO_FocusRect, SO_Button, SO_Tab, SO_MenuItem,
SO_Frame, SO_ProgressBar, SO_ToolBox, SO_Header, SO_Q3DockWindow,
SO_DockWidget, SO_Q3ListViewItem, SO_ViewItem, SO_TabWidgetFrame,
SO_TabBarBase, SO_RubberBand, SO_ToolBar, SO_GraphicsItem,

SO_Complex = 0xf0000, SO_Slider, SO_SpinBox, SO_ToolButton, SO_ComboBox,
SO_Q3ListView, SO_TitleBar, SO_GroupBox, SO_SizeGrip,

SO_CustomBase = 0xf00,
SO_ComplexCustomBase = 0xf000000
};

enum StyleOptionType { Type = SO_Default };
enum StyleOptionVersion { Version = 1 };

int version;
int type;
QStyle::State state;
Qt::LayoutDirection direction;
QRect rect;
QFontMetrics fontMetrics;
QPalette palette;

QStyleOption(int version = QStyleOption::Version, int type = SO_Default);
QStyleOption(const QStyleOption &other);
~QStyleOption();

void init(const QWidget *w);
inline void initFrom(const QWidget *w) { init(w); }
QStyleOption &operator=(const QStyleOption &other);
};

class  QStyleOptionFocusRect : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_FocusRect };
enum StyleOptionVersion { Version = 1 };

QColor backgroundColor;

QStyleOptionFocusRect();
QStyleOptionFocusRect(const QStyleOptionFocusRect &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionFocusRect(int version);
};

class  QStyleOptionFrame : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_Frame };
enum StyleOptionVersion { Version = 1 };

int lineWidth;
int midLineWidth;

QStyleOptionFrame();
QStyleOptionFrame(const QStyleOptionFrame &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionFrame(int version);
};

class  QStyleOptionFrameV2 : public QStyleOptionFrame
{
public:
enum StyleOptionVersion { Version = 2 };
enum FrameFeature {
None = 0x00,
Flat = 0x01
};
typedef QFlags<FrameFeature> FrameFeatures;
FrameFeatures features;

QStyleOptionFrameV2();
QStyleOptionFrameV2(const QStyleOptionFrameV2 &other) : QStyleOptionFrame(Version) { *this = other; }
QStyleOptionFrameV2(const QStyleOptionFrame &other);
QStyleOptionFrameV2 &operator=(const QStyleOptionFrame &other);

protected:
QStyleOptionFrameV2(int version);
};

inline QFlags<QStyleOptionFrameV2::FrameFeatures::enum_type> operator|(QStyleOptionFrameV2::FrameFeatures::enum_type f1, QStyleOptionFrameV2::FrameFeatures::enum_type f2) { return QFlags<QStyleOptionFrameV2::FrameFeatures::enum_type>(f1) | f2; } inline QFlags<QStyleOptionFrameV2::FrameFeatures::enum_type> operator|(QStyleOptionFrameV2::FrameFeatures::enum_type f1, QFlags<QStyleOptionFrameV2::FrameFeatures::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QStyleOptionFrameV2::FrameFeatures::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


class  QStyleOptionFrameV3 : public QStyleOptionFrameV2
{
public:
enum StyleOptionVersion { Version = 3 };
QFrame::Shape frameShape : 4;
uint unused : 28;

QStyleOptionFrameV3();
QStyleOptionFrameV3(const QStyleOptionFrameV3 &other) : QStyleOptionFrameV2(Version) { *this = other; }
QStyleOptionFrameV3(const QStyleOptionFrame &other);
QStyleOptionFrameV3 &operator=(const QStyleOptionFrame &other);

protected:
QStyleOptionFrameV3(int version);
};



# 175 "/usr/share/qt4/include/QtGui/qstyleoption.h"
class  QStyleOptionTabWidgetFrame : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_TabWidgetFrame };
enum StyleOptionVersion { Version = 1 };

int lineWidth;
int midLineWidth;
QTabBar::Shape shape;
QSize tabBarSize;
QSize rightCornerWidgetSize;
QSize leftCornerWidgetSize;

QStyleOptionTabWidgetFrame();
inline QStyleOptionTabWidgetFrame(const QStyleOptionTabWidgetFrame &other)
: QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionTabWidgetFrame(int version);
};

class  QStyleOptionTabWidgetFrameV2 : public QStyleOptionTabWidgetFrame
{
public:
enum StyleOptionVersion { Version = 2 };

QRect tabBarRect;
QRect selectedTabRect;

QStyleOptionTabWidgetFrameV2();
QStyleOptionTabWidgetFrameV2(const QStyleOptionTabWidgetFrameV2 &other) :
QStyleOptionTabWidgetFrame(Version) { *this = other; }
QStyleOptionTabWidgetFrameV2(const QStyleOptionTabWidgetFrame &other);
QStyleOptionTabWidgetFrameV2 &operator=(const QStyleOptionTabWidgetFrame &other);

protected:
QStyleOptionTabWidgetFrameV2(int version);
};





# 218 "/usr/share/qt4/include/QtGui/qstyleoption.h"
class  QStyleOptionTabBarBase : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_TabBarBase };
enum StyleOptionVersion { Version = 1 };

QTabBar::Shape shape;
QRect tabBarRect;
QRect selectedTabRect;

QStyleOptionTabBarBase();
QStyleOptionTabBarBase(const QStyleOptionTabBarBase &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionTabBarBase(int version);
};

class  QStyleOptionTabBarBaseV2 : public QStyleOptionTabBarBase
{
public:
enum StyleOptionVersion { Version = 2 };
bool documentMode;
QStyleOptionTabBarBaseV2();
QStyleOptionTabBarBaseV2(const QStyleOptionTabBarBaseV2 &other) : QStyleOptionTabBarBase(Version) { *this = other; }
QStyleOptionTabBarBaseV2(const QStyleOptionTabBarBase &other);
QStyleOptionTabBarBaseV2 &operator=(const QStyleOptionTabBarBase &other);

protected:
QStyleOptionTabBarBaseV2(int version);
};



# 251 "/usr/share/qt4/include/QtGui/qstyleoption.h"
class  QStyleOptionHeader : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_Header };
enum StyleOptionVersion { Version = 1 };

enum SectionPosition { Beginning, Middle, End, OnlyOneSection };
enum SelectedPosition { NotAdjacent, NextIsSelected, PreviousIsSelected,
NextAndPreviousAreSelected };
enum SortIndicator { None, SortUp, SortDown };

int section;
QString text;
Qt::Alignment textAlignment;
QIcon icon;
Qt::Alignment iconAlignment;
SectionPosition position;
SelectedPosition selectedPosition;
SortIndicator sortIndicator;
Qt::Orientation orientation;

QStyleOptionHeader();
QStyleOptionHeader(const QStyleOptionHeader &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionHeader(int version);
};

class  QStyleOptionButton : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_Button };
enum StyleOptionVersion { Version = 1 };

enum ButtonFeature { None = 0x00, Flat = 0x01, HasMenu = 0x02, DefaultButton = 0x04,
AutoDefaultButton = 0x08, CommandLinkButton = 0x10 };
typedef QFlags<ButtonFeature> ButtonFeatures;

ButtonFeatures features;
QString text;
QIcon icon;
QSize iconSize;

QStyleOptionButton();
QStyleOptionButton(const QStyleOptionButton &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionButton(int version);
};

inline QFlags<QStyleOptionButton::ButtonFeatures::enum_type> operator|(QStyleOptionButton::ButtonFeatures::enum_type f1, QStyleOptionButton::ButtonFeatures::enum_type f2) { return QFlags<QStyleOptionButton::ButtonFeatures::enum_type>(f1) | f2; } inline QFlags<QStyleOptionButton::ButtonFeatures::enum_type> operator|(QStyleOptionButton::ButtonFeatures::enum_type f1, QFlags<QStyleOptionButton::ButtonFeatures::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QStyleOptionButton::ButtonFeatures::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 304 "/usr/share/qt4/include/QtGui/qstyleoption.h"
class  QStyleOptionTab : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_Tab };
enum StyleOptionVersion { Version = 1 };

enum TabPosition { Beginning, Middle, End, OnlyOneTab };
enum SelectedPosition { NotAdjacent, NextIsSelected, PreviousIsSelected };
enum CornerWidget { NoCornerWidgets = 0x00, LeftCornerWidget = 0x01,
RightCornerWidget = 0x02 };
typedef QFlags<CornerWidget> CornerWidgets;

QTabBar::Shape shape;
QString text;
QIcon icon;
int row;
TabPosition position;
SelectedPosition selectedPosition;
CornerWidgets cornerWidgets;

QStyleOptionTab();
QStyleOptionTab(const QStyleOptionTab &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionTab(int version);
};

inline QFlags<QStyleOptionTab::CornerWidgets::enum_type> operator|(QStyleOptionTab::CornerWidgets::enum_type f1, QStyleOptionTab::CornerWidgets::enum_type f2) { return QFlags<QStyleOptionTab::CornerWidgets::enum_type>(f1) | f2; } inline QFlags<QStyleOptionTab::CornerWidgets::enum_type> operator|(QStyleOptionTab::CornerWidgets::enum_type f1, QFlags<QStyleOptionTab::CornerWidgets::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QStyleOptionTab::CornerWidgets::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class  QStyleOptionTabV2 : public QStyleOptionTab
{
public:
enum StyleOptionVersion { Version = 2 };
QSize iconSize;
QStyleOptionTabV2();
QStyleOptionTabV2(const QStyleOptionTabV2 &other) : QStyleOptionTab(Version) { *this = other; }
QStyleOptionTabV2(const QStyleOptionTab &other);
QStyleOptionTabV2 &operator=(const QStyleOptionTab &other);

protected:
QStyleOptionTabV2(int version);
};

class  QStyleOptionTabV3 : public QStyleOptionTabV2
{
public:
enum StyleOptionVersion { Version = 3 };
bool documentMode;
QSize leftButtonSize;
QSize rightButtonSize;
QStyleOptionTabV3();
QStyleOptionTabV3(const QStyleOptionTabV3 &other) : QStyleOptionTabV2(Version) { *this = other; }
QStyleOptionTabV3(const QStyleOptionTabV2 &other) : QStyleOptionTabV2(Version) { *this = other; }
QStyleOptionTabV3(const QStyleOptionTab &other);
QStyleOptionTabV3 &operator=(const QStyleOptionTab &other);

protected:
QStyleOptionTabV3(int version);
};






# 369 "/usr/share/qt4/include/QtGui/qstyleoption.h"
class  QStyleOptionToolBar : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_ToolBar };
enum StyleOptionVersion { Version = 1 };
enum ToolBarPosition { Beginning, Middle, End, OnlyOne };
enum ToolBarFeature { None = 0x0, Movable = 0x1 };
typedef QFlags<ToolBarFeature> ToolBarFeatures;
ToolBarPosition positionOfLine; 
ToolBarPosition positionWithinLine; 
Qt::ToolBarArea toolBarArea; 
ToolBarFeatures features;
int lineWidth;
int midLineWidth;
QStyleOptionToolBar();
QStyleOptionToolBar(const QStyleOptionToolBar &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionToolBar(int version);
};

inline QFlags<QStyleOptionToolBar::ToolBarFeatures::enum_type> operator|(QStyleOptionToolBar::ToolBarFeatures::enum_type f1, QStyleOptionToolBar::ToolBarFeatures::enum_type f2) { return QFlags<QStyleOptionToolBar::ToolBarFeatures::enum_type>(f1) | f2; } inline QFlags<QStyleOptionToolBar::ToolBarFeatures::enum_type> operator|(QStyleOptionToolBar::ToolBarFeatures::enum_type f1, QFlags<QStyleOptionToolBar::ToolBarFeatures::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QStyleOptionToolBar::ToolBarFeatures::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }





# 396 "/usr/share/qt4/include/QtGui/qstyleoption.h"
class  QStyleOptionProgressBar : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_ProgressBar };
enum StyleOptionVersion { Version = 1 };

int minimum;
int maximum;
int progress;
QString text;
Qt::Alignment textAlignment;
bool textVisible;

QStyleOptionProgressBar();
QStyleOptionProgressBar(const QStyleOptionProgressBar &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionProgressBar(int version);
};


class  QStyleOptionProgressBarV2 : public QStyleOptionProgressBar
{
public:
enum StyleOptionType { Type = SO_ProgressBar };
enum StyleOptionVersion { Version = 2 };
Qt::Orientation orientation;
bool invertedAppearance;
bool bottomToTop;

QStyleOptionProgressBarV2();
QStyleOptionProgressBarV2(const QStyleOptionProgressBar &other);
QStyleOptionProgressBarV2(const QStyleOptionProgressBarV2 &other);
QStyleOptionProgressBarV2 &operator=(const QStyleOptionProgressBar &other);

protected:
QStyleOptionProgressBarV2(int version);
};

class  QStyleOptionMenuItem : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_MenuItem };
enum StyleOptionVersion { Version = 1 };

enum MenuItemType { Normal, DefaultItem, Separator, SubMenu, Scroller, TearOff, Margin,
EmptyArea };
enum CheckType { NotCheckable, Exclusive, NonExclusive };

MenuItemType menuItemType;
CheckType checkType;
bool checked;
bool menuHasCheckableItems;
QRect menuRect;
QString text;
QIcon icon;
int maxIconWidth;
int tabWidth;
QFont font;

QStyleOptionMenuItem();
QStyleOptionMenuItem(const QStyleOptionMenuItem &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionMenuItem(int version);
};

class  QStyleOptionQ3ListViewItem : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_Q3ListViewItem };
enum StyleOptionVersion { Version = 1 };

enum Q3ListViewItemFeature { None = 0x00, Expandable = 0x01, MultiLine = 0x02, Visible = 0x04,
ParentControl = 0x08 };
typedef QFlags<Q3ListViewItemFeature> Q3ListViewItemFeatures;

Q3ListViewItemFeatures features;
int height;
int totalHeight;
int itemY;
int childCount;

QStyleOptionQ3ListViewItem();
QStyleOptionQ3ListViewItem(const QStyleOptionQ3ListViewItem &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionQ3ListViewItem(int version);
};

inline QFlags<QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type> operator|(QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type f1, QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type f2) { return QFlags<QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type>(f1) | f2; } inline QFlags<QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type> operator|(QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type f1, QFlags<QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QStyleOptionQ3ListViewItem::Q3ListViewItemFeatures::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class  QStyleOptionQ3DockWindow : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_Q3DockWindow };
enum StyleOptionVersion { Version = 1 };

bool docked;
bool closeEnabled;

QStyleOptionQ3DockWindow();
QStyleOptionQ3DockWindow(const QStyleOptionQ3DockWindow &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionQ3DockWindow(int version);
};

class  QStyleOptionDockWidget : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_DockWidget };
enum StyleOptionVersion { Version = 1 };

QString title;
bool closable;
bool movable;
bool floatable;

QStyleOptionDockWidget();
QStyleOptionDockWidget(const QStyleOptionDockWidget &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionDockWidget(int version);
};

class  QStyleOptionDockWidgetV2 : public QStyleOptionDockWidget
{
public:
enum StyleOptionVersion { Version = 2 };

bool verticalTitleBar;

QStyleOptionDockWidgetV2();
QStyleOptionDockWidgetV2(const QStyleOptionDockWidgetV2 &other)
: QStyleOptionDockWidget(Version) { *this = other; }
QStyleOptionDockWidgetV2(const QStyleOptionDockWidget &other);
QStyleOptionDockWidgetV2 &operator = (const QStyleOptionDockWidget &other);

protected:
QStyleOptionDockWidgetV2(int version);
};

class  QStyleOptionViewItem : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_ViewItem };
enum StyleOptionVersion { Version = 1 };

enum Position { Left, Right, Top, Bottom };

Qt::Alignment displayAlignment;
Qt::Alignment decorationAlignment;
Qt::TextElideMode textElideMode;
Position decorationPosition;
QSize decorationSize;
QFont font;
bool showDecorationSelected;

QStyleOptionViewItem();
QStyleOptionViewItem(const QStyleOptionViewItem &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionViewItem(int version);
};

class  QStyleOptionViewItemV2 : public QStyleOptionViewItem
{
public:
enum StyleOptionVersion { Version = 2 };

enum ViewItemFeature {
None = 0x00,
WrapText = 0x01,
Alternate = 0x02,
HasCheckIndicator = 0x04,
HasDisplay = 0x08,
HasDecoration = 0x10
};
typedef QFlags<ViewItemFeature> ViewItemFeatures;

ViewItemFeatures features;

QStyleOptionViewItemV2();
QStyleOptionViewItemV2(const QStyleOptionViewItemV2 &other) : QStyleOptionViewItem(Version) { *this = other; }
QStyleOptionViewItemV2(const QStyleOptionViewItem &other);
QStyleOptionViewItemV2 &operator=(const QStyleOptionViewItem &other);

protected:
QStyleOptionViewItemV2(int version);
};

inline QFlags<QStyleOptionViewItemV2::ViewItemFeatures::enum_type> operator|(QStyleOptionViewItemV2::ViewItemFeatures::enum_type f1, QStyleOptionViewItemV2::ViewItemFeatures::enum_type f2) { return QFlags<QStyleOptionViewItemV2::ViewItemFeatures::enum_type>(f1) | f2; } inline QFlags<QStyleOptionViewItemV2::ViewItemFeatures::enum_type> operator|(QStyleOptionViewItemV2::ViewItemFeatures::enum_type f1, QFlags<QStyleOptionViewItemV2::ViewItemFeatures::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QStyleOptionViewItemV2::ViewItemFeatures::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class  QStyleOptionViewItemV3 : public QStyleOptionViewItemV2
{
public:
enum StyleOptionVersion { Version = 3 };

QLocale locale;
const QWidget *widget;

QStyleOptionViewItemV3();
QStyleOptionViewItemV3(const QStyleOptionViewItemV3 &other)
: QStyleOptionViewItemV2(Version) { *this = other; }
QStyleOptionViewItemV3(const QStyleOptionViewItem &other);
QStyleOptionViewItemV3 &operator = (const QStyleOptionViewItem &other);

protected:
QStyleOptionViewItemV3(int version);
};


# 609 "/usr/share/qt4/include/QtGui/qstyleoption.h"
class  QStyleOptionViewItemV4 : public QStyleOptionViewItemV3
{
public:
enum StyleOptionVersion { Version = 4 };
enum ViewItemPosition { Invalid, Beginning, Middle, End, OnlyOne };

QModelIndex index;
Qt::CheckState checkState;
QIcon icon;
QString text;
ViewItemPosition viewItemPosition;
QBrush backgroundBrush;

QStyleOptionViewItemV4();
QStyleOptionViewItemV4(const QStyleOptionViewItemV4 &other)
: QStyleOptionViewItemV3(Version) { *this = other; }
QStyleOptionViewItemV4(const QStyleOptionViewItem &other);
QStyleOptionViewItemV4 &operator = (const QStyleOptionViewItem &other);

protected:
QStyleOptionViewItemV4(int version);
};


# 633 "/usr/share/qt4/include/QtGui/qstyleoption.h"
class  QStyleOptionToolBox : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_ToolBox };
enum StyleOptionVersion { Version = 1 };

QString text;
QIcon icon;

QStyleOptionToolBox();
QStyleOptionToolBox(const QStyleOptionToolBox &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionToolBox(int version);
};

class  QStyleOptionToolBoxV2 : public QStyleOptionToolBox
{
public:
enum StyleOptionVersion { Version = 2 };
enum TabPosition { Beginning, Middle, End, OnlyOneTab };
enum SelectedPosition { NotAdjacent, NextIsSelected, PreviousIsSelected };

TabPosition position;
SelectedPosition selectedPosition;

QStyleOptionToolBoxV2();
QStyleOptionToolBoxV2(const QStyleOptionToolBoxV2 &other) : QStyleOptionToolBox(Version) { *this = other; }
QStyleOptionToolBoxV2(const QStyleOptionToolBox &other);
QStyleOptionToolBoxV2 &operator=(const QStyleOptionToolBox &other);

protected:
QStyleOptionToolBoxV2(int version);
};


# 669 "/usr/share/qt4/include/QtGui/qstyleoption.h"
class  QStyleOptionRubberBand : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_RubberBand };
enum StyleOptionVersion { Version = 1 };

QRubberBand::Shape shape;
bool opaque;

QStyleOptionRubberBand();
QStyleOptionRubberBand(const QStyleOptionRubberBand &other) : QStyleOption(Version, Type) { *this = other; }

protected:
QStyleOptionRubberBand(int version);
};


# 686 "/usr/share/qt4/include/QtGui/qstyleoption.h"

class  QStyleOptionComplex : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_Complex };
enum StyleOptionVersion { Version = 1 };

QStyle::SubControls subControls;
QStyle::SubControls activeSubControls;

QStyleOptionComplex(int version = QStyleOptionComplex::Version, int type = SO_Complex);
QStyleOptionComplex(const QStyleOptionComplex &other) : QStyleOption(Version, Type) { *this = other; }
};


# 701 "/usr/share/qt4/include/QtGui/qstyleoption.h"
class  QStyleOptionSlider : public QStyleOptionComplex
{
public:
enum StyleOptionType { Type = SO_Slider };
enum StyleOptionVersion { Version = 1 };

Qt::Orientation orientation;
int minimum;
int maximum;
QSlider::TickPosition tickPosition;
int tickInterval;
bool upsideDown;
int sliderPosition;
int sliderValue;
int singleStep;
int pageStep;
qreal notchTarget;
bool dialWrapping;

QStyleOptionSlider();
QStyleOptionSlider(const QStyleOptionSlider &other) : QStyleOptionComplex(Version, Type) { *this = other; }

protected:
QStyleOptionSlider(int version);
};



# 729 "/usr/share/qt4/include/QtGui/qstyleoption.h"
class  QStyleOptionSpinBox : public QStyleOptionComplex
{
public:
enum StyleOptionType { Type = SO_SpinBox };
enum StyleOptionVersion { Version = 1 };

QAbstractSpinBox::ButtonSymbols buttonSymbols;
QAbstractSpinBox::StepEnabled stepEnabled;
bool frame;

QStyleOptionSpinBox();
QStyleOptionSpinBox(const QStyleOptionSpinBox &other) : QStyleOptionComplex(Version, Type) { *this = other; }

protected:
QStyleOptionSpinBox(int version);
};


# 747 "/usr/share/qt4/include/QtGui/qstyleoption.h"
class  QStyleOptionQ3ListView : public QStyleOptionComplex
{
public:
enum StyleOptionType { Type = SO_Q3ListView };
enum StyleOptionVersion { Version = 1 };

QList<QStyleOptionQ3ListViewItem> items;
QPalette viewportPalette;
QPalette::ColorRole viewportBGRole;
int sortColumn;
int itemMargin;
int treeStepSize;
bool rootIsDecorated;

QStyleOptionQ3ListView();
QStyleOptionQ3ListView(const QStyleOptionQ3ListView &other) : QStyleOptionComplex(Version, Type) { *this = other; }

protected:
QStyleOptionQ3ListView(int version);
};

class  QStyleOptionToolButton : public QStyleOptionComplex
{
public:
enum StyleOptionType { Type = SO_ToolButton };
enum StyleOptionVersion { Version = 1 };

enum ToolButtonFeature { None = 0x00, Arrow = 0x01, Menu = 0x04, MenuButtonPopup = Menu, PopupDelay = 0x08,
HasMenu = 0x10 };
typedef QFlags<ToolButtonFeature> ToolButtonFeatures;

ToolButtonFeatures features;
QIcon icon;
QSize iconSize;
QString text;
Qt::ArrowType arrowType;
Qt::ToolButtonStyle toolButtonStyle;
QPoint pos;
QFont font;

QStyleOptionToolButton();
QStyleOptionToolButton(const QStyleOptionToolButton &other) : QStyleOptionComplex(Version, Type) { *this = other; }

protected:
QStyleOptionToolButton(int version);
};

inline QFlags<QStyleOptionToolButton::ToolButtonFeatures::enum_type> operator|(QStyleOptionToolButton::ToolButtonFeatures::enum_type f1, QStyleOptionToolButton::ToolButtonFeatures::enum_type f2) { return QFlags<QStyleOptionToolButton::ToolButtonFeatures::enum_type>(f1) | f2; } inline QFlags<QStyleOptionToolButton::ToolButtonFeatures::enum_type> operator|(QStyleOptionToolButton::ToolButtonFeatures::enum_type f1, QFlags<QStyleOptionToolButton::ToolButtonFeatures::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QStyleOptionToolButton::ToolButtonFeatures::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class  QStyleOptionComboBox : public QStyleOptionComplex
{
public:
enum StyleOptionType { Type = SO_ComboBox };
enum StyleOptionVersion { Version = 1 };

bool editable;
QRect popupRect;
bool frame;
QString currentText;
QIcon currentIcon;
QSize iconSize;

QStyleOptionComboBox();
QStyleOptionComboBox(const QStyleOptionComboBox &other) : QStyleOptionComplex(Version, Type) { *this = other; }

protected:
QStyleOptionComboBox(int version);
};

class  QStyleOptionTitleBar : public QStyleOptionComplex
{
public:
enum StyleOptionType { Type = SO_TitleBar };
enum StyleOptionVersion { Version = 1 };

QString text;
QIcon icon;
int titleBarState;
Qt::WindowFlags titleBarFlags;

QStyleOptionTitleBar();
QStyleOptionTitleBar(const QStyleOptionTitleBar &other) : QStyleOptionComplex(Version, Type) { *this = other; }

protected:
QStyleOptionTitleBar(int version);
};

class  QStyleOptionGroupBox : public QStyleOptionComplex
{
public:
enum StyleOptionType { Type = SO_GroupBox };
enum StyleOptionVersion { Version = 1 };

QStyleOptionFrameV2::FrameFeatures features;
QString text;
Qt::Alignment textAlignment;
QColor textColor;
int lineWidth;
int midLineWidth;

QStyleOptionGroupBox();
QStyleOptionGroupBox(const QStyleOptionGroupBox &other) : QStyleOptionComplex(Version, Type) { *this = other; }
protected:
QStyleOptionGroupBox(int version);
};

class  QStyleOptionSizeGrip : public QStyleOptionComplex
{
public:
enum StyleOptionType { Type = SO_SizeGrip };
enum StyleOptionVersion { Version = 1 };

Qt::Corner corner;

QStyleOptionSizeGrip();
QStyleOptionSizeGrip(const QStyleOptionSizeGrip &other) : QStyleOptionComplex(Version, Type) { *this = other; }
protected:
QStyleOptionSizeGrip(int version);
};

class  QStyleOptionGraphicsItem : public QStyleOption
{
public:
enum StyleOptionType { Type = SO_GraphicsItem };
enum StyleOptionVersion { Version = 1 };

QRectF exposedRect;
QMatrix matrix;
qreal levelOfDetail;

QStyleOptionGraphicsItem();
QStyleOptionGraphicsItem(const QStyleOptionGraphicsItem &other) : QStyleOption(Version, Type) { *this = other; }
static qreal levelOfDetailFromTransform(const QTransform &worldTransform);
protected:
QStyleOptionGraphicsItem(int version);
};

template <typename T>
T qstyleoption_cast(const QStyleOption *opt)
{
if (opt && opt->version >= static_cast<T>(0)->Version && (opt->type == static_cast<T>(0)->Type
|| int(static_cast<T>(0)->Type) == QStyleOption::SO_Default
|| (int(static_cast<T>(0)->Type) == QStyleOption::SO_Complex
&& opt->type > QStyleOption::SO_Complex)))
return static_cast<T>(opt);
return 0;
}

template <typename T>
T qstyleoption_cast(QStyleOption *opt)
{
if (opt && opt->version >= static_cast<T>(0)->Version && (opt->type == static_cast<T>(0)->Type
|| int(static_cast<T>(0)->Type) == QStyleOption::SO_Default
|| (int(static_cast<T>(0)->Type) == QStyleOption::SO_Complex
&& opt->type > QStyleOption::SO_Complex)))
return static_cast<T>(opt);
return 0;
}


class  QStyleHintReturn {
public:
enum HintReturnType {
SH_Default=0xf000, SH_Mask, SH_Variant
};

enum StyleOptionType { Type = SH_Default };
enum StyleOptionVersion { Version = 1 };

QStyleHintReturn(int version = QStyleOption::Version, int type = SH_Default);
~QStyleHintReturn();

int version;
int type;
};

class  QStyleHintReturnMask : public QStyleHintReturn {
public:
enum StyleOptionType { Type = SH_Mask };
enum StyleOptionVersion { Version = 1 };

QStyleHintReturnMask();

QRegion region;
};

class  QStyleHintReturnVariant : public QStyleHintReturn {
public:
enum StyleOptionType { Type = SH_Variant };
enum StyleOptionVersion { Version = 1 };

QStyleHintReturnVariant();

QVariant variant;
};

template <typename T>
T qstyleoption_cast(const QStyleHintReturn *hint)
{
if (hint && hint->version <= static_cast<T>(0)->Version &&
(hint->type == static_cast<T>(0)->Type || int(static_cast<T>(0)->Type) == QStyleHintReturn::SH_Default))
return static_cast<T>(hint);
return 0;
}

template <typename T>
T qstyleoption_cast(QStyleHintReturn *hint)
{
if (hint && hint->version <= static_cast<T>(0)->Version &&
(hint->type == static_cast<T>(0)->Type || int(static_cast<T>(0)->Type) == QStyleHintReturn::SH_Default))
return static_cast<T>(hint);
return 0;
}

 QDebug operator<<(QDebug debug, const QStyleOption::OptionType &optionType);
 QDebug operator<<(QDebug debug, const QStyleOption &option);






# 46 "/usr/share/qt4/include/QtGui/qabstractitemdelegate.h"


# 48 "/usr/share/qt4/include/QtGui/qabstractitemdelegate.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qabstractitemdelegate.h"
class QPainter;
class QModelIndex;
class QAbstractItemModel;
class QAbstractItemView;
class QHelpEvent;

class  QAbstractItemDelegate : public QObject
{
Q_OBJECT

public:

enum EndEditHint {
NoHint,
EditNextItem,
EditPreviousItem,
SubmitModelCache,
RevertModelCache
};

explicit QAbstractItemDelegate(QObject *parent = 0);
virtual ~QAbstractItemDelegate();


virtual void paint(QPainter *painter,
const QStyleOptionViewItem &option,
const QModelIndex &index) const = 0;

virtual QSize sizeHint(const QStyleOptionViewItem &option,
const QModelIndex &index) const = 0;


virtual QWidget *createEditor(QWidget *parent,
const QStyleOptionViewItem &option,
const QModelIndex &index) const;

virtual void setEditorData(QWidget *editor, const QModelIndex &index) const;

virtual void setModelData(QWidget *editor,
QAbstractItemModel *model,
const QModelIndex &index) const;

virtual void updateEditorGeometry(QWidget *editor,
const QStyleOptionViewItem &option,
const QModelIndex &index) const;


virtual bool editorEvent(QEvent *event,
QAbstractItemModel *model,
const QStyleOptionViewItem &option,
const QModelIndex &index);

static QString elidedText(const QFontMetrics &fontMetrics, int width,
Qt::TextElideMode mode, const QString &text);

public slots:
bool helpEvent(QHelpEvent *event,
QAbstractItemView *view,
const QStyleOptionViewItem &option,
const QModelIndex &index);

signals:
void commitData(QWidget *editor);
void closeEditor(QWidget *editor, QAbstractItemDelegate::EndEditHint hint = NoHint);
void sizeHintChanged(const QModelIndex &);

protected:
QAbstractItemDelegate(QObjectPrivate &, QObject *parent = 0);
private:
QAbstractItemDelegate(const QAbstractItemDelegate &); QAbstractItemDelegate &operator=(const QAbstractItemDelegate &);
};



# 130 "/usr/share/qt4/include/QtGui/qabstractitemdelegate.h"





# 40 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qabstractitemview.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"












































# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 45 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"


# 47 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"
class QMargins;
class QScrollBar;
class QAbstractScrollAreaPrivate;

class  QAbstractScrollArea : public QFrame
{
Q_OBJECT
Q_PROPERTY(Qt::ScrollBarPolicy verticalScrollBarPolicy READ verticalScrollBarPolicy WRITE setVerticalScrollBarPolicy)
Q_PROPERTY(Qt::ScrollBarPolicy horizontalScrollBarPolicy READ horizontalScrollBarPolicy WRITE setHorizontalScrollBarPolicy)

public:
explicit QAbstractScrollArea(QWidget* parent=0);
~QAbstractScrollArea();

Qt::ScrollBarPolicy verticalScrollBarPolicy() const;
void setVerticalScrollBarPolicy(Qt::ScrollBarPolicy);
QScrollBar *verticalScrollBar() const;
void setVerticalScrollBar(QScrollBar *scrollbar);

Qt::ScrollBarPolicy horizontalScrollBarPolicy() const;
void setHorizontalScrollBarPolicy(Qt::ScrollBarPolicy);
QScrollBar *horizontalScrollBar() const;
void setHorizontalScrollBar(QScrollBar *scrollbar);

QWidget *cornerWidget() const;
void setCornerWidget(QWidget *widget);

void addScrollBarWidget(QWidget *widget, Qt::Alignment alignment);
QWidgetList scrollBarWidgets(Qt::Alignment alignment);

QWidget *viewport() const;
void setViewport(QWidget *widget);
QSize maximumViewportSize() const;

QSize minimumSizeHint() const;

QSize sizeHint() const;

protected slots:
void setupViewport(QWidget *viewport);

protected:
QAbstractScrollArea(QAbstractScrollAreaPrivate &dd, QWidget *parent = 0);
void setViewportMargins(int left, int top, int right, int bottom);
void setViewportMargins(const QMargins &margins);

bool event(QEvent *);
virtual bool viewportEvent(QEvent *);

void resizeEvent(QResizeEvent *);
void paintEvent(QPaintEvent *);
void mousePressEvent(QMouseEvent *);
void mouseReleaseEvent(QMouseEvent *);
void mouseDoubleClickEvent(QMouseEvent *);
void mouseMoveEvent(QMouseEvent *);

# 111 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"
void wheelEvent(QWheelEvent *);


# 114 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"
void contextMenuEvent(QContextMenuEvent *);


# 117 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"
void dragEnterEvent(QDragEnterEvent *);
void dragMoveEvent(QDragMoveEvent *);
void dragLeaveEvent(QDragLeaveEvent *);
void dropEvent(QDropEvent *);


# 123 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"
void keyPressEvent(QKeyEvent *);

virtual void scrollContentsBy(int dx, int dy);

private:
inline QAbstractScrollAreaPrivate* d_func() { return reinterpret_cast<QAbstractScrollAreaPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractScrollAreaPrivate* d_func() const { return reinterpret_cast<const QAbstractScrollAreaPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractScrollAreaPrivate;
QAbstractScrollArea(const QAbstractScrollArea &); QAbstractScrollArea &operator=(const QAbstractScrollArea &);




friend class QStyleSheetStyle;
friend class QWidgetPrivate;
};



# 140 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"





# 45 "/usr/share/qt4/include/QtGui/qabstractitemview.h"

# 1 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"


























































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qabstractitemview.h"

# 1 "/usr/share/qt4/include/QtGui/qitemselectionmodel.h"












































# 1 "/usr/share/qt4/include/QtCore/qset.h"














































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qitemselectionmodel.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qitemselectionmodel.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qitemselectionmodel.h"

# 1 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"


























































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qitemselectionmodel.h"


# 50 "/usr/share/qt4/include/QtGui/qitemselectionmodel.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 58 "/usr/share/qt4/include/QtGui/qitemselectionmodel.h"
class  QItemSelectionRange
{

public:
inline QItemSelectionRange() {}
inline QItemSelectionRange(const QItemSelectionRange &other)
: tl(other.tl), br(other.br) {}
inline QItemSelectionRange(const QModelIndex &topLeft, const QModelIndex &bottomRight);
explicit inline QItemSelectionRange(const QModelIndex &index)
{ tl = index; br = tl; }

inline int top() const { return tl.row(); }
inline int left() const { return tl.column(); }
inline int bottom() const { return br.row(); }
inline int right() const { return br.column(); }
inline int width() const { return br.column() - tl.column() + 1; }
inline int height() const { return br.row() - tl.row() + 1; }

inline QModelIndex topLeft() const { return QModelIndex(tl); }
inline QModelIndex bottomRight() const { return QModelIndex(br); }
inline QModelIndex parent() const { return tl.parent(); }
inline const QAbstractItemModel *model() const { return tl.model(); }

inline bool contains(const QModelIndex &index) const
{
return (parent() == index.parent()
&& tl.row() <= index.row() && tl.column() <= index.column()
&& br.row() >= index.row() && br.column() >= index.column());
}

inline bool contains(int row, int column, const QModelIndex &parentIndex) const
{
return (parent() == parentIndex
&& tl.row() <= row && tl.column() <= column
&& br.row() >= row && br.column() >= column);
}

bool intersects(const QItemSelectionRange &other) const;
QItemSelectionRange intersect(const QItemSelectionRange &other) const; 
inline QItemSelectionRange intersected(const QItemSelectionRange &other) const
{ return intersect(other); }

inline bool operator==(const QItemSelectionRange &other) const
{ return (tl == other.tl && br == other.br); }
inline bool operator!=(const QItemSelectionRange &other) const
{ return !operator==(other); }

inline bool isValid() const
{
return (tl.isValid() && br.isValid() && tl.parent() == br.parent()
&& top() <= bottom() && left() <= right());
}

QModelIndexList indexes() const;

private:
QPersistentModelIndex tl, br;
};
template <> class QTypeInfo<QItemSelectionRange > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QItemSelectionRange)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QItemSelectionRange"; } };

inline QItemSelectionRange::QItemSelectionRange(const QModelIndex &atopLeft,
const QModelIndex &abottomRight)
{ tl = atopLeft; br = abottomRight; }

class QItemSelection;
class QItemSelectionModelPrivate;

class  QItemSelectionModel : public QObject
{
Q_OBJECT
inline QItemSelectionModelPrivate* d_func() { return reinterpret_cast<QItemSelectionModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QItemSelectionModelPrivate* d_func() const { return reinterpret_cast<const QItemSelectionModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QItemSelectionModelPrivate;


public:

enum SelectionFlag {
NoUpdate = 0x0000,
Clear = 0x0001,
Select = 0x0002,
Deselect = 0x0004,
Toggle = 0x0008,
Current = 0x0010,
Rows = 0x0020,
Columns = 0x0040,
SelectCurrent = Select | Current,
ToggleCurrent = Toggle | Current,
ClearAndSelect = Clear | Select
};

typedef QFlags<SelectionFlag> SelectionFlags;

explicit QItemSelectionModel(QAbstractItemModel *model);
explicit QItemSelectionModel(QAbstractItemModel *model, QObject *parent);
virtual ~QItemSelectionModel();

QModelIndex currentIndex() const;

bool isSelected(const QModelIndex &index) const;
bool isRowSelected(int row, const QModelIndex &parent) const;
bool isColumnSelected(int column, const QModelIndex &parent) const;

bool rowIntersectsSelection(int row, const QModelIndex &parent) const;
bool columnIntersectsSelection(int column, const QModelIndex &parent) const;

bool hasSelection() const;

QModelIndexList selectedIndexes() const;
QModelIndexList selectedRows(int column = 0) const;
QModelIndexList selectedColumns(int row = 0) const;
const QItemSelection selection() const;

const QAbstractItemModel *model() const;

public slots:
void setCurrentIndex(const QModelIndex &index, QItemSelectionModel::SelectionFlags command);
virtual void select(const QModelIndex &index, QItemSelectionModel::SelectionFlags command);
virtual void select(const QItemSelection &selection, QItemSelectionModel::SelectionFlags command);
virtual void clear();
virtual void reset();

void clearSelection();

signals:
void selectionChanged(const QItemSelection &selected, const QItemSelection &deselected);
void currentChanged(const QModelIndex &current, const QModelIndex &previous);
void currentRowChanged(const QModelIndex &current, const QModelIndex &previous);
void currentColumnChanged(const QModelIndex &current, const QModelIndex &previous);

protected:
QItemSelectionModel(QItemSelectionModelPrivate &dd, QAbstractItemModel *model);
void emitSelectionChanged(const QItemSelection &newSelection, const QItemSelection &oldSelection);

private:
QItemSelectionModel(const QItemSelectionModel &); QItemSelectionModel &operator=(const QItemSelectionModel &);






};

inline QFlags<QItemSelectionModel::SelectionFlags::enum_type> operator|(QItemSelectionModel::SelectionFlags::enum_type f1, QItemSelectionModel::SelectionFlags::enum_type f2) { return QFlags<QItemSelectionModel::SelectionFlags::enum_type>(f1) | f2; } inline QFlags<QItemSelectionModel::SelectionFlags::enum_type> operator|(QItemSelectionModel::SelectionFlags::enum_type f1, QFlags<QItemSelectionModel::SelectionFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QItemSelectionModel::SelectionFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


inline uint qHash(const QItemSelectionRange &) { return 0; }

class  QItemSelection : public QList<QItemSelectionRange>
{
public:
QItemSelection() {}
QItemSelection(const QModelIndex &topLeft, const QModelIndex &bottomRight);
void select(const QModelIndex &topLeft, const QModelIndex &bottomRight);
bool contains(const QModelIndex &index) const;
QModelIndexList indexes() const;
void merge(const QItemSelection &other, QItemSelectionModel::SelectionFlags command);
static void split(const QItemSelectionRange &range,
const QItemSelectionRange &other,
QItemSelection *result);
};


# 220 "/usr/share/qt4/include/QtGui/qitemselectionmodel.h"
 QDebug operator<<(QDebug, const QItemSelectionRange &);




# 225 "/usr/share/qt4/include/QtGui/qitemselectionmodel.h"





# 47 "/usr/share/qt4/include/QtGui/qabstractitemview.h"

# 1 "/usr/share/qt4/include/QtGui/qabstractitemdelegate.h"






































































































































# 48 "/usr/share/qt4/include/QtGui/qabstractitemview.h"


# 50 "/usr/share/qt4/include/QtGui/qabstractitemview.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 58 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
class QMenu;
class QDrag;
class QEvent;
class QAbstractItemViewPrivate;

class  QAbstractItemView : public QAbstractScrollArea
{
Q_OBJECT
Q_ENUMS(SelectionMode SelectionBehavior ScrollHint ScrollMode DragDropMode)

Q_PROPERTY(bool autoScroll READ hasAutoScroll WRITE setAutoScroll)
Q_PROPERTY(int autoScrollMargin READ autoScrollMargin WRITE setAutoScrollMargin)
Q_PROPERTY(EditTriggers editTriggers READ editTriggers WRITE setEditTriggers)
Q_PROPERTY(bool tabKeyNavigation READ tabKeyNavigation WRITE setTabKeyNavigation)

# 73 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
Q_PROPERTY(bool showDropIndicator READ showDropIndicator WRITE setDropIndicatorShown)
Q_PROPERTY(bool dragEnabled READ dragEnabled WRITE setDragEnabled)
Q_PROPERTY(bool dragDropOverwriteMode READ dragDropOverwriteMode WRITE setDragDropOverwriteMode)
Q_PROPERTY(DragDropMode dragDropMode READ dragDropMode WRITE setDragDropMode)
Q_PROPERTY(Qt::DropAction defaultDropAction READ defaultDropAction WRITE setDefaultDropAction)

# 79 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
Q_PROPERTY(bool alternatingRowColors READ alternatingRowColors WRITE setAlternatingRowColors)
Q_PROPERTY(SelectionMode selectionMode READ selectionMode WRITE setSelectionMode)
Q_PROPERTY(SelectionBehavior selectionBehavior READ selectionBehavior WRITE setSelectionBehavior)
Q_PROPERTY(QSize iconSize READ iconSize WRITE setIconSize)
Q_PROPERTY(Qt::TextElideMode textElideMode READ textElideMode WRITE setTextElideMode)
Q_PROPERTY(ScrollMode verticalScrollMode READ verticalScrollMode WRITE setVerticalScrollMode)
Q_PROPERTY(ScrollMode horizontalScrollMode READ horizontalScrollMode WRITE setHorizontalScrollMode)

public:
enum SelectionMode {
NoSelection,
SingleSelection,
MultiSelection,
ExtendedSelection,
ContiguousSelection
};

enum SelectionBehavior {
SelectItems,
SelectRows,
SelectColumns
};

enum ScrollHint {
EnsureVisible,
PositionAtTop,
PositionAtBottom,
PositionAtCenter
};

enum EditTrigger {
NoEditTriggers = 0,
CurrentChanged = 1,
DoubleClicked = 2,
SelectedClicked = 4,
EditKeyPressed = 8,
AnyKeyPressed = 16,
AllEditTriggers = 31
};

typedef QFlags<EditTrigger> EditTriggers;

enum ScrollMode {
ScrollPerItem,
ScrollPerPixel
};

explicit QAbstractItemView(QWidget *parent = 0);
~QAbstractItemView();

virtual void setModel(QAbstractItemModel *model);
QAbstractItemModel *model() const;

virtual void setSelectionModel(QItemSelectionModel *selectionModel);
QItemSelectionModel *selectionModel() const;

void setItemDelegate(QAbstractItemDelegate *delegate);
QAbstractItemDelegate *itemDelegate() const;

void setSelectionMode(QAbstractItemView::SelectionMode mode);
QAbstractItemView::SelectionMode selectionMode() const;

void setSelectionBehavior(QAbstractItemView::SelectionBehavior behavior);
QAbstractItemView::SelectionBehavior selectionBehavior() const;

QModelIndex currentIndex() const;
QModelIndex rootIndex() const;

void setEditTriggers(EditTriggers triggers);
EditTriggers editTriggers() const;

void setVerticalScrollMode(ScrollMode mode);
ScrollMode verticalScrollMode() const;

void setHorizontalScrollMode(ScrollMode mode);
ScrollMode horizontalScrollMode() const;

void setAutoScroll(bool enable);
bool hasAutoScroll() const;

void setAutoScrollMargin(int margin);
int autoScrollMargin() const;

void setTabKeyNavigation(bool enable);
bool tabKeyNavigation() const;


# 166 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
void setDropIndicatorShown(bool enable);
bool showDropIndicator() const;

void setDragEnabled(bool enable);
bool dragEnabled() const;

void setDragDropOverwriteMode(bool overwrite);
bool dragDropOverwriteMode() const;

enum DragDropMode {
NoDragDrop,
DragOnly,
DropOnly,
DragDrop,
InternalMove
};

void setDragDropMode(DragDropMode behavior);
DragDropMode dragDropMode() const;

void setDefaultDropAction(Qt::DropAction dropAction);
Qt::DropAction defaultDropAction() const;


# 190 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
void setAlternatingRowColors(bool enable);
bool alternatingRowColors() const;

void setIconSize(const QSize &size);
QSize iconSize() const;

void setTextElideMode(Qt::TextElideMode mode);
Qt::TextElideMode textElideMode() const;

virtual void keyboardSearch(const QString &search);

virtual QRect visualRect(const QModelIndex &index) const = 0;
virtual void scrollTo(const QModelIndex &index, ScrollHint hint = EnsureVisible) = 0;
virtual QModelIndex indexAt(const QPoint &point) const = 0;

QSize sizeHintForIndex(const QModelIndex &index) const;
virtual int sizeHintForRow(int row) const;
virtual int sizeHintForColumn(int column) const;

void openPersistentEditor(const QModelIndex &index);
void closePersistentEditor(const QModelIndex &index);

void setIndexWidget(const QModelIndex &index, QWidget *widget);
QWidget *indexWidget(const QModelIndex &index) const;

void setItemDelegateForRow(int row, QAbstractItemDelegate *delegate);
QAbstractItemDelegate *itemDelegateForRow(int row) const;

void setItemDelegateForColumn(int column, QAbstractItemDelegate *delegate);
QAbstractItemDelegate *itemDelegateForColumn(int column) const;

QAbstractItemDelegate *itemDelegate(const QModelIndex &index) const;

virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const;


# 226 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
inline void update() { QAbstractScrollArea::update(); }




# 231 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
public slots:
virtual void reset();
virtual void setRootIndex(const QModelIndex &index);
virtual void doItemsLayout();
virtual void selectAll();
void edit(const QModelIndex &index);
void clearSelection();
void setCurrentIndex(const QModelIndex &index);
void scrollToTop();
void scrollToBottom();
void update(const QModelIndex &index);

protected slots:
virtual void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
virtual void rowsInserted(const QModelIndex &parent, int start, int end);
virtual void rowsAboutToBeRemoved(const QModelIndex &parent, int start, int end);
virtual void selectionChanged(const QItemSelection &selected, const QItemSelection &deselected);
virtual void currentChanged(const QModelIndex &current, const QModelIndex &previous);
virtual void updateEditorData();
virtual void updateEditorGeometries();
virtual void updateGeometries();
virtual void verticalScrollbarAction(int action);
virtual void horizontalScrollbarAction(int action);
virtual void verticalScrollbarValueChanged(int value);
virtual void horizontalScrollbarValueChanged(int value);
virtual void closeEditor(QWidget *editor, QAbstractItemDelegate::EndEditHint hint);
virtual void commitData(QWidget *editor);
virtual void editorDestroyed(QObject *editor);

signals:
void pressed(const QModelIndex &index);
void clicked(const QModelIndex &index);
void doubleClicked(const QModelIndex &index);

void activated(const QModelIndex &index);
void entered(const QModelIndex &index);
void viewportEntered();

protected:
QAbstractItemView(QAbstractItemViewPrivate &, QWidget *parent = 0);

void setHorizontalStepsPerItem(int steps);
int horizontalStepsPerItem() const;
void setVerticalStepsPerItem(int steps);
int verticalStepsPerItem() const;

enum CursorAction { MoveUp, MoveDown, MoveLeft, MoveRight,
MoveHome, MoveEnd, MovePageUp, MovePageDown,
MoveNext, MovePrevious };
virtual QModelIndex moveCursor(CursorAction cursorAction,
Qt::KeyboardModifiers modifiers) = 0;

virtual int horizontalOffset() const = 0;
virtual int verticalOffset() const = 0;

virtual bool isIndexHidden(const QModelIndex &index) const = 0;

virtual void setSelection(const QRect &rect, QItemSelectionModel::SelectionFlags command) = 0;
virtual QRegion visualRegionForSelection(const QItemSelection &selection) const = 0;
virtual QModelIndexList selectedIndexes() const;

virtual bool edit(const QModelIndex &index, EditTrigger trigger, QEvent *event);

virtual QItemSelectionModel::SelectionFlags selectionCommand(const QModelIndex &index,
const QEvent *event = 0) const;


# 298 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
virtual void startDrag(Qt::DropActions supportedActions);


# 301 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
virtual QStyleOptionViewItem viewOptions() const;

enum State {
NoState,
DraggingState,
DragSelectingState,
EditingState,
ExpandingState,
CollapsingState,
AnimatingState
};

State state() const;
void setState(State state);

void scheduleDelayedItemsLayout();
void executeDelayedItemsLayout();

void setDirtyRegion(const QRegion &region);
void scrollDirtyRegion(int dx, int dy);
QPoint dirtyRegionOffset() const;

void startAutoScroll();
void stopAutoScroll();
void doAutoScroll();

bool focusNextPrevChild(bool next);
bool event(QEvent *event);
bool viewportEvent(QEvent *event);
void mousePressEvent(QMouseEvent *event);
void mouseMoveEvent(QMouseEvent *event);
void mouseReleaseEvent(QMouseEvent *event);
void mouseDoubleClickEvent(QMouseEvent *event);

# 335 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
void dragEnterEvent(QDragEnterEvent *event);
void dragMoveEvent(QDragMoveEvent *event);
void dragLeaveEvent(QDragLeaveEvent *event);
void dropEvent(QDropEvent *event);

# 340 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
void focusInEvent(QFocusEvent *event);
void focusOutEvent(QFocusEvent *event);
void keyPressEvent(QKeyEvent *event);
void resizeEvent(QResizeEvent *event);
void timerEvent(QTimerEvent *event);
void inputMethodEvent(QInputMethodEvent *event);


# 348 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
enum DropIndicatorPosition { OnItem, AboveItem, BelowItem, OnViewport };
DropIndicatorPosition dropIndicatorPosition() const;


# 352 "/usr/share/qt4/include/QtGui/qabstractitemview.h"
private:
inline QAbstractItemViewPrivate* d_func() { return reinterpret_cast<QAbstractItemViewPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractItemViewPrivate* d_func() const { return reinterpret_cast<const QAbstractItemViewPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractItemViewPrivate;
QAbstractItemView(const QAbstractItemView &); QAbstractItemView &operator=(const QAbstractItemView &);








friend class QTreeViewPrivate; 
friend class QAccessibleItemRow;
friend class QListModeViewBase;
friend class QListViewPrivate; 
};

inline QFlags<QAbstractItemView::EditTriggers::enum_type> operator|(QAbstractItemView::EditTriggers::enum_type f1, QAbstractItemView::EditTriggers::enum_type f2) { return QFlags<QAbstractItemView::EditTriggers::enum_type>(f1) | f2; } inline QFlags<QAbstractItemView::EditTriggers::enum_type> operator|(QAbstractItemView::EditTriggers::enum_type f1, QFlags<QAbstractItemView::EditTriggers::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QAbstractItemView::EditTriggers::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 373 "/usr/share/qt4/include/QtGui/qabstractitemview.h"





# 41 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qabstractproxymodel.h"












































# 1 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"


























































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qabstractproxymodel.h"


# 47 "/usr/share/qt4/include/QtGui/qabstractproxymodel.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qabstractproxymodel.h"
class QAbstractProxyModelPrivate;
class QItemSelection;

class  QAbstractProxyModel : public QAbstractItemModel
{
Q_OBJECT

public:
QAbstractProxyModel(QObject *parent = 0);
~QAbstractProxyModel();

virtual void setSourceModel(QAbstractItemModel *sourceModel);
QAbstractItemModel *sourceModel() const;

virtual QModelIndex mapToSource(const QModelIndex &proxyIndex) const = 0;
virtual QModelIndex mapFromSource(const QModelIndex &sourceIndex) const = 0;

virtual QItemSelection mapSelectionToSource(const QItemSelection &selection) const;
virtual QItemSelection mapSelectionFromSource(const QItemSelection &selection) const;

bool submit();
void revert();

QVariant data(const QModelIndex &proxyIndex, int role = Qt::DisplayRole) const;
QVariant headerData(int section, Qt::Orientation orientation, int role) const;
QMap<int, QVariant> itemData(const QModelIndex &index) const;
Qt::ItemFlags flags(const QModelIndex &index) const;

bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);
bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value, int role = Qt::EditRole);

protected:
QAbstractProxyModel(QAbstractProxyModelPrivate &, QObject *parent);

private:
inline QAbstractProxyModelPrivate* d_func() { return reinterpret_cast<QAbstractProxyModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractProxyModelPrivate* d_func() const { return reinterpret_cast<const QAbstractProxyModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractProxyModelPrivate;
QAbstractProxyModel(const QAbstractProxyModel &); QAbstractProxyModel &operator=(const QAbstractProxyModel &);

};



# 97 "/usr/share/qt4/include/QtGui/qabstractproxymodel.h"





# 42 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcolumnview.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractitemview.h"

























































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qcolumnview.h"


# 47 "/usr/share/qt4/include/QtGui/qcolumnview.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qcolumnview.h"
class QColumnViewPrivate;

class  QColumnView : public QAbstractItemView {

Q_OBJECT
Q_PROPERTY(bool resizeGripsVisible READ resizeGripsVisible WRITE setResizeGripsVisible)

signals:
void updatePreviewWidget(const QModelIndex &index);

public:
explicit QColumnView(QWidget *parent = 0);
~QColumnView();


QModelIndex indexAt(const QPoint &point) const;
void scrollTo(const QModelIndex &index, ScrollHint hint = EnsureVisible);
QSize sizeHint() const;
QRect visualRect(const QModelIndex &index) const;
void setModel(QAbstractItemModel *model);
void setSelectionModel(QItemSelectionModel * selectionModel);
void setRootIndex(const QModelIndex &index);
void selectAll();


void setResizeGripsVisible(bool visible);
bool resizeGripsVisible() const;

QWidget *previewWidget() const;
void setPreviewWidget(QWidget *widget);

void setColumnWidths(const QList<int> &list);
QList<int> columnWidths() const;

protected:
QColumnView(QColumnViewPrivate &dd, QWidget *parent = 0);


bool isIndexHidden(const QModelIndex &index) const;
QModelIndex moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers);
void resizeEvent(QResizeEvent *event);
void setSelection(const QRect & rect, QItemSelectionModel::SelectionFlags command);
QRegion visualRegionForSelection(const QItemSelection &selection) const;
int horizontalOffset() const;
int verticalOffset() const;
void rowsInserted(const QModelIndex &parent, int start, int end);
void currentChanged(const QModelIndex &current, const QModelIndex &previous);


void scrollContentsBy(int dx, int dy);
virtual QAbstractItemView* createColumn(const QModelIndex &rootIndex);
void initializeColumn(QAbstractItemView *column) const;

private:
inline QColumnViewPrivate* d_func() { return reinterpret_cast<QColumnViewPrivate *>(qGetPtrHelper(d_ptr)); } inline const QColumnViewPrivate* d_func() const { return reinterpret_cast<const QColumnViewPrivate *>(qGetPtrHelper(d_ptr)); } friend class QColumnViewPrivate;
QColumnView(const QColumnView &); QColumnView &operator=(const QColumnView &);



};



# 118 "/usr/share/qt4/include/QtGui/qcolumnview.h"






# 43 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qdatawidgetmapper.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qdatawidgetmapper.h"




# 49 "/usr/share/qt4/include/QtGui/qdatawidgetmapper.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QAbstractItemDelegate;
class QAbstractItemModel;
class QModelIndex;
class QDataWidgetMapperPrivate;

class  QDataWidgetMapper: public QObject
{
Q_OBJECT

Q_ENUMS(SubmitPolicy)
Q_PROPERTY(int currentIndex READ currentIndex WRITE setCurrentIndex NOTIFY currentIndexChanged)
Q_PROPERTY(Qt::Orientation orientation READ orientation WRITE setOrientation)
Q_PROPERTY(SubmitPolicy submitPolicy READ submitPolicy WRITE setSubmitPolicy)

public:
QDataWidgetMapper(QObject *parent = 0);
~QDataWidgetMapper();

void setModel(QAbstractItemModel *model);
QAbstractItemModel *model() const;

void setItemDelegate(QAbstractItemDelegate *delegate);
QAbstractItemDelegate *itemDelegate() const;

void setRootIndex(const QModelIndex &index);
QModelIndex rootIndex() const;

void setOrientation(Qt::Orientation aOrientation);
Qt::Orientation orientation() const;

enum SubmitPolicy { AutoSubmit, ManualSubmit };
void setSubmitPolicy(SubmitPolicy policy);
SubmitPolicy submitPolicy() const;

void addMapping(QWidget *widget, int section);
void addMapping(QWidget *widget, int section, const QByteArray &propertyName);
void removeMapping(QWidget *widget);
int mappedSection(QWidget *widget) const;
QByteArray mappedPropertyName(QWidget *widget) const;
QWidget *mappedWidgetAt(int section) const;
void clearMapping();

int currentIndex() const;

public slots:
void revert();
bool submit();

void toFirst();
void toLast();
void toNext();
void toPrevious();
virtual void setCurrentIndex(int index);
void setCurrentModelIndex(const QModelIndex &index);

signals:
void currentIndexChanged(int index);

private:
inline QDataWidgetMapperPrivate* d_func() { return reinterpret_cast<QDataWidgetMapperPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDataWidgetMapperPrivate* d_func() const { return reinterpret_cast<const QDataWidgetMapperPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDataWidgetMapperPrivate;
QDataWidgetMapper(const QDataWidgetMapper &); QDataWidgetMapper &operator=(const QDataWidgetMapper &);




};








# 44 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qdirmodel.h"












































# 1 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"


























































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qdirmodel.h"

# 1 "/usr/share/qt4/include/QtCore/qdir.h"









































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qdirmodel.h"

# 1 "/usr/share/qt4/include/QtGui/qfileiconprovider.h"












































# 1 "/usr/share/qt4/include/QtCore/qfileinfo.h"




























































































































































































# 45 "/usr/share/qt4/include/QtGui/qfileiconprovider.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 46 "/usr/share/qt4/include/QtGui/qfileiconprovider.h"

# 1 "/usr/share/qt4/include/QtGui/qicon.h"


























































































































































# 47 "/usr/share/qt4/include/QtGui/qfileiconprovider.h"


# 49 "/usr/share/qt4/include/QtGui/qfileiconprovider.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 57 "/usr/share/qt4/include/QtGui/qfileiconprovider.h"
class QFileIconProviderPrivate;

class  QFileIconProvider
{
public:
QFileIconProvider();
virtual ~QFileIconProvider();
enum IconType { Computer, Desktop, Trashcan, Network, Drive, Folder, File };
virtual QIcon icon(IconType type) const;
virtual QIcon icon(const QFileInfo &info) const;
virtual QString type(const QFileInfo &info) const;

private:
inline QFileIconProviderPrivate* d_func() { return reinterpret_cast<QFileIconProviderPrivate *>(qGetPtrHelper(d_ptr)); } inline const QFileIconProviderPrivate* d_func() const { return reinterpret_cast<const QFileIconProviderPrivate *>(qGetPtrHelper(d_ptr)); } friend class QFileIconProviderPrivate;
QScopedPointer<QFileIconProviderPrivate> d_ptr;
QFileIconProvider(const QFileIconProvider &); QFileIconProvider &operator=(const QFileIconProvider &);
};



# 77 "/usr/share/qt4/include/QtGui/qfileiconprovider.h"






# 47 "/usr/share/qt4/include/QtGui/qdirmodel.h"


# 49 "/usr/share/qt4/include/QtGui/qdirmodel.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 57 "/usr/share/qt4/include/QtGui/qdirmodel.h"
class QDirModelPrivate;

class  QDirModel : public QAbstractItemModel
{
Q_OBJECT
Q_PROPERTY(bool resolveSymlinks READ resolveSymlinks WRITE setResolveSymlinks)
Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly)
Q_PROPERTY(bool lazyChildCount READ lazyChildCount WRITE setLazyChildCount)

public:
enum Roles {
FileIconRole = Qt::DecorationRole,
FilePathRole = Qt::UserRole + 1,
FileNameRole
};

QDirModel(const QStringList &nameFilters, QDir::Filters filters,
QDir::SortFlags sort, QObject *parent = 0);
explicit QDirModel(QObject *parent = 0);
~QDirModel();

QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
QModelIndex parent(const QModelIndex &child) const;

int rowCount(const QModelIndex &parent = QModelIndex()) const;
int columnCount(const QModelIndex &parent = QModelIndex()) const;

QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const;

bool hasChildren(const QModelIndex &index = QModelIndex()) const;
Qt::ItemFlags flags(const QModelIndex &index) const;

void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);

QStringList mimeTypes() const;
QMimeData *mimeData(const QModelIndexList &indexes) const;
bool dropMimeData(const QMimeData *data, Qt::DropAction action,
int row, int column, const QModelIndex &parent);
Qt::DropActions supportedDropActions() const;



void setIconProvider(QFileIconProvider *provider);
QFileIconProvider *iconProvider() const;

void setNameFilters(const QStringList &filters);
QStringList nameFilters() const;

void setFilter(QDir::Filters filters);
QDir::Filters filter() const;

void setSorting(QDir::SortFlags sort);
QDir::SortFlags sorting() const;

void setResolveSymlinks(bool enable);
bool resolveSymlinks() const;

void setReadOnly(bool enable);
bool isReadOnly() const;

void setLazyChildCount(bool enable);
bool lazyChildCount() const;

QModelIndex index(const QString &path, int column = 0) const;

bool isDir(const QModelIndex &index) const;
QModelIndex mkdir(const QModelIndex &parent, const QString &name);
bool rmdir(const QModelIndex &index);
bool remove(const QModelIndex &index);

QString filePath(const QModelIndex &index) const;
QString fileName(const QModelIndex &index) const;
QIcon fileIcon(const QModelIndex &index) const;
QFileInfo fileInfo(const QModelIndex &index) const;


# 136 "/usr/share/qt4/include/QtGui/qdirmodel.h"
inline QObject *parent() const { return QObject::parent(); }




# 141 "/usr/share/qt4/include/QtGui/qdirmodel.h"
public slots:
void refresh(const QModelIndex &parent = QModelIndex());

protected:
QDirModel(QDirModelPrivate &, QObject *parent = 0);
friend class QFileDialogPrivate;

private:
inline QDirModelPrivate* d_func() { return reinterpret_cast<QDirModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDirModelPrivate* d_func() const { return reinterpret_cast<const QDirModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDirModelPrivate;
QDirModel(const QDirModel &); QDirModel &operator=(const QDirModel &);

};



# 156 "/usr/share/qt4/include/QtGui/qdirmodel.h"





# 45 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qfileiconprovider.h"


















































































# 46 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qheaderview.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractitemview.h"

























































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qheaderview.h"


# 47 "/usr/share/qt4/include/QtGui/qheaderview.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qheaderview.h"
class QHeaderViewPrivate;
class QStyleOptionHeader;

class  QHeaderView : public QAbstractItemView
{
Q_OBJECT
Q_PROPERTY(bool showSortIndicator READ isSortIndicatorShown WRITE setSortIndicatorShown)
Q_PROPERTY(bool highlightSections READ highlightSections WRITE setHighlightSections)
Q_PROPERTY(bool stretchLastSection READ stretchLastSection WRITE setStretchLastSection)
Q_PROPERTY(bool cascadingSectionResizes READ cascadingSectionResizes WRITE setCascadingSectionResizes)
Q_PROPERTY(int defaultSectionSize READ defaultSectionSize WRITE setDefaultSectionSize)
Q_PROPERTY(int minimumSectionSize READ minimumSectionSize WRITE setMinimumSectionSize)
Q_PROPERTY(Qt::Alignment defaultAlignment READ defaultAlignment WRITE setDefaultAlignment)
Q_ENUMS(ResizeMode)

public:

enum ResizeMode
{
Interactive,
Stretch,
Fixed,
ResizeToContents,
Custom = Fixed
};

explicit QHeaderView(Qt::Orientation orientation, QWidget *parent = 0);
virtual ~QHeaderView();

void setModel(QAbstractItemModel *model);

Qt::Orientation orientation() const;
int offset() const;
int length() const;
QSize sizeHint() const;
int sectionSizeHint(int logicalIndex) const;

int visualIndexAt(int position) const;
int logicalIndexAt(int position) const;

inline int logicalIndexAt(int x, int y) const;
inline int logicalIndexAt(const QPoint &pos) const;

int sectionSize(int logicalIndex) const;
int sectionPosition(int logicalIndex) const;
int sectionViewportPosition(int logicalIndex) const;

void moveSection(int from, int to);
void swapSections(int first, int second);
void resizeSection(int logicalIndex, int size);
void resizeSections(QHeaderView::ResizeMode mode);

bool isSectionHidden(int logicalIndex) const;
void setSectionHidden(int logicalIndex, bool hide);
int hiddenSectionCount() const;

inline void hideSection(int logicalIndex);
inline void showSection(int logicalIndex);

int count() const;
int visualIndex(int logicalIndex) const;
int logicalIndex(int visualIndex) const;

void setMovable(bool movable);
bool isMovable() const;

void setClickable(bool clickable);
bool isClickable() const;

void setHighlightSections(bool highlight);
bool highlightSections() const;

void setResizeMode(ResizeMode mode);
void setResizeMode(int logicalIndex, ResizeMode mode);
ResizeMode resizeMode(int logicalIndex) const;
int stretchSectionCount() const;

void setSortIndicatorShown(bool show);
bool isSortIndicatorShown() const;

void setSortIndicator(int logicalIndex, Qt::SortOrder order);
int sortIndicatorSection() const;
Qt::SortOrder sortIndicatorOrder() const;

bool stretchLastSection() const;
void setStretchLastSection(bool stretch);

bool cascadingSectionResizes() const;
void setCascadingSectionResizes(bool enable);

int defaultSectionSize() const;
void setDefaultSectionSize(int size);

int minimumSectionSize() const;
void setMinimumSectionSize(int size);

Qt::Alignment defaultAlignment() const;
void setDefaultAlignment(Qt::Alignment alignment);

void doItemsLayout();
bool sectionsMoved() const;
bool sectionsHidden() const;


# 159 "/usr/share/qt4/include/QtGui/qheaderview.h"
QByteArray saveState() const;
bool restoreState(const QByteArray &state);


# 163 "/usr/share/qt4/include/QtGui/qheaderview.h"
void reset();

public slots:
void setOffset(int offset);
void setOffsetToSectionPosition(int visualIndex);
void setOffsetToLastSection();
void headerDataChanged(Qt::Orientation orientation, int logicalFirst, int logicalLast);

signals:
void sectionMoved(int logicalIndex, int oldVisualIndex, int newVisualIndex);
void sectionResized(int logicalIndex, int oldSize, int newSize);
void sectionPressed(int logicalIndex);
void sectionClicked(int logicalIndex);
void sectionEntered(int logicalIndex);
void sectionDoubleClicked(int logicalIndex);
void sectionCountChanged(int oldCount, int newCount);
void sectionHandleDoubleClicked(int logicalIndex);
void sectionAutoResize(int logicalIndex, QHeaderView::ResizeMode mode);
void geometriesChanged();
void sortIndicatorChanged(int logicalIndex, Qt::SortOrder order);

protected slots:
void updateSection(int logicalIndex);
void resizeSections();
void sectionsInserted(const QModelIndex &parent, int logicalFirst, int logicalLast);
void sectionsAboutToBeRemoved(const QModelIndex &parent, int logicalFirst, int logicalLast);

protected:
QHeaderView(QHeaderViewPrivate &dd, Qt::Orientation orientation, QWidget *parent = 0);
void initialize();

void initializeSections();
void initializeSections(int start, int end);
void currentChanged(const QModelIndex &current, const QModelIndex &old);

bool event(QEvent *e);
void paintEvent(QPaintEvent *e);
void mousePressEvent(QMouseEvent *e);
void mouseMoveEvent(QMouseEvent *e);
void mouseReleaseEvent(QMouseEvent *e);
void mouseDoubleClickEvent(QMouseEvent *e);
bool viewportEvent(QEvent *e);

virtual void paintSection(QPainter *painter, const QRect &rect, int logicalIndex) const;
virtual QSize sectionSizeFromContents(int logicalIndex) const;

int horizontalOffset() const;
int verticalOffset() const;
void updateGeometries();
void scrollContentsBy(int dx, int dy);

void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
void rowsInserted(const QModelIndex &parent, int start, int end);

QRect visualRect(const QModelIndex &index) const;
void scrollTo(const QModelIndex &index, ScrollHint hint);

QModelIndex indexAt(const QPoint &p) const;
bool isIndexHidden(const QModelIndex &index) const;

QModelIndex moveCursor(CursorAction, Qt::KeyboardModifiers);
void setSelection(const QRect& rect, QItemSelectionModel::SelectionFlags flags);
QRegion visualRegionForSelection(const QItemSelection &selection) const;
void initStyleOption(QStyleOptionHeader *option) const;

private:


inline QHeaderViewPrivate* d_func() { return reinterpret_cast<QHeaderViewPrivate *>(qGetPtrHelper(d_ptr)); } inline const QHeaderViewPrivate* d_func() const { return reinterpret_cast<const QHeaderViewPrivate *>(qGetPtrHelper(d_ptr)); } friend class QHeaderViewPrivate;
QHeaderView(const QHeaderView &); QHeaderView &operator=(const QHeaderView &);
};

inline int QHeaderView::logicalIndexAt(int ax, int ay) const
{ return orientation() == Qt::Horizontal ? logicalIndexAt(ax) : logicalIndexAt(ay); }
inline int QHeaderView::logicalIndexAt(const QPoint &apos) const
{ return logicalIndexAt(apos.x(), apos.y()); }
inline void QHeaderView::hideSection(int alogicalIndex)
{ setSectionHidden(alogicalIndex, true); }
inline void QHeaderView::showSection(int alogicalIndex)
{ setSectionHidden(alogicalIndex, false); }



# 246 "/usr/share/qt4/include/QtGui/qheaderview.h"





# 47 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qitemdelegate.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractitemdelegate.h"






































































































































# 45 "/usr/share/qt4/include/QtGui/qitemdelegate.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qitemdelegate.h"

# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qitemdelegate.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qitemdelegate.h"


# 50 "/usr/share/qt4/include/QtGui/qitemdelegate.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 58 "/usr/share/qt4/include/QtGui/qitemdelegate.h"
class QItemDelegatePrivate;
class QItemEditorFactory;

class  QItemDelegate : public QAbstractItemDelegate
{
Q_OBJECT
Q_PROPERTY(bool clipping READ hasClipping WRITE setClipping)

public:
explicit QItemDelegate(QObject *parent = 0);
~QItemDelegate();

bool hasClipping() const;
void setClipping(bool clip);


void paint(QPainter *painter,
const QStyleOptionViewItem &option,
const QModelIndex &index) const;
QSize sizeHint(const QStyleOptionViewItem &option,
const QModelIndex &index) const;


QWidget *createEditor(QWidget *parent,
const QStyleOptionViewItem &option,
const QModelIndex &index) const;

void setEditorData(QWidget *editor, const QModelIndex &index) const;
void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index) const;

void updateEditorGeometry(QWidget *editor,
const QStyleOptionViewItem &option,
const QModelIndex &index) const;


QItemEditorFactory *itemEditorFactory() const;
void setItemEditorFactory(QItemEditorFactory *factory);

protected:
virtual void drawDisplay(QPainter *painter, const QStyleOptionViewItem &option,
const QRect &rect, const QString &text) const;
virtual void drawDecoration(QPainter *painter, const QStyleOptionViewItem &option,
const QRect &rect, const QPixmap &pixmap) const;
virtual void drawFocus(QPainter *painter, const QStyleOptionViewItem &option,
const QRect &rect) const;
virtual void drawCheck(QPainter *painter, const QStyleOptionViewItem &option,
const QRect &rect, Qt::CheckState state) const;
void drawBackground(QPainter *painter, const QStyleOptionViewItem &option,
const QModelIndex &index) const;

void doLayout(const QStyleOptionViewItem &option,
QRect *checkRect, QRect *iconRect, QRect *textRect, bool hint) const;

QRect rect(const QStyleOptionViewItem &option, const QModelIndex &index, int role) const;

bool eventFilter(QObject *object, QEvent *event);
bool editorEvent(QEvent *event, QAbstractItemModel *model,
const QStyleOptionViewItem &option, const QModelIndex &index);

QStyleOptionViewItem setOptions(const QModelIndex &index,
const QStyleOptionViewItem &option) const;

QPixmap decoration(const QStyleOptionViewItem &option, const QVariant &variant) const;
QPixmap *selected(const QPixmap &pixmap, const QPalette &palette, bool enabled) const;

QRect check(const QStyleOptionViewItem &option, const QRect &bounding,
const QVariant &variant) const;
QRect textRectangle(QPainter *painter, const QRect &rect,
const QFont &font, const QString &text) const;

private:
inline QItemDelegatePrivate* d_func() { return reinterpret_cast<QItemDelegatePrivate *>(qGetPtrHelper(d_ptr)); } inline const QItemDelegatePrivate* d_func() const { return reinterpret_cast<const QItemDelegatePrivate *>(qGetPtrHelper(d_ptr)); } friend class QItemDelegatePrivate;
QItemDelegate(const QItemDelegate &); QItemDelegate &operator=(const QItemDelegate &);


};



# 137 "/usr/share/qt4/include/QtGui/qitemdelegate.h"





# 48 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qitemeditorfactory.h"












































# 1 "/usr/share/qt4/include/QtCore/qmetaobject.h"













































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qitemeditorfactory.h"

# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qitemeditorfactory.h"

# 1 "/usr/share/qt4/include/QtCore/qhash.h"






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qitemeditorfactory.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qitemeditorfactory.h"


# 50 "/usr/share/qt4/include/QtGui/qitemeditorfactory.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 58 "/usr/share/qt4/include/QtGui/qitemeditorfactory.h"
class QWidget;

class  QItemEditorCreatorBase
{
public:
virtual ~QItemEditorCreatorBase() {}

virtual QWidget *createWidget(QWidget *parent) const = 0;
virtual QByteArray valuePropertyName() const = 0;
};

template <class T>
class QItemEditorCreator : public QItemEditorCreatorBase
{
public:
inline QItemEditorCreator(const QByteArray &valuePropertyName);
inline QWidget *createWidget(QWidget *parent) const { return new T(parent); }
inline QByteArray valuePropertyName() const { return propertyName; }

private:
QByteArray propertyName;
};

template <class T>
class QStandardItemEditorCreator: public QItemEditorCreatorBase
{
public:
inline QStandardItemEditorCreator()
: propertyName(T::staticMetaObject.userProperty().name())
{}
inline QWidget *createWidget(QWidget *parent) const { return new T(parent); }
inline QByteArray valuePropertyName() const { return propertyName; }

private:
QByteArray propertyName;
};


template <class T>
inline QItemEditorCreator<T>::QItemEditorCreator(const QByteArray &avaluePropertyName)
: propertyName(avaluePropertyName) {}

class  QItemEditorFactory
{
public:
inline QItemEditorFactory() {}
virtual ~QItemEditorFactory();

virtual QWidget *createEditor(QVariant::Type type, QWidget *parent) const;
virtual QByteArray valuePropertyName(QVariant::Type type) const;

void registerEditor(QVariant::Type type, QItemEditorCreatorBase *creator);

static const QItemEditorFactory *defaultFactory();
static void setDefaultFactory(QItemEditorFactory *factory);

private:
QHash<QVariant::Type, QItemEditorCreatorBase *> creatorMap;
};



# 120 "/usr/share/qt4/include/QtGui/qitemeditorfactory.h"





# 49 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qitemselectionmodel.h"





































































































































































































































# 50 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qlistview.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractitemview.h"

























































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qlistview.h"


# 47 "/usr/share/qt4/include/QtGui/qlistview.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qlistview.h"
class QListViewPrivate;

class  QListView : public QAbstractItemView
{
Q_OBJECT
Q_ENUMS(Movement Flow ResizeMode LayoutMode ViewMode)
Q_PROPERTY(Movement movement READ movement WRITE setMovement)
Q_PROPERTY(Flow flow READ flow WRITE setFlow)
Q_PROPERTY(bool isWrapping READ isWrapping WRITE setWrapping)
Q_PROPERTY(ResizeMode resizeMode READ resizeMode WRITE setResizeMode)
Q_PROPERTY(LayoutMode layoutMode READ layoutMode WRITE setLayoutMode)
Q_PROPERTY(int spacing READ spacing WRITE setSpacing)
Q_PROPERTY(QSize gridSize READ gridSize WRITE setGridSize)
Q_PROPERTY(ViewMode viewMode READ viewMode WRITE setViewMode)
Q_PROPERTY(int modelColumn READ modelColumn WRITE setModelColumn)
Q_PROPERTY(bool uniformItemSizes READ uniformItemSizes WRITE setUniformItemSizes)
Q_PROPERTY(int batchSize READ batchSize WRITE setBatchSize)
Q_PROPERTY(bool wordWrap READ wordWrap WRITE setWordWrap)
Q_PROPERTY(bool selectionRectVisible READ isSelectionRectVisible WRITE setSelectionRectVisible)

public:
enum Movement { Static, Free, Snap };
enum Flow { LeftToRight, TopToBottom };
enum ResizeMode { Fixed, Adjust };
enum LayoutMode { SinglePass, Batched };
enum ViewMode { ListMode, IconMode };

explicit QListView(QWidget *parent = 0);
~QListView();

void setMovement(Movement movement);
Movement movement() const;

void setFlow(Flow flow);
Flow flow() const;

void setWrapping(bool enable);
bool isWrapping() const;

void setResizeMode(ResizeMode mode);
ResizeMode resizeMode() const;

void setLayoutMode(LayoutMode mode);
LayoutMode layoutMode() const;

void setSpacing(int space);
int spacing() const;

void setBatchSize(int batchSize);
int batchSize() const;

void setGridSize(const QSize &size);
QSize gridSize() const;

void setViewMode(ViewMode mode);
ViewMode viewMode() const;

void clearPropertyFlags();

bool isRowHidden(int row) const;
void setRowHidden(int row, bool hide);

void setModelColumn(int column);
int modelColumn() const;

void setUniformItemSizes(bool enable);
bool uniformItemSizes() const;

void setWordWrap(bool on);
bool wordWrap() const;

void setSelectionRectVisible(bool show);
bool isSelectionRectVisible() const;

QRect visualRect(const QModelIndex &index) const;
void scrollTo(const QModelIndex &index, ScrollHint hint = EnsureVisible);
QModelIndex indexAt(const QPoint &p) const;

void doItemsLayout();
void reset();
void setRootIndex(const QModelIndex &index);

signals:
void indexesMoved(const QModelIndexList &indexes);

protected:
QListView(QListViewPrivate &, QWidget *parent = 0);

bool event(QEvent *e);

void scrollContentsBy(int dx, int dy);

void resizeContents(int width, int height);
QSize contentsSize() const;

void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
void rowsInserted(const QModelIndex &parent, int start, int end);
void rowsAboutToBeRemoved(const QModelIndex &parent, int start, int end);

void mouseMoveEvent(QMouseEvent *e);
void mouseReleaseEvent(QMouseEvent *e);

void timerEvent(QTimerEvent *e);
void resizeEvent(QResizeEvent *e);

# 160 "/usr/share/qt4/include/QtGui/qlistview.h"
void dragMoveEvent(QDragMoveEvent *e);
void dragLeaveEvent(QDragLeaveEvent *e);
void dropEvent(QDropEvent *e);
void startDrag(Qt::DropActions supportedActions);

void internalDrop(QDropEvent *e);
void internalDrag(Qt::DropActions supportedActions);


# 169 "/usr/share/qt4/include/QtGui/qlistview.h"
QStyleOptionViewItem viewOptions() const;
void paintEvent(QPaintEvent *e);

int horizontalOffset() const;
int verticalOffset() const;
QModelIndex moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers);
QRect rectForIndex(const QModelIndex &index) const;
void setPositionForIndex(const QPoint &position, const QModelIndex &index);

void setSelection(const QRect &rect, QItemSelectionModel::SelectionFlags command);
QRegion visualRegionForSelection(const QItemSelection &selection) const;
QModelIndexList selectedIndexes() const;

void updateGeometries();

bool isIndexHidden(const QModelIndex &index) const;

void selectionChanged(const QItemSelection &selected, const QItemSelection &deselected);
void currentChanged(const QModelIndex &current, const QModelIndex &previous);

private:
friend class QAccessibleItemView;
int visualIndex(const QModelIndex &index) const;

inline QListViewPrivate* d_func() { return reinterpret_cast<QListViewPrivate *>(qGetPtrHelper(d_ptr)); } inline const QListViewPrivate* d_func() const { return reinterpret_cast<const QListViewPrivate *>(qGetPtrHelper(d_ptr)); } friend class QListViewPrivate;
QListView(const QListView &); QListView &operator=(const QListView &);
};



# 199 "/usr/share/qt4/include/QtGui/qlistview.h"





# 51 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qlistwidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qlistview.h"











































































































































































































# 45 "/usr/share/qt4/include/QtGui/qlistwidget.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qlistwidget.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qlistwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qitemselectionmodel.h"





































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qlistwidget.h"


# 50 "/usr/share/qt4/include/QtGui/qlistwidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 58 "/usr/share/qt4/include/QtGui/qlistwidget.h"
class QListWidget;
class QListModel;
class QWidgetItemData;
class QListWidgetItemPrivate;

class  QListWidgetItem
{
friend class QListModel;
friend class QListWidget;
public:
enum ItemType { Type = 0, UserType = 1000 };
explicit QListWidgetItem(QListWidget *view = 0, int type = Type);
explicit QListWidgetItem(const QString &text, QListWidget *view = 0, int type = Type);
explicit QListWidgetItem(const QIcon &icon, const QString &text,
QListWidget *view = 0, int type = Type);
QListWidgetItem(const QListWidgetItem &other);
virtual ~QListWidgetItem();

virtual QListWidgetItem *clone() const;

inline QListWidget *listWidget() const { return view; }

inline void setSelected(bool select);
inline bool isSelected() const;

inline void setHidden(bool hide);
inline bool isHidden() const;

inline Qt::ItemFlags flags() const { return itemFlags; }
void setFlags(Qt::ItemFlags flags);

inline QString text() const
{ return data(Qt::DisplayRole).toString(); }
inline void setText(const QString &text);

inline QIcon icon() const
{ return qvariant_cast<QIcon>(data(Qt::DecorationRole)); }
inline void setIcon(const QIcon &icon);

inline QString statusTip() const
{ return data(Qt::StatusTipRole).toString(); }
inline void setStatusTip(const QString &statusTip);


# 102 "/usr/share/qt4/include/QtGui/qlistwidget.h"
inline QString toolTip() const
{ return data(Qt::ToolTipRole).toString(); }
inline void setToolTip(const QString &toolTip);



# 108 "/usr/share/qt4/include/QtGui/qlistwidget.h"
inline QString whatsThis() const
{ return data(Qt::WhatsThisRole).toString(); }
inline void setWhatsThis(const QString &whatsThis);


# 113 "/usr/share/qt4/include/QtGui/qlistwidget.h"
inline QFont font() const
{ return qvariant_cast<QFont>(data(Qt::FontRole)); }
inline void setFont(const QFont &font);

inline int textAlignment() const
{ return data(Qt::TextAlignmentRole).toInt(); }
inline void setTextAlignment(int alignment)
{ setData(Qt::TextAlignmentRole, alignment); }

inline QColor backgroundColor() const
{ return qvariant_cast<QColor>(data(Qt::BackgroundColorRole)); }
virtual void setBackgroundColor(const QColor &color)
{ setData(Qt::BackgroundColorRole, color); }

inline QBrush background() const
{ return qvariant_cast<QBrush>(data(Qt::BackgroundRole)); }
inline void setBackground(const QBrush &brush)
{ setData(Qt::BackgroundRole, brush); }

inline QColor textColor() const
{ return qvariant_cast<QColor>(data(Qt::TextColorRole)); }
inline void setTextColor(const QColor &color)
{ setData(Qt::TextColorRole, color); }

inline QBrush foreground() const
{ return qvariant_cast<QBrush>(data(Qt::ForegroundRole)); }
inline void setForeground(const QBrush &brush)
{ setData(Qt::ForegroundRole, brush); }

inline Qt::CheckState checkState() const
{ return static_cast<Qt::CheckState>(data(Qt::CheckStateRole).toInt()); }
inline void setCheckState(Qt::CheckState state)
{ setData(Qt::CheckStateRole, static_cast<int>(state)); }

inline QSize sizeHint() const
{ return qvariant_cast<QSize>(data(Qt::SizeHintRole)); }
inline void setSizeHint(const QSize &size)
{ setData(Qt::SizeHintRole, size); }

virtual QVariant data(int role) const;
virtual void setData(int role, const QVariant &value);

virtual bool operator<(const QListWidgetItem &other) const;


# 158 "/usr/share/qt4/include/QtGui/qlistwidget.h"
virtual void read(QDataStream &in);
virtual void write(QDataStream &out) const;

# 161 "/usr/share/qt4/include/QtGui/qlistwidget.h"
QListWidgetItem &operator=(const QListWidgetItem &other);

inline int type() const { return rtti; }

private:
int rtti;
QVector<void *> dummy;
QListWidget *view;
QListWidgetItemPrivate *d;
Qt::ItemFlags itemFlags;
};

inline void QListWidgetItem::setText(const QString &atext)
{ setData(Qt::DisplayRole, atext); }

inline void QListWidgetItem::setIcon(const QIcon &aicon)
{ setData(Qt::DecorationRole, aicon); }

inline void QListWidgetItem::setStatusTip(const QString &astatusTip)
{ setData(Qt::StatusTipRole, astatusTip); }


# 183 "/usr/share/qt4/include/QtGui/qlistwidget.h"
inline void QListWidgetItem::setToolTip(const QString &atoolTip)
{ setData(Qt::ToolTipRole, atoolTip); }



# 188 "/usr/share/qt4/include/QtGui/qlistwidget.h"
inline void QListWidgetItem::setWhatsThis(const QString &awhatsThis)
{ setData(Qt::WhatsThisRole, awhatsThis); }


# 192 "/usr/share/qt4/include/QtGui/qlistwidget.h"
inline void QListWidgetItem::setFont(const QFont &afont)
{ setData(Qt::FontRole, afont); }


# 196 "/usr/share/qt4/include/QtGui/qlistwidget.h"
 QDataStream &operator<<(QDataStream &out, const QListWidgetItem &item);
 QDataStream &operator>>(QDataStream &in, QListWidgetItem &item);


# 200 "/usr/share/qt4/include/QtGui/qlistwidget.h"
class QListWidgetPrivate;

class  QListWidget : public QListView
{
Q_OBJECT
Q_PROPERTY(int count READ count)
Q_PROPERTY(int currentRow READ currentRow WRITE setCurrentRow NOTIFY currentRowChanged USER true)
Q_PROPERTY(bool sortingEnabled READ isSortingEnabled WRITE setSortingEnabled)

friend class QListWidgetItem;
friend class QListModel;
public:
explicit QListWidget(QWidget *parent = 0);
~QListWidget();

QListWidgetItem *item(int row) const;
int row(const QListWidgetItem *item) const;
void insertItem(int row, QListWidgetItem *item);
void insertItem(int row, const QString &label);
void insertItems(int row, const QStringList &labels);
inline void addItem(const QString &label) { insertItem(count(), label); }
inline void addItem(QListWidgetItem *item);
inline void addItems(const QStringList &labels) { insertItems(count(), labels); }
QListWidgetItem *takeItem(int row);
int count() const;

QListWidgetItem *currentItem() const;
void setCurrentItem(QListWidgetItem *item);
void setCurrentItem(QListWidgetItem *item, QItemSelectionModel::SelectionFlags command);

int currentRow() const;
void setCurrentRow(int row);
void setCurrentRow(int row, QItemSelectionModel::SelectionFlags command);

QListWidgetItem *itemAt(const QPoint &p) const;
inline QListWidgetItem *itemAt(int x, int y) const;
QRect visualItemRect(const QListWidgetItem *item) const;

void sortItems(Qt::SortOrder order = Qt::AscendingOrder);
void setSortingEnabled(bool enable);
bool isSortingEnabled() const;

void editItem(QListWidgetItem *item);
void openPersistentEditor(QListWidgetItem *item);
void closePersistentEditor(QListWidgetItem *item);

QWidget *itemWidget(QListWidgetItem *item) const;
void setItemWidget(QListWidgetItem *item, QWidget *widget);
inline void removeItemWidget(QListWidgetItem *item);

bool isItemSelected(const QListWidgetItem *item) const;
void setItemSelected(const QListWidgetItem *item, bool select);
QList<QListWidgetItem*> selectedItems() const;
QList<QListWidgetItem*> findItems(const QString &text, Qt::MatchFlags flags) const;

bool isItemHidden(const QListWidgetItem *item) const;
void setItemHidden(const QListWidgetItem *item, bool hide);
void dropEvent(QDropEvent *event);

public slots:
void scrollToItem(const QListWidgetItem *item, QAbstractItemView::ScrollHint hint = EnsureVisible);
void clear();

signals:
void itemPressed(QListWidgetItem *item);
void itemClicked(QListWidgetItem *item);
void itemDoubleClicked(QListWidgetItem *item);
void itemActivated(QListWidgetItem *item);
void itemEntered(QListWidgetItem *item);
void itemChanged(QListWidgetItem *item);

void currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous);
void currentTextChanged(const QString &currentText);
void currentRowChanged(int currentRow);

void itemSelectionChanged();

protected:
bool event(QEvent *e);
virtual QStringList mimeTypes() const;
virtual QMimeData *mimeData(const QList<QListWidgetItem*> items) const;

# 282 "/usr/share/qt4/include/QtGui/qlistwidget.h"
virtual bool dropMimeData(int index, const QMimeData *data, Qt::DropAction action);
virtual Qt::DropActions supportedDropActions() const;

# 285 "/usr/share/qt4/include/QtGui/qlistwidget.h"
QList<QListWidgetItem*> items(const QMimeData *data) const;

QModelIndex indexFromItem(QListWidgetItem *item) const;
QListWidgetItem *itemFromIndex(const QModelIndex &index) const;

private:
void setModel(QAbstractItemModel *model);
Qt::SortOrder sortOrder() const;

inline QListWidgetPrivate* d_func() { return reinterpret_cast<QListWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QListWidgetPrivate* d_func() const { return reinterpret_cast<const QListWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QListWidgetPrivate;
QListWidget(const QListWidget &); QListWidget &operator=(const QListWidget &);










};

inline void QListWidget::removeItemWidget(QListWidgetItem *aItem)
{ setItemWidget(aItem, 0); }

inline void QListWidget::addItem(QListWidgetItem *aitem)
{ insertItem(count(), aitem); }

inline QListWidgetItem *QListWidget::itemAt(int ax, int ay) const
{ return itemAt(QPoint(ax, ay)); }

inline void QListWidgetItem::setSelected(bool aselect)
{ if (view) view->setItemSelected(this, aselect); }

inline bool QListWidgetItem::isSelected() const
{ return (view ? view->isItemSelected(this) : false); }

inline void QListWidgetItem::setHidden(bool ahide)
{ if (view) view->setItemHidden(this, ahide); }

inline bool QListWidgetItem::isHidden() const
{ return (view ? view->isItemHidden(this) : false); }



# 331 "/usr/share/qt4/include/QtGui/qlistwidget.h"





# 52 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qproxymodel.h"












































# 1 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"


























































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qproxymodel.h"


# 47 "/usr/share/qt4/include/QtGui/qproxymodel.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qproxymodel.h"
class QProxyModelPrivate;

class  QProxyModel : public QAbstractItemModel
{
Q_OBJECT

public:
explicit QProxyModel(QObject *parent = 0);
~QProxyModel();

virtual void setModel(QAbstractItemModel *model);
QAbstractItemModel *model() const;



QModelIndex index(int row, int column, const QModelIndex &parent) const;
QModelIndex parent(const QModelIndex &child) const;

int rowCount(const QModelIndex &parent) const;
int columnCount(const QModelIndex &parent) const;
bool hasChildren(const QModelIndex &parent) const;

QVariant data(const QModelIndex &index, int role) const;
bool setData(const QModelIndex &index, const QVariant &value, int role);

QVariant headerData(int section, Qt::Orientation orientation, int role) const;
bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value,
int role);

QStringList mimeTypes() const;
QMimeData *mimeData(const QModelIndexList &indexes) const;
bool dropMimeData(const QMimeData *data, Qt::DropAction action,
int row, int column, const QModelIndex &parent);
Qt::DropActions supportedDropActions() const;

bool insertRows(int row, int count, const QModelIndex &parent);
bool insertColumns(int column, int count, const QModelIndex &parent);

void fetchMore(const QModelIndex &parent);
Qt::ItemFlags flags(const QModelIndex &index) const;

void sort(int column, Qt::SortOrder order);

QModelIndexList match(const QModelIndex &start, int role, const QVariant &value,
int hits, Qt::MatchFlags flags) const;

QSize span(const QModelIndex &index) const;

bool submit();
void revert();


# 107 "/usr/share/qt4/include/QtGui/qproxymodel.h"
inline QObject *parent() const { return QObject::parent(); }




# 112 "/usr/share/qt4/include/QtGui/qproxymodel.h"
protected:
QProxyModel(QProxyModelPrivate &, QObject *parent = 0);

QModelIndex setProxyModel(const QModelIndex &source_index) const;
QModelIndex setSourceModel(const QModelIndex &proxy_index) const;

void connectToModel(const QAbstractItemModel *model) const;
void disconnectFromModel(const QAbstractItemModel *model) const;

private:
inline QProxyModelPrivate* d_func() { return reinterpret_cast<QProxyModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QProxyModelPrivate* d_func() const { return reinterpret_cast<const QProxyModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QProxyModelPrivate;
QProxyModel(const QProxyModel &); QProxyModel &operator=(const QProxyModel &);










};



# 138 "/usr/share/qt4/include/QtGui/qproxymodel.h"





# 53 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qsortfilterproxymodel.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractproxymodel.h"





































































































# 45 "/usr/share/qt4/include/QtGui/qsortfilterproxymodel.h"




# 1 "/usr/share/qt4/include/QtCore/qregexp.h"




































































































































































# 49 "/usr/share/qt4/include/QtGui/qsortfilterproxymodel.h"


# 51 "/usr/share/qt4/include/QtGui/qsortfilterproxymodel.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QSortFilterProxyModelPrivate;
class QSortFilterProxyModelLessThan;
class QSortFilterProxyModelGreaterThan;

class  QSortFilterProxyModel : public QAbstractProxyModel
{
friend class QSortFilterProxyModelLessThan;
friend class QSortFilterProxyModelGreaterThan;

Q_OBJECT
Q_PROPERTY(QRegExp filterRegExp READ filterRegExp WRITE setFilterRegExp)
Q_PROPERTY(int filterKeyColumn READ filterKeyColumn WRITE setFilterKeyColumn)
Q_PROPERTY(bool dynamicSortFilter READ dynamicSortFilter WRITE setDynamicSortFilter)
Q_PROPERTY(Qt::CaseSensitivity filterCaseSensitivity READ filterCaseSensitivity WRITE setFilterCaseSensitivity)
Q_PROPERTY(Qt::CaseSensitivity sortCaseSensitivity READ sortCaseSensitivity WRITE setSortCaseSensitivity)
Q_PROPERTY(bool isSortLocaleAware READ isSortLocaleAware WRITE setSortLocaleAware)
Q_PROPERTY(int sortRole READ sortRole WRITE setSortRole)
Q_PROPERTY(int filterRole READ filterRole WRITE setFilterRole)

public:
QSortFilterProxyModel(QObject *parent = 0);
~QSortFilterProxyModel();

void setSourceModel(QAbstractItemModel *sourceModel);

QModelIndex mapToSource(const QModelIndex &proxyIndex) const;
QModelIndex mapFromSource(const QModelIndex &sourceIndex) const;

QItemSelection mapSelectionToSource(const QItemSelection &proxySelection) const;
QItemSelection mapSelectionFromSource(const QItemSelection &sourceSelection) const;

QRegExp filterRegExp() const;
void setFilterRegExp(const QRegExp &regExp);

int filterKeyColumn() const;
void setFilterKeyColumn(int column);

Qt::CaseSensitivity filterCaseSensitivity() const;
void setFilterCaseSensitivity(Qt::CaseSensitivity cs);

Qt::CaseSensitivity sortCaseSensitivity() const;
void setSortCaseSensitivity(Qt::CaseSensitivity cs);

bool isSortLocaleAware() const;
void setSortLocaleAware(bool on);

int sortColumn() const;
Qt::SortOrder sortOrder() const;

bool dynamicSortFilter() const;
void setDynamicSortFilter(bool enable);

int sortRole() const;
void setSortRole(int role);

int filterRole() const;
void setFilterRole(int role);

public slots:
void setFilterRegExp(const QString &pattern);
void setFilterWildcard(const QString &pattern);
void setFilterFixedString(const QString &pattern);
void clear();
void invalidate();

protected:
virtual bool filterAcceptsRow(int source_row, const QModelIndex &source_parent) const;
virtual bool filterAcceptsColumn(int source_column, const QModelIndex &source_parent) const;
virtual bool lessThan(const QModelIndex &left, const QModelIndex &right) const;

void filterChanged();
void invalidateFilter();

public:

# 132 "/usr/share/qt4/include/QtGui/qsortfilterproxymodel.h"
inline QObject *parent() const { return QObject::parent(); }




# 137 "/usr/share/qt4/include/QtGui/qsortfilterproxymodel.h"
QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
QModelIndex parent(const QModelIndex &child) const;

int rowCount(const QModelIndex &parent = QModelIndex()) const;
int columnCount(const QModelIndex &parent = QModelIndex()) const;
bool hasChildren(const QModelIndex &parent = QModelIndex()) const;

QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const;
bool setHeaderData(int section, Qt::Orientation orientation,
const QVariant &value, int role = Qt::EditRole);

QMimeData *mimeData(const QModelIndexList &indexes) const;
bool dropMimeData(const QMimeData *data, Qt::DropAction action,
int row, int column, const QModelIndex &parent);

bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
bool insertColumns(int column, int count, const QModelIndex &parent = QModelIndex());
bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());
bool removeColumns(int column, int count, const QModelIndex &parent = QModelIndex());

void fetchMore(const QModelIndex &parent);
bool canFetchMore(const QModelIndex &parent) const;
Qt::ItemFlags flags(const QModelIndex &index) const;

QModelIndex buddy(const QModelIndex &index) const;
QModelIndexList match(const QModelIndex &start, int role,
const QVariant &value, int hits = 1,
Qt::MatchFlags flags =
Qt::MatchFlags(Qt::MatchStartsWith|Qt::MatchWrap)) const;
QSize span(const QModelIndex &index) const;
void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);

QStringList mimeTypes() const;
Qt::DropActions supportedDropActions() const;
private:
inline QSortFilterProxyModelPrivate* d_func() { return reinterpret_cast<QSortFilterProxyModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSortFilterProxyModelPrivate* d_func() const { return reinterpret_cast<const QSortFilterProxyModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSortFilterProxyModelPrivate;
QSortFilterProxyModel(const QSortFilterProxyModel &); QSortFilterProxyModel &operator=(const QSortFilterProxyModel &);















};








# 54 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"












































# 1 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"


























































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"

# 1 "/usr/share/qt4/include/QtGui/qbrush.h"








































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"

# 1 "/usr/share/qt4/include/QtGui/qicon.h"


























































































































































# 48 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"


# 1 "/usr/share/qt4/include/QtCore/qdatastream.h"


















































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"



# 53 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 61 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
template <class T> class QList;

class QStandardItemModel;

class QStandardItemPrivate;
class  QStandardItem
{
public:
QStandardItem();
QStandardItem(const QString &text);
QStandardItem(const QIcon &icon, const QString &text);
explicit QStandardItem(int rows, int columns = 1);
virtual ~QStandardItem();

virtual QVariant data(int role = Qt::UserRole + 1) const;
virtual void setData(const QVariant &value, int role = Qt::UserRole + 1);

inline QString text() const {
return qvariant_cast<QString>(data(Qt::DisplayRole));
}
inline void setText(const QString &text);

inline QIcon icon() const {
return qvariant_cast<QIcon>(data(Qt::DecorationRole));
}
inline void setIcon(const QIcon &icon);


# 89 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
inline QString toolTip() const {
return qvariant_cast<QString>(data(Qt::ToolTipRole));
}
inline void setToolTip(const QString &toolTip);



# 96 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
inline QString statusTip() const {
return qvariant_cast<QString>(data(Qt::StatusTipRole));
}
inline void setStatusTip(const QString &statusTip);



# 103 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
inline QString whatsThis() const {
return qvariant_cast<QString>(data(Qt::WhatsThisRole));
}
inline void setWhatsThis(const QString &whatsThis);


# 109 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
inline QSize sizeHint() const {
return qvariant_cast<QSize>(data(Qt::SizeHintRole));
}
inline void setSizeHint(const QSize &sizeHint);

inline QFont font() const {
return qvariant_cast<QFont>(data(Qt::FontRole));
}
inline void setFont(const QFont &font);

inline Qt::Alignment textAlignment() const {
return Qt::Alignment(qvariant_cast<int>(data(Qt::TextAlignmentRole)));
}
inline void setTextAlignment(Qt::Alignment textAlignment);

inline QBrush background() const {
return qvariant_cast<QBrush>(data(Qt::BackgroundRole));
}
inline void setBackground(const QBrush &brush);

inline QBrush foreground() const {
return qvariant_cast<QBrush>(data(Qt::ForegroundRole));
}
inline void setForeground(const QBrush &brush);

inline Qt::CheckState checkState() const {
return Qt::CheckState(qvariant_cast<int>(data(Qt::CheckStateRole)));
}
inline void setCheckState(Qt::CheckState checkState);

inline QString accessibleText() const {
return qvariant_cast<QString>(data(Qt::AccessibleTextRole));
}
inline void setAccessibleText(const QString &accessibleText);

inline QString accessibleDescription() const {
return qvariant_cast<QString>(data(Qt::AccessibleDescriptionRole));
}
inline void setAccessibleDescription(const QString &accessibleDescription);

Qt::ItemFlags flags() const;
void setFlags(Qt::ItemFlags flags);

inline bool isEnabled() const {
return (flags() & Qt::ItemIsEnabled) != 0;
}
void setEnabled(bool enabled);

inline bool isEditable() const {
return (flags() & Qt::ItemIsEditable) != 0;
}
void setEditable(bool editable);

inline bool isSelectable() const {
return (flags() & Qt::ItemIsSelectable) != 0;
}
void setSelectable(bool selectable);

inline bool isCheckable() const {
return (flags() & Qt::ItemIsUserCheckable) != 0;
}
void setCheckable(bool checkable);

inline bool isTristate() const {
return (flags() & Qt::ItemIsTristate) != 0;
}
void setTristate(bool tristate);


# 178 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
inline bool isDragEnabled() const {
return (flags() & Qt::ItemIsDragEnabled) != 0;
}
void setDragEnabled(bool dragEnabled);

inline bool isDropEnabled() const {
return (flags() & Qt::ItemIsDropEnabled) != 0;
}
void setDropEnabled(bool dropEnabled);


# 189 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
QStandardItem *parent() const;
int row() const;
int column() const;
QModelIndex index() const;
QStandardItemModel *model() const;

int rowCount() const;
void setRowCount(int rows);
int columnCount() const;
void setColumnCount(int columns);

bool hasChildren() const;
QStandardItem *child(int row, int column = 0) const;
void setChild(int row, int column, QStandardItem *item);
inline void setChild(int row, QStandardItem *item);

void insertRow(int row, const QList<QStandardItem*> &items);
void insertColumn(int column, const QList<QStandardItem*> &items);
void insertRows(int row, const QList<QStandardItem*> &items);
void insertRows(int row, int count);
void insertColumns(int column, int count);

void removeRow(int row);
void removeColumn(int column);
void removeRows(int row, int count);
void removeColumns(int column, int count);

inline void appendRow(const QList<QStandardItem*> &items);
inline void appendRows(const QList<QStandardItem*> &items);
inline void appendColumn(const QList<QStandardItem*> &items);
inline void insertRow(int row, QStandardItem *item);
inline void appendRow(QStandardItem *item);

QStandardItem *takeChild(int row, int column = 0);
QList<QStandardItem*> takeRow(int row);
QList<QStandardItem*> takeColumn(int column);

void sortChildren(int column, Qt::SortOrder order = Qt::AscendingOrder);

virtual QStandardItem *clone() const;

enum ItemType { Type = 0, UserType = 1000 };
virtual int type() const;


# 234 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
virtual void read(QDataStream &in);
virtual void write(QDataStream &out) const;

# 237 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
virtual bool operator<(const QStandardItem &other) const;

protected:
QStandardItem(const QStandardItem &other);
QStandardItem(QStandardItemPrivate &dd);
QStandardItem &operator=(const QStandardItem &other);
QScopedPointer<QStandardItemPrivate> d_ptr;

void emitDataChanged();

private:
inline QStandardItemPrivate* d_func() { return reinterpret_cast<QStandardItemPrivate *>(qGetPtrHelper(d_ptr)); } inline const QStandardItemPrivate* d_func() const { return reinterpret_cast<const QStandardItemPrivate *>(qGetPtrHelper(d_ptr)); } friend class QStandardItemPrivate;
friend class QStandardItemModelPrivate;
friend class QStandardItemModel;
};

inline void QStandardItem::setText(const QString &atext)
{ setData(atext, Qt::DisplayRole); }

inline void QStandardItem::setIcon(const QIcon &aicon)
{ setData(aicon, Qt::DecorationRole); }


# 260 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
inline void QStandardItem::setToolTip(const QString &atoolTip)
{ setData(atoolTip, Qt::ToolTipRole); }



# 265 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
inline void QStandardItem::setStatusTip(const QString &astatusTip)
{ setData(astatusTip, Qt::StatusTipRole); }



# 270 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
inline void QStandardItem::setWhatsThis(const QString &awhatsThis)
{ setData(awhatsThis, Qt::WhatsThisRole); }


# 274 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
inline void QStandardItem::setSizeHint(const QSize &asizeHint)
{ setData(asizeHint, Qt::SizeHintRole); }

inline void QStandardItem::setFont(const QFont &afont)
{ setData(afont, Qt::FontRole); }

inline void QStandardItem::setTextAlignment(Qt::Alignment atextAlignment)
{ setData(int(atextAlignment), Qt::TextAlignmentRole); }

inline void QStandardItem::setBackground(const QBrush &abrush)
{ setData(abrush, Qt::BackgroundRole); }

inline void QStandardItem::setForeground(const QBrush &abrush)
{ setData(abrush, Qt::ForegroundRole); }

inline void QStandardItem::setCheckState(Qt::CheckState acheckState)
{ setData(acheckState, Qt::CheckStateRole); }

inline void QStandardItem::setAccessibleText(const QString &aaccessibleText)
{ setData(aaccessibleText, Qt::AccessibleTextRole); }

inline void QStandardItem::setAccessibleDescription(const QString &aaccessibleDescription)
{ setData(aaccessibleDescription, Qt::AccessibleDescriptionRole); }

inline void QStandardItem::setChild(int arow, QStandardItem *aitem)
{ setChild(arow, 0, aitem); }

inline void QStandardItem::appendRow(const QList<QStandardItem*> &aitems)
{ insertRow(rowCount(), aitems); }

inline void QStandardItem::appendRows(const QList<QStandardItem*> &aitems)
{ insertRows(rowCount(), aitems); }

inline void QStandardItem::appendColumn(const QList<QStandardItem*> &aitems)
{ insertColumn(columnCount(), aitems); }

inline void QStandardItem::insertRow(int arow, QStandardItem *aitem)
{ insertRow(arow, QList<QStandardItem*>() << aitem); }

inline void QStandardItem::appendRow(QStandardItem *aitem)
{ insertRow(rowCount(), aitem); }

class QStandardItemModelPrivate;

class  QStandardItemModel : public QAbstractItemModel
{
Q_OBJECT
Q_PROPERTY(int sortRole READ sortRole WRITE setSortRole)

public:
explicit QStandardItemModel(QObject *parent = 0);
QStandardItemModel(int rows, int columns, QObject *parent = 0);
~QStandardItemModel();

QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
QModelIndex parent(const QModelIndex &child) const;

int rowCount(const QModelIndex &parent = QModelIndex()) const;
int columnCount(const QModelIndex &parent = QModelIndex()) const;
bool hasChildren(const QModelIndex &parent = QModelIndex()) const;

QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

QVariant headerData(int section, Qt::Orientation orientation,
int role = Qt::DisplayRole) const;
bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value,
int role = Qt::EditRole);

bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
bool insertColumns(int column, int count, const QModelIndex &parent = QModelIndex());
bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());
bool removeColumns(int column, int count, const QModelIndex &parent = QModelIndex());

Qt::ItemFlags flags(const QModelIndex &index) const;
Qt::DropActions supportedDropActions() const;

QMap<int, QVariant> itemData(const QModelIndex &index) const;
bool setItemData(const QModelIndex &index, const QMap<int, QVariant> &roles);

void clear();


# 357 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
inline QObject *parent() const { return QObject::parent(); }




# 362 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);

QStandardItem *itemFromIndex(const QModelIndex &index) const;
QModelIndex indexFromItem(const QStandardItem *item) const;

QStandardItem *item(int row, int column = 0) const;
void setItem(int row, int column, QStandardItem *item);
inline void setItem(int row, QStandardItem *item);
QStandardItem *invisibleRootItem() const;

QStandardItem *horizontalHeaderItem(int column) const;
void setHorizontalHeaderItem(int column, QStandardItem *item);
QStandardItem *verticalHeaderItem(int row) const;
void setVerticalHeaderItem(int row, QStandardItem *item);

void setHorizontalHeaderLabels(const QStringList &labels);
void setVerticalHeaderLabels(const QStringList &labels);

void setRowCount(int rows);
void setColumnCount(int columns);

void appendRow(const QList<QStandardItem*> &items);
void appendColumn(const QList<QStandardItem*> &items);
inline void appendRow(QStandardItem *item);

void insertRow(int row, const QList<QStandardItem*> &items);
void insertColumn(int column, const QList<QStandardItem*> &items);
inline void insertRow(int row, QStandardItem *item);

inline bool insertRow(int row, const QModelIndex &parent = QModelIndex());
inline bool insertColumn(int column, const QModelIndex &parent = QModelIndex());

QStandardItem *takeItem(int row, int column = 0);
QList<QStandardItem*> takeRow(int row);
QList<QStandardItem*> takeColumn(int column);

QStandardItem *takeHorizontalHeaderItem(int column);
QStandardItem *takeVerticalHeaderItem(int row);

const QStandardItem *itemPrototype() const;
void setItemPrototype(const QStandardItem *item);

QList<QStandardItem*> findItems(const QString &text,
Qt::MatchFlags flags = Qt::MatchExactly,
int column = 0) const;

int sortRole() const;
void setSortRole(int role);

QStringList mimeTypes() const;
QMimeData *mimeData(const QModelIndexList &indexes) const;
bool dropMimeData (const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &parent);

signals:
void itemChanged(QStandardItem *item);

protected:
QStandardItemModel(QStandardItemModelPrivate &dd, QObject *parent = 0);

private:
friend class QStandardItemPrivate;
friend class QStandardItem;
QStandardItemModel(const QStandardItemModel &); QStandardItemModel &operator=(const QStandardItemModel &);
inline QStandardItemModelPrivate* d_func() { return reinterpret_cast<QStandardItemModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QStandardItemModelPrivate* d_func() const { return reinterpret_cast<const QStandardItemModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QStandardItemModelPrivate;


};

inline void QStandardItemModel::setItem(int arow, QStandardItem *aitem)
{ setItem(arow, 0, aitem); }

inline void QStandardItemModel::appendRow(QStandardItem *aitem)
{ appendRow(QList<QStandardItem*>() << aitem); }

inline void QStandardItemModel::insertRow(int arow, QStandardItem *aitem)
{ insertRow(arow, QList<QStandardItem*>() << aitem); }

inline bool QStandardItemModel::insertRow(int arow, const QModelIndex &aparent)
{ return QAbstractItemModel::insertRow(arow, aparent); }
inline bool QStandardItemModel::insertColumn(int acolumn, const QModelIndex &aparent)
{ return QAbstractItemModel::insertColumn(acolumn, aparent); }


# 445 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"
 QDataStream &operator>>(QDataStream &in, QStandardItem &item);
 QDataStream &operator<<(QDataStream &out, const QStandardItem &item);




# 451 "/usr/share/qt4/include/QtGui/qstandarditemmodel.h"





# 55 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qstringlistmodel.h"












































# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"



































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qstringlistmodel.h"

# 1 "/usr/share/qt4/include/QtGui/qabstractitemview.h"

























































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qstringlistmodel.h"


# 48 "/usr/share/qt4/include/QtGui/qstringlistmodel.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qstringlistmodel.h"
class  QStringListModel : public QAbstractListModel
{
Q_OBJECT
public:
explicit QStringListModel(QObject *parent = 0);
QStringListModel(const QStringList &strings, QObject *parent = 0);

int rowCount(const QModelIndex &parent = QModelIndex()) const;

QVariant data(const QModelIndex &index, int role) const;
bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

Qt::ItemFlags flags(const QModelIndex &index) const;

bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());

void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);

QStringList stringList() const;
void setStringList(const QStringList &strings);

Qt::DropActions supportedDropActions() const;

private:
QStringListModel(const QStringListModel &); QStringListModel &operator=(const QStringListModel &);
QStringList lst;
};



# 87 "/usr/share/qt4/include/QtGui/qstringlistmodel.h"





# 56 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qstyleditemdelegate.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractitemdelegate.h"






































































































































# 45 "/usr/share/qt4/include/QtGui/qstyleditemdelegate.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qstyleditemdelegate.h"

# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qstyleditemdelegate.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qstyleditemdelegate.h"


# 50 "/usr/share/qt4/include/QtGui/qstyleditemdelegate.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 58 "/usr/share/qt4/include/QtGui/qstyleditemdelegate.h"
class QStyledItemDelegatePrivate;
class QItemEditorFactory;

class  QStyledItemDelegate : public QAbstractItemDelegate
{
Q_OBJECT

public:
explicit QStyledItemDelegate(QObject *parent = 0);
~QStyledItemDelegate();


void paint(QPainter *painter,
const QStyleOptionViewItem &option, const QModelIndex &index) const;
QSize sizeHint(const QStyleOptionViewItem &option,
const QModelIndex &index) const;


QWidget *createEditor(QWidget *parent,
const QStyleOptionViewItem &option,
const QModelIndex &index) const;

void setEditorData(QWidget *editor, const QModelIndex &index) const;
void setModelData(QWidget *editor,
QAbstractItemModel *model,
const QModelIndex &index) const;

void updateEditorGeometry(QWidget *editor,
const QStyleOptionViewItem &option,
const QModelIndex &index) const;


QItemEditorFactory *itemEditorFactory() const;
void setItemEditorFactory(QItemEditorFactory *factory);

virtual QString displayText(const QVariant &value, const QLocale &locale) const;

protected:
virtual void initStyleOption(QStyleOptionViewItem *option,
const QModelIndex &index) const;

bool eventFilter(QObject *object, QEvent *event);
bool editorEvent(QEvent *event, QAbstractItemModel *model,
const QStyleOptionViewItem &option, const QModelIndex &index);

private:
inline QStyledItemDelegatePrivate* d_func() { return reinterpret_cast<QStyledItemDelegatePrivate *>(qGetPtrHelper(d_ptr)); } inline const QStyledItemDelegatePrivate* d_func() const { return reinterpret_cast<const QStyledItemDelegatePrivate *>(qGetPtrHelper(d_ptr)); } friend class QStyledItemDelegatePrivate;
QStyledItemDelegate(const QStyledItemDelegate &); QStyledItemDelegate &operator=(const QStyledItemDelegate &);


};



# 112 "/usr/share/qt4/include/QtGui/qstyleditemdelegate.h"





# 57 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtableview.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractitemview.h"

























































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtableview.h"


# 47 "/usr/share/qt4/include/QtGui/qtableview.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qtableview.h"
class QHeaderView;
class QTableViewPrivate;

class  QTableView : public QAbstractItemView
{
Q_OBJECT
Q_PROPERTY(bool showGrid READ showGrid WRITE setShowGrid)
Q_PROPERTY(Qt::PenStyle gridStyle READ gridStyle WRITE setGridStyle)
Q_PROPERTY(bool sortingEnabled READ isSortingEnabled WRITE setSortingEnabled)
Q_PROPERTY(bool wordWrap READ wordWrap WRITE setWordWrap)
Q_PROPERTY(bool cornerButtonEnabled READ isCornerButtonEnabled WRITE setCornerButtonEnabled)

public:
explicit QTableView(QWidget *parent = 0);
~QTableView();

void setModel(QAbstractItemModel *model);
void setRootIndex(const QModelIndex &index);
void setSelectionModel(QItemSelectionModel *selectionModel);

QHeaderView *horizontalHeader() const;
QHeaderView *verticalHeader() const;
void setHorizontalHeader(QHeaderView *header);
void setVerticalHeader(QHeaderView *header);

int rowViewportPosition(int row) const;
int rowAt(int y) const;

void setRowHeight(int row, int height);
int rowHeight(int row) const;

int columnViewportPosition(int column) const;
int columnAt(int x) const;

void setColumnWidth(int column, int width);
int columnWidth(int column) const;

bool isRowHidden(int row) const;
void setRowHidden(int row, bool hide);

bool isColumnHidden(int column) const;
void setColumnHidden(int column, bool hide);

void setSortingEnabled(bool enable);
bool isSortingEnabled() const;

bool showGrid() const;

Qt::PenStyle gridStyle() const;
void setGridStyle(Qt::PenStyle style);

void setWordWrap(bool on);
bool wordWrap() const;

void setCornerButtonEnabled(bool enable);
bool isCornerButtonEnabled() const;

QRect visualRect(const QModelIndex &index) const;
void scrollTo(const QModelIndex &index, ScrollHint hint = EnsureVisible);
QModelIndex indexAt(const QPoint &p) const;

void setSpan(int row, int column, int rowSpan, int columnSpan);
int rowSpan(int row, int column) const;
int columnSpan(int row, int column) const;
void clearSpans();

void sortByColumn(int column, Qt::SortOrder order);

public slots:
void selectRow(int row);
void selectColumn(int column);
void hideRow(int row);
void hideColumn(int column);
void showRow(int row);
void showColumn(int column);
void resizeRowToContents(int row);
void resizeRowsToContents();
void resizeColumnToContents(int column);
void resizeColumnsToContents();
void sortByColumn(int column);
void setShowGrid(bool show);

protected slots:
void rowMoved(int row, int oldIndex, int newIndex);
void columnMoved(int column, int oldIndex, int newIndex);
void rowResized(int row, int oldHeight, int newHeight);
void columnResized(int column, int oldWidth, int newWidth);
void rowCountChanged(int oldCount, int newCount);
void columnCountChanged(int oldCount, int newCount);

protected:
QTableView(QTableViewPrivate &, QWidget *parent);
void scrollContentsBy(int dx, int dy);

QStyleOptionViewItem viewOptions() const;
void paintEvent(QPaintEvent *e);

void timerEvent(QTimerEvent *event);

int horizontalOffset() const;
int verticalOffset() const;
QModelIndex moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers);

void setSelection(const QRect &rect, QItemSelectionModel::SelectionFlags command);
QRegion visualRegionForSelection(const QItemSelection &selection) const;
QModelIndexList selectedIndexes() const;

void updateGeometries();

int sizeHintForRow(int row) const;
int sizeHintForColumn(int column) const;

void verticalScrollbarAction(int action);
void horizontalScrollbarAction(int action);

bool isIndexHidden(const QModelIndex &index) const;

void selectionChanged(const QItemSelection &selected,
const QItemSelection &deselected);
void currentChanged(const QModelIndex &current,
const QModelIndex &previous);

private:
friend class QAccessibleItemView;
int visualIndex(const QModelIndex &index) const;

inline QTableViewPrivate* d_func() { return reinterpret_cast<QTableViewPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTableViewPrivate* d_func() const { return reinterpret_cast<const QTableViewPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTableViewPrivate;
QTableView(const QTableView &); QTableView &operator=(const QTableView &);






};



# 193 "/usr/share/qt4/include/QtGui/qtableview.h"





# 58 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtablewidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qtableview.h"





































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtablewidget.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qtablewidget.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qtablewidget.h"

# 48 "/usr/share/qt4/include/QtGui/qtablewidget.h"






typedef QtValidLicenseForGuiModule QtGuiModule;



# 58 "/usr/share/qt4/include/QtGui/qtablewidget.h"
class  QTableWidgetSelectionRange
{
public:
QTableWidgetSelectionRange();
QTableWidgetSelectionRange(int top, int left, int bottom, int right);
QTableWidgetSelectionRange(const QTableWidgetSelectionRange &other);
~QTableWidgetSelectionRange();

inline int topRow() const { return top; }
inline int bottomRow() const { return bottom; }
inline int leftColumn() const { return left; }
inline int rightColumn() const { return right; }
inline int rowCount() const { return bottom - top + 1; }
inline int columnCount() const { return right - left + 1; }

private:
int top, left, bottom, right;
};

class QTableWidget;
class QTableModel;
class QWidgetItemData;
class QTableWidgetItemPrivate;

class  QTableWidgetItem
{
friend class QTableWidget;
friend class QTableModel;
public:
enum ItemType { Type = 0, UserType = 1000 };
QTableWidgetItem(int type = Type);
explicit QTableWidgetItem(const QString &text, int type = Type);
explicit QTableWidgetItem(const QIcon &icon, const QString &text, int type = Type);
QTableWidgetItem(const QTableWidgetItem &other);
virtual ~QTableWidgetItem();

virtual QTableWidgetItem *clone() const;

inline QTableWidget *tableWidget() const { return view; }

inline int row() const;
inline int column() const;

inline void setSelected(bool select);
inline bool isSelected() const;

inline Qt::ItemFlags flags() const { return itemFlags; }
void setFlags(Qt::ItemFlags flags);

inline QString text() const
{ return data(Qt::DisplayRole).toString(); }
inline void setText(const QString &text);

inline QIcon icon() const
{ return qvariant_cast<QIcon>(data(Qt::DecorationRole)); }
inline void setIcon(const QIcon &icon);

inline QString statusTip() const
{ return data(Qt::StatusTipRole).toString(); }
inline void setStatusTip(const QString &statusTip);


# 120 "/usr/share/qt4/include/QtGui/qtablewidget.h"
inline QString toolTip() const
{ return data(Qt::ToolTipRole).toString(); }
inline void setToolTip(const QString &toolTip);



# 126 "/usr/share/qt4/include/QtGui/qtablewidget.h"
inline QString whatsThis() const
{ return data(Qt::WhatsThisRole).toString(); }
inline void setWhatsThis(const QString &whatsThis);


# 131 "/usr/share/qt4/include/QtGui/qtablewidget.h"
inline QFont font() const
{ return qvariant_cast<QFont>(data(Qt::FontRole)); }
inline void setFont(const QFont &font);

inline int textAlignment() const
{ return data(Qt::TextAlignmentRole).toInt(); }
inline void setTextAlignment(int alignment)
{ setData(Qt::TextAlignmentRole, alignment); }

inline QColor backgroundColor() const
{ return qvariant_cast<QColor>(data(Qt::BackgroundColorRole)); }
inline void setBackgroundColor(const QColor &color)
{ setData(Qt::BackgroundColorRole, color); }

inline QBrush background() const
{ return qvariant_cast<QBrush>(data(Qt::BackgroundRole)); }
inline void setBackground(const QBrush &brush)
{ setData(Qt::BackgroundRole, brush); }

inline QColor textColor() const
{ return qvariant_cast<QColor>(data(Qt::TextColorRole)); }
inline void setTextColor(const QColor &color)
{ setData(Qt::TextColorRole, color); }

inline QBrush foreground() const
{ return qvariant_cast<QBrush>(data(Qt::ForegroundRole)); }
inline void setForeground(const QBrush &brush)
{ setData(Qt::ForegroundRole, brush); }

inline Qt::CheckState checkState() const
{ return static_cast<Qt::CheckState>(data(Qt::CheckStateRole).toInt()); }
inline void setCheckState(Qt::CheckState state)
{ setData(Qt::CheckStateRole, state); }

inline QSize sizeHint() const
{ return qvariant_cast<QSize>(data(Qt::SizeHintRole)); }
inline void setSizeHint(const QSize &size)
{ setData(Qt::SizeHintRole, size); }

virtual QVariant data(int role) const;
virtual void setData(int role, const QVariant &value);

virtual bool operator<(const QTableWidgetItem &other) const;


# 176 "/usr/share/qt4/include/QtGui/qtablewidget.h"
virtual void read(QDataStream &in);
virtual void write(QDataStream &out) const;

# 179 "/usr/share/qt4/include/QtGui/qtablewidget.h"
QTableWidgetItem &operator=(const QTableWidgetItem &other);

inline int type() const { return rtti; }

private:
int rtti;
QVector<QWidgetItemData> values;
QTableWidget *view;
QTableWidgetItemPrivate *d;
Qt::ItemFlags itemFlags;
};

inline void QTableWidgetItem::setText(const QString &atext)
{ setData(Qt::DisplayRole, atext); }

inline void QTableWidgetItem::setIcon(const QIcon &aicon)
{ setData(Qt::DecorationRole, aicon); }

inline void QTableWidgetItem::setStatusTip(const QString &astatusTip)
{ setData(Qt::StatusTipRole, astatusTip); }


# 201 "/usr/share/qt4/include/QtGui/qtablewidget.h"
inline void QTableWidgetItem::setToolTip(const QString &atoolTip)
{ setData(Qt::ToolTipRole, atoolTip); }



# 206 "/usr/share/qt4/include/QtGui/qtablewidget.h"
inline void QTableWidgetItem::setWhatsThis(const QString &awhatsThis)
{ setData(Qt::WhatsThisRole, awhatsThis); }


# 210 "/usr/share/qt4/include/QtGui/qtablewidget.h"
inline void QTableWidgetItem::setFont(const QFont &afont)
{ setData(Qt::FontRole, afont); }


# 214 "/usr/share/qt4/include/QtGui/qtablewidget.h"
 QDataStream &operator>>(QDataStream &in, QTableWidgetItem &item);
 QDataStream &operator<<(QDataStream &out, const QTableWidgetItem &item);


# 218 "/usr/share/qt4/include/QtGui/qtablewidget.h"
class QTableWidgetPrivate;

class  QTableWidget : public QTableView
{
Q_OBJECT
Q_PROPERTY(int rowCount READ rowCount WRITE setRowCount)
Q_PROPERTY(int columnCount READ columnCount WRITE setColumnCount)

friend class QTableModel;
public:
explicit QTableWidget(QWidget *parent = 0);
QTableWidget(int rows, int columns, QWidget *parent = 0);
~QTableWidget();

void setRowCount(int rows);
int rowCount() const;

void setColumnCount(int columns);
int columnCount() const;

int row(const QTableWidgetItem *item) const;
int column(const QTableWidgetItem *item) const;

QTableWidgetItem *item(int row, int column) const;
void setItem(int row, int column, QTableWidgetItem *item);
QTableWidgetItem *takeItem(int row, int column);

QTableWidgetItem *verticalHeaderItem(int row) const;
void setVerticalHeaderItem(int row, QTableWidgetItem *item);
QTableWidgetItem *takeVerticalHeaderItem(int row);

QTableWidgetItem *horizontalHeaderItem(int column) const;
void setHorizontalHeaderItem(int column, QTableWidgetItem *item);
QTableWidgetItem *takeHorizontalHeaderItem(int column);
void setVerticalHeaderLabels(const QStringList &labels);
void setHorizontalHeaderLabels(const QStringList &labels);

int currentRow() const;
int currentColumn() const;
QTableWidgetItem *currentItem() const;
void setCurrentItem(QTableWidgetItem *item);
void setCurrentItem(QTableWidgetItem *item, QItemSelectionModel::SelectionFlags command);
void setCurrentCell(int row, int column);
void setCurrentCell(int row, int column, QItemSelectionModel::SelectionFlags command);

void sortItems(int column, Qt::SortOrder order = Qt::AscendingOrder);
void setSortingEnabled(bool enable);
bool isSortingEnabled() const;

void editItem(QTableWidgetItem *item);
void openPersistentEditor(QTableWidgetItem *item);
void closePersistentEditor(QTableWidgetItem *item);

QWidget *cellWidget(int row, int column) const;
void setCellWidget(int row, int column, QWidget *widget);
inline void removeCellWidget(int row, int column);

bool isItemSelected(const QTableWidgetItem *item) const;
void setItemSelected(const QTableWidgetItem *item, bool select);
void setRangeSelected(const QTableWidgetSelectionRange &range, bool select);

QList<QTableWidgetSelectionRange> selectedRanges() const;
QList<QTableWidgetItem*> selectedItems();
QList<QTableWidgetItem*> findItems(const QString &text, Qt::MatchFlags flags) const;

int visualRow(int logicalRow) const;
int visualColumn(int logicalColumn) const;

QTableWidgetItem *itemAt(const QPoint &p) const;
inline QTableWidgetItem *itemAt(int x, int y) const;
QRect visualItemRect(const QTableWidgetItem *item) const;

const QTableWidgetItem *itemPrototype() const;
void setItemPrototype(const QTableWidgetItem *item);

public slots:
void scrollToItem(const QTableWidgetItem *item, QAbstractItemView::ScrollHint hint = EnsureVisible);
void insertRow(int row);
void insertColumn(int column);
void removeRow(int row);
void removeColumn(int column);
void clear();
void clearContents();

signals:
void itemPressed(QTableWidgetItem *item);
void itemClicked(QTableWidgetItem *item);
void itemDoubleClicked(QTableWidgetItem *item);

void itemActivated(QTableWidgetItem *item);
void itemEntered(QTableWidgetItem *item);
void itemChanged(QTableWidgetItem *item);

void currentItemChanged(QTableWidgetItem *current, QTableWidgetItem *previous);
void itemSelectionChanged();

void cellPressed(int row, int column);
void cellClicked(int row, int column);
void cellDoubleClicked(int row, int column);

void cellActivated(int row, int column);
void cellEntered(int row, int column);
void cellChanged(int row, int column);

void currentCellChanged(int currentRow, int currentColumn, int previousRow, int previousColumn);

protected:
bool event(QEvent *e);
virtual QStringList mimeTypes() const;
virtual QMimeData *mimeData(const QList<QTableWidgetItem*> items) const;
virtual bool dropMimeData(int row, int column, const QMimeData *data, Qt::DropAction action);
virtual Qt::DropActions supportedDropActions() const;
QList<QTableWidgetItem*> items(const QMimeData *data) const;

QModelIndex indexFromItem(QTableWidgetItem *item) const;
QTableWidgetItem *itemFromIndex(const QModelIndex &index) const;
void dropEvent(QDropEvent *event);

private:
void setModel(QAbstractItemModel *model);

inline QTableWidgetPrivate* d_func() { return reinterpret_cast<QTableWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTableWidgetPrivate* d_func() const { return reinterpret_cast<const QTableWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTableWidgetPrivate;
QTableWidget(const QTableWidget &); QTableWidget &operator=(const QTableWidget &);










};

inline void QTableWidget::removeCellWidget(int arow, int acolumn)
{ setCellWidget(arow, acolumn, 0); }

inline QTableWidgetItem *QTableWidget::itemAt(int ax, int ay) const
{ return itemAt(QPoint(ax, ay)); }

inline int QTableWidgetItem::row() const
{ return (view ? view->row(this) : -1); }

inline int QTableWidgetItem::column() const
{ return (view ? view->column(this) : -1); }

inline void QTableWidgetItem::setSelected(bool aselect)
{ if (view) view->setItemSelected(this, aselect); }

inline bool QTableWidgetItem::isSelected() const
{ return (view ? view->isItemSelected(this) : false); }



# 373 "/usr/share/qt4/include/QtGui/qtablewidget.h"





# 59 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtreeview.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractitemview.h"

























































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtreeview.h"


# 47 "/usr/share/qt4/include/QtGui/qtreeview.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qtreeview.h"
class QTreeViewPrivate;
class QHeaderView;

class  QTreeView : public QAbstractItemView
{
Q_OBJECT
Q_PROPERTY(int autoExpandDelay READ autoExpandDelay WRITE setAutoExpandDelay)
Q_PROPERTY(int indentation READ indentation WRITE setIndentation)
Q_PROPERTY(bool rootIsDecorated READ rootIsDecorated WRITE setRootIsDecorated)
Q_PROPERTY(bool uniformRowHeights READ uniformRowHeights WRITE setUniformRowHeights)
Q_PROPERTY(bool itemsExpandable READ itemsExpandable WRITE setItemsExpandable)
Q_PROPERTY(bool sortingEnabled READ isSortingEnabled WRITE setSortingEnabled)
Q_PROPERTY(bool animated READ isAnimated WRITE setAnimated)
Q_PROPERTY(bool allColumnsShowFocus READ allColumnsShowFocus WRITE setAllColumnsShowFocus)
Q_PROPERTY(bool wordWrap READ wordWrap WRITE setWordWrap)
Q_PROPERTY(bool headerHidden READ isHeaderHidden WRITE setHeaderHidden)
Q_PROPERTY(bool expandsOnDoubleClick READ expandsOnDoubleClick WRITE setExpandsOnDoubleClick)

public:
explicit QTreeView(QWidget *parent = 0);
~QTreeView();

void setModel(QAbstractItemModel *model);
void setRootIndex(const QModelIndex &index);
void setSelectionModel(QItemSelectionModel *selectionModel);

QHeaderView *header() const;
void setHeader(QHeaderView *header);

int autoExpandDelay() const;
void setAutoExpandDelay(int delay);

int indentation() const;
void setIndentation(int i);

bool rootIsDecorated() const;
void setRootIsDecorated(bool show);

bool uniformRowHeights() const;
void setUniformRowHeights(bool uniform);

bool itemsExpandable() const;
void setItemsExpandable(bool enable);

bool expandsOnDoubleClick() const;
void setExpandsOnDoubleClick(bool enable);

int columnViewportPosition(int column) const;
int columnWidth(int column) const;
void setColumnWidth(int column, int width);
int columnAt(int x) const;

bool isColumnHidden(int column) const;
void setColumnHidden(int column, bool hide);

bool isHeaderHidden() const;
void setHeaderHidden(bool hide);

bool isRowHidden(int row, const QModelIndex &parent) const;
void setRowHidden(int row, const QModelIndex &parent, bool hide);

bool isFirstColumnSpanned(int row, const QModelIndex &parent) const;
void setFirstColumnSpanned(int row, const QModelIndex &parent, bool span);

bool isExpanded(const QModelIndex &index) const;
void setExpanded(const QModelIndex &index, bool expand);

void setSortingEnabled(bool enable);
bool isSortingEnabled() const;

void setAnimated(bool enable);
bool isAnimated() const;

void setAllColumnsShowFocus(bool enable);
bool allColumnsShowFocus() const;

void setWordWrap(bool on);
bool wordWrap() const;

void keyboardSearch(const QString &search);

QRect visualRect(const QModelIndex &index) const;
void scrollTo(const QModelIndex &index, ScrollHint hint = EnsureVisible);
QModelIndex indexAt(const QPoint &p) const;
QModelIndex indexAbove(const QModelIndex &index) const;
QModelIndex indexBelow(const QModelIndex &index) const;

void doItemsLayout();
void reset();

void sortByColumn(int column, Qt::SortOrder order);

void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight);
void selectAll();

signals:
void expanded(const QModelIndex &index);
void collapsed(const QModelIndex &index);

public slots:
void hideColumn(int column);
void showColumn(int column);
void expand(const QModelIndex &index);
void collapse(const QModelIndex &index);
void resizeColumnToContents(int column);
void sortByColumn(int column);
void expandAll();
void collapseAll();
void expandToDepth(int depth);

protected slots:
void columnResized(int column, int oldSize, int newSize);
void columnCountChanged(int oldCount, int newCount);
void columnMoved();
void reexpand();
void rowsRemoved(const QModelIndex &parent, int first, int last);

protected:
QTreeView(QTreeViewPrivate &dd, QWidget *parent = 0);
void scrollContentsBy(int dx, int dy);
void rowsInserted(const QModelIndex &parent, int start, int end);
void rowsAboutToBeRemoved(const QModelIndex &parent, int start, int end);

QModelIndex moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers);
int horizontalOffset() const;
int verticalOffset() const;

void setSelection(const QRect &rect, QItemSelectionModel::SelectionFlags command);
QRegion visualRegionForSelection(const QItemSelection &selection) const;
QModelIndexList selectedIndexes() const;

void timerEvent(QTimerEvent *event);
void paintEvent(QPaintEvent *event);

void drawTree(QPainter *painter, const QRegion &region) const;
virtual void drawRow(QPainter *painter,
const QStyleOptionViewItem &options,
const QModelIndex &index) const;
virtual void drawBranches(QPainter *painter,
const QRect &rect,
const QModelIndex &index) const;

void mousePressEvent(QMouseEvent *event);
void mouseReleaseEvent(QMouseEvent *event);
void mouseDoubleClickEvent(QMouseEvent *event);
void mouseMoveEvent(QMouseEvent *event);
void keyPressEvent(QKeyEvent *event);

# 203 "/usr/share/qt4/include/QtGui/qtreeview.h"
void dragMoveEvent(QDragMoveEvent *event);

# 205 "/usr/share/qt4/include/QtGui/qtreeview.h"
bool viewportEvent(QEvent *event);

void updateGeometries();

int sizeHintForColumn(int column) const;
int indexRowSizeHint(const QModelIndex &index) const;
int rowHeight(const QModelIndex &index) const;

void horizontalScrollbarAction(int action);

bool isIndexHidden(const QModelIndex &index) const;
void selectionChanged(const QItemSelection &selected,
const QItemSelection &deselected);
void currentChanged(const QModelIndex &current, const QModelIndex &previous);

private:
friend class QAccessibleItemView;
int visualIndex(const QModelIndex &index) const;

inline QTreeViewPrivate* d_func() { return reinterpret_cast<QTreeViewPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTreeViewPrivate* d_func() const { return reinterpret_cast<const QTreeViewPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTreeViewPrivate;
QTreeView(const QTreeView &); QTreeView &operator=(const QTreeView &);

# 227 "/usr/share/qt4/include/QtGui/qtreeview.h"


# 229 "/usr/share/qt4/include/QtGui/qtreeview.h"


};



# 235 "/usr/share/qt4/include/QtGui/qtreeview.h"





# 60 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtreewidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qtreeview.h"















































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtreewidget.h"

# 1 "/usr/share/qt4/include/QtGui/qtreewidgetitemiterator.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtreewidgetitemiterator.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 46 "/usr/share/qt4/include/QtGui/qtreewidgetitemiterator.h"


# 48 "/usr/share/qt4/include/QtGui/qtreewidgetitemiterator.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qtreewidgetitemiterator.h"
class QTreeWidget;
class QTreeWidgetItem;
class QTreeModel;

class QTreeWidgetItemIteratorPrivate;
class  QTreeWidgetItemIterator
{
friend class QTreeModel;

public:
enum IteratorFlag {
All = 0x00000000,
Hidden = 0x00000001,
NotHidden = 0x00000002,
Selected = 0x00000004,
Unselected = 0x00000008,
Selectable = 0x00000010,
NotSelectable = 0x00000020,
DragEnabled = 0x00000040,
DragDisabled = 0x00000080,
DropEnabled = 0x00000100,
DropDisabled = 0x00000200,
HasChildren = 0x00000400,
NoChildren = 0x00000800,
Checked = 0x00001000,
NotChecked = 0x00002000,
Enabled = 0x00004000,
Disabled = 0x00008000,
Editable = 0x00010000,
NotEditable = 0x00020000,
UserFlag = 0x01000000 
};
typedef QFlags<IteratorFlag> IteratorFlags;

QTreeWidgetItemIterator(const QTreeWidgetItemIterator &it);
explicit QTreeWidgetItemIterator(QTreeWidget *widget, IteratorFlags flags = All);
explicit QTreeWidgetItemIterator(QTreeWidgetItem *item, IteratorFlags flags = All);
~QTreeWidgetItemIterator();

QTreeWidgetItemIterator &operator=(const QTreeWidgetItemIterator &it);

QTreeWidgetItemIterator &operator++();
inline const QTreeWidgetItemIterator operator++(int);
inline QTreeWidgetItemIterator &operator+=(int n);

QTreeWidgetItemIterator &operator--();
inline const QTreeWidgetItemIterator operator--(int);
inline QTreeWidgetItemIterator &operator-=(int n);

inline QTreeWidgetItem *operator*() const;

private:
bool matchesFlags(const QTreeWidgetItem *item) const;
QScopedPointer<QTreeWidgetItemIteratorPrivate> d_ptr;
QTreeWidgetItem *current;
IteratorFlags flags;
inline QTreeWidgetItemIteratorPrivate* d_func() { return reinterpret_cast<QTreeWidgetItemIteratorPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTreeWidgetItemIteratorPrivate* d_func() const { return reinterpret_cast<const QTreeWidgetItemIteratorPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTreeWidgetItemIteratorPrivate;
};

inline const QTreeWidgetItemIterator QTreeWidgetItemIterator::operator++(int)
{
QTreeWidgetItemIterator it = *this;
++(*this);
return it;
}

inline const QTreeWidgetItemIterator QTreeWidgetItemIterator::operator--(int)
{
QTreeWidgetItemIterator it = *this;
--(*this);
return it;
}

inline QTreeWidgetItemIterator &QTreeWidgetItemIterator::operator+=(int n)
{
if (n < 0)
return (*this) -= (-n);
while (current && n--)
++(*this);
return *this;
}

inline QTreeWidgetItemIterator &QTreeWidgetItemIterator::operator-=(int n)
{
if (n < 0)
return (*this) += (-n);
while (current && n--)
--(*this);
return *this;
}

inline QTreeWidgetItem *QTreeWidgetItemIterator::operator*() const
{
return current;
}

inline QFlags<QTreeWidgetItemIterator::IteratorFlags::enum_type> operator|(QTreeWidgetItemIterator::IteratorFlags::enum_type f1, QTreeWidgetItemIterator::IteratorFlags::enum_type f2) { return QFlags<QTreeWidgetItemIterator::IteratorFlags::enum_type>(f1) | f2; } inline QFlags<QTreeWidgetItemIterator::IteratorFlags::enum_type> operator|(QTreeWidgetItemIterator::IteratorFlags::enum_type f1, QFlags<QTreeWidgetItemIterator::IteratorFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTreeWidgetItemIterator::IteratorFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }




# 157 "/usr/share/qt4/include/QtGui/qtreewidgetitemiterator.h"



# 46 "/usr/share/qt4/include/QtGui/qtreewidget.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qtreewidget.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qtreewidget.h"


# 50 "/usr/share/qt4/include/QtGui/qtreewidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 58 "/usr/share/qt4/include/QtGui/qtreewidget.h"
class QTreeWidget;
class QTreeModel;
class QWidgetItemData;
class QTreeWidgetItemPrivate;

class  QTreeWidgetItem
{
friend class QTreeModel;
friend class QTreeWidget;
friend class QTreeWidgetPrivate;
friend class QTreeWidgetItemIterator;
friend class QTreeWidgetItemPrivate;
public:
enum ItemType { Type = 0, UserType = 1000 };
explicit QTreeWidgetItem(int type = Type);
QTreeWidgetItem(const QStringList &strings, int type = Type);
explicit QTreeWidgetItem(QTreeWidget *view, int type = Type);
QTreeWidgetItem(QTreeWidget *view, const QStringList &strings, int type = Type);
QTreeWidgetItem(QTreeWidget *view, QTreeWidgetItem *after, int type = Type);
explicit QTreeWidgetItem(QTreeWidgetItem *parent, int type = Type);
QTreeWidgetItem(QTreeWidgetItem *parent, const QStringList &strings, int type = Type);
QTreeWidgetItem(QTreeWidgetItem *parent, QTreeWidgetItem *after, int type = Type);
QTreeWidgetItem(const QTreeWidgetItem &other);
virtual ~QTreeWidgetItem();

virtual QTreeWidgetItem *clone() const;

inline QTreeWidget *treeWidget() const { return view; }

inline void setSelected(bool select);
inline bool isSelected() const;

inline void setHidden(bool hide);
inline bool isHidden() const;

inline void setExpanded(bool expand);
inline bool isExpanded() const;

inline void setFirstColumnSpanned(bool span);
inline bool isFirstColumnSpanned() const;

inline void setDisabled(bool disabled);
inline bool isDisabled() const;

enum ChildIndicatorPolicy { ShowIndicator, DontShowIndicator, DontShowIndicatorWhenChildless };
void setChildIndicatorPolicy(QTreeWidgetItem::ChildIndicatorPolicy policy);
QTreeWidgetItem::ChildIndicatorPolicy childIndicatorPolicy() const;

Qt::ItemFlags flags() const;
void setFlags(Qt::ItemFlags flags);

inline QString text(int column) const
{ return data(column, Qt::DisplayRole).toString(); }
inline void setText(int column, const QString &text);

inline QIcon icon(int column) const
{ return qvariant_cast<QIcon>(data(column, Qt::DecorationRole)); }
inline void setIcon(int column, const QIcon &icon);

inline QString statusTip(int column) const
{ return data(column, Qt::StatusTipRole).toString(); }
inline void setStatusTip(int column, const QString &statusTip);


# 122 "/usr/share/qt4/include/QtGui/qtreewidget.h"
inline QString toolTip(int column) const
{ return data(column, Qt::ToolTipRole).toString(); }
inline void setToolTip(int column, const QString &toolTip);



# 128 "/usr/share/qt4/include/QtGui/qtreewidget.h"
inline QString whatsThis(int column) const
{ return data(column, Qt::WhatsThisRole).toString(); }
inline void setWhatsThis(int column, const QString &whatsThis);


# 133 "/usr/share/qt4/include/QtGui/qtreewidget.h"
inline QFont font(int column) const
{ return qvariant_cast<QFont>(data(column, Qt::FontRole)); }
inline void setFont(int column, const QFont &font);

inline int textAlignment(int column) const
{ return data(column, Qt::TextAlignmentRole).toInt(); }
inline void setTextAlignment(int column, int alignment)
{ setData(column, Qt::TextAlignmentRole, alignment); }

inline QColor backgroundColor(int column) const
{ return qvariant_cast<QColor>(data(column, Qt::BackgroundColorRole)); }
inline void setBackgroundColor(int column, const QColor &color)
{ setData(column, Qt::BackgroundColorRole, color); }

inline QBrush background(int column) const
{ return qvariant_cast<QBrush>(data(column, Qt::BackgroundRole)); }
inline void setBackground(int column, const QBrush &brush)
{ setData(column, Qt::BackgroundRole, brush); }

inline QColor textColor(int column) const
{ return qvariant_cast<QColor>(data(column, Qt::TextColorRole)); }
inline void setTextColor(int column, const QColor &color)
{ setData(column, Qt::TextColorRole, color); }

inline QBrush foreground(int column) const
{ return qvariant_cast<QBrush>(data(column, Qt::ForegroundRole)); }
inline void setForeground(int column, const QBrush &brush)
{ setData(column, Qt::ForegroundRole, brush); }

inline Qt::CheckState checkState(int column) const
{ return static_cast<Qt::CheckState>(data(column, Qt::CheckStateRole).toInt()); }
inline void setCheckState(int column, Qt::CheckState state)
{ setData(column, Qt::CheckStateRole, state); }

inline QSize sizeHint(int column) const
{ return qvariant_cast<QSize>(data(column, Qt::SizeHintRole)); }
inline void setSizeHint(int column, const QSize &size)
{ setData(column, Qt::SizeHintRole, size); }

virtual QVariant data(int column, int role) const;
virtual void setData(int column, int role, const QVariant &value);

virtual bool operator<(const QTreeWidgetItem &other) const;


# 178 "/usr/share/qt4/include/QtGui/qtreewidget.h"
virtual void read(QDataStream &in);
virtual void write(QDataStream &out) const;

# 181 "/usr/share/qt4/include/QtGui/qtreewidget.h"
QTreeWidgetItem &operator=(const QTreeWidgetItem &other);

inline QTreeWidgetItem *parent() const { return par; }
inline QTreeWidgetItem *child(int index) const {
if (index < 0 || index >= children.size())
return 0;
executePendingSort();
return children.at(index);
}
inline int childCount() const { return children.count(); }
inline int columnCount() const { return values.count(); }
inline int indexOfChild(QTreeWidgetItem *child) const;

void addChild(QTreeWidgetItem *child);
void insertChild(int index, QTreeWidgetItem *child);
void removeChild(QTreeWidgetItem *child);
QTreeWidgetItem *takeChild(int index);

void addChildren(const QList<QTreeWidgetItem*> &children);
void insertChildren(int index, const QList<QTreeWidgetItem*> &children);
QList<QTreeWidgetItem*> takeChildren();

inline int type() const { return rtti; }
inline void sortChildren(int column, Qt::SortOrder order)
{ sortChildren(column, order, false); }

protected:
void emitDataChanged();

private:
void sortChildren(int column, Qt::SortOrder order, bool climb);
QVariant childrenCheckState(int column) const;
void itemChanged();
void executePendingSort() const;

int rtti;

QVector< QVector<QWidgetItemData> > values;
QTreeWidget *view;
QTreeWidgetItemPrivate *d;
QTreeWidgetItem *par;
QList<QTreeWidgetItem*> children;
Qt::ItemFlags itemFlags;
};

inline void QTreeWidgetItem::setText(int column, const QString &atext)
{ setData(column, Qt::DisplayRole, atext); }

inline void QTreeWidgetItem::setIcon(int column, const QIcon &aicon)
{ setData(column, Qt::DecorationRole, aicon); }


# 233 "/usr/share/qt4/include/QtGui/qtreewidget.h"
inline void QTreeWidgetItem::setStatusTip(int column, const QString &astatusTip)
{ setData(column, Qt::StatusTipRole, astatusTip); }



# 238 "/usr/share/qt4/include/QtGui/qtreewidget.h"
inline void QTreeWidgetItem::setToolTip(int column, const QString &atoolTip)
{ setData(column, Qt::ToolTipRole, atoolTip); }



# 243 "/usr/share/qt4/include/QtGui/qtreewidget.h"
inline void QTreeWidgetItem::setWhatsThis(int column, const QString &awhatsThis)
{ setData(column, Qt::WhatsThisRole, awhatsThis); }


# 247 "/usr/share/qt4/include/QtGui/qtreewidget.h"
inline void QTreeWidgetItem::setFont(int column, const QFont &afont)
{ setData(column, Qt::FontRole, afont); }

inline int QTreeWidgetItem::indexOfChild(QTreeWidgetItem *achild) const
{ executePendingSort(); return children.indexOf(achild); }


# 254 "/usr/share/qt4/include/QtGui/qtreewidget.h"
 QDataStream &operator<<(QDataStream &out, const QTreeWidgetItem &item);
 QDataStream &operator>>(QDataStream &in, QTreeWidgetItem &item);


# 258 "/usr/share/qt4/include/QtGui/qtreewidget.h"
class QTreeWidgetPrivate;

class  QTreeWidget : public QTreeView
{
Q_OBJECT
Q_PROPERTY(int columnCount READ columnCount WRITE setColumnCount)
Q_PROPERTY(int topLevelItemCount READ topLevelItemCount)

friend class QTreeModel;
friend class QTreeWidgetItem;
public:
explicit QTreeWidget(QWidget *parent = 0);
~QTreeWidget();

int columnCount() const;
void setColumnCount(int columns);

QTreeWidgetItem *invisibleRootItem() const;
QTreeWidgetItem *topLevelItem(int index) const;
int topLevelItemCount() const;
void insertTopLevelItem(int index, QTreeWidgetItem *item);
void addTopLevelItem(QTreeWidgetItem *item);
QTreeWidgetItem *takeTopLevelItem(int index);
int indexOfTopLevelItem(QTreeWidgetItem *item); 
int indexOfTopLevelItem(QTreeWidgetItem *item) const;

void insertTopLevelItems(int index, const QList<QTreeWidgetItem*> &items);
void addTopLevelItems(const QList<QTreeWidgetItem*> &items);

QTreeWidgetItem *headerItem() const;
void setHeaderItem(QTreeWidgetItem *item);
void setHeaderLabels(const QStringList &labels);
inline void setHeaderLabel(const QString &label);

QTreeWidgetItem *currentItem() const;
int currentColumn() const;
void setCurrentItem(QTreeWidgetItem *item);
void setCurrentItem(QTreeWidgetItem *item, int column);
void setCurrentItem(QTreeWidgetItem *item, int column, QItemSelectionModel::SelectionFlags command);

QTreeWidgetItem *itemAt(const QPoint &p) const;
inline QTreeWidgetItem *itemAt(int x, int y) const;
QRect visualItemRect(const QTreeWidgetItem *item) const;

int sortColumn() const;
void sortItems(int column, Qt::SortOrder order);
void setSortingEnabled(bool enable);
bool isSortingEnabled() const;

void editItem(QTreeWidgetItem *item, int column = 0);
void openPersistentEditor(QTreeWidgetItem *item, int column = 0);
void closePersistentEditor(QTreeWidgetItem *item, int column = 0);

QWidget *itemWidget(QTreeWidgetItem *item, int column) const;
void setItemWidget(QTreeWidgetItem *item, int column, QWidget *widget);
inline void removeItemWidget(QTreeWidgetItem *item, int column);

bool isItemSelected(const QTreeWidgetItem *item) const;
void setItemSelected(const QTreeWidgetItem *item, bool select);
QList<QTreeWidgetItem*> selectedItems() const;
QList<QTreeWidgetItem*> findItems(const QString &text, Qt::MatchFlags flags,
int column = 0) const;

bool isItemHidden(const QTreeWidgetItem *item) const;
void setItemHidden(const QTreeWidgetItem *item, bool hide);

bool isItemExpanded(const QTreeWidgetItem *item) const;
void setItemExpanded(const QTreeWidgetItem *item, bool expand);

bool isFirstItemColumnSpanned(const QTreeWidgetItem *item) const;
void setFirstItemColumnSpanned(const QTreeWidgetItem *item, bool span);

QTreeWidgetItem *itemAbove(const QTreeWidgetItem *item) const;
QTreeWidgetItem *itemBelow(const QTreeWidgetItem *item) const;

void setSelectionModel(QItemSelectionModel *selectionModel);

public slots:
void scrollToItem(const QTreeWidgetItem *item,
QAbstractItemView::ScrollHint hint = EnsureVisible);
void expandItem(const QTreeWidgetItem *item);
void collapseItem(const QTreeWidgetItem *item);
void clear();

signals:
void itemPressed(QTreeWidgetItem *item, int column);
void itemClicked(QTreeWidgetItem *item, int column);
void itemDoubleClicked(QTreeWidgetItem *item, int column);
void itemActivated(QTreeWidgetItem *item, int column);
void itemEntered(QTreeWidgetItem *item, int column);
void itemChanged(QTreeWidgetItem *item, int column);
void itemExpanded(QTreeWidgetItem *item);
void itemCollapsed(QTreeWidgetItem *item);
void currentItemChanged(QTreeWidgetItem *current, QTreeWidgetItem *previous);
void itemSelectionChanged();

protected:
bool event(QEvent *e);
virtual QStringList mimeTypes() const;
virtual QMimeData *mimeData(const QList<QTreeWidgetItem*> items) const;
virtual bool dropMimeData(QTreeWidgetItem *parent, int index,
const QMimeData *data, Qt::DropAction action);
virtual Qt::DropActions supportedDropActions() const;
QList<QTreeWidgetItem*> items(const QMimeData *data) const;

QModelIndex indexFromItem(QTreeWidgetItem *item, int column = 0) const;
QTreeWidgetItem *itemFromIndex(const QModelIndex &index) const;
void dropEvent(QDropEvent *event);

private:
void setModel(QAbstractItemModel *model);

inline QTreeWidgetPrivate* d_func() { return reinterpret_cast<QTreeWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTreeWidgetPrivate* d_func() const { return reinterpret_cast<const QTreeWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTreeWidgetPrivate;
QTreeWidget(const QTreeWidget &); QTreeWidget &operator=(const QTreeWidget &);













};

inline void QTreeWidget::removeItemWidget(QTreeWidgetItem *item, int column)
{ setItemWidget(item, column, 0); }

inline QTreeWidgetItem *QTreeWidget::itemAt(int ax, int ay) const
{ return itemAt(QPoint(ax, ay)); }

inline void QTreeWidget::setHeaderLabel(const QString &alabel)
{ setHeaderLabels(QStringList(alabel)); }

inline void QTreeWidgetItem::setSelected(bool aselect)
{ if (view) view->setItemSelected(this, aselect); }

inline bool QTreeWidgetItem::isSelected() const
{ return (view ? view->isItemSelected(this) : false); }

inline void QTreeWidgetItem::setHidden(bool ahide)
{ if (view) view->setItemHidden(this, ahide); }

inline bool QTreeWidgetItem::isHidden() const
{ return (view ? view->isItemHidden(this) : false); }

inline void QTreeWidgetItem::setExpanded(bool aexpand)
{ if (view) view->setItemExpanded(this, aexpand); }

inline bool QTreeWidgetItem::isExpanded() const
{ return (view ? view->isItemExpanded(this) : false); }

inline void QTreeWidgetItem::setFirstColumnSpanned(bool aspan)
{ if (view) view->setFirstItemColumnSpanned(this, aspan); }

inline bool QTreeWidgetItem::isFirstColumnSpanned() const
{ return (view ? view->isFirstItemColumnSpanned(this) : false); }

inline void QTreeWidgetItem::setDisabled(bool disabled)
{ setFlags(disabled ? (flags() & ~Qt::ItemIsEnabled) : flags() | Qt::ItemIsEnabled); }

inline bool QTreeWidgetItem::isDisabled() const
{ return !(flags() & Qt::ItemIsEnabled); }



# 428 "/usr/share/qt4/include/QtGui/qtreewidget.h"





# 61 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtreewidgetitemiterator.h"































































































































































# 62 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcdestyle.h"













































# 1 "/usr/share/qt4/include/QtGui/qmotifstyle.h"












































# 1 "/usr/share/qt4/include/QtGui/qcommonstyle.h"












































# 1 "/usr/share/qt4/include/QtGui/qstyle.h"























































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qcommonstyle.h"


# 47 "/usr/share/qt4/include/QtGui/qcommonstyle.h"



typedef QtValidLicenseForGuiModule QtGuiModule;

class QCommonStylePrivate;

class  QCommonStyle: public QStyle
{
Q_OBJECT

public:
QCommonStyle();
~QCommonStyle();

void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
const QWidget *w = 0) const;
void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
const QWidget *w = 0) const;
QRect subElementRect(SubElement r, const QStyleOption *opt, const QWidget *widget = 0) const;
void drawComplexControl(ComplexControl cc, const QStyleOptionComplex *opt, QPainter *p,
const QWidget *w = 0) const;
SubControl hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
const QPoint &pt, const QWidget *w = 0) const;
QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt, SubControl sc,
const QWidget *w = 0) const;
QSize sizeFromContents(ContentsType ct, const QStyleOption *opt,
const QSize &contentsSize, const QWidget *widget = 0) const;

int pixelMetric(PixelMetric m, const QStyleOption *opt = 0, const QWidget *widget = 0) const;

int styleHint(StyleHint sh, const QStyleOption *opt = 0, const QWidget *w = 0,
QStyleHintReturn *shret = 0) const;

QPixmap standardPixmap(StandardPixmap sp, const QStyleOption *opt = 0,
const QWidget *widget = 0) const;

QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
const QStyleOption *opt) const;

void polish(QPalette &);
void polish(QApplication *app);
void polish(QWidget *widget);
void unpolish(QWidget *widget);
void unpolish(QApplication *application);

protected slots:
QIcon standardIconImplementation(StandardPixmap standardIcon, const QStyleOption *opt = 0,
const QWidget *widget = 0) const;

protected:
QCommonStyle(QCommonStylePrivate &dd);

private:
inline QCommonStylePrivate* d_func() { return reinterpret_cast<QCommonStylePrivate *>(qGetPtrHelper(d_ptr)); } inline const QCommonStylePrivate* d_func() const { return reinterpret_cast<const QCommonStylePrivate *>(qGetPtrHelper(d_ptr)); } friend class QCommonStylePrivate;
QCommonStyle(const QCommonStyle &); QCommonStyle &operator=(const QCommonStyle &);
};






# 45 "/usr/share/qt4/include/QtGui/qmotifstyle.h"

# 1 "/usr/share/qt4/include/QtCore/qpointer.h"








































































































































































# 46 "/usr/share/qt4/include/QtGui/qmotifstyle.h"


# 48 "/usr/share/qt4/include/QtGui/qmotifstyle.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qmotifstyle.h"
class QPalette;
class QFocusFrame;

class QMotifStylePrivate;
class  QMotifStyle : public QCommonStyle
{
Q_OBJECT
public:
explicit QMotifStyle(bool useHighlightCols=false);
virtual ~QMotifStyle();

void setUseHighlightColors(bool);
bool useHighlightColors() const;

void polish(QPalette&);
void polish(QWidget*);
void unpolish(QWidget*);
void polish(QApplication*);
void unpolish(QApplication*);

void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
const QWidget *w = 0) const;

void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
const QWidget *w = 0) const;

void drawComplexControl(ComplexControl cc, const QStyleOptionComplex *opt, QPainter *p,
const QWidget *w = 0) const;

QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
SubControl sc, const QWidget *widget = 0) const;

int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
const QWidget *widget = 0) const;

QSize sizeFromContents(ContentsType ct, const QStyleOption *opt,
const QSize &contentsSize, const QWidget *widget = 0) const;

QRect subElementRect(SubElement r, const QStyleOption *opt, const QWidget *widget = 0) const;

QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
const QWidget *widget = 0) const;

int styleHint(StyleHint hint, const QStyleOption *opt = 0, const QWidget *widget = 0,
QStyleHintReturn *returnData = 0) const;

bool event(QEvent *);
QPalette standardPalette() const;

protected slots:
QIcon standardIconImplementation(StandardPixmap standardIcon, const QStyleOption *opt = 0,
const QWidget *widget = 0) const;

protected:
QPointer<QFocusFrame> focus;
QMotifStyle(QMotifStylePrivate &dd, bool useHighlightCols = false);
void timerEvent(QTimerEvent *event);
bool eventFilter(QObject *o, QEvent *e);

private:
inline QMotifStylePrivate* d_func() { return reinterpret_cast<QMotifStylePrivate *>(qGetPtrHelper(d_ptr)); } inline const QMotifStylePrivate* d_func() const { return reinterpret_cast<const QMotifStylePrivate *>(qGetPtrHelper(d_ptr)); } friend class QMotifStylePrivate;
QMotifStyle(const QMotifStyle &); QMotifStyle &operator=(const QMotifStyle &);

bool highlightCols;
};



# 124 "/usr/share/qt4/include/QtGui/qmotifstyle.h"





# 46 "/usr/share/qt4/include/QtGui/qcdestyle.h"


# 48 "/usr/share/qt4/include/QtGui/qcdestyle.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qcdestyle.h"
class  QCDEStyle : public QMotifStyle
{
Q_OBJECT
public:
explicit QCDEStyle(bool useHighlightCols = false);
virtual ~QCDEStyle();

int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
const QWidget *widget = 0) const;
void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
const QWidget *w = 0) const;
void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
const QWidget *w = 0) const;
QPalette standardPalette() const;

protected slots:
QIcon standardIconImplementation(StandardPixmap standardIcon, const QStyleOption *opt = 0,
const QWidget *widget = 0) const;
};



# 78 "/usr/share/qt4/include/QtGui/qcdestyle.h"





# 63 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcleanlooksstyle.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowsstyle.h"












































# 1 "/usr/share/qt4/include/QtGui/qcommonstyle.h"













































































































# 45 "/usr/share/qt4/include/QtGui/qwindowsstyle.h"


# 47 "/usr/share/qt4/include/QtGui/qwindowsstyle.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qwindowsstyle.h"
class QWindowsStylePrivate;

class  QWindowsStyle : public QCommonStyle
{
Q_OBJECT
public:
QWindowsStyle();
~QWindowsStyle();

void polish(QApplication*);
void unpolish(QApplication*);

void polish(QWidget*);
void unpolish(QWidget*);

void polish(QPalette &);

void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
const QWidget *w = 0) const;
void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
const QWidget *w = 0) const;
QRect subElementRect(SubElement r, const QStyleOption *opt, const QWidget *widget = 0) const;
void drawComplexControl(ComplexControl cc, const QStyleOptionComplex *opt, QPainter *p,
const QWidget *w = 0) const;
QSize sizeFromContents(ContentsType ct, const QStyleOption *opt,
const QSize &contentsSize, const QWidget *widget = 0) const;

int pixelMetric(PixelMetric pm, const QStyleOption *option = 0, const QWidget *widget = 0) const;

int styleHint(StyleHint hint, const QStyleOption *opt = 0, const QWidget *widget = 0,
QStyleHintReturn *returnData = 0) const;

QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
const QWidget *widget = 0) const;

protected slots:
QIcon standardIconImplementation(StandardPixmap standardIcon, const QStyleOption *option,
const QWidget *widget = 0) const;

protected:
bool eventFilter(QObject *o, QEvent *e);
void timerEvent(QTimerEvent *event);
QWindowsStyle(QWindowsStylePrivate &dd);

private:
QWindowsStyle(const QWindowsStyle &); QWindowsStyle &operator=(const QWindowsStyle &);
inline QWindowsStylePrivate* d_func() { return reinterpret_cast<QWindowsStylePrivate *>(qGetPtrHelper(d_ptr)); } inline const QWindowsStylePrivate* d_func() const { return reinterpret_cast<const QWindowsStylePrivate *>(qGetPtrHelper(d_ptr)); } friend class QWindowsStylePrivate;
void *reserved;
};



# 107 "/usr/share/qt4/include/QtGui/qwindowsstyle.h"





# 45 "/usr/share/qt4/include/QtGui/qcleanlooksstyle.h"


# 47 "/usr/share/qt4/include/QtGui/qcleanlooksstyle.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qcleanlooksstyle.h"
class QCleanlooksStylePrivate;
class  QCleanlooksStyle : public QWindowsStyle
{
Q_OBJECT
inline QCleanlooksStylePrivate* d_func() { return reinterpret_cast<QCleanlooksStylePrivate *>(qGetPtrHelper(d_ptr)); } inline const QCleanlooksStylePrivate* d_func() const { return reinterpret_cast<const QCleanlooksStylePrivate *>(qGetPtrHelper(d_ptr)); } friend class QCleanlooksStylePrivate;

public:
QCleanlooksStyle();
~QCleanlooksStyle();

QPalette standardPalette () const;
void drawPrimitive(PrimitiveElement elem,
const QStyleOption *option,
QPainter *painter, const QWidget *widget = 0) const;
void drawControl(ControlElement ce, const QStyleOption *option, QPainter *painter,
const QWidget *widget) const;
int pixelMetric(PixelMetric metric, const QStyleOption *option = 0, const QWidget *widget = 0) const;
void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
QPainter *painter, const QWidget *widget) const;
QRect subElementRect(SubElement r, const QStyleOption *opt, const QWidget *widget = 0) const;
QSize sizeFromContents(ContentsType type, const QStyleOption *option,
const QSize &size, const QWidget *widget) const;
SubControl hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
const QPoint &pt, const QWidget *w = 0) const;
QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
SubControl sc, const QWidget *widget) const;
QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
const QStyleOption *opt) const;
int styleHint(StyleHint hint, const QStyleOption *option = 0, const QWidget *widget = 0,
QStyleHintReturn *returnData = 0) const;
QRect itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const;
QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
const QWidget *widget = 0) const;
void drawItemPixmap(QPainter *painter, const QRect &rect,
int alignment, const QPixmap &pixmap) const;
void drawItemText(QPainter *painter, const QRect &rect,
int flags, const QPalette &pal, bool enabled,
const QString &text, QPalette::ColorRole textRole = QPalette::NoRole) const;
void polish(QWidget *widget);
void polish(QApplication *app);
void polish(QPalette &pal);
void unpolish(QWidget *widget);
void unpolish(QApplication *app);

protected slots:
QIcon standardIconImplementation(StandardPixmap standardIcon, const QStyleOption *option,
const QWidget *widget = 0) const;

protected:
QCleanlooksStyle(QCleanlooksStylePrivate &dd);

};



# 110 "/usr/share/qt4/include/QtGui/qcleanlooksstyle.h"





# 64 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcommonstyle.h"













































































































# 65 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgtkstyle.h"












































# 1 "/usr/share/qt4/include/QtGui/qcleanlooksstyle.h"


















































































































# 1 "/usr/share/qt4/include/QtGui/QCleanlooksStyle"

# 45 "/usr/share/qt4/include/QtGui/qgtkstyle.h"

# 1 "/usr/share/qt4/include/QtGui/qpalette.h"




































































































































































































































































# 1 "/usr/share/qt4/include/QtGui/QPalette"

# 46 "/usr/share/qt4/include/QtGui/qgtkstyle.h"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 1 "/usr/share/qt4/include/QtGui/QFont"

# 47 "/usr/share/qt4/include/QtGui/qgtkstyle.h"

# 1 "/usr/share/qt4/include/QtGui/qfiledialog.h"












































# 1 "/usr/share/qt4/include/QtCore/qdir.h"









































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qfiledialog.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qfiledialog.h"

# 1 "/usr/share/qt4/include/QtGui/qdialog.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qdialog.h"


# 47 "/usr/share/qt4/include/QtGui/qdialog.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QPushButton;
class QDialogPrivate;

class  QDialog : public QWidget
{
Q_OBJECT
friend class QPushButton;

Q_PROPERTY(bool sizeGripEnabled READ isSizeGripEnabled WRITE setSizeGripEnabled)
Q_PROPERTY(bool modal READ isModal WRITE setModal)

public:
explicit QDialog(QWidget *parent = 0, Qt::WindowFlags f = 0);




# 70 "/usr/share/qt4/include/QtGui/qdialog.h"
~QDialog();

enum DialogCode { Rejected, Accepted };

int result() const;

void setVisible(bool visible);

void setOrientation(Qt::Orientation orientation);
Qt::Orientation orientation() const;

void setExtension(QWidget* extension);
QWidget* extension() const;

QSize sizeHint() const;
QSize minimumSizeHint() const;

void setSizeGripEnabled(bool);
bool isSizeGripEnabled() const;

void setModal(bool modal);
void setResult(int r);

signals:
void finished(int result);
void accepted();
void rejected();

public slots:
void open();
int exec();
virtual void done(int);
virtual void accept();
virtual void reject();

void showExtension(bool);

protected:
QDialog(QDialogPrivate &, QWidget *parent, Qt::WindowFlags f = 0);




# 113 "/usr/share/qt4/include/QtGui/qdialog.h"
void keyPressEvent(QKeyEvent *);
void closeEvent(QCloseEvent *);
void showEvent(QShowEvent *);
void resizeEvent(QResizeEvent *);

# 118 "/usr/share/qt4/include/QtGui/qdialog.h"
void contextMenuEvent(QContextMenuEvent *);

# 120 "/usr/share/qt4/include/QtGui/qdialog.h"
bool eventFilter(QObject *, QEvent *);
void adjustPosition(QWidget*);
private:
inline QDialogPrivate* d_func() { return reinterpret_cast<QDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDialogPrivate* d_func() const { return reinterpret_cast<const QDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDialogPrivate;
QDialog(const QDialog &); QDialog &operator=(const QDialog &);









# 134 "/usr/share/qt4/include/QtGui/qdialog.h"
};






# 47 "/usr/share/qt4/include/QtGui/qfiledialog.h"


# 49 "/usr/share/qt4/include/QtGui/qfiledialog.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 57 "/usr/share/qt4/include/QtGui/qfiledialog.h"
class QModelIndex;
class QItemSelection;
struct QFileDialogArgs;
class QFileIconProvider;
class QFileDialogPrivate;
class QAbstractItemDelegate;
class QAbstractProxyModel;
class QUrl;

class  QFileDialog : public QDialog
{
Q_OBJECT
Q_ENUMS(ViewMode FileMode AcceptMode Option)
Q_PROPERTY(ViewMode viewMode READ viewMode WRITE setViewMode)
Q_PROPERTY(FileMode fileMode READ fileMode WRITE setFileMode)
Q_PROPERTY(AcceptMode acceptMode READ acceptMode WRITE setAcceptMode)
Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly DESIGNABLE false)
Q_PROPERTY(bool resolveSymlinks READ resolveSymlinks WRITE setResolveSymlinks DESIGNABLE false)
Q_PROPERTY(bool confirmOverwrite READ confirmOverwrite WRITE setConfirmOverwrite DESIGNABLE false)
Q_PROPERTY(QString defaultSuffix READ defaultSuffix WRITE setDefaultSuffix)
Q_PROPERTY(bool nameFilterDetailsVisible READ isNameFilterDetailsVisible
WRITE setNameFilterDetailsVisible DESIGNABLE false)
Q_PROPERTY(Options options READ options WRITE setOptions)

public:
enum ViewMode { Detail, List };
enum FileMode { AnyFile, ExistingFile, Directory, ExistingFiles, DirectoryOnly };
enum AcceptMode { AcceptOpen, AcceptSave };
enum DialogLabel { LookIn, FileName, FileType, Accept, Reject };


enum Option
{
ShowDirsOnly = 0x00000001,
DontResolveSymlinks = 0x00000002,
DontConfirmOverwrite = 0x00000004,
DontUseSheet = 0x00000008,
DontUseNativeDialog = 0x00000010,
ReadOnly = 0x00000020,
HideNameFilterDetails = 0x00000040
};
typedef QFlags<Option> Options;

QFileDialog(QWidget *parent, Qt::WindowFlags f);
explicit QFileDialog(QWidget *parent = 0,
const QString &caption = QString(),
const QString &directory = QString(),
const QString &filter = QString());
~QFileDialog();

void setDirectory(const QString &directory);
inline void setDirectory(const QDir &directory);
QDir directory() const;

void selectFile(const QString &filename);
QStringList selectedFiles() const;


# 115 "/usr/share/qt4/include/QtGui/qfiledialog.h"
 void setFilter(const QString &filter);
 void setFilters(const QStringList &filters);
 QStringList filters() const;
 void selectFilter(const QString &filter);
 QString selectedFilter() const;

# 121 "/usr/share/qt4/include/QtGui/qfiledialog.h"
void setNameFilterDetailsVisible(bool enabled);
bool isNameFilterDetailsVisible() const;

void setNameFilter(const QString &filter);
void setNameFilters(const QStringList &filters);
QStringList nameFilters() const;
void selectNameFilter(const QString &filter);
QString selectedNameFilter() const;

QDir::Filters filter() const;
void setFilter(QDir::Filters filters);

void setViewMode(ViewMode mode);
ViewMode viewMode() const;

void setFileMode(FileMode mode);
FileMode fileMode() const;

void setAcceptMode(AcceptMode mode);
AcceptMode acceptMode() const;

void setReadOnly(bool enabled);
bool isReadOnly() const;

void setResolveSymlinks(bool enabled);
bool resolveSymlinks() const;

void setSidebarUrls(const QList<QUrl> &urls);
QList<QUrl> sidebarUrls() const;

QByteArray saveState() const;
bool restoreState(const QByteArray &state);

void setConfirmOverwrite(bool enabled);
bool confirmOverwrite() const;

void setDefaultSuffix(const QString &suffix);
QString defaultSuffix() const;

void setHistory(const QStringList &paths);
QStringList history() const;

void setItemDelegate(QAbstractItemDelegate *delegate);
QAbstractItemDelegate *itemDelegate() const;

void setIconProvider(QFileIconProvider *provider);
QFileIconProvider *iconProvider() const;

void setLabelText(DialogLabel label, const QString &text);
QString labelText(DialogLabel label) const;


# 173 "/usr/share/qt4/include/QtGui/qfiledialog.h"
void setProxyModel(QAbstractProxyModel *model);
QAbstractProxyModel *proxyModel() const;


# 177 "/usr/share/qt4/include/QtGui/qfiledialog.h"
void setOption(Option option, bool on = true);
bool testOption(Option option) const;
void setOptions(Options options);
Options options() const;



# 184 "/usr/share/qt4/include/QtGui/qfiledialog.h"
void open() { QDialog::open(); }




# 189 "/usr/share/qt4/include/QtGui/qfiledialog.h"
void open(QObject *receiver, const char *member);
void setVisible(bool visible);

signals:
void fileSelected(const QString &file);
void filesSelected(const QStringList &files);
void currentChanged(const QString &path);
void directoryEntered(const QString &directory);
void filterSelected(const QString &filter);

public:









# 209 "/usr/share/qt4/include/QtGui/qfiledialog.h"
static QString getOpenFileName(QWidget *parent = 0,
const QString &caption = QString(),
const QString &dir = QString(),
const QString &filter = QString(),
QString *selectedFilter = 0,
Options options = 0);

static QString getSaveFileName(QWidget *parent = 0,
const QString &caption = QString(),
const QString &dir = QString(),
const QString &filter = QString(),
QString *selectedFilter = 0,
Options options = 0);

static QString getExistingDirectory(QWidget *parent = 0,
const QString &caption = QString(),
const QString &dir = QString(),
Options options = ShowDirsOnly);

static QStringList getOpenFileNames(QWidget *parent = 0,
const QString &caption = QString(),
const QString &dir = QString(),
const QString &filter = QString(),
QString *selectedFilter = 0,
Options options = 0);













































# 279 "/usr/share/qt4/include/QtGui/qfiledialog.h"
protected:
QFileDialog(const QFileDialogArgs &args);
void done(int result);
void accept();
void changeEvent(QEvent *e);

private:
inline QFileDialogPrivate* d_func() { return reinterpret_cast<QFileDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QFileDialogPrivate* d_func() const { return reinterpret_cast<const QFileDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QFileDialogPrivate;
QFileDialog(const QFileDialog &); QFileDialog &operator=(const QFileDialog &);




























# 316 "/usr/share/qt4/include/QtGui/qfiledialog.h"
};

inline void QFileDialog::setDirectory(const QDir &adirectory)
{ setDirectory(adirectory.absolutePath()); }

inline QFlags<QFileDialog::Options::enum_type> operator|(QFileDialog::Options::enum_type f1, QFileDialog::Options::enum_type f2) { return QFlags<QFileDialog::Options::enum_type>(f1) | f2; } inline QFlags<QFileDialog::Options::enum_type> operator|(QFileDialog::Options::enum_type f1, QFlags<QFileDialog::Options::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QFileDialog::Options::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 325 "/usr/share/qt4/include/QtGui/qfiledialog.h"





# 1 "/usr/share/qt4/include/QtGui/QFileDialog"

# 48 "/usr/share/qt4/include/QtGui/qgtkstyle.h"


# 50 "/usr/share/qt4/include/QtGui/qgtkstyle.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 58 "/usr/share/qt4/include/QtGui/qgtkstyle.h"
class QPainterPath;
class QGtkStylePrivate;

class  QGtkStyle : public QCleanlooksStyle
{
Q_OBJECT
inline QGtkStylePrivate* d_func() { return reinterpret_cast<QGtkStylePrivate *>(qGetPtrHelper(d_ptr)); } inline const QGtkStylePrivate* d_func() const { return reinterpret_cast<const QGtkStylePrivate *>(qGetPtrHelper(d_ptr)); } friend class QGtkStylePrivate;

public:
QGtkStyle();
QGtkStyle(QGtkStylePrivate &dd);

~QGtkStyle();

QPalette standardPalette() const;

void drawPrimitive(PrimitiveElement element, const QStyleOption *option,
QPainter *painter, const QWidget *widget) const;
void drawControl(ControlElement control, const QStyleOption *option,
QPainter *painter, const QWidget *widget) const;
void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
QPainter *painter, const QWidget *widget) const;
void drawItemPixmap(QPainter *painter, const QRect &rect, int alignment,
const QPixmap &pixmap) const;
void drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
bool enabled, const QString& text, QPalette::ColorRole textRole) const;

int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
const QWidget *widget = 0) const;
int styleHint(StyleHint hint, const QStyleOption *option,
const QWidget *widget, QStyleHintReturn *returnData) const;

QStyle::SubControl hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
const QPoint &pt, const QWidget *w) const;

QRect subControlRect(ComplexControl control, const QStyleOptionComplex *option,
SubControl subControl, const QWidget *widget) const;
QRect subElementRect(SubElement sr, const QStyleOption *opt, const QWidget *w) const;
QRect itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const;


QSize sizeFromContents(ContentsType type, const QStyleOption *option,
const QSize &size, const QWidget *widget) const;
QPixmap standardPixmap(StandardPixmap sp, const QStyleOption *option,
const QWidget *widget) const;
QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
const QStyleOption *opt) const;

void polish(QWidget *widget);
void polish(QApplication *app);
void polish(QPalette &palette);

void unpolish(QWidget *widget);
void unpolish(QApplication *app);

static bool getGConfBool(const QString &key, bool fallback = 0);
static QString getGConfString(const QString &key, const QString &fallback = QString());


protected slots:
QIcon standardIconImplementation(StandardPixmap standardIcon, const QStyleOption *option,
const QWidget *widget = 0) const;
};



# 124 "/usr/share/qt4/include/QtGui/qgtkstyle.h"





# 66 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmotifstyle.h"
































































































































# 67 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qplastiquestyle.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowsstyle.h"















































































































# 45 "/usr/share/qt4/include/QtGui/qplastiquestyle.h"


# 47 "/usr/share/qt4/include/QtGui/qplastiquestyle.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qplastiquestyle.h"
class QPlastiqueStylePrivate;
class  QPlastiqueStyle : public QWindowsStyle
{
Q_OBJECT
inline QPlastiqueStylePrivate* d_func() { return reinterpret_cast<QPlastiqueStylePrivate *>(qGetPtrHelper(d_ptr)); } inline const QPlastiqueStylePrivate* d_func() const { return reinterpret_cast<const QPlastiqueStylePrivate *>(qGetPtrHelper(d_ptr)); } friend class QPlastiqueStylePrivate;
public:
QPlastiqueStyle();
~QPlastiqueStyle();

void drawPrimitive(PrimitiveElement element, const QStyleOption *option,
QPainter *painter, const QWidget *widget = 0) const;
void drawControl(ControlElement element, const QStyleOption *option,
QPainter *painter, const QWidget *widget) const;
void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
QPainter *painter, const QWidget *widget) const;
QSize sizeFromContents(ContentsType type, const QStyleOption *option,
const QSize &size, const QWidget *widget) const;

QRect subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const;
QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
SubControl sc, const QWidget *widget) const;

int styleHint(StyleHint hint, const QStyleOption *option = 0, const QWidget *widget = 0,
QStyleHintReturn *returnData = 0) const;
SubControl hitTestComplexControl(ComplexControl control, const QStyleOptionComplex *option,
const QPoint &pos, const QWidget *widget = 0) const;

int pixelMetric(PixelMetric metric, const QStyleOption *option = 0, const QWidget *widget = 0) const;

QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
const QWidget *widget = 0) const;

void polish(QWidget *widget);
void polish(QApplication *app);
void polish(QPalette &pal);
void unpolish(QWidget *widget);
void unpolish(QApplication *app);

QPalette standardPalette() const;

protected slots:
QIcon standardIconImplementation(StandardPixmap standardIcon, const QStyleOption *opt = 0,
const QWidget *widget = 0) const;
int layoutSpacingImplementation(QSizePolicy::ControlType control1,
QSizePolicy::ControlType control2, 
Qt::Orientation orientation,
const QStyleOption *option = 0, 
const QWidget *widget = 0) const;

protected:
bool eventFilter(QObject *watched, QEvent *event);
void timerEvent(QTimerEvent *event);

private:
QPlastiqueStyle(const QPlastiqueStyle &); QPlastiqueStyle &operator=(const QPlastiqueStyle &);
void *reserved;
};



# 115 "/usr/share/qt4/include/QtGui/qplastiquestyle.h"





# 68 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qproxystyle.h"












































# 1 "/usr/share/qt4/include/QtGui/qcommonstyle.h"













































































































# 1 "/usr/share/qt4/include/QtGui/QCommonStyle"

# 45 "/usr/share/qt4/include/QtGui/qproxystyle.h"


# 47 "/usr/share/qt4/include/QtGui/qproxystyle.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qproxystyle.h"
class QProxyStylePrivate;
class  QProxyStyle : public QCommonStyle
{
Q_OBJECT

public:
QProxyStyle(QStyle *baseStyle = 0);
~QProxyStyle();

QStyle *baseStyle() const;
void setBaseStyle(QStyle *style);

void drawPrimitive(PrimitiveElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget = 0) const;
void drawControl(ControlElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget = 0) const;
void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option, QPainter *painter, const QWidget *widget = 0) const;
void drawItemText(QPainter *painter, const QRect &rect, int flags, const QPalette &pal, bool enabled,
const QString &text, QPalette::ColorRole textRole = QPalette::NoRole) const;
virtual void drawItemPixmap(QPainter *painter, const QRect &rect, int alignment, const QPixmap &pixmap) const;

QSize sizeFromContents(ContentsType type, const QStyleOption *option, const QSize &size, const QWidget *widget) const;

QRect subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const;
QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt, SubControl sc, const QWidget *widget) const;
QRect itemTextRect(const QFontMetrics &fm, const QRect &r, int flags, bool enabled, const QString &text) const;
QRect itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const;

SubControl hitTestComplexControl(ComplexControl control, const QStyleOptionComplex *option, const QPoint &pos, const QWidget *widget = 0) const;
int styleHint(StyleHint hint, const QStyleOption *option = 0, const QWidget *widget = 0, QStyleHintReturn *returnData = 0) const;
int pixelMetric(PixelMetric metric, const QStyleOption *option = 0, const QWidget *widget = 0) const;

QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt, const QWidget *widget = 0) const;
QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap, const QStyleOption *opt) const;
QPalette standardPalette() const;

void polish(QWidget *widget);
void polish(QPalette &pal);
void polish(QApplication *app);

void unpolish(QWidget *widget);
void unpolish(QApplication *app);

protected:
bool event(QEvent *e);

protected slots:
QIcon standardIconImplementation(StandardPixmap standardIcon, const QStyleOption *option, const QWidget *widget) const;
int layoutSpacingImplementation(QSizePolicy::ControlType control1, QSizePolicy::ControlType control2,
Qt::Orientation orientation, const QStyleOption *option = 0, const QWidget *widget = 0) const;
private:
QProxyStyle(const QProxyStyle &); QProxyStyle &operator=(const QProxyStyle &);
inline QProxyStylePrivate* d_func() { return reinterpret_cast<QProxyStylePrivate *>(qGetPtrHelper(d_ptr)); } inline const QProxyStylePrivate* d_func() const { return reinterpret_cast<const QProxyStylePrivate *>(qGetPtrHelper(d_ptr)); } friend class QProxyStylePrivate;
};



# 110 "/usr/share/qt4/include/QtGui/qproxystyle.h"





# 69 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qs60style.h"












































# 1 "/usr/share/qt4/include/QtGui/qcommonstyle.h"













































































































# 45 "/usr/share/qt4/include/QtGui/qs60style.h"


# 47 "/usr/share/qt4/include/QtGui/qs60style.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qs60style.h"
class QS60StylePrivate;

class  QS60Style : public QCommonStyle
{
Q_OBJECT
inline QS60StylePrivate* d_func() { return reinterpret_cast<QS60StylePrivate *>(qGetPtrHelper(d_ptr)); } inline const QS60StylePrivate* d_func() const { return reinterpret_cast<const QS60StylePrivate *>(qGetPtrHelper(d_ptr)); } friend class QS60StylePrivate;

public:
QS60Style();
~QS60Style();

void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option, QPainter *painter, const QWidget *widget = 0) const;
void drawControl(ControlElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget = 0) const;
void drawPrimitive(PrimitiveElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget = 0) const;
int pixelMetric(PixelMetric metric, const QStyleOption *option = 0, const QWidget *widget = 0) const;
QSize sizeFromContents(ContentsType ct, const QStyleOption *opt, const QSize &contentsSize, const QWidget *w = 0) const;
int styleHint(StyleHint sh, const QStyleOption *opt = 0, const QWidget *w = 0,
QStyleHintReturn *shret = 0) const;
QRect subControlRect(ComplexControl control, const QStyleOptionComplex *option, SubControl scontrol, const QWidget *widget = 0) const;
QRect subElementRect(SubElement element, const QStyleOption *opt, const QWidget *widget = 0) const;
void polish(QWidget *widget);
void unpolish(QWidget *widget);
void polish(QApplication *application);
void unpolish(QApplication *application);



# 82 "/usr/share/qt4/include/QtGui/qs60style.h"
bool event(QEvent *e);


# 85 "/usr/share/qt4/include/QtGui/qs60style.h"
static QStringList partKeys();
static QStringList colorListKeys();
void setS60Theme(const QHash<QString, QPicture> &parts,
const QHash<QPair<QString , int>, QColor> &colors);
bool loadS60ThemeFromBlob(const QString &blobFile);
bool saveS60ThemeToBlob(const QString &blobFile) const;


# 93 "/usr/share/qt4/include/QtGui/qs60style.h"
protected slots:
QIcon standardIconImplementation(
StandardPixmap standardIcon, const QStyleOption * option = 0, const QWidget * widget = 0 ) const;

protected:
void timerEvent(QTimerEvent *event);
bool eventFilter(QObject *o, QEvent *e);
private:
QS60Style(const QS60Style &); QS60Style &operator=(const QS60Style &);
friend class QStyleFactory;
friend class QApplicationPrivate;
};



# 108 "/usr/share/qt4/include/QtGui/qs60style.h"





# 70 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qstyle.h"























































































































































































































































































































































































































































































































































































































































































































































































































































































































# 71 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qstylefactory.h"












































# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"



































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qstylefactory.h"


# 47 "/usr/share/qt4/include/QtGui/qstylefactory.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QStyle;

class  QStyleFactory
{
public:
static QStringList keys();
static QStyle *create(const QString&);
};






# 72 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qstyleoption.h"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 73 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qstyleplugin.h"












































# 1 "/usr/share/qt4/include/QtCore/qplugin.h"














































































































# 45 "/usr/share/qt4/include/QtGui/qstyleplugin.h"

# 1 "/usr/share/qt4/include/QtCore/qfactoryinterface.h"



































































# 46 "/usr/share/qt4/include/QtGui/qstyleplugin.h"


# 48 "/usr/share/qt4/include/QtGui/qstyleplugin.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QStyle;

struct  QStyleFactoryInterface : public QFactoryInterface
{
virtual QStyle *create(const QString &key) = 0;
};



# 63 "/usr/share/qt4/include/QtGui/qstyleplugin.h"
template <> inline const char *qobject_interface_iid<QStyleFactoryInterface *>() { return "com.trolltech.Qt.QStyleFactoryInterface"; } template <> inline QStyleFactoryInterface *qobject_cast<QStyleFactoryInterface *>(QObject *object) { return reinterpret_cast<QStyleFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QStyleFactoryInterface") : 0)); } template <> inline QStyleFactoryInterface *qobject_cast<QStyleFactoryInterface *>(const QObject *object) { return reinterpret_cast<QStyleFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QStyleFactoryInterface") : 0)); }

class  QStylePlugin : public QObject, public QStyleFactoryInterface
{
Q_OBJECT

public:
explicit QStylePlugin(QObject *parent = 0);
~QStylePlugin();

virtual QStringList keys() const = 0;
virtual QStyle *create(const QString &key) = 0;
};






# 74 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qwindowscestyle.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowsstyle.h"















































































































# 45 "/usr/share/qt4/include/QtGui/qwindowscestyle.h"


# 47 "/usr/share/qt4/include/QtGui/qwindowscestyle.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qwindowscestyle.h"
class  QWindowsCEStyle : public QWindowsStyle
{
Q_OBJECT
public:
QWindowsCEStyle();

void drawPrimitive(PrimitiveElement element, const QStyleOption *option,
QPainter *painter, const QWidget *widget = 0) const;

void drawControl(ControlElement element, const QStyleOption *option,
QPainter *painter, const QWidget *widget) const;

void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
QPainter *painter, const QWidget *widget) const;

virtual void drawItemText(QPainter *painter, const QRect &rect,
int flags, const QPalette &pal, bool enabled,
const QString &text, QPalette::ColorRole textRole = QPalette::NoRole) const;

QSize sizeFromContents(ContentsType type, const QStyleOption *option,
const QSize &size, const QWidget *widget) const;

QRect subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const;
QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
SubControl sc, const QWidget *widget) const;

SubControl hitTestComplexControl(ComplexControl control, const QStyleOptionComplex *option,
const QPoint &pos, const QWidget *widget = 0) const;

QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
const QWidget *widget = 0) const;
int pixelMetric(PixelMetric metric, const QStyleOption *option = 0, const QWidget *widget = 0) const;

int styleHint(StyleHint hint, const QStyleOption *opt = 0, const QWidget *widget = 0,
QStyleHintReturn *returnData = 0) const;

void polish(QWidget *widget);
void polish(QPalette &palette);
void polish(QApplication *app);
QPalette standardPalette() const;
};



# 99 "/usr/share/qt4/include/QtGui/qwindowscestyle.h"





# 75 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qwindowsmobilestyle.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowsstyle.h"















































































































# 45 "/usr/share/qt4/include/QtGui/qwindowsmobilestyle.h"


# 47 "/usr/share/qt4/include/QtGui/qwindowsmobilestyle.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qwindowsmobilestyle.h"
class QWindowsMobileStylePrivate;

class  QWindowsMobileStyle : public QWindowsStyle
{
Q_OBJECT
public:
QWindowsMobileStyle();

void drawPrimitive(PrimitiveElement element, const QStyleOption *option,
QPainter *painter, const QWidget *widget = 0) const;

void drawControl(ControlElement element, const QStyleOption *option,
QPainter *painter, const QWidget *widget) const;

void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
QPainter *painter, const QWidget *widget) const;

QSize sizeFromContents(ContentsType type, const QStyleOption *option,
const QSize &size, const QWidget *widget) const;

QRect subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const;

QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
SubControl sc, const QWidget *widget) const;

QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
const QStyleOption *option) const;

QPixmap standardPixmap(StandardPixmap sp, const QStyleOption *option,
const QWidget *widget) const;

int pixelMetric(PixelMetric metric, const QStyleOption *option = 0, const QWidget *widget = 0) const;

int styleHint(StyleHint hint, const QStyleOption *opt = 0, const QWidget *widget = 0,
QStyleHintReturn *returnData = 0) const;

void polish(QApplication*);
void unpolish(QApplication*);
void polish(QWidget *widget);
void unpolish(QWidget *widget);
void polish(QPalette &);

QPalette standardPalette() const;

bool doubleControls() const;

void setDoubleControls(bool);

protected:
QWindowsMobileStyle(QWindowsMobileStylePrivate &dd);

private:
inline QWindowsMobileStylePrivate* d_func() { return reinterpret_cast<QWindowsMobileStylePrivate *>(qGetPtrHelper(d_ptr)); } inline const QWindowsMobileStylePrivate* d_func() const { return reinterpret_cast<const QWindowsMobileStylePrivate *>(qGetPtrHelper(d_ptr)); } friend class QWindowsMobileStylePrivate;
};



# 112 "/usr/share/qt4/include/QtGui/qwindowsmobilestyle.h"





# 76 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qwindowsstyle.h"















































































































# 77 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qwindowsvistastyle.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowsxpstyle.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowsstyle.h"















































































































# 45 "/usr/share/qt4/include/QtGui/qwindowsxpstyle.h"


# 47 "/usr/share/qt4/include/QtGui/qwindowsxpstyle.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qwindowsxpstyle.h"
class QWindowsXPStylePrivate;
class  QWindowsXPStyle : public QWindowsStyle
{
Q_OBJECT
public:
QWindowsXPStyle();
QWindowsXPStyle(QWindowsXPStylePrivate &dd);
~QWindowsXPStyle();

void unpolish(QApplication*);
void polish(QApplication*);
void polish(QWidget*);
void polish(QPalette&);
void unpolish(QWidget*);

void drawPrimitive(PrimitiveElement pe, const QStyleOption *option, QPainter *p,
const QWidget *widget = 0) const;
void drawControl(ControlElement element, const QStyleOption *option, QPainter *p,
const QWidget *wwidget = 0) const;
QRect subElementRect(SubElement r, const QStyleOption *option, const QWidget *widget = 0) const;
QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *option, SubControl sc,
const QWidget *widget = 0) const;
void drawComplexControl(ComplexControl cc, const QStyleOptionComplex *option, QPainter *p,
const QWidget *widget = 0) const;
QSize sizeFromContents(ContentsType ct, const QStyleOption *option, const QSize &contentsSize,
const QWidget *widget = 0) const;
int pixelMetric(PixelMetric pm, const QStyleOption *option = 0,
const QWidget *widget = 0) const;
int styleHint(StyleHint hint, const QStyleOption *option = 0, const QWidget *widget = 0,
QStyleHintReturn *returnData = 0) const;

QPalette standardPalette() const;
QPixmap standardPixmap(StandardPixmap standardIcon, const QStyleOption *option,
const QWidget *widget = 0) const;

protected slots:
QIcon standardIconImplementation(StandardPixmap standardIcon, const QStyleOption *option,
const QWidget *widget = 0) const;

private:
QWindowsXPStyle(const QWindowsXPStyle &); QWindowsXPStyle &operator=(const QWindowsXPStyle &);
inline QWindowsXPStylePrivate* d_func() { return reinterpret_cast<QWindowsXPStylePrivate *>(qGetPtrHelper(d_ptr)); } inline const QWindowsXPStylePrivate* d_func() const { return reinterpret_cast<const QWindowsXPStylePrivate *>(qGetPtrHelper(d_ptr)); } friend class QWindowsXPStylePrivate;
friend class QStyleFactory;
void *reserved;
};



# 103 "/usr/share/qt4/include/QtGui/qwindowsxpstyle.h"





# 45 "/usr/share/qt4/include/QtGui/qwindowsvistastyle.h"


# 47 "/usr/share/qt4/include/QtGui/qwindowsvistastyle.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qwindowsvistastyle.h"
class QWindowsVistaStylePrivate;
class  QWindowsVistaStyle : public QWindowsXPStyle
{
Q_OBJECT
public:
QWindowsVistaStyle();

void drawPrimitive(PrimitiveElement element, const QStyleOption *option,
QPainter *painter, const QWidget *widget = 0) const;
void drawControl(ControlElement element, const QStyleOption *option,
QPainter *painter, const QWidget *widget) const;
void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
QPainter *painter, const QWidget *widget) const;
QSize sizeFromContents(ContentsType type, const QStyleOption *option,
const QSize &size, const QWidget *widget) const;

QRect subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const;
QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
SubControl sc, const QWidget *widget) const;

SubControl hitTestComplexControl(ComplexControl control, const QStyleOptionComplex *option,
const QPoint &pos, const QWidget *widget = 0) const;

QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
const QWidget *widget = 0) const;
int pixelMetric(PixelMetric metric, const QStyleOption *option = 0, const QWidget *widget = 0) const;
int styleHint(StyleHint hint, const QStyleOption *opt = 0, const QWidget *widget = 0,
QStyleHintReturn *returnData = 0) const;


void polish(QWidget *widget);
void unpolish(QWidget *widget);
void polish(QPalette &pal);
void polish(QApplication *app);
void unpolish(QApplication *app);
bool event(QEvent *event);
QPalette standardPalette() const;

protected slots:
QIcon standardIconImplementation(StandardPixmap standardIcon, const QStyleOption *option,
const QWidget *widget = 0) const;

private:
QWindowsVistaStyle(const QWindowsVistaStyle &); QWindowsVistaStyle &operator=(const QWindowsVistaStyle &);
inline QWindowsVistaStylePrivate* d_func() { return reinterpret_cast<QWindowsVistaStylePrivate *>(qGetPtrHelper(d_ptr)); } inline const QWindowsVistaStylePrivate* d_func() const { return reinterpret_cast<const QWindowsVistaStylePrivate *>(qGetPtrHelper(d_ptr)); } friend class QWindowsVistaStylePrivate;
friend class QStyleFactory;
};


# 104 "/usr/share/qt4/include/QtGui/qwindowsvistastyle.h"





# 78 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qwindowsxpstyle.h"











































































































# 79 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qabstractbutton.h"












































# 1 "/usr/share/qt4/include/QtGui/qicon.h"


























































































































































# 45 "/usr/share/qt4/include/QtGui/qabstractbutton.h"

# 1 "/usr/share/qt4/include/QtGui/qkeysequence.h"







































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qabstractbutton.h"

# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qabstractbutton.h"


# 49 "/usr/share/qt4/include/QtGui/qabstractbutton.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QButtonGroup;
class QAbstractButtonPrivate;

class  QAbstractButton : public QWidget
{
Q_OBJECT

Q_PROPERTY(QString text READ text WRITE setText)
Q_PROPERTY(QIcon icon READ icon WRITE setIcon)
Q_PROPERTY(QSize iconSize READ iconSize WRITE setIconSize)

# 66 "/usr/share/qt4/include/QtGui/qabstractbutton.h"
Q_PROPERTY(QKeySequence shortcut READ shortcut WRITE setShortcut)

# 68 "/usr/share/qt4/include/QtGui/qabstractbutton.h"
Q_PROPERTY(bool checkable READ isCheckable WRITE setCheckable)
Q_PROPERTY(bool checked READ isChecked WRITE setChecked DESIGNABLE isCheckable NOTIFY toggled USER true)
Q_PROPERTY(bool autoRepeat READ autoRepeat WRITE setAutoRepeat)
Q_PROPERTY(bool autoExclusive READ autoExclusive WRITE setAutoExclusive)
Q_PROPERTY(int autoRepeatDelay READ autoRepeatDelay WRITE setAutoRepeatDelay)
Q_PROPERTY(int autoRepeatInterval READ autoRepeatInterval WRITE setAutoRepeatInterval)
Q_PROPERTY(bool down READ isDown WRITE setDown DESIGNABLE false)

public:
explicit QAbstractButton(QWidget* parent=0);
~QAbstractButton();

void setText(const QString &text);
QString text() const;

void setIcon(const QIcon &icon);
QIcon icon() const;

QSize iconSize() const;


# 89 "/usr/share/qt4/include/QtGui/qabstractbutton.h"
void setShortcut(const QKeySequence &key);
QKeySequence shortcut() const;


# 93 "/usr/share/qt4/include/QtGui/qabstractbutton.h"
void setCheckable(bool);
bool isCheckable() const;

bool isChecked() const;

void setDown(bool);
bool isDown() const;

void setAutoRepeat(bool);
bool autoRepeat() const;

void setAutoRepeatDelay(int);
int autoRepeatDelay() const;

void setAutoRepeatInterval(int);
int autoRepeatInterval() const;

void setAutoExclusive(bool);
bool autoExclusive() const;


# 114 "/usr/share/qt4/include/QtGui/qabstractbutton.h"
QButtonGroup *group() const;


# 117 "/usr/share/qt4/include/QtGui/qabstractbutton.h"
public slots:
void setIconSize(const QSize &size);
void animateClick(int msec = 100);
void click();
void toggle();
void setChecked(bool);

signals:
void pressed();
void released();
void clicked(bool checked = false);
void toggled(bool checked);

protected:
virtual void paintEvent(QPaintEvent *e) = 0;
virtual bool hitButton(const QPoint &pos) const;
virtual void checkStateSet();
virtual void nextCheckState();

bool event(QEvent *e);
void keyPressEvent(QKeyEvent *e);
void keyReleaseEvent(QKeyEvent *e);
void mousePressEvent(QMouseEvent *e);
void mouseReleaseEvent(QMouseEvent *e);
void mouseMoveEvent(QMouseEvent *e);
void focusInEvent(QFocusEvent *e);
void focusOutEvent(QFocusEvent *e);
void changeEvent(QEvent *e);
void timerEvent(QTimerEvent *e);





















# 167 "/usr/share/qt4/include/QtGui/qabstractbutton.h"
protected:
QAbstractButton(QAbstractButtonPrivate &dd, QWidget* parent = 0);

private:
inline QAbstractButtonPrivate* d_func() { return reinterpret_cast<QAbstractButtonPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractButtonPrivate* d_func() const { return reinterpret_cast<const QAbstractButtonPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractButtonPrivate;
QAbstractButton(const QAbstractButton &); QAbstractButton &operator=(const QAbstractButton &);
friend class QButtonGroup;
};






# 80 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"
















































































































































# 81 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qabstractslider.h"
























































































































































































# 82 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qabstractspinbox.h"



















































































































































































# 83 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qbuttongroup.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qbuttongroup.h"


# 47 "/usr/share/qt4/include/QtGui/qbuttongroup.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qbuttongroup.h"
class QAbstractButton;
class QAbstractButtonPrivate;
class QButtonGroupPrivate;

class  QButtonGroup : public QObject
{
Q_OBJECT

Q_PROPERTY(bool exclusive READ exclusive WRITE setExclusive)
public:
explicit QButtonGroup(QObject *parent = 0);
~QButtonGroup();

void setExclusive(bool);
bool exclusive() const;

void addButton(QAbstractButton *);
void addButton(QAbstractButton *, int id);
void removeButton(QAbstractButton *);

QList<QAbstractButton*> buttons() const;

QAbstractButton * checkedButton() const;


QAbstractButton *button(int id) const;
void setId(QAbstractButton *button, int id);
int id(QAbstractButton *button) const;
int checkedId() const;

signals:
void buttonClicked(QAbstractButton *);
void buttonClicked(int);
void buttonPressed(QAbstractButton *);
void buttonPressed(int);
void buttonReleased(QAbstractButton *);
void buttonReleased(int);







# 99 "/usr/share/qt4/include/QtGui/qbuttongroup.h"
private:
QButtonGroup(const QButtonGroup &); QButtonGroup &operator=(const QButtonGroup &);
inline QButtonGroupPrivate* d_func() { return reinterpret_cast<QButtonGroupPrivate *>(qGetPtrHelper(d_ptr)); } inline const QButtonGroupPrivate* d_func() const { return reinterpret_cast<const QButtonGroupPrivate *>(qGetPtrHelper(d_ptr)); } friend class QButtonGroupPrivate;
friend class QAbstractButton;
friend class QAbstractButtonPrivate;
};



# 108 "/usr/share/qt4/include/QtGui/qbuttongroup.h"





# 84 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcalendarwidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qcalendarwidget.h"

# 1 "/usr/share/qt4/include/QtCore/qdatetime.h"














































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qcalendarwidget.h"


# 48 "/usr/share/qt4/include/QtGui/qcalendarwidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qcalendarwidget.h"
class QDate;
class QTextCharFormat;
class QCalendarWidgetPrivate;

class  QCalendarWidget : public QWidget
{
Q_OBJECT
Q_ENUMS(Qt::DayOfWeek)
Q_ENUMS(HorizontalHeaderFormat)
Q_ENUMS(VerticalHeaderFormat)
Q_ENUMS(SelectionMode)
Q_PROPERTY(QDate selectedDate READ selectedDate WRITE setSelectedDate)
Q_PROPERTY(QDate minimumDate READ minimumDate WRITE setMinimumDate)
Q_PROPERTY(QDate maximumDate READ maximumDate WRITE setMaximumDate)
Q_PROPERTY(Qt::DayOfWeek firstDayOfWeek READ firstDayOfWeek WRITE setFirstDayOfWeek)
Q_PROPERTY(bool gridVisible READ isGridVisible WRITE setGridVisible)
Q_PROPERTY(SelectionMode selectionMode READ selectionMode WRITE setSelectionMode)
Q_PROPERTY(HorizontalHeaderFormat horizontalHeaderFormat READ horizontalHeaderFormat WRITE setHorizontalHeaderFormat)
Q_PROPERTY(VerticalHeaderFormat verticalHeaderFormat READ verticalHeaderFormat WRITE setVerticalHeaderFormat)
Q_PROPERTY(bool headerVisible READ isHeaderVisible WRITE setHeaderVisible STORED false DESIGNABLE false) 
Q_PROPERTY(bool navigationBarVisible READ isNavigationBarVisible WRITE setNavigationBarVisible)
Q_PROPERTY(bool dateEditEnabled READ isDateEditEnabled WRITE setDateEditEnabled)
Q_PROPERTY(int dateEditAcceptDelay READ dateEditAcceptDelay WRITE setDateEditAcceptDelay)

public:
enum HorizontalHeaderFormat {
NoHorizontalHeader,
SingleLetterDayNames,
ShortDayNames,
LongDayNames
};

enum VerticalHeaderFormat {
NoVerticalHeader,
ISOWeekNumbers
};

enum SelectionMode {
NoSelection,
SingleSelection
};

explicit QCalendarWidget(QWidget *parent = 0);
~QCalendarWidget();

virtual QSize sizeHint() const;
virtual QSize minimumSizeHint() const;

QDate selectedDate() const;

int yearShown() const;
int monthShown() const;

QDate minimumDate() const;
void setMinimumDate(const QDate &date);

QDate maximumDate() const;
void setMaximumDate(const QDate &date);

Qt::DayOfWeek firstDayOfWeek() const;
void setFirstDayOfWeek(Qt::DayOfWeek dayOfWeek);


bool isHeaderVisible() const;
void setHeaderVisible(bool show); 

inline bool isNavigationBarVisible() const { return isHeaderVisible(); }

bool isGridVisible() const;

SelectionMode selectionMode() const;
void setSelectionMode(SelectionMode mode);

HorizontalHeaderFormat horizontalHeaderFormat() const;
void setHorizontalHeaderFormat(HorizontalHeaderFormat format);

VerticalHeaderFormat verticalHeaderFormat() const;
void setVerticalHeaderFormat(VerticalHeaderFormat format);

QTextCharFormat headerTextFormat() const;
void setHeaderTextFormat(const QTextCharFormat &format);

QTextCharFormat weekdayTextFormat(Qt::DayOfWeek dayOfWeek) const;
void setWeekdayTextFormat(Qt::DayOfWeek dayOfWeek, const QTextCharFormat &format);

QMap<QDate, QTextCharFormat> dateTextFormat() const;
QTextCharFormat dateTextFormat(const QDate &date) const;
void setDateTextFormat(const QDate &date, const QTextCharFormat &format);

bool isDateEditEnabled() const;
void setDateEditEnabled(bool enable);

int dateEditAcceptDelay() const;
void setDateEditAcceptDelay(int delay);

protected:
bool event(QEvent *event);
bool eventFilter(QObject *watched, QEvent *event);
void mousePressEvent(QMouseEvent *event);
void resizeEvent(QResizeEvent * event);
void keyPressEvent(QKeyEvent * event);

virtual void paintCell(QPainter *painter, const QRect &rect, const QDate &date) const;
void updateCell(const QDate &date);
void updateCells();

public slots:
void setSelectedDate(const QDate &date);
void setDateRange(const QDate &min, const QDate &max);
void setCurrentPage(int year, int month);
void setGridVisible(bool show);
void setNavigationBarVisible(bool visible);
void showNextMonth();
void showPreviousMonth();
void showNextYear();
void showPreviousYear();
void showSelectedDate();
void showToday();

signals:
void selectionChanged();
void clicked(const QDate &date);
void activated(const QDate &date);
void currentPageChanged(int year, int month);

private:
inline QCalendarWidgetPrivate* d_func() { return reinterpret_cast<QCalendarWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QCalendarWidgetPrivate* d_func() const { return reinterpret_cast<const QCalendarWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QCalendarWidgetPrivate;
QCalendarWidget(const QCalendarWidget &); QCalendarWidget &operator=(const QCalendarWidget &);











};



# 199 "/usr/share/qt4/include/QtGui/qcalendarwidget.h"






# 85 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcheckbox.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractbutton.h"




















































































































































































# 45 "/usr/share/qt4/include/QtGui/qcheckbox.h"


# 47 "/usr/share/qt4/include/QtGui/qcheckbox.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QCheckBoxPrivate;
class QStyleOptionButton;

class  QCheckBox : public QAbstractButton
{
Q_OBJECT

Q_PROPERTY(bool tristate READ isTristate WRITE setTristate)

public:
explicit QCheckBox(QWidget *parent=0);
explicit QCheckBox(const QString &text, QWidget *parent=0);


QSize sizeHint() const;

void setTristate(bool y = true);
bool isTristate() const;

Qt::CheckState checkState() const;
void setCheckState(Qt::CheckState state);

signals:
void stateChanged(int);

protected:
bool event(QEvent *e);
bool hitButton(const QPoint &pos) const;
void checkStateSet();
void nextCheckState();
void paintEvent(QPaintEvent *);
void mouseMoveEvent(QMouseEvent *);
void initStyleOption(QStyleOptionButton *option) const;


















# 104 "/usr/share/qt4/include/QtGui/qcheckbox.h"
private:
inline QCheckBoxPrivate* d_func() { return reinterpret_cast<QCheckBoxPrivate *>(qGetPtrHelper(d_ptr)); } inline const QCheckBoxPrivate* d_func() const { return reinterpret_cast<const QCheckBoxPrivate *>(qGetPtrHelper(d_ptr)); } friend class QCheckBoxPrivate;
QCheckBox(const QCheckBox &); QCheckBox &operator=(const QCheckBox &);
};






# 86 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcombobox.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qcombobox.h"

# 1 "/usr/share/qt4/include/QtGui/qabstractitemdelegate.h"






































































































































# 46 "/usr/share/qt4/include/QtGui/qcombobox.h"

# 1 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"


























































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qcombobox.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qcombobox.h"


# 50 "/usr/share/qt4/include/QtGui/qcombobox.h"




typedef QtValidLicenseForGuiModule QtGuiModule;


# 57 "/usr/share/qt4/include/QtGui/qcombobox.h"
class QAbstractItemView;
class QLineEdit;
class QComboBoxPrivate;
class QCompleter;

class  QComboBox : public QWidget
{
Q_OBJECT

Q_ENUMS(InsertPolicy)
Q_ENUMS(SizeAdjustPolicy)
Q_PROPERTY(bool editable READ isEditable WRITE setEditable)
Q_PROPERTY(int count READ count)
Q_PROPERTY(QString currentText READ currentText)
Q_PROPERTY(int currentIndex READ currentIndex WRITE setCurrentIndex NOTIFY currentIndexChanged)
Q_PROPERTY(int maxVisibleItems READ maxVisibleItems WRITE setMaxVisibleItems)
Q_PROPERTY(int maxCount READ maxCount WRITE setMaxCount)
Q_PROPERTY(InsertPolicy insertPolicy READ insertPolicy WRITE setInsertPolicy)
Q_PROPERTY(SizeAdjustPolicy sizeAdjustPolicy READ sizeAdjustPolicy WRITE setSizeAdjustPolicy)
Q_PROPERTY(int minimumContentsLength READ minimumContentsLength WRITE setMinimumContentsLength)
Q_PROPERTY(QSize iconSize READ iconSize WRITE setIconSize)


# 80 "/usr/share/qt4/include/QtGui/qcombobox.h"
Q_PROPERTY(bool autoCompletion READ autoCompletion WRITE setAutoCompletion DESIGNABLE false)
Q_PROPERTY(Qt::CaseSensitivity autoCompletionCaseSensitivity READ autoCompletionCaseSensitivity WRITE setAutoCompletionCaseSensitivity DESIGNABLE false)


# 84 "/usr/share/qt4/include/QtGui/qcombobox.h"
Q_PROPERTY(bool duplicatesEnabled READ duplicatesEnabled WRITE setDuplicatesEnabled)
Q_PROPERTY(bool frame READ hasFrame WRITE setFrame)
Q_PROPERTY(int modelColumn READ modelColumn WRITE setModelColumn)

public:
explicit QComboBox(QWidget *parent = 0);
~QComboBox();

int maxVisibleItems() const;
void setMaxVisibleItems(int maxItems);

int count() const;
void setMaxCount(int max);
int maxCount() const;


# 100 "/usr/share/qt4/include/QtGui/qcombobox.h"
bool autoCompletion() const;
void setAutoCompletion(bool enable);

Qt::CaseSensitivity autoCompletionCaseSensitivity() const;
void setAutoCompletionCaseSensitivity(Qt::CaseSensitivity sensitivity);


# 107 "/usr/share/qt4/include/QtGui/qcombobox.h"
bool duplicatesEnabled() const;
void setDuplicatesEnabled(bool enable);

void setFrame(bool);
bool hasFrame() const;

inline int findText(const QString &text,
Qt::MatchFlags flags = Qt::MatchExactly|Qt::MatchCaseSensitive) const
{ return findData(text, Qt::DisplayRole, flags); }
int findData(const QVariant &data, int role = Qt::UserRole,
Qt::MatchFlags flags = Qt::MatchExactly|Qt::MatchCaseSensitive) const;

enum InsertPolicy {
NoInsert,
InsertAtTop,
InsertAtCurrent,
InsertAtBottom,
InsertAfterCurrent,
InsertBeforeCurrent,
InsertAlphabetically









# 136 "/usr/share/qt4/include/QtGui/qcombobox.h"
};




# 141 "/usr/share/qt4/include/QtGui/qcombobox.h"
InsertPolicy insertPolicy() const;
void setInsertPolicy(InsertPolicy policy);

enum SizeAdjustPolicy {
AdjustToContents,
AdjustToContentsOnFirstShow,
AdjustToMinimumContentsLength, 
AdjustToMinimumContentsLengthWithIcon
};

SizeAdjustPolicy sizeAdjustPolicy() const;
void setSizeAdjustPolicy(SizeAdjustPolicy policy);
int minimumContentsLength() const;
void setMinimumContentsLength(int characters);
QSize iconSize() const;
void setIconSize(const QSize &size);

bool isEditable() const;
void setEditable(bool editable);
void setLineEdit(QLineEdit *edit);
QLineEdit *lineEdit() const;

# 163 "/usr/share/qt4/include/QtGui/qcombobox.h"
void setValidator(const QValidator *v);
const QValidator *validator() const;



# 168 "/usr/share/qt4/include/QtGui/qcombobox.h"
void setCompleter(QCompleter *c);
QCompleter *completer() const;


# 172 "/usr/share/qt4/include/QtGui/qcombobox.h"
QAbstractItemDelegate *itemDelegate() const;
void setItemDelegate(QAbstractItemDelegate *delegate);

QAbstractItemModel *model() const;
void setModel(QAbstractItemModel *model);

QModelIndex rootModelIndex() const;
void setRootModelIndex(const QModelIndex &index);

int modelColumn() const;
void setModelColumn(int visibleColumn);

int currentIndex() const;

QString currentText() const;

QString itemText(int index) const;
QIcon itemIcon(int index) const;
QVariant itemData(int index, int role = Qt::UserRole) const;

inline void addItem(const QString &text, const QVariant &userData = QVariant());
inline void addItem(const QIcon &icon, const QString &text,
const QVariant &userData = QVariant());
inline void addItems(const QStringList &texts)
{ insertItems(count(), texts); }

inline void insertItem(int index, const QString &text, const QVariant &userData = QVariant());
void insertItem(int index, const QIcon &icon, const QString &text,
const QVariant &userData = QVariant());
void insertItems(int index, const QStringList &texts);
void insertSeparator(int index);

void removeItem(int index);

void setItemText(int index, const QString &text);
void setItemIcon(int index, const QIcon &icon);
void setItemData(int index, const QVariant &value, int role = Qt::UserRole);

QAbstractItemView *view() const;
void setView(QAbstractItemView *itemView);

QSize sizeHint() const;
QSize minimumSizeHint() const;

virtual void showPopup();
virtual void hidePopup();

bool event(QEvent *event);

public slots:
void clear();
void clearEditText();
void setEditText(const QString &text);
void setCurrentIndex(int index);

signals:
void editTextChanged(const QString &);
void activated(int index);
void activated(const QString &);
void highlighted(int index);
void highlighted(const QString &);
void currentIndexChanged(int index);
void currentIndexChanged(const QString &);

protected:
void focusInEvent(QFocusEvent *e);
void focusOutEvent(QFocusEvent *e);
void changeEvent(QEvent *e);
void resizeEvent(QResizeEvent *e);
void paintEvent(QPaintEvent *e);
void showEvent(QShowEvent *e);
void hideEvent(QHideEvent *e);
void mousePressEvent(QMouseEvent *e);
void mouseReleaseEvent(QMouseEvent *e);
void keyPressEvent(QKeyEvent *e);
void keyReleaseEvent(QKeyEvent *e);
void wheelEvent(QWheelEvent *e);
void contextMenuEvent(QContextMenuEvent *e);
void inputMethodEvent(QInputMethodEvent *);
QVariant inputMethodQuery(Qt::InputMethodQuery) const;
void initStyleOption(QStyleOptionComboBox *option) const;













































# 298 "/usr/share/qt4/include/QtGui/qcombobox.h"
protected:
QComboBox(QComboBoxPrivate &, QWidget *);

private:
inline QComboBoxPrivate* d_func() { return reinterpret_cast<QComboBoxPrivate *>(qGetPtrHelper(d_ptr)); } inline const QComboBoxPrivate* d_func() const { return reinterpret_cast<const QComboBoxPrivate *>(qGetPtrHelper(d_ptr)); } friend class QComboBoxPrivate;
QComboBox(const QComboBox &); QComboBox &operator=(const QComboBox &);















# 319 "/usr/share/qt4/include/QtGui/qcombobox.h"
};

inline void QComboBox::addItem(const QString &atext, const QVariant &auserData)
{ insertItem(count(), atext, auserData); }
inline void QComboBox::addItem(const QIcon &aicon, const QString &atext,
const QVariant &auserData)
{ insertItem(count(), aicon, atext, auserData); }

inline void QComboBox::insertItem(int aindex, const QString &atext,
const QVariant &auserData)
{ insertItem(aindex, QIcon(), atext, auserData); }



# 333 "/usr/share/qt4/include/QtGui/qcombobox.h"





# 87 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcommandlinkbutton.h"












































# 1 "/usr/share/qt4/include/QtGui/qpushbutton.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractbutton.h"




















































































































































































# 45 "/usr/share/qt4/include/QtGui/qpushbutton.h"


# 47 "/usr/share/qt4/include/QtGui/qpushbutton.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QPushButtonPrivate;
class QMenu;
class QStyleOptionButton;

class  QPushButton : public QAbstractButton
{
Q_OBJECT

Q_PROPERTY(bool autoDefault READ autoDefault WRITE setAutoDefault)
Q_PROPERTY(bool default READ isDefault WRITE setDefault)
Q_PROPERTY(bool flat READ isFlat WRITE setFlat)

public:
explicit QPushButton(QWidget *parent=0);
explicit QPushButton(const QString &text, QWidget *parent=0);
QPushButton(const QIcon& icon, const QString &text, QWidget *parent=0);
~QPushButton();

QSize sizeHint() const;
QSize minimumSizeHint() const;

bool autoDefault() const;
void setAutoDefault(bool);
bool isDefault() const;
void setDefault(bool);


# 80 "/usr/share/qt4/include/QtGui/qpushbutton.h"
void setMenu(QMenu* menu);
QMenu* menu() const;


# 84 "/usr/share/qt4/include/QtGui/qpushbutton.h"
void setFlat(bool);
bool isFlat() const;

public slots:

# 89 "/usr/share/qt4/include/QtGui/qpushbutton.h"
void showMenu();


# 92 "/usr/share/qt4/include/QtGui/qpushbutton.h"
protected:
bool event(QEvent *e);
void paintEvent(QPaintEvent *);
void keyPressEvent(QKeyEvent *);
void focusInEvent(QFocusEvent *);
void focusOutEvent(QFocusEvent *);
void initStyleOption(QStyleOptionButton *option) const;
QPushButton(QPushButtonPrivate &dd, QWidget* parent = 0);

public:










# 112 "/usr/share/qt4/include/QtGui/qpushbutton.h"
private:
QPushButton(const QPushButton &); QPushButton &operator=(const QPushButton &);
inline QPushButtonPrivate* d_func() { return reinterpret_cast<QPushButtonPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPushButtonPrivate* d_func() const { return reinterpret_cast<const QPushButtonPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPushButtonPrivate;

# 116 "/usr/share/qt4/include/QtGui/qpushbutton.h"


# 118 "/usr/share/qt4/include/QtGui/qpushbutton.h"
};






# 45 "/usr/share/qt4/include/QtGui/qcommandlinkbutton.h"


# 47 "/usr/share/qt4/include/QtGui/qcommandlinkbutton.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QCommandLinkButtonPrivate;

class  QCommandLinkButton: public QPushButton 
{
Q_OBJECT

Q_PROPERTY(QString description READ description WRITE setDescription)
Q_PROPERTY(bool flat READ isFlat WRITE setFlat DESIGNABLE false)

public:
explicit QCommandLinkButton(QWidget *parent=0);
explicit QCommandLinkButton(const QString &text, QWidget *parent=0);
QCommandLinkButton(const QString &text, const QString &description, QWidget *parent=0);
QString description() const;
void setDescription(const QString &description);

protected:
QSize sizeHint() const;
int heightForWidth(int) const;
QSize minimumSizeHint() const;
bool event(QEvent *e);
void paintEvent(QPaintEvent *);

private:
QCommandLinkButton(const QCommandLinkButton &); QCommandLinkButton &operator=(const QCommandLinkButton &);
inline QCommandLinkButtonPrivate* d_func() { return reinterpret_cast<QCommandLinkButtonPrivate *>(qGetPtrHelper(d_ptr)); } inline const QCommandLinkButtonPrivate* d_func() const { return reinterpret_cast<const QCommandLinkButtonPrivate *>(qGetPtrHelper(d_ptr)); } friend class QCommandLinkButtonPrivate;
};






# 88 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qdatetimeedit.h"












































# 1 "/usr/share/qt4/include/QtCore/qdatetime.h"














































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qdatetimeedit.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qdatetimeedit.h"

# 1 "/usr/share/qt4/include/QtGui/qabstractspinbox.h"



















































































































































































# 47 "/usr/share/qt4/include/QtGui/qdatetimeedit.h"


# 49 "/usr/share/qt4/include/QtGui/qdatetimeedit.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 57 "/usr/share/qt4/include/QtGui/qdatetimeedit.h"
class QDateTimeEditPrivate;
class QStyleOptionSpinBox;
class QCalendarWidget;

class  QDateTimeEdit : public QAbstractSpinBox
{
Q_OBJECT

Q_ENUMS(Section)

Q_PROPERTY(QDateTime dateTime READ dateTime WRITE setDateTime NOTIFY dateTimeChanged USER true)
Q_PROPERTY(QDate date READ date WRITE setDate NOTIFY dateChanged)
Q_PROPERTY(QTime time READ time WRITE setTime NOTIFY timeChanged)
Q_PROPERTY(QDateTime maximumDateTime READ maximumDateTime WRITE setMaximumDateTime RESET clearMaximumDateTime)
Q_PROPERTY(QDateTime minimumDateTime READ minimumDateTime WRITE setMinimumDateTime RESET clearMinimumDateTime)
Q_PROPERTY(QDate maximumDate READ maximumDate WRITE setMaximumDate RESET clearMaximumDate)
Q_PROPERTY(QDate minimumDate READ minimumDate WRITE setMinimumDate RESET clearMinimumDate)
Q_PROPERTY(QTime maximumTime READ maximumTime WRITE setMaximumTime RESET clearMaximumTime)
Q_PROPERTY(QTime minimumTime READ minimumTime WRITE setMinimumTime RESET clearMinimumTime)
Q_PROPERTY(Section currentSection READ currentSection WRITE setCurrentSection)
Q_PROPERTY(Sections displayedSections READ displayedSections)
Q_PROPERTY(QString displayFormat READ displayFormat WRITE setDisplayFormat)
Q_PROPERTY(bool calendarPopup READ calendarPopup WRITE setCalendarPopup)
Q_PROPERTY(int currentSectionIndex READ currentSectionIndex WRITE setCurrentSectionIndex)
Q_PROPERTY(int sectionCount READ sectionCount)
Q_PROPERTY(Qt::TimeSpec timeSpec READ timeSpec WRITE setTimeSpec)
public:
enum Section {
NoSection = 0x0000,
AmPmSection = 0x0001,
MSecSection = 0x0002,
SecondSection = 0x0004,
MinuteSection = 0x0008,
HourSection = 0x0010,
DaySection = 0x0100,
MonthSection = 0x0200,
YearSection = 0x0400,
TimeSections_Mask = AmPmSection|MSecSection|SecondSection|MinuteSection|HourSection,
DateSections_Mask = DaySection|MonthSection|YearSection
};

typedef QFlags<Section> Sections;

explicit QDateTimeEdit(QWidget *parent = 0);
explicit QDateTimeEdit(const QDateTime &dt, QWidget *parent = 0);
explicit QDateTimeEdit(const QDate &d, QWidget *parent = 0);
explicit QDateTimeEdit(const QTime &t, QWidget *parent = 0);

QDateTime dateTime() const;
QDate date() const;
QTime time() const;

QDateTime minimumDateTime() const;
void clearMinimumDateTime();
void setMinimumDateTime(const QDateTime &dt);

QDateTime maximumDateTime() const;
void clearMaximumDateTime();
void setMaximumDateTime(const QDateTime &dt);

void setDateTimeRange(const QDateTime &min, const QDateTime &max);

QDate minimumDate() const;
void setMinimumDate(const QDate &min);
void clearMinimumDate();

QDate maximumDate() const;
void setMaximumDate(const QDate &max);
void clearMaximumDate();

void setDateRange(const QDate &min, const QDate &max);

QTime minimumTime() const;
void setMinimumTime(const QTime &min);
void clearMinimumTime();

QTime maximumTime() const;
void setMaximumTime(const QTime &max);
void clearMaximumTime();

void setTimeRange(const QTime &min, const QTime &max);

Sections displayedSections() const;
Section currentSection() const;
Section sectionAt(int index) const;
void setCurrentSection(Section section);

int currentSectionIndex() const;
void setCurrentSectionIndex(int index);

QCalendarWidget *calendarWidget() const;
void setCalendarWidget(QCalendarWidget *calendarWidget);

int sectionCount() const;

void setSelectedSection(Section section);

QString sectionText(Section section) const;

QString displayFormat() const;
void setDisplayFormat(const QString &format);

bool calendarPopup() const;
void setCalendarPopup(bool enable);

Qt::TimeSpec timeSpec() const;
void setTimeSpec(Qt::TimeSpec spec);

QSize sizeHint() const;

virtual void clear();
virtual void stepBy(int steps);

bool event(QEvent *event);
signals:
void dateTimeChanged(const QDateTime &date);
void timeChanged(const QTime &date);
void dateChanged(const QDate &date);

public slots:
void setDateTime(const QDateTime &dateTime);
void setDate(const QDate &date);
void setTime(const QTime &time);

protected:
virtual void keyPressEvent(QKeyEvent *event);

# 184 "/usr/share/qt4/include/QtGui/qdatetimeedit.h"
virtual void wheelEvent(QWheelEvent *event);

# 186 "/usr/share/qt4/include/QtGui/qdatetimeedit.h"
virtual void focusInEvent(QFocusEvent *event);
virtual bool focusNextPrevChild(bool next);
virtual QValidator::State validate(QString &input, int &pos) const;
virtual void fixup(QString &input) const;

virtual QDateTime dateTimeFromText(const QString &text) const;
virtual QString textFromDateTime(const QDateTime &dt) const;
virtual StepEnabled stepEnabled() const;
virtual void mousePressEvent(QMouseEvent *event);
virtual void paintEvent(QPaintEvent *event);
void initStyleOption(QStyleOptionSpinBox *option) const;

QDateTimeEdit(const QVariant &val, QVariant::Type parserType, QWidget *parent = 0);
private:
inline QDateTimeEditPrivate* d_func() { return reinterpret_cast<QDateTimeEditPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDateTimeEditPrivate* d_func() const { return reinterpret_cast<const QDateTimeEditPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDateTimeEditPrivate;
QDateTimeEdit(const QDateTimeEdit &); QDateTimeEdit &operator=(const QDateTimeEdit &);


};

class  QTimeEdit : public QDateTimeEdit
{
Q_OBJECT
Q_PROPERTY(QTime time READ time WRITE setTime NOTIFY timeChanged USER true)
public:
QTimeEdit(QWidget *parent = 0);
QTimeEdit(const QTime &time, QWidget *parent = 0);
};

class  QDateEdit : public QDateTimeEdit
{
Q_OBJECT
Q_PROPERTY(QDate date READ date WRITE setDate NOTIFY dateChanged USER true)
public:
QDateEdit(QWidget *parent = 0);
QDateEdit(const QDate &date, QWidget *parent = 0);
};

inline QFlags<QDateTimeEdit::Sections::enum_type> operator|(QDateTimeEdit::Sections::enum_type f1, QDateTimeEdit::Sections::enum_type f2) { return QFlags<QDateTimeEdit::Sections::enum_type>(f1) | f2; } inline QFlags<QDateTimeEdit::Sections::enum_type> operator|(QDateTimeEdit::Sections::enum_type f1, QFlags<QDateTimeEdit::Sections::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QDateTimeEdit::Sections::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 228 "/usr/share/qt4/include/QtGui/qdatetimeedit.h"





# 89 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qdial.h"













































# 1 "/usr/share/qt4/include/QtGui/qabstractslider.h"
























































































































































































# 46 "/usr/share/qt4/include/QtGui/qdial.h"


# 48 "/usr/share/qt4/include/QtGui/qdial.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qdial.h"
class QDialPrivate;
class QStyleOptionSlider;

class  QDial: public QAbstractSlider
{
Q_OBJECT

Q_PROPERTY(bool wrapping READ wrapping WRITE setWrapping)
Q_PROPERTY(int notchSize READ notchSize)
Q_PROPERTY(qreal notchTarget READ notchTarget WRITE setNotchTarget)
Q_PROPERTY(bool notchesVisible READ notchesVisible WRITE setNotchesVisible)
public:
explicit QDial(QWidget *parent = 0);

~QDial();

bool wrapping() const;

int notchSize() const;

void setNotchTarget(double target);
qreal notchTarget() const;
bool notchesVisible() const;

QSize sizeHint() const;
QSize minimumSizeHint() const;

public slots:
void setNotchesVisible(bool visible);
void setWrapping(bool on);

protected:
bool event(QEvent *e);
void resizeEvent(QResizeEvent *re);
void paintEvent(QPaintEvent *pe);

void mousePressEvent(QMouseEvent *me);
void mouseReleaseEvent(QMouseEvent *me);
void mouseMoveEvent(QMouseEvent *me);

void sliderChange(SliderChange change);
void initStyleOption(QStyleOptionSlider *option) const;













# 111 "/usr/share/qt4/include/QtGui/qdial.h"
private:
inline QDialPrivate* d_func() { return reinterpret_cast<QDialPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDialPrivate* d_func() const { return reinterpret_cast<const QDialPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDialPrivate;
QDial(const QDial &); QDial &operator=(const QDial &);
};



# 118 "/usr/share/qt4/include/QtGui/qdial.h"





# 90 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qdialogbuttonbox.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qdialogbuttonbox.h"


# 47 "/usr/share/qt4/include/QtGui/qdialogbuttonbox.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QAbstractButton;
class QPushButton;
class QDialogButtonBoxPrivate;

class  QDialogButtonBox : public QWidget
{
Q_OBJECT

Q_PROPERTY(Qt::Orientation orientation READ orientation WRITE setOrientation)
Q_PROPERTY(StandardButtons standardButtons READ standardButtons WRITE setStandardButtons)
Q_PROPERTY(bool centerButtons READ centerButtons WRITE setCenterButtons)

public:
enum ButtonRole {

InvalidRole = -1,
AcceptRole,
RejectRole,
DestructiveRole,
ActionRole,
HelpRole,
YesRole,
NoRole,
ResetRole,
ApplyRole,

NRoles
};

enum StandardButton {

NoButton = 0x00000000,
Ok = 0x00000400,
Save = 0x00000800,
SaveAll = 0x00001000,
Open = 0x00002000,
Yes = 0x00004000,
YesToAll = 0x00008000,
No = 0x00010000,
NoToAll = 0x00020000,
Abort = 0x00040000,
Retry = 0x00080000,
Ignore = 0x00100000,
Close = 0x00200000,
Cancel = 0x00400000,
Discard = 0x00800000,
Help = 0x01000000,
Apply = 0x02000000,
Reset = 0x04000000,
RestoreDefaults = 0x08000000,


# 105 "/usr/share/qt4/include/QtGui/qdialogbuttonbox.h"
FirstButton = Ok,
LastButton = RestoreDefaults

# 108 "/usr/share/qt4/include/QtGui/qdialogbuttonbox.h"
};

typedef QFlags<StandardButton> StandardButtons;

enum ButtonLayout {
WinLayout,
MacLayout,
KdeLayout,
GnomeLayout
};

QDialogButtonBox(QWidget *parent = 0);
QDialogButtonBox(Qt::Orientation orientation, QWidget *parent = 0);
QDialogButtonBox(StandardButtons buttons, Qt::Orientation orientation = Qt::Horizontal,
QWidget *parent = 0);
~QDialogButtonBox();

void setOrientation(Qt::Orientation orientation);
Qt::Orientation orientation() const;

void addButton(QAbstractButton *button, ButtonRole role);
QPushButton *addButton(const QString &text, ButtonRole role);
QPushButton *addButton(StandardButton button);
void removeButton(QAbstractButton *button);
void clear();

QList<QAbstractButton *> buttons() const;
ButtonRole buttonRole(QAbstractButton *button) const;

void setStandardButtons(StandardButtons buttons);
StandardButtons standardButtons() const;
StandardButton standardButton(QAbstractButton *button) const;
QPushButton *button(StandardButton which) const;

void setCenterButtons(bool center);
bool centerButtons() const;

signals:
void clicked(QAbstractButton *button);
void accepted();
void helpRequested();
void rejected();

protected:
void changeEvent(QEvent *event);
bool event(QEvent *event);

private:
QDialogButtonBox(const QDialogButtonBox &); QDialogButtonBox &operator=(const QDialogButtonBox &);
inline QDialogButtonBoxPrivate* d_func() { return reinterpret_cast<QDialogButtonBoxPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDialogButtonBoxPrivate* d_func() const { return reinterpret_cast<const QDialogButtonBoxPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDialogButtonBoxPrivate;


};

inline QFlags<QDialogButtonBox::StandardButtons::enum_type> operator|(QDialogButtonBox::StandardButtons::enum_type f1, QDialogButtonBox::StandardButtons::enum_type f2) { return QFlags<QDialogButtonBox::StandardButtons::enum_type>(f1) | f2; } inline QFlags<QDialogButtonBox::StandardButtons::enum_type> operator|(QDialogButtonBox::StandardButtons::enum_type f1, QFlags<QDialogButtonBox::StandardButtons::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QDialogButtonBox::StandardButtons::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }






# 91 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qdockwidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qdockwidget.h"


# 47 "/usr/share/qt4/include/QtGui/qdockwidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qdockwidget.h"
class QDockAreaLayout;
class QDockWidgetPrivate;
class QMainWindow;
class QStyleOptionDockWidget;

class  QDockWidget : public QWidget
{
Q_OBJECT


Q_PROPERTY(bool floating READ isFloating WRITE setFloating)
Q_PROPERTY(DockWidgetFeatures features READ features WRITE setFeatures NOTIFY featuresChanged)
Q_PROPERTY(Qt::DockWidgetAreas allowedAreas READ allowedAreas
WRITE setAllowedAreas NOTIFY allowedAreasChanged)
Q_PROPERTY(QString windowTitle READ windowTitle WRITE setWindowTitle DESIGNABLE true)

public:
explicit QDockWidget(const QString &title, QWidget *parent = 0, Qt::WindowFlags flags = 0);
explicit QDockWidget(QWidget *parent = 0, Qt::WindowFlags flags = 0);
~QDockWidget();

QWidget *widget() const;
void setWidget(QWidget *widget);

enum DockWidgetFeature {
DockWidgetClosable = 0x01,
DockWidgetMovable = 0x02,
DockWidgetFloatable = 0x04,
DockWidgetVerticalTitleBar = 0x08,

DockWidgetFeatureMask = 0x0f,
AllDockWidgetFeatures = DockWidgetClosable|DockWidgetMovable|DockWidgetFloatable, 
NoDockWidgetFeatures = 0x00,

Reserved = 0xff
};
typedef QFlags<DockWidgetFeature> DockWidgetFeatures;

void setFeatures(DockWidgetFeatures features);
DockWidgetFeatures features() const;

void setFloating(bool floating);
inline bool isFloating() const { return isWindow(); }

void setAllowedAreas(Qt::DockWidgetAreas areas);
Qt::DockWidgetAreas allowedAreas() const;

void setTitleBarWidget(QWidget *widget);
QWidget *titleBarWidget() const;

inline bool isAreaAllowed(Qt::DockWidgetArea area) const
{ return (allowedAreas() & area) == area; }


# 109 "/usr/share/qt4/include/QtGui/qdockwidget.h"
QAction *toggleViewAction() const;


# 112 "/usr/share/qt4/include/QtGui/qdockwidget.h"
signals:
void featuresChanged(QDockWidget::DockWidgetFeatures features);
void topLevelChanged(bool topLevel);
void allowedAreasChanged(Qt::DockWidgetAreas allowedAreas);
void visibilityChanged(bool visible);
void dockLocationChanged(Qt::DockWidgetArea area);

protected:
void changeEvent(QEvent *event);
void closeEvent(QCloseEvent *event);
void paintEvent(QPaintEvent *event);
bool event(QEvent *event);
void initStyleOption(QStyleOptionDockWidget *option) const;

private:
inline QDockWidgetPrivate* d_func() { return reinterpret_cast<QDockWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDockWidgetPrivate* d_func() const { return reinterpret_cast<const QDockWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDockWidgetPrivate;
QDockWidget(const QDockWidget &); QDockWidget &operator=(const QDockWidget &);


friend class QDockAreaLayout;
friend class QDockWidgetItem;
friend class QMainWindowLayout;
friend class QDockWidgetLayout;
friend class QDockAreaLayoutInfo;
};

inline QFlags<QDockWidget::DockWidgetFeatures::enum_type> operator|(QDockWidget::DockWidgetFeatures::enum_type f1, QDockWidget::DockWidgetFeatures::enum_type f2) { return QFlags<QDockWidget::DockWidgetFeatures::enum_type>(f1) | f2; } inline QFlags<QDockWidget::DockWidgetFeatures::enum_type> operator|(QDockWidget::DockWidgetFeatures::enum_type f1, QFlags<QDockWidget::DockWidgetFeatures::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QDockWidget::DockWidgetFeatures::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 142 "/usr/share/qt4/include/QtGui/qdockwidget.h"





# 92 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qfocusframe.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qfocusframe.h"


# 47 "/usr/share/qt4/include/QtGui/qfocusframe.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QFocusFramePrivate;
class QStyleOption;

class  QFocusFrame : public QWidget
{
Q_OBJECT
public:
QFocusFrame(QWidget *parent=0);
~QFocusFrame();

void setWidget(QWidget *widget);
QWidget *widget() const;

protected:
bool event(QEvent *e);

bool eventFilter(QObject *, QEvent *);
void paintEvent(QPaintEvent *);
void initStyleOption(QStyleOption *option) const;

private:
inline QFocusFramePrivate* d_func() { return reinterpret_cast<QFocusFramePrivate *>(qGetPtrHelper(d_ptr)); } inline const QFocusFramePrivate* d_func() const { return reinterpret_cast<const QFocusFramePrivate *>(qGetPtrHelper(d_ptr)); } friend class QFocusFramePrivate;
QFocusFrame(const QFocusFrame &); QFocusFrame &operator=(const QFocusFrame &);
};






# 93 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qfontcombobox.h"












































# 1 "/usr/share/qt4/include/QtGui/qcombobox.h"

















































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qfontcombobox.h"

# 1 "/usr/share/qt4/include/QtGui/qfontdatabase.h"


















































































































































































# 46 "/usr/share/qt4/include/QtGui/qfontcombobox.h"




# 50 "/usr/share/qt4/include/QtGui/qfontcombobox.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QFontComboBoxPrivate;

class  QFontComboBox : public QComboBox
{
Q_OBJECT

Q_PROPERTY(QFontDatabase::WritingSystem writingSystem READ writingSystem WRITE setWritingSystem)
Q_PROPERTY(FontFilters fontFilters READ fontFilters WRITE setFontFilters)
Q_PROPERTY(QFont currentFont READ currentFont WRITE setCurrentFont NOTIFY currentFontChanged)
Q_ENUMS(FontSelection)

public:
explicit QFontComboBox(QWidget *parent = 0);
~QFontComboBox();

void setWritingSystem(QFontDatabase::WritingSystem);
QFontDatabase::WritingSystem writingSystem() const;

enum FontFilter {
AllFonts = 0,
ScalableFonts = 0x1,
NonScalableFonts = 0x2,
MonospacedFonts = 0x4,
ProportionalFonts = 0x8
};
typedef QFlags<FontFilter> FontFilters;

void setFontFilters(FontFilters filters);
FontFilters fontFilters() const;

QFont currentFont() const;
QSize sizeHint() const;

public slots:
void setCurrentFont(const QFont &f);

signals:
void currentFontChanged(const QFont &f);

protected:
bool event(QEvent *e);

private:
QFontComboBox(const QFontComboBox &); QFontComboBox &operator=(const QFontComboBox &);
inline QFontComboBoxPrivate* d_func() { return reinterpret_cast<QFontComboBoxPrivate *>(qGetPtrHelper(d_ptr)); } inline const QFontComboBoxPrivate* d_func() const { return reinterpret_cast<const QFontComboBoxPrivate *>(qGetPtrHelper(d_ptr)); } friend class QFontComboBoxPrivate;


};

inline QFlags<QFontComboBox::FontFilters::enum_type> operator|(QFontComboBox::FontFilters::enum_type f1, QFontComboBox::FontFilters::enum_type f2) { return QFlags<QFontComboBox::FontFilters::enum_type>(f1) | f2; } inline QFlags<QFontComboBox::FontFilters::enum_type> operator|(QFontComboBox::FontFilters::enum_type f1, QFlags<QFontComboBox::FontFilters::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QFontComboBox::FontFilters::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }







# 94 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 95 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgroupbox.h"












































# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 45 "/usr/share/qt4/include/QtGui/qgroupbox.h"


# 47 "/usr/share/qt4/include/QtGui/qgroupbox.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qgroupbox.h"
class QGroupBoxPrivate;
class QStyleOptionGroupBox;
class  QGroupBox : public QWidget
{
Q_OBJECT

Q_PROPERTY(QString title READ title WRITE setTitle)
Q_PROPERTY(Qt::Alignment alignment READ alignment WRITE setAlignment)
Q_PROPERTY(bool flat READ isFlat WRITE setFlat)
Q_PROPERTY(bool checkable READ isCheckable WRITE setCheckable)
Q_PROPERTY(bool checked READ isChecked WRITE setChecked DESIGNABLE isCheckable NOTIFY toggled USER true)
public:
explicit QGroupBox(QWidget* parent=0);
explicit QGroupBox(const QString &title, QWidget* parent=0);
~QGroupBox();

QString title() const;
void setTitle(const QString &title);

Qt::Alignment alignment() const;
void setAlignment(int alignment);

QSize minimumSizeHint() const;

bool isFlat() const;
void setFlat(bool flat);
bool isCheckable() const;
void setCheckable(bool checkable);
bool isChecked() const;

public slots:
void setChecked(bool checked);

signals:
void clicked(bool checked = false);
void toggled(bool);

protected:
bool event(QEvent *event);
void childEvent(QChildEvent *event);
void resizeEvent(QResizeEvent *event);
void paintEvent(QPaintEvent *event);
void focusInEvent(QFocusEvent *event);
void changeEvent(QEvent *event);
void mousePressEvent(QMouseEvent *event);
void mouseMoveEvent(QMouseEvent *event);
void mouseReleaseEvent(QMouseEvent *event); 
void initStyleOption(QStyleOptionGroupBox *option) const;







# 110 "/usr/share/qt4/include/QtGui/qgroupbox.h"
private:
QGroupBox(const QGroupBox &); QGroupBox &operator=(const QGroupBox &);
inline QGroupBoxPrivate* d_func() { return reinterpret_cast<QGroupBoxPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGroupBoxPrivate* d_func() const { return reinterpret_cast<const QGroupBoxPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGroupBoxPrivate;

};



# 118 "/usr/share/qt4/include/QtGui/qgroupbox.h"





# 96 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qlabel.h"












































# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 45 "/usr/share/qt4/include/QtGui/qlabel.h"


# 47 "/usr/share/qt4/include/QtGui/qlabel.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QLabelPrivate;

class  QLabel : public QFrame
{
Q_OBJECT
Q_PROPERTY(QString text READ text WRITE setText)
Q_PROPERTY(Qt::TextFormat textFormat READ textFormat WRITE setTextFormat)
Q_PROPERTY(QPixmap pixmap READ pixmap WRITE setPixmap)
Q_PROPERTY(bool scaledContents READ hasScaledContents WRITE setScaledContents)
Q_PROPERTY(Qt::Alignment alignment READ alignment WRITE setAlignment)
Q_PROPERTY(bool wordWrap READ wordWrap WRITE setWordWrap)
Q_PROPERTY(int margin READ margin WRITE setMargin)
Q_PROPERTY(int indent READ indent WRITE setIndent)
Q_PROPERTY(bool openExternalLinks READ openExternalLinks WRITE setOpenExternalLinks)
Q_PROPERTY(Qt::TextInteractionFlags textInteractionFlags READ textInteractionFlags WRITE setTextInteractionFlags)

public:
explicit QLabel(QWidget *parent=0, Qt::WindowFlags f=0);
explicit QLabel(const QString &text, QWidget *parent=0, Qt::WindowFlags f=0);
~QLabel();

QString text() const;
const QPixmap *pixmap() const;

# 77 "/usr/share/qt4/include/QtGui/qlabel.h"
const QPicture *picture() const;


# 80 "/usr/share/qt4/include/QtGui/qlabel.h"
QMovie *movie() const;


# 83 "/usr/share/qt4/include/QtGui/qlabel.h"
Qt::TextFormat textFormat() const;
void setTextFormat(Qt::TextFormat);

Qt::Alignment alignment() const;
void setAlignment(Qt::Alignment);

void setWordWrap(bool on);
bool wordWrap() const;

int indent() const;
void setIndent(int);

int margin() const;
void setMargin(int);

bool hasScaledContents() const;
void setScaledContents(bool);
QSize sizeHint() const;
QSize minimumSizeHint() const;

# 103 "/usr/share/qt4/include/QtGui/qlabel.h"
void setBuddy(QWidget *);
QWidget *buddy() const;

# 106 "/usr/share/qt4/include/QtGui/qlabel.h"
int heightForWidth(int) const;

bool openExternalLinks() const;
void setOpenExternalLinks(bool open);

void setTextInteractionFlags(Qt::TextInteractionFlags flags);
Qt::TextInteractionFlags textInteractionFlags() const;

public slots:
void setText(const QString &);
void setPixmap(const QPixmap &);

# 118 "/usr/share/qt4/include/QtGui/qlabel.h"
void setPicture(const QPicture &);


# 121 "/usr/share/qt4/include/QtGui/qlabel.h"
void setMovie(QMovie *movie);

# 123 "/usr/share/qt4/include/QtGui/qlabel.h"
void setNum(int);
void setNum(double);
void clear();

signals:
void linkActivated(const QString& link);
void linkHovered(const QString& link);

protected:
bool event(QEvent *e);
void keyPressEvent(QKeyEvent *ev);
void paintEvent(QPaintEvent *);
void changeEvent(QEvent *);
void mousePressEvent(QMouseEvent *ev);
void mouseMoveEvent(QMouseEvent *ev);
void mouseReleaseEvent(QMouseEvent *ev);
void contextMenuEvent(QContextMenuEvent *ev);
void focusInEvent(QFocusEvent *ev);
void focusOutEvent(QFocusEvent *ev);
bool focusNextPrevChild(bool next);














# 157 "/usr/share/qt4/include/QtGui/qlabel.h"
private:
QLabel(const QLabel &); QLabel &operator=(const QLabel &);
inline QLabelPrivate* d_func() { return reinterpret_cast<QLabelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QLabelPrivate* d_func() const { return reinterpret_cast<const QLabelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QLabelPrivate;

# 161 "/usr/share/qt4/include/QtGui/qlabel.h"



# 164 "/usr/share/qt4/include/QtGui/qlabel.h"


friend class QTipLabel;
friend class QMessageBoxPrivate;
friend class QBalloonTip;
};






# 97 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qlcdnumber.h"












































# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 45 "/usr/share/qt4/include/QtGui/qlcdnumber.h"

# 1 "/usr/share/qt4/include/QtCore/qbitarray.h"














































































































































































# 46 "/usr/share/qt4/include/QtGui/qlcdnumber.h"


# 48 "/usr/share/qt4/include/QtGui/qlcdnumber.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qlcdnumber.h"
class QLCDNumberPrivate;
class  QLCDNumber : public QFrame 
{
Q_OBJECT
Q_ENUMS(Mode SegmentStyle)
Q_PROPERTY(bool smallDecimalPoint READ smallDecimalPoint WRITE setSmallDecimalPoint)
Q_PROPERTY(int numDigits READ numDigits WRITE setNumDigits)
Q_PROPERTY(int digitCount READ digitCount WRITE setDigitCount)
Q_PROPERTY(Mode mode READ mode WRITE setMode)
Q_PROPERTY(SegmentStyle segmentStyle READ segmentStyle WRITE setSegmentStyle)
Q_PROPERTY(double value READ value WRITE display)
Q_PROPERTY(int intValue READ intValue WRITE display)

public:
explicit QLCDNumber(QWidget* parent = 0);
explicit QLCDNumber(uint numDigits, QWidget* parent = 0);
~QLCDNumber();

enum Mode {
Hex, Dec, Oct, Bin



# 79 "/usr/share/qt4/include/QtGui/qlcdnumber.h"
};
enum SegmentStyle {
Outline, Filled, Flat
};

bool smallDecimalPoint() const;

# 86 "/usr/share/qt4/include/QtGui/qlcdnumber.h"
 int numDigits() const;
 void setNumDigits(int nDigits);

# 89 "/usr/share/qt4/include/QtGui/qlcdnumber.h"
int digitCount() const;
void setDigitCount(int nDigits);

bool checkOverflow(double num) const;
bool checkOverflow(int num) const;

Mode mode() const;
void setMode(Mode);

SegmentStyle segmentStyle() const;
void setSegmentStyle(SegmentStyle);

double value() const;
int intValue() const;

QSize sizeHint() const;

public slots:
void display(const QString &str);
void display(int num);
void display(double num);
void setHexMode();
void setDecMode();
void setOctMode();
void setBinMode();
void setSmallDecimalPoint(bool);

signals:
void overflow();

protected:
bool event(QEvent *e);
void paintEvent(QPaintEvent *);

public:









# 133 "/usr/share/qt4/include/QtGui/qlcdnumber.h"
private:
QLCDNumber(const QLCDNumber &); QLCDNumber &operator=(const QLCDNumber &);
inline QLCDNumberPrivate* d_func() { return reinterpret_cast<QLCDNumberPrivate *>(qGetPtrHelper(d_ptr)); } inline const QLCDNumberPrivate* d_func() const { return reinterpret_cast<const QLCDNumberPrivate *>(qGetPtrHelper(d_ptr)); } friend class QLCDNumberPrivate;
};



# 140 "/usr/share/qt4/include/QtGui/qlcdnumber.h"





# 98 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qlineedit.h"












































# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 45 "/usr/share/qt4/include/QtGui/qlineedit.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qlineedit.h"

# 1 "/usr/share/qt4/include/QtCore/qmargins.h"

















































































































































# 47 "/usr/share/qt4/include/QtGui/qlineedit.h"


# 49 "/usr/share/qt4/include/QtGui/qlineedit.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 57 "/usr/share/qt4/include/QtGui/qlineedit.h"
class QValidator;
class QMenu;
class QLineEditPrivate;
class QCompleter;
class QStyleOptionFrame;
class QAbstractSpinBox;
class QDateTimeEdit;

class  QLineEdit : public QWidget
{
Q_OBJECT

Q_ENUMS(EchoMode)
Q_PROPERTY(QString inputMask READ inputMask WRITE setInputMask)
Q_PROPERTY(QString text READ text WRITE setText NOTIFY textChanged USER true)
Q_PROPERTY(int maxLength READ maxLength WRITE setMaxLength)
Q_PROPERTY(bool frame READ hasFrame WRITE setFrame)
Q_PROPERTY(EchoMode echoMode READ echoMode WRITE setEchoMode)
Q_PROPERTY(QString displayText READ displayText)
Q_PROPERTY(int cursorPosition READ cursorPosition WRITE setCursorPosition)
Q_PROPERTY(Qt::Alignment alignment READ alignment WRITE setAlignment)
Q_PROPERTY(bool modified READ isModified WRITE setModified DESIGNABLE false)
Q_PROPERTY(bool hasSelectedText READ hasSelectedText)
Q_PROPERTY(QString selectedText READ selectedText)
Q_PROPERTY(bool dragEnabled READ dragEnabled WRITE setDragEnabled)
Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly)
Q_PROPERTY(bool undoAvailable READ isUndoAvailable)
Q_PROPERTY(bool redoAvailable READ isRedoAvailable)
Q_PROPERTY(bool acceptableInput READ hasAcceptableInput)





# 91 "/usr/share/qt4/include/QtGui/qlineedit.h"
public:
explicit QLineEdit(QWidget* parent=0);
explicit QLineEdit(const QString &, QWidget* parent=0);





# 99 "/usr/share/qt4/include/QtGui/qlineedit.h"
~QLineEdit();

QString text() const;

QString displayText() const;







# 111 "/usr/share/qt4/include/QtGui/qlineedit.h"
int maxLength() const;
void setMaxLength(int);

void setFrame(bool);
bool hasFrame() const;

enum EchoMode { Normal, NoEcho, Password, PasswordEchoOnEdit };
EchoMode echoMode() const;
void setEchoMode(EchoMode);

bool isReadOnly() const;
void setReadOnly(bool);


# 125 "/usr/share/qt4/include/QtGui/qlineedit.h"
void setValidator(const QValidator *);
const QValidator * validator() const;



# 130 "/usr/share/qt4/include/QtGui/qlineedit.h"
void setCompleter(QCompleter *completer);
QCompleter *completer() const;


# 134 "/usr/share/qt4/include/QtGui/qlineedit.h"
QSize sizeHint() const;
QSize minimumSizeHint() const;

int cursorPosition() const;
void setCursorPosition(int);
int cursorPositionAt(const QPoint &pos);

void setAlignment(Qt::Alignment flag);
Qt::Alignment alignment() const;

void cursorForward(bool mark, int steps = 1);
void cursorBackward(bool mark, int steps = 1);
void cursorWordForward(bool mark);
void cursorWordBackward(bool mark);
void backspace();
void del();
void home(bool mark);
void end(bool mark);

bool isModified() const;
void setModified(bool);

void setSelection(int, int);
bool hasSelectedText() const;
QString selectedText() const;
int selectionStart() const;

bool isUndoAvailable() const;
bool isRedoAvailable() const;

void setDragEnabled(bool b);
bool dragEnabled() const;

QString inputMask() const;
void setInputMask(const QString &inputMask);
bool hasAcceptableInput() const;

void setTextMargins(int left, int top, int right, int bottom);
void setTextMargins(const QMargins &margins);
void getTextMargins(int *left, int *top, int *right, int *bottom) const;
QMargins textMargins() const;

public slots:
void setText(const QString &);
void clear();
void selectAll();
void undo();
void redo();

# 183 "/usr/share/qt4/include/QtGui/qlineedit.h"
void cut();
void copy() const;
void paste();


# 188 "/usr/share/qt4/include/QtGui/qlineedit.h"
public:
void deselect();
void insert(const QString &);

# 192 "/usr/share/qt4/include/QtGui/qlineedit.h"
QMenu *createStandardContextMenu();


# 195 "/usr/share/qt4/include/QtGui/qlineedit.h"
signals:
void textChanged(const QString &);
void textEdited(const QString &);
void cursorPositionChanged(int, int);
void returnPressed();
void editingFinished();
void selectionChanged();

protected:
void mousePressEvent(QMouseEvent *);
void mouseMoveEvent(QMouseEvent *);
void mouseReleaseEvent(QMouseEvent *);
void mouseDoubleClickEvent(QMouseEvent *);
void keyPressEvent(QKeyEvent *);
void focusInEvent(QFocusEvent *);
void focusOutEvent(QFocusEvent *);
void paintEvent(QPaintEvent *);

# 213 "/usr/share/qt4/include/QtGui/qlineedit.h"
void dragEnterEvent(QDragEnterEvent *);
void dragMoveEvent(QDragMoveEvent *e);
void dragLeaveEvent(QDragLeaveEvent *e);
void dropEvent(QDropEvent *);

# 218 "/usr/share/qt4/include/QtGui/qlineedit.h"
void changeEvent(QEvent *);

# 220 "/usr/share/qt4/include/QtGui/qlineedit.h"
void contextMenuEvent(QContextMenuEvent *);





# 226 "/usr/share/qt4/include/QtGui/qlineedit.h"
void inputMethodEvent(QInputMethodEvent *);
void initStyleOption(QStyleOptionFrame *option) const;
public:
QVariant inputMethodQuery(Qt::InputMethodQuery) const;
bool event(QEvent *);
protected:
QRect cursorRect() const;

public:








































# 275 "/usr/share/qt4/include/QtGui/qlineedit.h"
private:
friend class QAbstractSpinBox;



# 280 "/usr/share/qt4/include/QtGui/qlineedit.h"
QLineEdit(const QLineEdit &); QLineEdit &operator=(const QLineEdit &);
inline QLineEditPrivate* d_func() { return reinterpret_cast<QLineEditPrivate *>(qGetPtrHelper(d_ptr)); } inline const QLineEditPrivate* d_func() const { return reinterpret_cast<const QLineEditPrivate *>(qGetPtrHelper(d_ptr)); } friend class QLineEditPrivate;




# 286 "/usr/share/qt4/include/QtGui/qlineedit.h"





# 291 "/usr/share/qt4/include/QtGui/qlineedit.h"

};



# 296 "/usr/share/qt4/include/QtGui/qlineedit.h"





# 99 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmainwindow.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qmainwindow.h"

# 1 "/usr/share/qt4/include/QtGui/qtabwidget.h"




























































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qmainwindow.h"


# 48 "/usr/share/qt4/include/QtGui/qmainwindow.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qmainwindow.h"
class QDockWidget;
class QMainWindowPrivate;
class QMenuBar;
class QStatusBar;
class QToolBar;
class QMenu;

class  QMainWindow : public QWidget
{
Q_OBJECT

Q_ENUMS(DockOption)

Q_PROPERTY(QSize iconSize READ iconSize WRITE setIconSize)
Q_PROPERTY(Qt::ToolButtonStyle toolButtonStyle READ toolButtonStyle WRITE setToolButtonStyle)

# 72 "/usr/share/qt4/include/QtGui/qmainwindow.h"
Q_PROPERTY(bool animated READ isAnimated WRITE setAnimated)

# 74 "/usr/share/qt4/include/QtGui/qmainwindow.h"
Q_PROPERTY(bool documentMode READ documentMode WRITE setDocumentMode)


# 77 "/usr/share/qt4/include/QtGui/qmainwindow.h"
Q_PROPERTY(QTabWidget::TabShape tabShape READ tabShape WRITE setTabShape)

# 79 "/usr/share/qt4/include/QtGui/qmainwindow.h"
Q_PROPERTY(bool dockNestingEnabled READ isDockNestingEnabled WRITE setDockNestingEnabled)

# 81 "/usr/share/qt4/include/QtGui/qmainwindow.h"
Q_PROPERTY(DockOptions dockOptions READ dockOptions WRITE setDockOptions)

# 83 "/usr/share/qt4/include/QtGui/qmainwindow.h"
Q_PROPERTY(bool unifiedTitleAndToolBarOnMac READ unifiedTitleAndToolBarOnMac WRITE setUnifiedTitleAndToolBarOnMac)


# 86 "/usr/share/qt4/include/QtGui/qmainwindow.h"
public:
enum DockOption {
AnimatedDocks = 0x01,
AllowNestedDocks = 0x02,
AllowTabbedDocks = 0x04,
ForceTabbedDocks = 0x08, 
VerticalTabs = 0x10 
};
typedef QFlags<DockOption> DockOptions;

explicit QMainWindow(QWidget *parent = 0, Qt::WindowFlags flags = 0);
~QMainWindow();

QSize iconSize() const;
void setIconSize(const QSize &iconSize);

Qt::ToolButtonStyle toolButtonStyle() const;
void setToolButtonStyle(Qt::ToolButtonStyle toolButtonStyle);


# 106 "/usr/share/qt4/include/QtGui/qmainwindow.h"
bool isAnimated() const;
bool isDockNestingEnabled() const;



# 111 "/usr/share/qt4/include/QtGui/qmainwindow.h"
bool documentMode() const;
void setDocumentMode(bool enabled);



# 116 "/usr/share/qt4/include/QtGui/qmainwindow.h"
QTabWidget::TabShape tabShape() const;
void setTabShape(QTabWidget::TabShape tabShape);
QTabWidget::TabPosition tabPosition(Qt::DockWidgetArea area) const;
void setTabPosition(Qt::DockWidgetAreas areas, QTabWidget::TabPosition tabPosition);


# 122 "/usr/share/qt4/include/QtGui/qmainwindow.h"
void setDockOptions(DockOptions options);
DockOptions dockOptions() const;

bool isSeparator(const QPoint &pos) const;


# 128 "/usr/share/qt4/include/QtGui/qmainwindow.h"
QMenuBar *menuBar() const;
void setMenuBar(QMenuBar *menubar);

QWidget *menuWidget() const;
void setMenuWidget(QWidget *menubar);



# 136 "/usr/share/qt4/include/QtGui/qmainwindow.h"
QStatusBar *statusBar() const;
void setStatusBar(QStatusBar *statusbar);


# 140 "/usr/share/qt4/include/QtGui/qmainwindow.h"
QWidget *centralWidget() const;
void setCentralWidget(QWidget *widget);


# 144 "/usr/share/qt4/include/QtGui/qmainwindow.h"
void setCorner(Qt::Corner corner, Qt::DockWidgetArea area);
Qt::DockWidgetArea corner(Qt::Corner corner) const;



# 149 "/usr/share/qt4/include/QtGui/qmainwindow.h"
void addToolBarBreak(Qt::ToolBarArea area = Qt::TopToolBarArea);
void insertToolBarBreak(QToolBar *before);

void addToolBar(Qt::ToolBarArea area, QToolBar *toolbar);
void addToolBar(QToolBar *toolbar);
QToolBar *addToolBar(const QString &title);
void insertToolBar(QToolBar *before, QToolBar *toolbar);
void removeToolBar(QToolBar *toolbar);
void removeToolBarBreak(QToolBar *before);

void setUnifiedTitleAndToolBarOnMac(bool set);
bool unifiedTitleAndToolBarOnMac() const;

Qt::ToolBarArea toolBarArea(QToolBar *toolbar) const;
bool toolBarBreak(QToolBar *toolbar) const;


# 166 "/usr/share/qt4/include/QtGui/qmainwindow.h"
void addDockWidget(Qt::DockWidgetArea area, QDockWidget *dockwidget);
void addDockWidget(Qt::DockWidgetArea area, QDockWidget *dockwidget,
Qt::Orientation orientation);
void splitDockWidget(QDockWidget *after, QDockWidget *dockwidget,
Qt::Orientation orientation);
void tabifyDockWidget(QDockWidget *first, QDockWidget *second);
QList<QDockWidget*> tabifiedDockWidgets(QDockWidget *dockwidget) const;
void removeDockWidget(QDockWidget *dockwidget);
bool restoreDockWidget(QDockWidget *dockwidget);

Qt::DockWidgetArea dockWidgetArea(QDockWidget *dockwidget) const;


# 179 "/usr/share/qt4/include/QtGui/qmainwindow.h"
QByteArray saveState(int version = 0) const;
bool restoreState(const QByteArray &state, int version = 0);


# 183 "/usr/share/qt4/include/QtGui/qmainwindow.h"
virtual QMenu *createPopupMenu();







# 191 "/usr/share/qt4/include/QtGui/qmainwindow.h"
public slots:
void setAnimated(bool enabled);
void setDockNestingEnabled(bool enabled);


# 196 "/usr/share/qt4/include/QtGui/qmainwindow.h"
signals:
void iconSizeChanged(const QSize &iconSize);
void toolButtonStyleChanged(Qt::ToolButtonStyle toolButtonStyle);

protected:

# 202 "/usr/share/qt4/include/QtGui/qmainwindow.h"
void contextMenuEvent(QContextMenuEvent *event);

# 204 "/usr/share/qt4/include/QtGui/qmainwindow.h"
bool event(QEvent *event);

private:
inline QMainWindowPrivate* d_func() { return reinterpret_cast<QMainWindowPrivate *>(qGetPtrHelper(d_ptr)); } inline const QMainWindowPrivate* d_func() const { return reinterpret_cast<const QMainWindowPrivate *>(qGetPtrHelper(d_ptr)); } friend class QMainWindowPrivate;
QMainWindow(const QMainWindow &); QMainWindow &operator=(const QMainWindow &);
};

inline QFlags<QMainWindow::DockOptions::enum_type> operator|(QMainWindow::DockOptions::enum_type f1, QMainWindow::DockOptions::enum_type f2) { return QFlags<QMainWindow::DockOptions::enum_type>(f1) | f2; } inline QFlags<QMainWindow::DockOptions::enum_type> operator|(QMainWindow::DockOptions::enum_type f1, QFlags<QMainWindow::DockOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QMainWindow::DockOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 215 "/usr/share/qt4/include/QtGui/qmainwindow.h"





# 100 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmdiarea.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"
















































































































































# 45 "/usr/share/qt4/include/QtGui/qmdiarea.h"

# 1 "/usr/share/qt4/include/QtGui/qtabwidget.h"




























































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qmdiarea.h"


# 48 "/usr/share/qt4/include/QtGui/qmdiarea.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qmdiarea.h"
class QMdiSubWindow;

class QMdiAreaPrivate;
class  QMdiArea : public QAbstractScrollArea
{
Q_OBJECT
Q_ENUMS(ViewMode)
Q_PROPERTY(QBrush background READ background WRITE setBackground)
Q_PROPERTY(WindowOrder activationOrder READ activationOrder WRITE setActivationOrder)
Q_PROPERTY(ViewMode viewMode READ viewMode WRITE setViewMode)

# 67 "/usr/share/qt4/include/QtGui/qmdiarea.h"
Q_PROPERTY(bool documentMode READ documentMode WRITE setDocumentMode)


# 70 "/usr/share/qt4/include/QtGui/qmdiarea.h"
Q_PROPERTY(QTabWidget::TabShape tabShape READ tabShape WRITE setTabShape)
Q_PROPERTY(QTabWidget::TabPosition tabPosition READ tabPosition WRITE setTabPosition)

# 73 "/usr/share/qt4/include/QtGui/qmdiarea.h"
Q_ENUMS(WindowOrder)
public:
enum AreaOption {
DontMaximizeSubWindowOnActivation = 0x1
};
typedef QFlags<AreaOption> AreaOptions;

enum WindowOrder {
CreationOrder,
StackingOrder,
ActivationHistoryOrder
};

enum ViewMode {
SubWindowView,
TabbedView
};

QMdiArea(QWidget *parent = 0);
~QMdiArea();

QSize sizeHint() const;
QSize minimumSizeHint() const;

QMdiSubWindow *currentSubWindow() const;
QMdiSubWindow *activeSubWindow() const;
QList<QMdiSubWindow *> subWindowList(WindowOrder order = CreationOrder) const;

QMdiSubWindow *addSubWindow(QWidget *widget, Qt::WindowFlags flags = 0);
void removeSubWindow(QWidget *widget);

QBrush background() const;
void setBackground(const QBrush &background);

WindowOrder activationOrder() const;
void setActivationOrder(WindowOrder order);

void setOption(AreaOption option, bool on = true);
bool testOption(AreaOption opton) const;

void setViewMode(ViewMode mode);
ViewMode viewMode() const;


# 117 "/usr/share/qt4/include/QtGui/qmdiarea.h"
bool documentMode() const;
void setDocumentMode(bool enabled);


# 121 "/usr/share/qt4/include/QtGui/qmdiarea.h"
void setTabShape(QTabWidget::TabShape shape);
QTabWidget::TabShape tabShape() const;

void setTabPosition(QTabWidget::TabPosition position);
QTabWidget::TabPosition tabPosition() const;


# 128 "/usr/share/qt4/include/QtGui/qmdiarea.h"
signals:
void subWindowActivated(QMdiSubWindow *);

public slots:
void setActiveSubWindow(QMdiSubWindow *window);
void tileSubWindows();
void cascadeSubWindows();
void closeActiveSubWindow();
void closeAllSubWindows();
void activateNextSubWindow();
void activatePreviousSubWindow();

protected slots:
void setupViewport(QWidget *viewport);

protected:
bool event(QEvent *event);
bool eventFilter(QObject *object, QEvent *event);
void paintEvent(QPaintEvent *paintEvent);
void childEvent(QChildEvent *childEvent);
void resizeEvent(QResizeEvent *resizeEvent);
void timerEvent(QTimerEvent *timerEvent);
void showEvent(QShowEvent *showEvent);
bool viewportEvent(QEvent *event);
void scrollContentsBy(int dx, int dy);

private:
QMdiArea(const QMdiArea &); QMdiArea &operator=(const QMdiArea &);
inline QMdiAreaPrivate* d_func() { return reinterpret_cast<QMdiAreaPrivate *>(qGetPtrHelper(d_ptr)); } inline const QMdiAreaPrivate* d_func() const { return reinterpret_cast<const QMdiAreaPrivate *>(qGetPtrHelper(d_ptr)); } friend class QMdiAreaPrivate;



};

inline QFlags<QMdiArea::AreaOptions::enum_type> operator|(QMdiArea::AreaOptions::enum_type f1, QMdiArea::AreaOptions::enum_type f2) { return QFlags<QMdiArea::AreaOptions::enum_type>(f1) | f2; } inline QFlags<QMdiArea::AreaOptions::enum_type> operator|(QMdiArea::AreaOptions::enum_type f1, QFlags<QMdiArea::AreaOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QMdiArea::AreaOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }







# 101 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmdisubwindow.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qmdisubwindow.h"


# 47 "/usr/share/qt4/include/QtGui/qmdisubwindow.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qmdisubwindow.h"
class QMenu;
class QMdiArea;

namespace QMdi { class ControlContainer; }
class QMdiSubWindowPrivate;
class  QMdiSubWindow : public QWidget
{
Q_OBJECT
Q_PROPERTY(int keyboardSingleStep READ keyboardSingleStep WRITE setKeyboardSingleStep)
Q_PROPERTY(int keyboardPageStep READ keyboardPageStep WRITE setKeyboardPageStep)
public:
enum SubWindowOption {
AllowOutsideAreaHorizontally = 0x1, 
AllowOutsideAreaVertically = 0x2, 
RubberBandResize = 0x4,
RubberBandMove = 0x8
};
typedef QFlags<SubWindowOption> SubWindowOptions;

QMdiSubWindow(QWidget *parent = 0, Qt::WindowFlags flags = 0);
~QMdiSubWindow();

QSize sizeHint() const;
QSize minimumSizeHint() const;

void setWidget(QWidget *widget);
QWidget *widget() const;

QWidget *maximizedButtonsWidget() const; 
QWidget *maximizedSystemMenuIconWidget() const; 

bool isShaded() const;

void setOption(SubWindowOption option, bool on = true);
bool testOption(SubWindowOption) const;

void setKeyboardSingleStep(int step);
int keyboardSingleStep() const;

void setKeyboardPageStep(int step);
int keyboardPageStep() const;


# 98 "/usr/share/qt4/include/QtGui/qmdisubwindow.h"
void setSystemMenu(QMenu *systemMenu);
QMenu *systemMenu() const;


# 102 "/usr/share/qt4/include/QtGui/qmdisubwindow.h"
QMdiArea *mdiArea() const;

signals:
void windowStateChanged(Qt::WindowStates oldState, Qt::WindowStates newState);
void aboutToActivate();

public slots:

# 110 "/usr/share/qt4/include/QtGui/qmdisubwindow.h"
void showSystemMenu();

# 112 "/usr/share/qt4/include/QtGui/qmdisubwindow.h"
void showShaded();

protected:
bool eventFilter(QObject *object, QEvent *event);
bool event(QEvent *event);
void showEvent(QShowEvent *showEvent);
void hideEvent(QHideEvent *hideEvent);
void changeEvent(QEvent *changeEvent);
void closeEvent(QCloseEvent *closeEvent);
void leaveEvent(QEvent *leaveEvent);
void resizeEvent(QResizeEvent *resizeEvent);
void timerEvent(QTimerEvent *timerEvent);
void moveEvent(QMoveEvent *moveEvent);
void paintEvent(QPaintEvent *paintEvent);
void mousePressEvent(QMouseEvent *mouseEvent);
void mouseDoubleClickEvent(QMouseEvent *mouseEvent);
void mouseReleaseEvent(QMouseEvent *mouseEvent);
void mouseMoveEvent(QMouseEvent *mouseEvent);
void keyPressEvent(QKeyEvent *keyEvent);

# 132 "/usr/share/qt4/include/QtGui/qmdisubwindow.h"
void contextMenuEvent(QContextMenuEvent *contextMenuEvent);

# 134 "/usr/share/qt4/include/QtGui/qmdisubwindow.h"
void focusInEvent(QFocusEvent *focusInEvent);
void focusOutEvent(QFocusEvent *focusOutEvent);
void childEvent(QChildEvent *childEvent);

private:
QMdiSubWindow(const QMdiSubWindow &); QMdiSubWindow &operator=(const QMdiSubWindow &);
inline QMdiSubWindowPrivate* d_func() { return reinterpret_cast<QMdiSubWindowPrivate *>(qGetPtrHelper(d_ptr)); } inline const QMdiSubWindowPrivate* d_func() const { return reinterpret_cast<const QMdiSubWindowPrivate *>(qGetPtrHelper(d_ptr)); } friend class QMdiSubWindowPrivate;



friend class QMdiAreaPrivate;

# 146 "/usr/share/qt4/include/QtGui/qmdisubwindow.h"
friend class QMdiAreaTabBar;

# 148 "/usr/share/qt4/include/QtGui/qmdisubwindow.h"
friend class QMdi::ControlContainer;
};

inline QFlags<QMdiSubWindow::SubWindowOptions::enum_type> operator|(QMdiSubWindow::SubWindowOptions::enum_type f1, QMdiSubWindow::SubWindowOptions::enum_type f2) { return QFlags<QMdiSubWindow::SubWindowOptions::enum_type>(f1) | f2; } inline QFlags<QMdiSubWindow::SubWindowOptions::enum_type> operator|(QMdiSubWindow::SubWindowOptions::enum_type f1, QFlags<QMdiSubWindow::SubWindowOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QMdiSubWindow::SubWindowOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }








# 102 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmenu.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qmenu.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qmenu.h"

# 1 "/usr/share/qt4/include/QtGui/qicon.h"


























































































































































# 47 "/usr/share/qt4/include/QtGui/qmenu.h"

# 1 "/usr/share/qt4/include/QtGui/qaction.h"












































# 1 "/usr/share/qt4/include/QtGui/qkeysequence.h"







































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qaction.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qaction.h"

# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qaction.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qaction.h"

# 1 "/usr/share/qt4/include/QtGui/qicon.h"


























































































































































# 49 "/usr/share/qt4/include/QtGui/qaction.h"


# 51 "/usr/share/qt4/include/QtGui/qaction.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 59 "/usr/share/qt4/include/QtGui/qaction.h"
class QMenu;
class QActionGroup;
class QActionPrivate;
class QGraphicsWidget;

class  QAction : public QObject
{
Q_OBJECT
inline QActionPrivate* d_func() { return reinterpret_cast<QActionPrivate *>(qGetPtrHelper(d_ptr)); } inline const QActionPrivate* d_func() const { return reinterpret_cast<const QActionPrivate *>(qGetPtrHelper(d_ptr)); } friend class QActionPrivate;

Q_ENUMS(MenuRole)
Q_ENUMS(SoftKeyRole)
Q_ENUMS(Priority)
Q_PROPERTY(bool checkable READ isCheckable WRITE setCheckable NOTIFY changed)
Q_PROPERTY(bool checked READ isChecked WRITE setChecked DESIGNABLE isCheckable NOTIFY toggled)
Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled NOTIFY changed)
Q_PROPERTY(QIcon icon READ icon WRITE setIcon NOTIFY changed)
Q_PROPERTY(QString text READ text WRITE setText NOTIFY changed)
Q_PROPERTY(QString iconText READ iconText WRITE setIconText NOTIFY changed)
Q_PROPERTY(QString toolTip READ toolTip WRITE setToolTip NOTIFY changed)
Q_PROPERTY(QString statusTip READ statusTip WRITE setStatusTip NOTIFY changed)
Q_PROPERTY(QString whatsThis READ whatsThis WRITE setWhatsThis NOTIFY changed)
Q_PROPERTY(QFont font READ font WRITE setFont NOTIFY changed)

# 83 "/usr/share/qt4/include/QtGui/qaction.h"
Q_PROPERTY(QKeySequence shortcut READ shortcut WRITE setShortcut NOTIFY changed)
Q_PROPERTY(Qt::ShortcutContext shortcutContext READ shortcutContext WRITE setShortcutContext NOTIFY changed)
Q_PROPERTY(bool autoRepeat READ autoRepeat WRITE setAutoRepeat NOTIFY changed)

# 87 "/usr/share/qt4/include/QtGui/qaction.h"
Q_PROPERTY(bool visible READ isVisible WRITE setVisible NOTIFY changed)
Q_PROPERTY(MenuRole menuRole READ menuRole WRITE setMenuRole NOTIFY changed)
Q_PROPERTY(SoftKeyRole softKeyRole READ softKeyRole WRITE setSoftKeyRole NOTIFY changed)
Q_PROPERTY(bool iconVisibleInMenu READ isIconVisibleInMenu WRITE setIconVisibleInMenu NOTIFY changed)
Q_PROPERTY(Priority priority READ priority WRITE setPriority)

public:
enum MenuRole { NoRole, TextHeuristicRole, ApplicationSpecificRole, AboutQtRole,
AboutRole, PreferencesRole, QuitRole };
enum SoftKeyRole {
NoSoftKey, PositiveSoftKey, NegativeSoftKey, SelectSoftKey };
enum Priority { LowPriority = 0,
NormalPriority = 128,
HighPriority = 256};
explicit QAction(QObject* parent);
QAction(const QString &text, QObject* parent);
QAction(const QIcon &icon, const QString &text, QObject* parent);









# 113 "/usr/share/qt4/include/QtGui/qaction.h"
~QAction();

void setActionGroup(QActionGroup *group);
QActionGroup *actionGroup() const;
void setIcon(const QIcon &icon);
QIcon icon() const;

void setText(const QString &text);
QString text() const;

void setIconText(const QString &text);
QString iconText() const;

void setToolTip(const QString &tip);
QString toolTip() const;

void setStatusTip(const QString &statusTip);
QString statusTip() const;

void setWhatsThis(const QString &what);
QString whatsThis() const;

void setPriority(Priority priority);
Priority priority() const;


# 139 "/usr/share/qt4/include/QtGui/qaction.h"
QMenu *menu() const;
void setMenu(QMenu *menu);


# 143 "/usr/share/qt4/include/QtGui/qaction.h"
void setSeparator(bool b);
bool isSeparator() const;


# 147 "/usr/share/qt4/include/QtGui/qaction.h"
void setShortcut(const QKeySequence &shortcut);
QKeySequence shortcut() const;

void setShortcuts(const QList<QKeySequence> &shortcuts);
void setShortcuts(QKeySequence::StandardKey);
QList<QKeySequence> shortcuts() const;

void setShortcutContext(Qt::ShortcutContext context);
Qt::ShortcutContext shortcutContext() const;

void setAutoRepeat(bool);
bool autoRepeat() const;


# 161 "/usr/share/qt4/include/QtGui/qaction.h"
void setFont(const QFont &font);
QFont font() const;

void setCheckable(bool);
bool isCheckable() const;

QVariant data() const;
void setData(const QVariant &var);

bool isChecked() const;

bool isEnabled() const;

bool isVisible() const;

enum ActionEvent { Trigger, Hover };
void activate(ActionEvent event);
bool showStatusText(QWidget *widget=0);

void setMenuRole(MenuRole menuRole);
MenuRole menuRole() const;

void setSoftKeyRole(SoftKeyRole softKeyRole);
SoftKeyRole softKeyRole() const;

void setIconVisibleInMenu(bool visible);
bool isIconVisibleInMenu() const;















# 203 "/usr/share/qt4/include/QtGui/qaction.h"
QWidget *parentWidget() const;

QList<QWidget *> associatedWidgets() const;

# 207 "/usr/share/qt4/include/QtGui/qaction.h"
QList<QGraphicsWidget *> associatedGraphicsWidgets() const; 


# 210 "/usr/share/qt4/include/QtGui/qaction.h"
protected:
bool event(QEvent *);
QAction(QActionPrivate &dd, QObject *parent);

public slots:



# 218 "/usr/share/qt4/include/QtGui/qaction.h"
void trigger() { activate(Trigger); }
void hover() { activate(Hover); }
void setChecked(bool);
void toggle();
void setEnabled(bool);
inline void setDisabled(bool b) { setEnabled(!b); }
void setVisible(bool);

signals:
void changed();
void triggered(bool checked = false);
void hovered();
void toggled(bool);




# 235 "/usr/share/qt4/include/QtGui/qaction.h"
private:
QAction(const QAction &); QAction &operator=(const QAction &);




# 241 "/usr/share/qt4/include/QtGui/qaction.h"
friend class QGraphicsWidget;
friend class QWidget;
friend class QActionGroup;
friend class QMenu;
friend class QMenuPrivate;
friend class QMenuBar;
friend class QShortcutMap;
friend class QToolButton;
};


# 1 "/usr/share/qt4/include/QtGui/qactiongroup.h"












































# 1 "/usr/share/qt4/include/QtGui/qaction.h"





































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qactiongroup.h"


# 47 "/usr/share/qt4/include/QtGui/qactiongroup.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qactiongroup.h"
class QActionGroupPrivate;

class  QActionGroup : public QObject
{
Q_OBJECT
inline QActionGroupPrivate* d_func() { return reinterpret_cast<QActionGroupPrivate *>(qGetPtrHelper(d_ptr)); } inline const QActionGroupPrivate* d_func() const { return reinterpret_cast<const QActionGroupPrivate *>(qGetPtrHelper(d_ptr)); } friend class QActionGroupPrivate;

Q_PROPERTY(bool exclusive READ isExclusive WRITE setExclusive)
Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled)
Q_PROPERTY(bool visible READ isVisible WRITE setVisible)

public:
explicit QActionGroup(QObject* parent);
~QActionGroup();

QAction *addAction(QAction* a);
QAction *addAction(const QString &text);
QAction *addAction(const QIcon &icon, const QString &text);
void removeAction(QAction *a);
QList<QAction*> actions() const;

QAction *checkedAction() const;
bool isExclusive() const;
bool isEnabled() const;
bool isVisible() const;








# 88 "/usr/share/qt4/include/QtGui/qactiongroup.h"
public slots:
void setEnabled(bool);
inline void setDisabled(bool b) { setEnabled(!b); }
void setVisible(bool);
void setExclusive(bool);

signals:
void triggered(QAction *);
 void selected(QAction *);
void hovered(QAction *);

private:
QActionGroup(const QActionGroup &); QActionGroup &operator=(const QActionGroup &);



};



# 108 "/usr/share/qt4/include/QtGui/qactiongroup.h"





# 252 "/usr/share/qt4/include/QtGui/qaction.h"

# 253 "/usr/share/qt4/include/QtGui/qaction.h"




# 257 "/usr/share/qt4/include/QtGui/qaction.h"





# 48 "/usr/share/qt4/include/QtGui/qmenu.h"






# 54 "/usr/share/qt4/include/QtGui/qmenu.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 62 "/usr/share/qt4/include/QtGui/qmenu.h"
class QMenuPrivate;
class QStyleOptionMenuItem;




# 68 "/usr/share/qt4/include/QtGui/qmenu.h"
class  QMenu : public QWidget
{
private:
Q_OBJECT
inline QMenuPrivate* d_func() { return reinterpret_cast<QMenuPrivate *>(qGetPtrHelper(d_ptr)); } inline const QMenuPrivate* d_func() const { return reinterpret_cast<const QMenuPrivate *>(qGetPtrHelper(d_ptr)); } friend class QMenuPrivate;

Q_PROPERTY(bool tearOffEnabled READ isTearOffEnabled WRITE setTearOffEnabled)
Q_PROPERTY(QString title READ title WRITE setTitle)
Q_PROPERTY(QIcon icon READ icon WRITE setIcon)
Q_PROPERTY(bool separatorsCollapsible READ separatorsCollapsible WRITE setSeparatorsCollapsible)

public:
explicit QMenu(QWidget *parent = 0);
explicit QMenu(const QString &title, QWidget *parent = 0);
~QMenu();


# 85 "/usr/share/qt4/include/QtGui/qmenu.h"
inline void addAction(QAction *action) { QWidget::addAction(action); }



# 89 "/usr/share/qt4/include/QtGui/qmenu.h"
QAction *addAction(const QString &text);
QAction *addAction(const QIcon &icon, const QString &text);
QAction *addAction(const QString &text, const QObject *receiver, const char* member, const QKeySequence &shortcut = 0);
QAction *addAction(const QIcon &icon, const QString &text, const QObject *receiver, const char* member, const QKeySequence &shortcut = 0);

QAction *addMenu(QMenu *menu);
QMenu *addMenu(const QString &title);
QMenu *addMenu(const QIcon &icon, const QString &title);

QAction *addSeparator();

QAction *insertMenu(QAction *before, QMenu *menu);
QAction *insertSeparator(QAction *before);

bool isEmpty() const;
void clear();

void setTearOffEnabled(bool);
bool isTearOffEnabled() const;

bool isTearOffMenuVisible() const;
void hideTearOffMenu();

void setDefaultAction(QAction *);
QAction *defaultAction() const;

void setActiveAction(QAction *act);
QAction *activeAction() const;

void popup(const QPoint &pos, QAction *at=0);
QAction *exec();
QAction *exec(const QPoint &pos, QAction *at=0);


static QAction *exec(QList<QAction*> actions, const QPoint &pos, QAction *at=0);
static QAction *exec(QList<QAction*> actions, const QPoint &pos, QAction *at, QWidget *parent);

QSize sizeHint() const;

QRect actionGeometry(QAction *) const;
QAction *actionAt(const QPoint &) const;

QAction *menuAction() const;

QString title() const;
void setTitle(const QString &title);

QIcon icon() const;
void setIcon(const QIcon &icon);

void setNoReplayFor(QWidget *widget);








# 148 "/usr/share/qt4/include/QtGui/qmenu.h"
bool separatorsCollapsible() const;
void setSeparatorsCollapsible(bool collapse);

signals:
void aboutToShow();
void aboutToHide();
void triggered(QAction *action);
void hovered(QAction *action);

protected:
int columnCount() const;

void changeEvent(QEvent *);
void keyPressEvent(QKeyEvent *);
void mouseReleaseEvent(QMouseEvent *);
void mousePressEvent(QMouseEvent *);
void mouseMoveEvent(QMouseEvent *);
void wheelEvent(QWheelEvent *);
void enterEvent(QEvent *);
void leaveEvent(QEvent *);
void hideEvent(QHideEvent *);
void paintEvent(QPaintEvent *);
void actionEvent(QActionEvent *);
void timerEvent(QTimerEvent *);
bool event(QEvent *);
bool focusNextPrevChild(bool next);
void initStyleOption(QStyleOptionMenuItem *option, const QAction *action) const;





# 180 "/usr/share/qt4/include/QtGui/qmenu.h"
private slots:
void internalSetSloppyAction();
void internalDelayedPopup();

private:





















































































































































































































# 398 "/usr/share/qt4/include/QtGui/qmenu.h"
protected:
QMenu(QMenuPrivate &dd, QWidget* parent = 0);

private:
QMenu(const QMenu &); QMenu &operator=(const QMenu &);

friend class QMenuBar;
friend class QMenuBarPrivate;
friend class QTornOffMenu;
friend class Q3PopupMenu;
friend class QComboBox;
friend class QAction;
friend class QToolButtonPrivate;








# 419 "/usr/share/qt4/include/QtGui/qmenu.h"
};



# 423 "/usr/share/qt4/include/QtGui/qmenu.h"





# 103 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmenubar.h"












































# 1 "/usr/share/qt4/include/QtGui/qmenu.h"











































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qmenubar.h"


# 47 "/usr/share/qt4/include/QtGui/qmenubar.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qmenubar.h"
class QMenuBarPrivate;
class QStyleOptionMenuItem;
class QWindowsStyle;




# 62 "/usr/share/qt4/include/QtGui/qmenubar.h"
class  QMenuBar : public QWidget
{
Q_OBJECT

Q_PROPERTY(bool defaultUp READ isDefaultUp WRITE setDefaultUp)
Q_PROPERTY(bool nativeMenuBar READ isNativeMenuBar WRITE setNativeMenuBar)

public:
explicit QMenuBar(QWidget *parent = 0);
~QMenuBar();


# 74 "/usr/share/qt4/include/QtGui/qmenubar.h"
void addAction(QAction *action) { QWidget::addAction(action); }



# 78 "/usr/share/qt4/include/QtGui/qmenubar.h"
QAction *addAction(const QString &text);
QAction *addAction(const QString &text, const QObject *receiver, const char* member);

QAction *addMenu(QMenu *menu);
QMenu *addMenu(const QString &title);
QMenu *addMenu(const QIcon &icon, const QString &title);


QAction *addSeparator();
QAction *insertSeparator(QAction *before);

QAction *insertMenu(QAction *before, QMenu *menu);

void clear();

QAction *activeAction() const;
void setActiveAction(QAction *action);

void setDefaultUp(bool);
bool isDefaultUp() const;

QSize sizeHint() const;
QSize minimumSizeHint() const;
int heightForWidth(int) const;

QRect actionGeometry(QAction *) const;
QAction *actionAt(const QPoint &) const;

void setCornerWidget(QWidget *w, Qt::Corner corner = Qt::TopRightCorner);
QWidget *cornerWidget(Qt::Corner corner = Qt::TopRightCorner) const;














# 122 "/usr/share/qt4/include/QtGui/qmenubar.h"
bool isNativeMenuBar() const;
void setNativeMenuBar(bool nativeMenuBar);

public slots:
virtual void setVisible(bool visible);

signals:
void triggered(QAction *action);
void hovered(QAction *action);

protected:
void changeEvent(QEvent *);
void keyPressEvent(QKeyEvent *);
void mouseReleaseEvent(QMouseEvent *);
void mousePressEvent(QMouseEvent *);
void mouseMoveEvent(QMouseEvent *);
void leaveEvent(QEvent *);
void paintEvent(QPaintEvent *);
void resizeEvent(QResizeEvent *);
void actionEvent(QActionEvent *);
void focusOutEvent(QFocusEvent *);
void focusInEvent(QFocusEvent *);
void timerEvent(QTimerEvent *);
bool eventFilter(QObject *, QEvent *);
bool event(QEvent *);
void initStyleOption(QStyleOptionMenuItem *option, const QAction *action) const;






























































































































































































# 338 "/usr/share/qt4/include/QtGui/qmenubar.h"
private:
inline QMenuBarPrivate* d_func() { return reinterpret_cast<QMenuBarPrivate *>(qGetPtrHelper(d_ptr)); } inline const QMenuBarPrivate* d_func() const { return reinterpret_cast<const QMenuBarPrivate *>(qGetPtrHelper(d_ptr)); } friend class QMenuBarPrivate;
QMenuBar(const QMenuBar &); QMenuBar &operator=(const QMenuBar &);









# 350 "/usr/share/qt4/include/QtGui/qmenubar.h"
friend class QMenu;
friend class QMenuPrivate;
friend class QWindowsStyle;






# 359 "/usr/share/qt4/include/QtGui/qmenubar.h"
};



# 363 "/usr/share/qt4/include/QtGui/qmenubar.h"





# 104 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmenudata.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qmenudata.h"




































# 105 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qplaintextedit.h"












































# 1 "/usr/share/qt4/include/QtGui/qtextedit.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"
















































































































































# 45 "/usr/share/qt4/include/QtGui/qtextedit.h"

# 1 "/usr/share/qt4/include/QtGui/qtextdocument.h"














































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qtextedit.h"

# 1 "/usr/share/qt4/include/QtGui/qtextoption.h"

































































































































































# 47 "/usr/share/qt4/include/QtGui/qtextedit.h"

# 1 "/usr/share/qt4/include/QtGui/qtextcursor.h"








































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qtextedit.h"

# 1 "/usr/share/qt4/include/QtGui/qtextformat.h"















































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qtextedit.h"









# 58 "/usr/share/qt4/include/QtGui/qtextedit.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QStyleSheet;
class QTextDocument;
class QMenu;
class QTextEditPrivate;
class QMimeData;

class  QTextEdit : public QAbstractScrollArea
{
Q_OBJECT
inline QTextEditPrivate* d_func() { return reinterpret_cast<QTextEditPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTextEditPrivate* d_func() const { return reinterpret_cast<const QTextEditPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTextEditPrivate;

Q_ENUMS(LineWrapMode)
Q_PROPERTY(AutoFormatting autoFormatting READ autoFormatting WRITE setAutoFormatting)
Q_PROPERTY(bool tabChangesFocus READ tabChangesFocus WRITE setTabChangesFocus)
Q_PROPERTY(QString documentTitle READ documentTitle WRITE setDocumentTitle)
Q_PROPERTY(bool undoRedoEnabled READ isUndoRedoEnabled WRITE setUndoRedoEnabled)
Q_PROPERTY(LineWrapMode lineWrapMode READ lineWrapMode WRITE setLineWrapMode)

Q_PROPERTY(int lineWrapColumnOrWidth READ lineWrapColumnOrWidth WRITE setLineWrapColumnOrWidth)
Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly)

# 85 "/usr/share/qt4/include/QtGui/qtextedit.h"
Q_PROPERTY(QString html READ toHtml WRITE setHtml NOTIFY textChanged USER true)

# 87 "/usr/share/qt4/include/QtGui/qtextedit.h"
Q_PROPERTY(QString plainText READ toPlainText WRITE setPlainText DESIGNABLE false)
Q_PROPERTY(bool overwriteMode READ overwriteMode WRITE setOverwriteMode)
Q_PROPERTY(int tabStopWidth READ tabStopWidth WRITE setTabStopWidth)
Q_PROPERTY(bool acceptRichText READ acceptRichText WRITE setAcceptRichText)
Q_PROPERTY(int cursorWidth READ cursorWidth WRITE setCursorWidth)
Q_PROPERTY(Qt::TextInteractionFlags textInteractionFlags READ textInteractionFlags WRITE setTextInteractionFlags)
public:
enum LineWrapMode {
NoWrap,
WidgetWidth,
FixedPixelWidth,
FixedColumnWidth
};

enum AutoFormattingFlag {
AutoNone = 0,
AutoBulletList = 0x00000001,
AutoAll = 0xffffffff
};

typedef QFlags<AutoFormattingFlag> AutoFormatting;























# 131 "/usr/share/qt4/include/QtGui/qtextedit.h"
explicit QTextEdit(QWidget *parent = 0);
explicit QTextEdit(const QString &text, QWidget *parent = 0);
virtual ~QTextEdit();

void setDocument(QTextDocument *document);
QTextDocument *document() const;

void setTextCursor(const QTextCursor &cursor);
QTextCursor textCursor() const;

bool isReadOnly() const;
void setReadOnly(bool ro);

void setTextInteractionFlags(Qt::TextInteractionFlags flags);
Qt::TextInteractionFlags textInteractionFlags() const;

qreal fontPointSize() const;
QString fontFamily() const;
int fontWeight() const;
bool fontUnderline() const;
bool fontItalic() const;
QColor textColor() const;
QColor textBackgroundColor() const;
QFont currentFont() const;
Qt::Alignment alignment() const;

void mergeCurrentCharFormat(const QTextCharFormat &modifier);

void setCurrentCharFormat(const QTextCharFormat &format);
QTextCharFormat currentCharFormat() const;

AutoFormatting autoFormatting() const;
void setAutoFormatting(AutoFormatting features);

bool tabChangesFocus() const;
void setTabChangesFocus(bool b);

inline void setDocumentTitle(const QString &title)
{ document()->setMetaInformation(QTextDocument::DocumentTitle, title); }
inline QString documentTitle() const
{ return document()->metaInformation(QTextDocument::DocumentTitle); }

inline bool isUndoRedoEnabled() const
{ return document()->isUndoRedoEnabled(); }
inline void setUndoRedoEnabled(bool enable)
{ document()->setUndoRedoEnabled(enable); }

LineWrapMode lineWrapMode() const;
void setLineWrapMode(LineWrapMode mode);

int lineWrapColumnOrWidth() const;
void setLineWrapColumnOrWidth(int w);

QTextOption::WrapMode wordWrapMode() const;
void setWordWrapMode(QTextOption::WrapMode policy);

bool find(const QString &exp, QTextDocument::FindFlags options = 0);

inline QString toPlainText() const
{ return document()->toPlainText(); }

# 192 "/usr/share/qt4/include/QtGui/qtextedit.h"
inline QString toHtml() const
{ return document()->toHtml(); }


# 196 "/usr/share/qt4/include/QtGui/qtextedit.h"
void ensureCursorVisible();

virtual QVariant loadResource(int type, const QUrl &name);

# 200 "/usr/share/qt4/include/QtGui/qtextedit.h"
QMenu *createStandardContextMenu();
QMenu *createStandardContextMenu(const QPoint &position);


# 204 "/usr/share/qt4/include/QtGui/qtextedit.h"
QTextCursor cursorForPosition(const QPoint &pos) const;
QRect cursorRect(const QTextCursor &cursor) const;
QRect cursorRect() const;

QString anchorAt(const QPoint& pos) const;

bool overwriteMode() const;
void setOverwriteMode(bool overwrite);

int tabStopWidth() const;
void setTabStopWidth(int width);

int cursorWidth() const;
void setCursorWidth(int width);

bool acceptRichText() const;
void setAcceptRichText(bool accept);

struct ExtraSelection
{
QTextCursor cursor;
QTextCharFormat format;
};
void setExtraSelections(const QList<ExtraSelection> &selections);
QList<ExtraSelection> extraSelections() const;

void moveCursor(QTextCursor::MoveOperation operation, QTextCursor::MoveMode mode = QTextCursor::MoveAnchor);

bool canPaste() const;


# 235 "/usr/share/qt4/include/QtGui/qtextedit.h"
void print(QPrinter *printer) const;


# 238 "/usr/share/qt4/include/QtGui/qtextedit.h"
public slots:
void setFontPointSize(qreal s);
void setFontFamily(const QString &fontFamily);
void setFontWeight(int w);
void setFontUnderline(bool b);
void setFontItalic(bool b);
void setTextColor(const QColor &c);
void setTextBackgroundColor(const QColor &c);
void setCurrentFont(const QFont &f);
void setAlignment(Qt::Alignment a);

void setPlainText(const QString &text);

# 251 "/usr/share/qt4/include/QtGui/qtextedit.h"
void setHtml(const QString &text);

# 253 "/usr/share/qt4/include/QtGui/qtextedit.h"
void setText(const QString &text);


# 256 "/usr/share/qt4/include/QtGui/qtextedit.h"
void cut();
void copy();
void paste();


# 261 "/usr/share/qt4/include/QtGui/qtextedit.h"
void undo();
void redo();

void clear();
void selectAll();

void insertPlainText(const QString &text);

# 269 "/usr/share/qt4/include/QtGui/qtextedit.h"
void insertHtml(const QString &text);


# 272 "/usr/share/qt4/include/QtGui/qtextedit.h"
void append(const QString &text);

void scrollToAnchor(const QString &name);

void zoomIn(int range = 1);
void zoomOut(int range = 1);

signals:
void textChanged();
void undoAvailable(bool b);
void redoAvailable(bool b);
void currentCharFormatChanged(const QTextCharFormat &format);
void copyAvailable(bool b);
void selectionChanged();
void cursorPositionChanged();

protected:
virtual bool event(QEvent *e);
virtual void timerEvent(QTimerEvent *e);
virtual void keyPressEvent(QKeyEvent *e);
virtual void keyReleaseEvent(QKeyEvent *e);
virtual void resizeEvent(QResizeEvent *e);
virtual void paintEvent(QPaintEvent *e);
virtual void mousePressEvent(QMouseEvent *e);
virtual void mouseMoveEvent(QMouseEvent *e);
virtual void mouseReleaseEvent(QMouseEvent *e);
virtual void mouseDoubleClickEvent(QMouseEvent *e);
virtual bool focusNextPrevChild(bool next);

# 301 "/usr/share/qt4/include/QtGui/qtextedit.h"
virtual void contextMenuEvent(QContextMenuEvent *e);


# 304 "/usr/share/qt4/include/QtGui/qtextedit.h"
virtual void dragEnterEvent(QDragEnterEvent *e);
virtual void dragLeaveEvent(QDragLeaveEvent *e);
virtual void dragMoveEvent(QDragMoveEvent *e);
virtual void dropEvent(QDropEvent *e);

# 309 "/usr/share/qt4/include/QtGui/qtextedit.h"
virtual void focusInEvent(QFocusEvent *e);
virtual void focusOutEvent(QFocusEvent *e);
virtual void showEvent(QShowEvent *);
virtual void changeEvent(QEvent *e);

# 314 "/usr/share/qt4/include/QtGui/qtextedit.h"
virtual void wheelEvent(QWheelEvent *e);


# 317 "/usr/share/qt4/include/QtGui/qtextedit.h"
virtual QMimeData *createMimeDataFromSelection() const;
virtual bool canInsertFromMimeData(const QMimeData *source) const;
virtual void insertFromMimeData(const QMimeData *source);

virtual void inputMethodEvent(QInputMethodEvent *);
QVariant inputMethodQuery(Qt::InputMethodQuery property) const;

QTextEdit(QTextEditPrivate &dd, QWidget *parent);

virtual void scrollContentsBy(int dx, int dy);




















































































# 411 "/usr/share/qt4/include/QtGui/qtextedit.h"
private:
QTextEdit(const QTextEdit &); QTextEdit &operator=(const QTextEdit &);




friend class QTextEditControl;
friend class QTextDocument;
friend class QTextControl;
};

inline QFlags<QTextEdit::AutoFormatting::enum_type> operator|(QTextEdit::AutoFormatting::enum_type f1, QTextEdit::AutoFormatting::enum_type f2) { return QFlags<QTextEdit::AutoFormatting::enum_type>(f1) | f2; } inline QFlags<QTextEdit::AutoFormatting::enum_type> operator|(QTextEdit::AutoFormatting::enum_type f1, QFlags<QTextEdit::AutoFormatting::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTextEdit::AutoFormatting::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }








# 45 "/usr/share/qt4/include/QtGui/qplaintextedit.h"


# 1 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"
















































































































































# 47 "/usr/share/qt4/include/QtGui/qplaintextedit.h"

# 1 "/usr/share/qt4/include/QtGui/qtextdocument.h"














































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qplaintextedit.h"

# 1 "/usr/share/qt4/include/QtGui/qtextoption.h"

































































































































































# 49 "/usr/share/qt4/include/QtGui/qplaintextedit.h"

# 1 "/usr/share/qt4/include/QtGui/qtextcursor.h"








































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qplaintextedit.h"

# 1 "/usr/share/qt4/include/QtGui/qtextformat.h"















































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 51 "/usr/share/qt4/include/QtGui/qplaintextedit.h"

# 1 "/usr/share/qt4/include/QtGui/qabstracttextdocumentlayout.h"






















































































































































# 52 "/usr/share/qt4/include/QtGui/qplaintextedit.h"




# 56 "/usr/share/qt4/include/QtGui/qplaintextedit.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QStyleSheet;
class QTextDocument;
class QMenu;
class QPlainTextEditPrivate;
class QMimeData;


class  QPlainTextEdit : public QAbstractScrollArea
{
Q_OBJECT
inline QPlainTextEditPrivate* d_func() { return reinterpret_cast<QPlainTextEditPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPlainTextEditPrivate* d_func() const { return reinterpret_cast<const QPlainTextEditPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPlainTextEditPrivate;
Q_ENUMS(LineWrapMode)
Q_PROPERTY(bool tabChangesFocus READ tabChangesFocus WRITE setTabChangesFocus)
Q_PROPERTY(QString documentTitle READ documentTitle WRITE setDocumentTitle)
Q_PROPERTY(bool undoRedoEnabled READ isUndoRedoEnabled WRITE setUndoRedoEnabled)
Q_PROPERTY(LineWrapMode lineWrapMode READ lineWrapMode WRITE setLineWrapMode)

Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly)
Q_PROPERTY(QString plainText READ toPlainText WRITE setPlainText NOTIFY textChanged USER true)
Q_PROPERTY(bool overwriteMode READ overwriteMode WRITE setOverwriteMode)
Q_PROPERTY(int tabStopWidth READ tabStopWidth WRITE setTabStopWidth)
Q_PROPERTY(int cursorWidth READ cursorWidth WRITE setCursorWidth)
Q_PROPERTY(Qt::TextInteractionFlags textInteractionFlags READ textInteractionFlags WRITE setTextInteractionFlags)
Q_PROPERTY(int blockCount READ blockCount)
Q_PROPERTY(int maximumBlockCount READ maximumBlockCount WRITE setMaximumBlockCount)
Q_PROPERTY(bool backgroundVisible READ backgroundVisible WRITE setBackgroundVisible)
Q_PROPERTY(bool centerOnScroll READ centerOnScroll WRITE setCenterOnScroll)
public:
enum LineWrapMode {
NoWrap,
WidgetWidth
};

explicit QPlainTextEdit(QWidget *parent = 0);
explicit QPlainTextEdit(const QString &text, QWidget *parent = 0);
virtual ~QPlainTextEdit();

void setDocument(QTextDocument *document);
QTextDocument *document() const;

void setTextCursor(const QTextCursor &cursor);
QTextCursor textCursor() const;

bool isReadOnly() const;
void setReadOnly(bool ro);

void setTextInteractionFlags(Qt::TextInteractionFlags flags);
Qt::TextInteractionFlags textInteractionFlags() const;

void mergeCurrentCharFormat(const QTextCharFormat &modifier);
void setCurrentCharFormat(const QTextCharFormat &format);
QTextCharFormat currentCharFormat() const;

bool tabChangesFocus() const;
void setTabChangesFocus(bool b);

inline void setDocumentTitle(const QString &title)
{ document()->setMetaInformation(QTextDocument::DocumentTitle, title); }
inline QString documentTitle() const
{ return document()->metaInformation(QTextDocument::DocumentTitle); }

inline bool isUndoRedoEnabled() const
{ return document()->isUndoRedoEnabled(); }
inline void setUndoRedoEnabled(bool enable)
{ document()->setUndoRedoEnabled(enable); }

inline void setMaximumBlockCount(int maximum)
{ document()->setMaximumBlockCount(maximum); }
inline int maximumBlockCount() const
{ return document()->maximumBlockCount(); }


LineWrapMode lineWrapMode() const;
void setLineWrapMode(LineWrapMode mode);

QTextOption::WrapMode wordWrapMode() const;
void setWordWrapMode(QTextOption::WrapMode policy);

void setBackgroundVisible(bool visible);
bool backgroundVisible() const;

void setCenterOnScroll(bool enabled);
bool centerOnScroll() const;

bool find(const QString &exp, QTextDocument::FindFlags options = 0);

inline QString toPlainText() const
{ return document()->toPlainText(); }

void ensureCursorVisible();

virtual QVariant loadResource(int type, const QUrl &name);

# 155 "/usr/share/qt4/include/QtGui/qplaintextedit.h"
QMenu *createStandardContextMenu();


# 158 "/usr/share/qt4/include/QtGui/qplaintextedit.h"
QTextCursor cursorForPosition(const QPoint &pos) const;
QRect cursorRect(const QTextCursor &cursor) const;
QRect cursorRect() const;

bool overwriteMode() const;
void setOverwriteMode(bool overwrite);

int tabStopWidth() const;
void setTabStopWidth(int width);

int cursorWidth() const;
void setCursorWidth(int width);

void setExtraSelections(const QList<QTextEdit::ExtraSelection> &selections);
QList<QTextEdit::ExtraSelection> extraSelections() const;

void moveCursor(QTextCursor::MoveOperation operation, QTextCursor::MoveMode mode = QTextCursor::MoveAnchor);

bool canPaste() const;


# 179 "/usr/share/qt4/include/QtGui/qplaintextedit.h"
void print(QPrinter *printer) const;


# 182 "/usr/share/qt4/include/QtGui/qplaintextedit.h"
int blockCount() const;

public slots:

void setPlainText(const QString &text);


# 189 "/usr/share/qt4/include/QtGui/qplaintextedit.h"
void cut();
void copy();
void paste();


# 194 "/usr/share/qt4/include/QtGui/qplaintextedit.h"
void undo();
void redo();

void clear();
void selectAll();

void insertPlainText(const QString &text);

void appendPlainText(const QString &text);
void appendHtml(const QString &html);

void centerCursor();

signals:
void textChanged();
void undoAvailable(bool b);
void redoAvailable(bool b);
void copyAvailable(bool b);
void selectionChanged();
void cursorPositionChanged();

void updateRequest(const QRect &rect, int dy);
void blockCountChanged(int newBlockCount);
void modificationChanged(bool);

protected:
virtual bool event(QEvent *e);
virtual void timerEvent(QTimerEvent *e);
virtual void keyPressEvent(QKeyEvent *e);
virtual void keyReleaseEvent(QKeyEvent *e);
virtual void resizeEvent(QResizeEvent *e);
virtual void paintEvent(QPaintEvent *e);
virtual void mousePressEvent(QMouseEvent *e);
virtual void mouseMoveEvent(QMouseEvent *e);
virtual void mouseReleaseEvent(QMouseEvent *e);
virtual void mouseDoubleClickEvent(QMouseEvent *e);
virtual bool focusNextPrevChild(bool next);

# 232 "/usr/share/qt4/include/QtGui/qplaintextedit.h"
virtual void contextMenuEvent(QContextMenuEvent *e);


# 235 "/usr/share/qt4/include/QtGui/qplaintextedit.h"
virtual void dragEnterEvent(QDragEnterEvent *e);
virtual void dragLeaveEvent(QDragLeaveEvent *e);
virtual void dragMoveEvent(QDragMoveEvent *e);
virtual void dropEvent(QDropEvent *e);

# 240 "/usr/share/qt4/include/QtGui/qplaintextedit.h"
virtual void focusInEvent(QFocusEvent *e);
virtual void focusOutEvent(QFocusEvent *e);
virtual void showEvent(QShowEvent *);
virtual void changeEvent(QEvent *e);

# 245 "/usr/share/qt4/include/QtGui/qplaintextedit.h"
virtual void wheelEvent(QWheelEvent *e);


# 248 "/usr/share/qt4/include/QtGui/qplaintextedit.h"
virtual QMimeData *createMimeDataFromSelection() const;
virtual bool canInsertFromMimeData(const QMimeData *source) const;
virtual void insertFromMimeData(const QMimeData *source);

virtual void inputMethodEvent(QInputMethodEvent *);
QVariant inputMethodQuery(Qt::InputMethodQuery property) const;

QPlainTextEdit(QPlainTextEditPrivate &dd, QWidget *parent);

virtual void scrollContentsBy(int dx, int dy);

QTextBlock firstVisibleBlock() const;
QPointF contentOffset() const;
QRectF blockBoundingRect(const QTextBlock &block) const;
QRectF blockBoundingGeometry(const QTextBlock &block) const;
QAbstractTextDocumentLayout::PaintContext getPaintContext() const;


private:
QPlainTextEdit(const QPlainTextEdit &); QPlainTextEdit &operator=(const QPlainTextEdit &);





friend class QPlainTextEditControl;
};


class QPlainTextDocumentLayoutPrivate;
class  QPlainTextDocumentLayout : public QAbstractTextDocumentLayout
{
Q_OBJECT
inline QPlainTextDocumentLayoutPrivate* d_func() { return reinterpret_cast<QPlainTextDocumentLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPlainTextDocumentLayoutPrivate* d_func() const { return reinterpret_cast<const QPlainTextDocumentLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPlainTextDocumentLayoutPrivate;
Q_PROPERTY(int cursorWidth READ cursorWidth WRITE setCursorWidth)

public:
QPlainTextDocumentLayout(QTextDocument *document);
~QPlainTextDocumentLayout();

void draw(QPainter *, const PaintContext &);
int hitTest(const QPointF &, Qt::HitTestAccuracy ) const;

int pageCount() const;
QSizeF documentSize() const;

QRectF frameBoundingRect(QTextFrame *) const;
QRectF blockBoundingRect(const QTextBlock &block) const;

void ensureBlockLayout(const QTextBlock &block) const;

void setCursorWidth(int width);
int cursorWidth() const;

void requestUpdate();

protected:
void documentChanged(int from, int , int charsAdded);


private:
void setTextWidth(qreal newWidth);
qreal textWidth() const;
void layoutBlock(const QTextBlock &block);
qreal blockWidth(const QTextBlock &block);

QPlainTextDocumentLayoutPrivate *priv() const;

friend class QPlainTextEdit;
friend class QPlainTextEditPrivate;
};









# 106 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qprintpreviewwidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qprintpreviewwidget.h"

# 1 "/usr/share/qt4/include/QtGui/qprinter.h"













































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qprintpreviewwidget.h"




# 50 "/usr/share/qt4/include/QtGui/qprintpreviewwidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QPrintPreviewWidgetPrivate;

class  QPrintPreviewWidget : public QWidget
{
Q_OBJECT
inline QPrintPreviewWidgetPrivate* d_func() { return reinterpret_cast<QPrintPreviewWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPrintPreviewWidgetPrivate* d_func() const { return reinterpret_cast<const QPrintPreviewWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPrintPreviewWidgetPrivate;
public:

enum ViewMode {
SinglePageView,
FacingPagesView,
AllPagesView
};

enum ZoomMode {
CustomZoom,
FitToWidth,
FitInView
};

explicit QPrintPreviewWidget(QPrinter *printer, QWidget *parent = 0, Qt::WindowFlags flags = 0);
explicit QPrintPreviewWidget(QWidget *parent = 0, Qt::WindowFlags flags = 0);
~QPrintPreviewWidget();

qreal zoomFactor() const;
QPrinter::Orientation orientation() const;
ViewMode viewMode() const;
ZoomMode zoomMode() const;
int currentPage() const;

# 86 "/usr/share/qt4/include/QtGui/qprintpreviewwidget.h"
 int numPages() const;

# 88 "/usr/share/qt4/include/QtGui/qprintpreviewwidget.h"
int pageCount() const;
void setVisible(bool visible);

public slots:
void print();

void zoomIn(qreal zoom = 1.1);
void zoomOut(qreal zoom = 1.1);
void setZoomFactor(qreal zoomFactor);
void setOrientation(QPrinter::Orientation orientation);
void setViewMode(ViewMode viewMode);
void setZoomMode(ZoomMode zoomMode);
void setCurrentPage(int pageNumber);

void fitToWidth();
void fitInView();
void setLandscapeOrientation();
void setPortraitOrientation();
void setSinglePageViewMode();
void setFacingPagesViewMode();
void setAllPagesViewMode();

void updatePreview();

signals:
void paintRequested(QPrinter *printer);
void previewChanged();

private:
void *dummy; 


};







# 107 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qprogressbar.h"












































# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 45 "/usr/share/qt4/include/QtGui/qprogressbar.h"


# 47 "/usr/share/qt4/include/QtGui/qprogressbar.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qprogressbar.h"
class QProgressBarPrivate;
class QStyleOptionProgressBar;

class  QProgressBar : public QWidget
{
Q_OBJECT
Q_ENUMS(Direction)
Q_PROPERTY(int minimum READ minimum WRITE setMinimum)
Q_PROPERTY(int maximum READ maximum WRITE setMaximum)
Q_PROPERTY(QString text READ text)
Q_PROPERTY(int value READ value WRITE setValue NOTIFY valueChanged)
Q_PROPERTY(Qt::Alignment alignment READ alignment WRITE setAlignment)
Q_PROPERTY(bool textVisible READ isTextVisible WRITE setTextVisible)
Q_PROPERTY(Qt::Orientation orientation READ orientation WRITE setOrientation)
Q_PROPERTY(bool invertedAppearance READ invertedAppearance WRITE setInvertedAppearance)
Q_PROPERTY(Direction textDirection READ textDirection WRITE setTextDirection)
Q_PROPERTY(QString format READ format WRITE setFormat)

public:
enum Direction { TopToBottom, BottomToTop };

explicit QProgressBar(QWidget *parent = 0);

int minimum() const;
int maximum() const;

int value() const;

virtual QString text() const;
void setTextVisible(bool visible);
bool isTextVisible() const;

Qt::Alignment alignment() const;
void setAlignment(Qt::Alignment alignment);

QSize sizeHint() const;
QSize minimumSizeHint() const;

Qt::Orientation orientation() const;

void setInvertedAppearance(bool invert);
bool invertedAppearance();
void setTextDirection(QProgressBar::Direction textDirection);
QProgressBar::Direction textDirection();

void setFormat(const QString &format);
QString format() const;

public slots:
void reset();
void setRange(int minimum, int maximum);
void setMinimum(int minimum);
void setMaximum(int maximum);
void setValue(int value);
void setOrientation(Qt::Orientation);

signals:
void valueChanged(int value);

protected:
bool event(QEvent *e);
void paintEvent(QPaintEvent *);
void initStyleOption(QStyleOptionProgressBar *option) const;

private:
inline QProgressBarPrivate* d_func() { return reinterpret_cast<QProgressBarPrivate *>(qGetPtrHelper(d_ptr)); } inline const QProgressBarPrivate* d_func() const { return reinterpret_cast<const QProgressBarPrivate *>(qGetPtrHelper(d_ptr)); } friend class QProgressBarPrivate;
QProgressBar(const QProgressBar &); QProgressBar &operator=(const QProgressBar &);
};



# 126 "/usr/share/qt4/include/QtGui/qprogressbar.h"





# 108 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpushbutton.h"




























































































































# 109 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qradiobutton.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractbutton.h"




















































































































































































# 45 "/usr/share/qt4/include/QtGui/qradiobutton.h"


# 47 "/usr/share/qt4/include/QtGui/qradiobutton.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QRadioButtonPrivate;
class QStyleOptionButton;

class  QRadioButton : public QAbstractButton
{
Q_OBJECT

public:
explicit QRadioButton(QWidget *parent=0);
explicit QRadioButton(const QString &text, QWidget *parent=0);

QSize sizeHint() const;

protected:
bool event(QEvent *e);
bool hitButton(const QPoint &) const;
void paintEvent(QPaintEvent *);
void mouseMoveEvent(QMouseEvent *);
void initStyleOption(QStyleOptionButton *button) const;







# 79 "/usr/share/qt4/include/QtGui/qradiobutton.h"
private:
inline QRadioButtonPrivate* d_func() { return reinterpret_cast<QRadioButtonPrivate *>(qGetPtrHelper(d_ptr)); } inline const QRadioButtonPrivate* d_func() const { return reinterpret_cast<const QRadioButtonPrivate *>(qGetPtrHelper(d_ptr)); } friend class QRadioButtonPrivate;
QRadioButton(const QRadioButton &); QRadioButton &operator=(const QRadioButton &);
};






# 110 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qrubberband.h"








































































































# 111 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qscrollarea.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractscrollarea.h"
















































































































































# 45 "/usr/share/qt4/include/QtGui/qscrollarea.h"


# 47 "/usr/share/qt4/include/QtGui/qscrollarea.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qscrollarea.h"
class QScrollAreaPrivate;

class  QScrollArea : public QAbstractScrollArea
{
Q_OBJECT
Q_PROPERTY(bool widgetResizable READ widgetResizable WRITE setWidgetResizable)
Q_PROPERTY(Qt::Alignment alignment READ alignment WRITE setAlignment)

public:
explicit QScrollArea(QWidget* parent=0);
~QScrollArea();

QWidget *widget() const;
void setWidget(QWidget *widget);
QWidget *takeWidget();

bool widgetResizable() const;
void setWidgetResizable(bool resizable);

QSize sizeHint() const;
bool focusNextPrevChild(bool next);

Qt::Alignment alignment() const;
void setAlignment(Qt::Alignment);

void ensureVisible(int x, int y, int xmargin = 50, int ymargin = 50);
void ensureWidgetVisible(QWidget *childWidget, int xmargin = 50, int ymargin = 50);

protected:
QScrollArea(QScrollAreaPrivate &dd, QWidget *parent = 0);
bool event(QEvent *);
bool eventFilter(QObject *, QEvent *);
void resizeEvent(QResizeEvent *);
void scrollContentsBy(int dx, int dy);

private:
inline QScrollAreaPrivate* d_func() { return reinterpret_cast<QScrollAreaPrivate *>(qGetPtrHelper(d_ptr)); } inline const QScrollAreaPrivate* d_func() const { return reinterpret_cast<const QScrollAreaPrivate *>(qGetPtrHelper(d_ptr)); } friend class QScrollAreaPrivate;
QScrollArea(const QScrollArea &); QScrollArea &operator=(const QScrollArea &);
};



# 97 "/usr/share/qt4/include/QtGui/qscrollarea.h"





# 112 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qscrollbar.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qscrollbar.h"

# 1 "/usr/share/qt4/include/QtGui/qabstractslider.h"
























































































































































































# 46 "/usr/share/qt4/include/QtGui/qscrollbar.h"


# 48 "/usr/share/qt4/include/QtGui/qscrollbar.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qscrollbar.h"
class QScrollBarPrivate;
class QStyleOptionSlider;

class  QScrollBar : public QAbstractSlider
{
Q_OBJECT
public:
explicit QScrollBar(QWidget *parent=0);
explicit QScrollBar(Qt::Orientation, QWidget *parent=0);
~QScrollBar();

QSize sizeHint() const;
bool event(QEvent *event);

protected:
void paintEvent(QPaintEvent *);
void mousePressEvent(QMouseEvent *);
void mouseReleaseEvent(QMouseEvent *);
void mouseMoveEvent(QMouseEvent *);
void hideEvent(QHideEvent*);
void sliderChange(SliderChange change);

# 78 "/usr/share/qt4/include/QtGui/qscrollbar.h"
void contextMenuEvent(QContextMenuEvent *);

# 80 "/usr/share/qt4/include/QtGui/qscrollbar.h"
void initStyleOption(QStyleOptionSlider *option) const;










# 91 "/usr/share/qt4/include/QtGui/qscrollbar.h"
private:
friend  QStyleOptionSlider qt_qscrollbarStyleOption(QScrollBar *scrollBar);

QScrollBar(const QScrollBar &); QScrollBar &operator=(const QScrollBar &);
inline QScrollBarPrivate* d_func() { return reinterpret_cast<QScrollBarPrivate *>(qGetPtrHelper(d_ptr)); } inline const QScrollBarPrivate* d_func() const { return reinterpret_cast<const QScrollBarPrivate *>(qGetPtrHelper(d_ptr)); } friend class QScrollBarPrivate;
};



# 100 "/usr/share/qt4/include/QtGui/qscrollbar.h"





# 113 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qsizegrip.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qsizegrip.h"


# 47 "/usr/share/qt4/include/QtGui/qsizegrip.h"




typedef QtValidLicenseForGuiModule QtGuiModule;


# 54 "/usr/share/qt4/include/QtGui/qsizegrip.h"
class QSizeGripPrivate;
class  QSizeGrip : public QWidget
{
Q_OBJECT
public:
explicit QSizeGrip(QWidget *parent);
~QSizeGrip();

QSize sizeHint() const;
void setVisible(bool);

protected:
void paintEvent(QPaintEvent *);
void mousePressEvent(QMouseEvent *);
void mouseMoveEvent(QMouseEvent *);
void mouseReleaseEvent(QMouseEvent *mouseEvent);
void moveEvent(QMoveEvent *moveEvent);
void showEvent(QShowEvent *showEvent);
void hideEvent(QHideEvent *hideEvent);
bool eventFilter(QObject *, QEvent *);
bool event(QEvent *);




# 79 "/usr/share/qt4/include/QtGui/qsizegrip.h"
public:




# 84 "/usr/share/qt4/include/QtGui/qsizegrip.h"
private:
inline QSizeGripPrivate* d_func() { return reinterpret_cast<QSizeGripPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSizeGripPrivate* d_func() const { return reinterpret_cast<const QSizeGripPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSizeGripPrivate;
QSizeGrip(const QSizeGrip &); QSizeGrip &operator=(const QSizeGrip &);

};


# 91 "/usr/share/qt4/include/QtGui/qsizegrip.h"





# 114 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qslider.h"






































































































































# 115 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qspinbox.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractspinbox.h"



















































































































































































# 45 "/usr/share/qt4/include/QtGui/qspinbox.h"


# 47 "/usr/share/qt4/include/QtGui/qspinbox.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qspinbox.h"
class QSpinBoxPrivate;
class  QSpinBox : public QAbstractSpinBox
{
Q_OBJECT

Q_PROPERTY(QString suffix READ suffix WRITE setSuffix)
Q_PROPERTY(QString prefix READ prefix WRITE setPrefix)
Q_PROPERTY(QString cleanText READ cleanText)
Q_PROPERTY(int minimum READ minimum WRITE setMinimum)
Q_PROPERTY(int maximum READ maximum WRITE setMaximum)
Q_PROPERTY(int singleStep READ singleStep WRITE setSingleStep)
Q_PROPERTY(int value READ value WRITE setValue NOTIFY valueChanged USER true)

public:
explicit QSpinBox(QWidget *parent = 0);






# 76 "/usr/share/qt4/include/QtGui/qspinbox.h"
int value() const;

QString prefix() const;
void setPrefix(const QString &prefix);

QString suffix() const;
void setSuffix(const QString &suffix);

QString cleanText() const;

int singleStep() const;
void setSingleStep(int val);

int minimum() const;
void setMinimum(int min);

int maximum() const;
void setMaximum(int max);

void setRange(int min, int max);









# 105 "/usr/share/qt4/include/QtGui/qspinbox.h"
protected:
bool event(QEvent *event);
virtual QValidator::State validate(QString &input, int &pos) const;
virtual int valueFromText(const QString &text) const;
virtual QString textFromValue(int val) const;
virtual void fixup(QString &str) const;


public slots:
void setValue(int val);

signals:
void valueChanged(int);
void valueChanged(const QString &);

private:
QSpinBox(const QSpinBox &); QSpinBox &operator=(const QSpinBox &);
inline QSpinBoxPrivate* d_func() { return reinterpret_cast<QSpinBoxPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSpinBoxPrivate* d_func() const { return reinterpret_cast<const QSpinBoxPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSpinBoxPrivate;
};

class QDoubleSpinBoxPrivate;
class  QDoubleSpinBox : public QAbstractSpinBox
{
Q_OBJECT

Q_PROPERTY(QString prefix READ prefix WRITE setPrefix)
Q_PROPERTY(QString suffix READ suffix WRITE setSuffix)
Q_PROPERTY(QString cleanText READ cleanText)
Q_PROPERTY(int decimals READ decimals WRITE setDecimals)
Q_PROPERTY(double minimum READ minimum WRITE setMinimum)
Q_PROPERTY(double maximum READ maximum WRITE setMaximum)
Q_PROPERTY(double singleStep READ singleStep WRITE setSingleStep)
Q_PROPERTY(double value READ value WRITE setValue NOTIFY valueChanged USER true)
public:
explicit QDoubleSpinBox(QWidget *parent = 0);

double value() const;

QString prefix() const;
void setPrefix(const QString &prefix);

QString suffix() const;
void setSuffix(const QString &suffix);

QString cleanText() const;

double singleStep() const;
void setSingleStep(double val);

double minimum() const;
void setMinimum(double min);

double maximum() const;
void setMaximum(double max);

void setRange(double min, double max);

int decimals() const;
void setDecimals(int prec);

virtual QValidator::State validate(QString &input, int &pos) const;
virtual double valueFromText(const QString &text) const;
virtual QString textFromValue(double val) const;
virtual void fixup(QString &str) const;

public slots:
void setValue(double val);

signals:
void valueChanged(double);
void valueChanged(const QString &);

private:
QDoubleSpinBox(const QDoubleSpinBox &); QDoubleSpinBox &operator=(const QDoubleSpinBox &);
inline QDoubleSpinBoxPrivate* d_func() { return reinterpret_cast<QDoubleSpinBoxPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDoubleSpinBoxPrivate* d_func() const { return reinterpret_cast<const QDoubleSpinBoxPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDoubleSpinBoxPrivate;
};



# 184 "/usr/share/qt4/include/QtGui/qspinbox.h"





# 116 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qsplashscreen.h"












































# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qsplashscreen.h"

# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qsplashscreen.h"


# 48 "/usr/share/qt4/include/QtGui/qsplashscreen.h"




typedef QtValidLicenseForGuiModule QtGuiModule;


# 55 "/usr/share/qt4/include/QtGui/qsplashscreen.h"
class QSplashScreenPrivate;

class  QSplashScreen : public QWidget
{
Q_OBJECT
public:
explicit QSplashScreen(const QPixmap &pixmap = QPixmap(), Qt::WindowFlags f = 0);
QSplashScreen(QWidget *parent, const QPixmap &pixmap = QPixmap(), Qt::WindowFlags f = 0);
virtual ~QSplashScreen();

void setPixmap(const QPixmap &pixmap);
const QPixmap pixmap() const;
void finish(QWidget *w);
void repaint();

public slots:
void showMessage(const QString &message, int alignment = Qt::AlignLeft,
const QColor &color = Qt::black);
void clearMessage();






# 80 "/usr/share/qt4/include/QtGui/qsplashscreen.h"
signals:
void messageChanged(const QString &message);

protected:
bool event(QEvent *e);
virtual void drawContents(QPainter *painter);
void mousePressEvent(QMouseEvent *);

private:
QSplashScreen(const QSplashScreen &); QSplashScreen &operator=(const QSplashScreen &);
inline QSplashScreenPrivate* d_func() { return reinterpret_cast<QSplashScreenPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSplashScreenPrivate* d_func() const { return reinterpret_cast<const QSplashScreenPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSplashScreenPrivate;
};



# 95 "/usr/share/qt4/include/QtGui/qsplashscreen.h"





# 117 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qsplitter.h"












































# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 45 "/usr/share/qt4/include/QtGui/qsplitter.h"

# 1 "/usr/share/qt4/include/QtGui/qsizepolicy.h"






































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qsplitter.h"


# 48 "/usr/share/qt4/include/QtGui/qsplitter.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qsplitter.h"
class QSplitterPrivate;
class QTextStream;
template <typename T> class QList;

class QSplitterHandle;

class  QSplitter : public QFrame
{
Q_OBJECT

Q_PROPERTY(Qt::Orientation orientation READ orientation WRITE setOrientation)
Q_PROPERTY(bool opaqueResize READ opaqueResize WRITE setOpaqueResize)
Q_PROPERTY(int handleWidth READ handleWidth WRITE setHandleWidth)
Q_PROPERTY(bool childrenCollapsible READ childrenCollapsible WRITE setChildrenCollapsible)

public:
explicit QSplitter(QWidget* parent = 0);
explicit QSplitter(Qt::Orientation, QWidget* parent = 0);
~QSplitter();

void addWidget(QWidget *widget);
void insertWidget(int index, QWidget *widget);

void setOrientation(Qt::Orientation);
Qt::Orientation orientation() const;

void setChildrenCollapsible(bool);
bool childrenCollapsible() const;

void setCollapsible(int index, bool);
bool isCollapsible(int index) const;
void setOpaqueResize(bool opaque = true);
bool opaqueResize() const;
void refresh();

QSize sizeHint() const;
QSize minimumSizeHint() const;

QList<int> sizes() const;
void setSizes(const QList<int> &list);

QByteArray saveState() const;
bool restoreState(const QByteArray &state);

int handleWidth() const;
void setHandleWidth(int);

int indexOf(QWidget *w) const;
QWidget *widget(int index) const;
int count() const;

void getRange(int index, int *, int *) const;
QSplitterHandle *handle(int index) const;

void setStretchFactor(int index, int stretch);

signals:
void splitterMoved(int pos, int index);

protected:
virtual QSplitterHandle *createHandle();

void childEvent(QChildEvent *);

bool event(QEvent *);
void resizeEvent(QResizeEvent *);

void changeEvent(QEvent *);
void moveSplitter(int pos, int index);
void setRubberBand(int position);
int closestLegalPosition(int, int);
















# 143 "/usr/share/qt4/include/QtGui/qsplitter.h"
private:
QSplitter(const QSplitter &); QSplitter &operator=(const QSplitter &);
inline QSplitterPrivate* d_func() { return reinterpret_cast<QSplitterPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSplitterPrivate* d_func() const { return reinterpret_cast<const QSplitterPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSplitterPrivate;
private:
friend class QSplitterHandle;
};



# 152 "/usr/share/qt4/include/QtGui/qsplitter.h"
 QTextStream& operator<<(QTextStream&, const QSplitter&);
 QTextStream& operator>>(QTextStream&, QSplitter&);

# 155 "/usr/share/qt4/include/QtGui/qsplitter.h"


class QSplitterHandlePrivate;
class  QSplitterHandle : public QWidget
{
Q_OBJECT
public:
QSplitterHandle(Qt::Orientation o, QSplitter *parent);
void setOrientation(Qt::Orientation o);
Qt::Orientation orientation() const;
bool opaqueResize() const;
QSplitter *splitter() const;

QSize sizeHint() const;

protected:
void paintEvent(QPaintEvent *);
void mouseMoveEvent(QMouseEvent *);
void mousePressEvent(QMouseEvent *);
void mouseReleaseEvent(QMouseEvent *);
bool event(QEvent *);

void moveSplitter(int p);
int closestLegalPosition(int p);

private:
QSplitterHandle(const QSplitterHandle &); QSplitterHandle &operator=(const QSplitterHandle &);
inline QSplitterHandlePrivate* d_func() { return reinterpret_cast<QSplitterHandlePrivate *>(qGetPtrHelper(d_ptr)); } inline const QSplitterHandlePrivate* d_func() const { return reinterpret_cast<const QSplitterHandlePrivate *>(qGetPtrHelper(d_ptr)); } friend class QSplitterHandlePrivate;
};



# 187 "/usr/share/qt4/include/QtGui/qsplitter.h"





# 118 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qstackedwidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 45 "/usr/share/qt4/include/QtGui/qstackedwidget.h"


# 47 "/usr/share/qt4/include/QtGui/qstackedwidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qstackedwidget.h"
class QStackedWidgetPrivate;

class  QStackedWidget : public QFrame
{
Q_OBJECT

Q_PROPERTY(int currentIndex READ currentIndex WRITE setCurrentIndex NOTIFY currentChanged)
Q_PROPERTY(int count READ count)
public:
explicit QStackedWidget(QWidget *parent=0);
~QStackedWidget();

int addWidget(QWidget *w);
int insertWidget(int index, QWidget *w);
void removeWidget(QWidget *w);

QWidget *currentWidget() const;
int currentIndex() const;

int indexOf(QWidget *) const;
QWidget *widget(int) const;
int count() const;

public slots:
void setCurrentIndex(int index);
void setCurrentWidget(QWidget *w);

signals:
void currentChanged(int);
void widgetRemoved(int index);

protected:
bool event(QEvent *e);

private:
QStackedWidget(const QStackedWidget &); QStackedWidget &operator=(const QStackedWidget &);
inline QStackedWidgetPrivate* d_func() { return reinterpret_cast<QStackedWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QStackedWidgetPrivate* d_func() const { return reinterpret_cast<const QStackedWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QStackedWidgetPrivate;
};



# 96 "/usr/share/qt4/include/QtGui/qstackedwidget.h"





# 119 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qstatusbar.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qstatusbar.h"


# 47 "/usr/share/qt4/include/QtGui/qstatusbar.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qstatusbar.h"
class QStatusBarPrivate;

class  QStatusBar: public QWidget
{
Q_OBJECT

Q_PROPERTY(bool sizeGripEnabled READ isSizeGripEnabled WRITE setSizeGripEnabled)

public:
explicit QStatusBar(QWidget* parent=0);
virtual ~QStatusBar();

void addWidget(QWidget *widget, int stretch = 0);
int insertWidget(int index, QWidget *widget, int stretch = 0);
void addPermanentWidget(QWidget *widget, int stretch = 0);
int insertPermanentWidget(int index, QWidget *widget, int stretch = 0);
void removeWidget(QWidget *widget);

void setSizeGripEnabled(bool);
bool isSizeGripEnabled() const;

QString currentMessage() const;

public slots:
void showMessage(const QString &text, int timeout = 0);
void clearMessage();











# 92 "/usr/share/qt4/include/QtGui/qstatusbar.h"
signals:
void messageChanged(const QString &text);

protected:
void showEvent(QShowEvent *);
void paintEvent(QPaintEvent *);
void resizeEvent(QResizeEvent *);


void reformat();
void hideOrShow();
bool event(QEvent *);

private:
QStatusBar(const QStatusBar &); QStatusBar &operator=(const QStatusBar &);
inline QStatusBarPrivate* d_func() { return reinterpret_cast<QStatusBarPrivate *>(qGetPtrHelper(d_ptr)); } inline const QStatusBarPrivate* d_func() const { return reinterpret_cast<const QStatusBarPrivate *>(qGetPtrHelper(d_ptr)); } friend class QStatusBarPrivate;
};



# 112 "/usr/share/qt4/include/QtGui/qstatusbar.h"





# 120 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtabbar.h"


































































































































































































































# 121 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtabwidget.h"




























































































































































































































































# 122 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtextbrowser.h"












































# 1 "/usr/share/qt4/include/QtGui/qtextedit.h"














































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtextbrowser.h"

# 1 "/usr/share/qt4/include/QtCore/qurl.h"
































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qtextbrowser.h"


# 48 "/usr/share/qt4/include/QtGui/qtextbrowser.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qtextbrowser.h"
class QTextBrowserPrivate;

class  QTextBrowser : public QTextEdit
{
Q_OBJECT

Q_PROPERTY(QUrl source READ source WRITE setSource)



Q_PROPERTY(QStringList searchPaths READ searchPaths WRITE setSearchPaths)
Q_PROPERTY(bool openExternalLinks READ openExternalLinks WRITE setOpenExternalLinks)
Q_PROPERTY(bool openLinks READ openLinks WRITE setOpenLinks)

public:
explicit QTextBrowser(QWidget* parent = 0);
virtual ~QTextBrowser();

QUrl source() const;

QStringList searchPaths() const;
void setSearchPaths(const QStringList &paths);

virtual QVariant loadResource(int type, const QUrl &name);

bool isBackwardAvailable() const;
bool isForwardAvailable() const;
void clearHistory();
QString historyTitle(int) const;
QUrl historyUrl(int) const;
int backwardHistoryCount() const;
int forwardHistoryCount() const;

bool openExternalLinks() const;
void setOpenExternalLinks(bool open);

bool openLinks() const;
void setOpenLinks(bool open);

public slots:
virtual void setSource(const QUrl &name);
virtual void backward();
virtual void forward();
virtual void home();
virtual void reload();

signals:
void backwardAvailable(bool);
void forwardAvailable(bool);
void historyChanged();
void sourceChanged(const QUrl &);
void highlighted(const QUrl &);
void highlighted(const QString &);
void anchorClicked(const QUrl &);

protected:
bool event(QEvent *e);
virtual void keyPressEvent(QKeyEvent *ev);
virtual void mouseMoveEvent(QMouseEvent *ev);
virtual void mousePressEvent(QMouseEvent *ev);
virtual void mouseReleaseEvent(QMouseEvent *ev);
virtual void focusOutEvent(QFocusEvent *ev);
virtual bool focusNextPrevChild(bool next);
virtual void paintEvent(QPaintEvent *e);






# 126 "/usr/share/qt4/include/QtGui/qtextbrowser.h"
private:
QTextBrowser(const QTextBrowser &); QTextBrowser &operator=(const QTextBrowser &);
inline QTextBrowserPrivate* d_func() { return reinterpret_cast<QTextBrowserPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTextBrowserPrivate* d_func() const { return reinterpret_cast<const QTextBrowserPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTextBrowserPrivate;



};



# 136 "/usr/share/qt4/include/QtGui/qtextbrowser.h"





# 123 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtextedit.h"














































































































































































































































































































































































































































# 124 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtoolbar.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtoolbar.h"


# 47 "/usr/share/qt4/include/QtGui/qtoolbar.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qtoolbar.h"
class QToolBarPrivate;

class QAction;
class QIcon;
class QMainWindow;
class QStyleOptionToolBar;

class  QToolBar : public QWidget
{
Q_OBJECT

Q_PROPERTY(bool movable READ isMovable WRITE setMovable
DESIGNABLE (qobject_cast<QMainWindow *>(parentWidget()) != 0)
NOTIFY movableChanged)
Q_PROPERTY(Qt::ToolBarAreas allowedAreas READ allowedAreas WRITE setAllowedAreas
DESIGNABLE (qobject_cast<QMainWindow *>(parentWidget()) != 0)
NOTIFY allowedAreasChanged)
Q_PROPERTY(Qt::Orientation orientation READ orientation WRITE setOrientation
DESIGNABLE (qobject_cast<QMainWindow *>(parentWidget()) == 0)
NOTIFY orientationChanged)
Q_PROPERTY(QSize iconSize READ iconSize WRITE setIconSize NOTIFY iconSizeChanged)
Q_PROPERTY(Qt::ToolButtonStyle toolButtonStyle READ toolButtonStyle WRITE setToolButtonStyle
NOTIFY toolButtonStyleChanged)
Q_PROPERTY(bool floating READ isFloating)
Q_PROPERTY(bool floatable READ isFloatable WRITE setFloatable)

public:
explicit QToolBar(const QString &title, QWidget *parent = 0);
explicit QToolBar(QWidget *parent = 0);
~QToolBar();

void setMovable(bool movable);
bool isMovable() const;

void setAllowedAreas(Qt::ToolBarAreas areas);
Qt::ToolBarAreas allowedAreas() const;

inline bool isAreaAllowed(Qt::ToolBarArea area) const
{ return (allowedAreas() & area) == area; }

void setOrientation(Qt::Orientation orientation);
Qt::Orientation orientation() const;

void clear();


# 101 "/usr/share/qt4/include/QtGui/qtoolbar.h"
inline void addAction(QAction *action)
{ QWidget::addAction(action); }




# 107 "/usr/share/qt4/include/QtGui/qtoolbar.h"
QAction *addAction(const QString &text);
QAction *addAction(const QIcon &icon, const QString &text);
QAction *addAction(const QString &text, const QObject *receiver, const char* member);
QAction *addAction(const QIcon &icon, const QString &text,
const QObject *receiver, const char* member);

QAction *addSeparator();
QAction *insertSeparator(QAction *before);

QAction *addWidget(QWidget *widget);
QAction *insertWidget(QAction *before, QWidget *widget);

QRect actionGeometry(QAction *action) const;
QAction *actionAt(const QPoint &p) const;
inline QAction *actionAt(int x, int y) const;

QAction *toggleViewAction() const;

QSize iconSize() const;
Qt::ToolButtonStyle toolButtonStyle() const;

QWidget *widgetForAction(QAction *action) const;

bool isFloatable() const;
void setFloatable(bool floatable);
bool isFloating() const;

public slots:
void setIconSize(const QSize &iconSize);
void setToolButtonStyle(Qt::ToolButtonStyle toolButtonStyle);

signals:
void actionTriggered(QAction *action);
void movableChanged(bool movable);
void allowedAreasChanged(Qt::ToolBarAreas allowedAreas);
void orientationChanged(Qt::Orientation orientation);
void iconSizeChanged(const QSize &iconSize);
void toolButtonStyleChanged(Qt::ToolButtonStyle toolButtonStyle);
void topLevelChanged(bool topLevel);

protected:
void actionEvent(QActionEvent *event);
void changeEvent(QEvent *event);
void childEvent(QChildEvent *event);
void paintEvent(QPaintEvent *event);
void resizeEvent(QResizeEvent *event);
bool event(QEvent *event);
void initStyleOption(QStyleOptionToolBar *option) const;










# 165 "/usr/share/qt4/include/QtGui/qtoolbar.h"
private:
inline QToolBarPrivate* d_func() { return reinterpret_cast<QToolBarPrivate *>(qGetPtrHelper(d_ptr)); } inline const QToolBarPrivate* d_func() const { return reinterpret_cast<const QToolBarPrivate *>(qGetPtrHelper(d_ptr)); } friend class QToolBarPrivate;
QToolBar(const QToolBar &); QToolBar &operator=(const QToolBar &);




friend class QMainWindow;
friend class QMainWindowLayout;
friend class QToolBarLayout;
friend class QToolBarAreaLayout;
};

inline QAction *QToolBar::actionAt(int ax, int ay) const
{ return actionAt(QPoint(ax, ay)); }



# 183 "/usr/share/qt4/include/QtGui/qtoolbar.h"





# 125 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtoolbox.h"












































# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 45 "/usr/share/qt4/include/QtGui/qtoolbox.h"

# 1 "/usr/share/qt4/include/QtGui/qicon.h"


























































































































































# 46 "/usr/share/qt4/include/QtGui/qtoolbox.h"


# 48 "/usr/share/qt4/include/QtGui/qtoolbox.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qtoolbox.h"
class QToolBoxPrivate;

class  QToolBox : public QFrame
{
Q_OBJECT
Q_PROPERTY(int currentIndex READ currentIndex WRITE setCurrentIndex NOTIFY currentChanged)
Q_PROPERTY(int count READ count)

public:
explicit QToolBox(QWidget *parent = 0, Qt::WindowFlags f = 0);
~QToolBox();

int addItem(QWidget *widget, const QString &text);
int addItem(QWidget *widget, const QIcon &icon, const QString &text);
int insertItem(int index, QWidget *widget, const QString &text);
int insertItem(int index, QWidget *widget, const QIcon &icon, const QString &text);

void removeItem(int index);

void setItemEnabled(int index, bool enabled);
bool isItemEnabled(int index) const;

void setItemText(int index, const QString &text);
QString itemText(int index) const;

void setItemIcon(int index, const QIcon &icon);
QIcon itemIcon(int index) const;


# 85 "/usr/share/qt4/include/QtGui/qtoolbox.h"
void setItemToolTip(int index, const QString &toolTip);
QString itemToolTip(int index) const;


# 89 "/usr/share/qt4/include/QtGui/qtoolbox.h"
int currentIndex() const;
QWidget *currentWidget() const;
QWidget *widget(int index) const;
int indexOf(QWidget *widget) const;
int count() const;

public slots:
void setCurrentIndex(int index);
void setCurrentWidget(QWidget *widget);

signals:
void currentChanged(int index);

protected:
bool event(QEvent *e);
virtual void itemInserted(int index);
virtual void itemRemoved(int index);
void showEvent(QShowEvent *e);
void changeEvent(QEvent *);


















# 126 "/usr/share/qt4/include/QtGui/qtoolbox.h"
private:
inline QToolBoxPrivate* d_func() { return reinterpret_cast<QToolBoxPrivate *>(qGetPtrHelper(d_ptr)); } inline const QToolBoxPrivate* d_func() const { return reinterpret_cast<const QToolBoxPrivate *>(qGetPtrHelper(d_ptr)); } friend class QToolBoxPrivate;
QToolBox(const QToolBox &); QToolBox &operator=(const QToolBox &);


};


inline int QToolBox::addItem(QWidget *item, const QString &text)
{ return insertItem(-1, item, QIcon(), text); }
inline int QToolBox::addItem(QWidget *item, const QIcon &iconSet,
const QString &text)
{ return insertItem(-1, item, iconSet, text); }
inline int QToolBox::insertItem(int index, QWidget *item, const QString &text)
{ return insertItem(index, item, QIcon(), text); }



# 144 "/usr/share/qt4/include/QtGui/qtoolbox.h"





# 126 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtoolbutton.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractbutton.h"




















































































































































































# 45 "/usr/share/qt4/include/QtGui/qtoolbutton.h"


# 47 "/usr/share/qt4/include/QtGui/qtoolbutton.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qtoolbutton.h"
class QToolButtonPrivate;
class QMenu;
class QStyleOptionToolButton;

class  QToolButton : public QAbstractButton
{
Q_OBJECT
Q_ENUMS(Qt::ToolButtonStyle Qt::ArrowType ToolButtonPopupMode)

# 64 "/usr/share/qt4/include/QtGui/qtoolbutton.h"
Q_PROPERTY(ToolButtonPopupMode popupMode READ popupMode WRITE setPopupMode)

# 66 "/usr/share/qt4/include/QtGui/qtoolbutton.h"
Q_PROPERTY(Qt::ToolButtonStyle toolButtonStyle READ toolButtonStyle WRITE setToolButtonStyle)
Q_PROPERTY(bool autoRaise READ autoRaise WRITE setAutoRaise)
Q_PROPERTY(Qt::ArrowType arrowType READ arrowType WRITE setArrowType)

public:
enum ToolButtonPopupMode {
DelayedPopup,
MenuButtonPopup,
InstantPopup
};

explicit QToolButton(QWidget * parent=0);
~QToolButton();

QSize sizeHint() const;
QSize minimumSizeHint() const;

Qt::ToolButtonStyle toolButtonStyle() const;

Qt::ArrowType arrowType() const;
void setArrowType(Qt::ArrowType type);


# 89 "/usr/share/qt4/include/QtGui/qtoolbutton.h"
void setMenu(QMenu* menu);
QMenu* menu() const;

void setPopupMode(ToolButtonPopupMode mode);
ToolButtonPopupMode popupMode() const;


# 96 "/usr/share/qt4/include/QtGui/qtoolbutton.h"
QAction *defaultAction() const;

void setAutoRaise(bool enable);
bool autoRaise() const;

public slots:

# 103 "/usr/share/qt4/include/QtGui/qtoolbutton.h"
void showMenu();

# 105 "/usr/share/qt4/include/QtGui/qtoolbutton.h"
void setToolButtonStyle(Qt::ToolButtonStyle style);
void setDefaultAction(QAction *);

signals:
void triggered(QAction *);

protected:
QToolButton(QToolButtonPrivate &, QWidget* parent);
bool event(QEvent *e);
void mousePressEvent(QMouseEvent *);
void mouseReleaseEvent(QMouseEvent *);
void paintEvent(QPaintEvent *);
void actionEvent(QActionEvent *);

void enterEvent(QEvent *);
void leaveEvent(QEvent *);
void timerEvent(QTimerEvent *);
void changeEvent(QEvent *);

bool hitButton(const QPoint &pos) const;
void nextCheckState();
void initStyleOption(QStyleOptionToolButton *option) const;

private:
QToolButton(const QToolButton &); QToolButton &operator=(const QToolButton &);
inline QToolButtonPrivate* d_func() { return reinterpret_cast<QToolButtonPrivate *>(qGetPtrHelper(d_ptr)); } inline const QToolButtonPrivate* d_func() const { return reinterpret_cast<const QToolButtonPrivate *>(qGetPtrHelper(d_ptr)); } friend class QToolButtonPrivate;

# 132 "/usr/share/qt4/include/QtGui/qtoolbutton.h"




# 136 "/usr/share/qt4/include/QtGui/qtoolbutton.h"























































# 191 "/usr/share/qt4/include/QtGui/qtoolbutton.h"
};



# 195 "/usr/share/qt4/include/QtGui/qtoolbutton.h"





# 127 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qvalidator.h"























































































































































































































# 128 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qworkspace.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qworkspace.h"


# 47 "/usr/share/qt4/include/QtGui/qworkspace.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qworkspace.h"
class QAction;
class QWorkspaceChild;
class QShowEvent;
class QWorkspacePrivate;

class  QWorkspace : public QWidget
{
Q_OBJECT
Q_PROPERTY(bool scrollBarsEnabled READ scrollBarsEnabled WRITE setScrollBarsEnabled)
Q_PROPERTY(QBrush background READ background WRITE setBackground)

public:
explicit QWorkspace(QWidget* parent=0);
~QWorkspace();

enum WindowOrder { CreationOrder, StackingOrder };

QWidget* activeWindow() const;
QWidgetList windowList(WindowOrder order = CreationOrder) const;

QWidget * addWindow(QWidget *w, Qt::WindowFlags flags = 0);

QSize sizeHint() const;

bool scrollBarsEnabled() const;
void setScrollBarsEnabled(bool enable);







# 88 "/usr/share/qt4/include/QtGui/qworkspace.h"
void setBackground(const QBrush &background);
QBrush background() const;

signals:
void windowActivated(QWidget* w);

public slots:
void setActiveWindow(QWidget *w);
void cascade();
void tile();
void arrangeIcons();
void closeActiveWindow();
void closeAllWindows();
void activateNextWindow();
void activatePreviousWindow();

protected:
bool event(QEvent *e);
void paintEvent(QPaintEvent *e);
void changeEvent(QEvent *);
void childEvent(QChildEvent *);
void resizeEvent(QResizeEvent *);
bool eventFilter(QObject *, QEvent *);
void showEvent(QShowEvent *e);
void hideEvent(QHideEvent *e);

# 114 "/usr/share/qt4/include/QtGui/qworkspace.h"
void wheelEvent(QWheelEvent *e);


# 117 "/usr/share/qt4/include/QtGui/qworkspace.h"
private:
inline QWorkspacePrivate* d_func() { return reinterpret_cast<QWorkspacePrivate *>(qGetPtrHelper(d_ptr)); } inline const QWorkspacePrivate* d_func() const { return reinterpret_cast<const QWorkspacePrivate *>(qGetPtrHelper(d_ptr)); } friend class QWorkspacePrivate;
QWorkspace(const QWorkspace &); QWorkspace &operator=(const QWorkspace &);








friend class QWorkspaceChild;
};



# 133 "/usr/share/qt4/include/QtGui/qworkspace.h"





# 129 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qbitmap.h"












































# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qbitmap.h"


# 47 "/usr/share/qt4/include/QtGui/qbitmap.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QVariant;

class  QBitmap : public QPixmap
{
public:
QBitmap();
QBitmap(const QPixmap &);
QBitmap(int w, int h);
explicit QBitmap(const QSize &);
explicit QBitmap(const QString &fileName, const char *format=0);
~QBitmap();

QBitmap &operator=(const QPixmap &);
operator QVariant() const;

inline void clear() { fill(Qt::color0); }

static QBitmap fromImage(const QImage &image, Qt::ImageConversionFlags flags = Qt::AutoColor);
static QBitmap fromData(const QSize &size, const uchar *bits,
QImage::Format monoFormat = QImage::Format_MonoLSB);

QBitmap transformed(const QMatrix &) const;
QBitmap transformed(const QTransform &matrix) const;










# 86 "/usr/share/qt4/include/QtGui/qbitmap.h"
typedef QExplicitlySharedDataPointer<QPixmapData> DataPtr;
};
template <> inline bool qIsDetached<QBitmap>(QBitmap &t) { return t.isDetached(); } template <> inline void qSwap<QBitmap>(QBitmap &value1, QBitmap &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }















# 104 "/usr/share/qt4/include/QtGui/qbitmap.h"





# 130 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qicon.h"


























































































































































# 131 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qiconengine.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qiconengine.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qiconengine.h"

# 1 "/usr/share/qt4/include/QtGui/qicon.h"


























































































































































# 47 "/usr/share/qt4/include/QtGui/qiconengine.h"


# 49 "/usr/share/qt4/include/QtGui/qiconengine.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class  QIconEngine
{
public:
virtual ~QIconEngine();
virtual void paint(QPainter *painter, const QRect &rect, QIcon::Mode mode, QIcon::State state) = 0;
virtual QSize actualSize(const QSize &size, QIcon::Mode mode, QIcon::State state);
virtual QPixmap pixmap(const QSize &size, QIcon::Mode mode, QIcon::State state);

virtual void addPixmap(const QPixmap &pixmap, QIcon::Mode mode, QIcon::State state);
virtual void addFile(const QString &fileName, const QSize &size, QIcon::Mode mode, QIcon::State state);





# 70 "/usr/share/qt4/include/QtGui/qiconengine.h"
};


class  QIconEngineV2 : public QIconEngine
{
public:
virtual QString key() const;
virtual QIconEngineV2 *clone() const;
virtual bool read(QDataStream &in);
virtual bool write(QDataStream &out) const;
virtual void virtual_hook(int id, void *data);

public:
enum IconEngineHook { AvailableSizesHook = 1 };

struct AvailableSizesArgument
{
QIcon::Mode mode;
QIcon::State state;
QList<QSize> sizes;
};


QList<QSize> availableSizes(QIcon::Mode mode = QIcon::Normal,
QIcon::State state = QIcon::Off);
};






# 132 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qiconengineplugin.h"












































# 1 "/usr/share/qt4/include/QtCore/qplugin.h"














































































































# 45 "/usr/share/qt4/include/QtGui/qiconengineplugin.h"

# 1 "/usr/share/qt4/include/QtCore/qfactoryinterface.h"



































































# 46 "/usr/share/qt4/include/QtGui/qiconengineplugin.h"


# 48 "/usr/share/qt4/include/QtGui/qiconengineplugin.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QIconEngine;
class QIconEngineV2;

struct  QIconEngineFactoryInterface : public QFactoryInterface
{
virtual QIconEngine *create(const QString &filename) = 0;
};


# 64 "/usr/share/qt4/include/QtGui/qiconengineplugin.h"
template <> inline const char *qobject_interface_iid<QIconEngineFactoryInterface *>() { return "com.trolltech.Qt.QIconEngineFactoryInterface"; } template <> inline QIconEngineFactoryInterface *qobject_cast<QIconEngineFactoryInterface *>(QObject *object) { return reinterpret_cast<QIconEngineFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QIconEngineFactoryInterface") : 0)); } template <> inline QIconEngineFactoryInterface *qobject_cast<QIconEngineFactoryInterface *>(const QObject *object) { return reinterpret_cast<QIconEngineFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QIconEngineFactoryInterface") : 0)); }

class  QIconEnginePlugin : public QObject, public QIconEngineFactoryInterface
{
Q_OBJECT

public:
QIconEnginePlugin(QObject *parent = 0);
~QIconEnginePlugin();

virtual QStringList keys() const = 0;
virtual QIconEngine *create(const QString &filename) = 0;
};


struct  QIconEngineFactoryInterfaceV2 : public QFactoryInterface
{
virtual QIconEngineV2 *create(const QString &filename = QString()) = 0;
};


# 86 "/usr/share/qt4/include/QtGui/qiconengineplugin.h"
template <> inline const char *qobject_interface_iid<QIconEngineFactoryInterfaceV2 *>() { return "com.trolltech.Qt.QIconEngineFactoryInterfaceV2"; } template <> inline QIconEngineFactoryInterfaceV2 *qobject_cast<QIconEngineFactoryInterfaceV2 *>(QObject *object) { return reinterpret_cast<QIconEngineFactoryInterfaceV2 *>((object ? object->qt_metacast("com.trolltech.Qt.QIconEngineFactoryInterfaceV2") : 0)); } template <> inline QIconEngineFactoryInterfaceV2 *qobject_cast<QIconEngineFactoryInterfaceV2 *>(const QObject *object) { return reinterpret_cast<QIconEngineFactoryInterfaceV2 *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QIconEngineFactoryInterfaceV2") : 0)); }

class  QIconEnginePluginV2 : public QObject, public QIconEngineFactoryInterfaceV2
{
Q_OBJECT

public:
QIconEnginePluginV2(QObject *parent = 0);
~QIconEnginePluginV2();

virtual QStringList keys() const = 0;
virtual QIconEngineV2 *create(const QString &filename = QString()) = 0;
};






# 133 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qimage.h"









































































































































































































































































































































































# 134 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qimageiohandler.h"












































# 1 "/usr/share/qt4/include/QtCore/qplugin.h"














































































































# 45 "/usr/share/qt4/include/QtGui/qimageiohandler.h"

# 1 "/usr/share/qt4/include/QtCore/qfactoryinterface.h"



































































# 46 "/usr/share/qt4/include/QtGui/qimageiohandler.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 47 "/usr/share/qt4/include/QtGui/qimageiohandler.h"


# 49 "/usr/share/qt4/include/QtGui/qimageiohandler.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QImage;
class QRect;
class QSize;
class QVariant;

class QImageIOHandlerPrivate;
class  QImageIOHandler
{
inline QImageIOHandlerPrivate* d_func() { return reinterpret_cast<QImageIOHandlerPrivate *>(qGetPtrHelper(d_ptr)); } inline const QImageIOHandlerPrivate* d_func() const { return reinterpret_cast<const QImageIOHandlerPrivate *>(qGetPtrHelper(d_ptr)); } friend class QImageIOHandlerPrivate;
public:
QImageIOHandler();
virtual ~QImageIOHandler();

void setDevice(QIODevice *device);
QIODevice *device() const;

void setFormat(const QByteArray &format);
void setFormat(const QByteArray &format) const;
QByteArray format() const;

virtual QByteArray name() const;

virtual bool canRead() const = 0;
virtual bool read(QImage *image) = 0;
virtual bool write(const QImage &image);

enum ImageOption {
Size,
ClipRect,
Description,
ScaledClipRect,
ScaledSize,
CompressionRatio,
Gamma,
Quality,
Name,
SubType,
IncrementalReading,
Endianness,
Animation,
BackgroundColor,
ImageFormat
};
virtual QVariant option(ImageOption option) const;
virtual void setOption(ImageOption option, const QVariant &value);
virtual bool supportsOption(ImageOption option) const;


virtual bool jumpToNextImage();
virtual bool jumpToImage(int imageNumber);
virtual int loopCount() const;
virtual int imageCount() const;
virtual int nextImageDelay() const;
virtual int currentImageNumber() const;
virtual QRect currentImageRect() const;

protected:
QImageIOHandler(QImageIOHandlerPrivate &dd);
QScopedPointer<QImageIOHandlerPrivate> d_ptr;
private:
QImageIOHandler(const QImageIOHandler &); QImageIOHandler &operator=(const QImageIOHandler &);
};

struct  QImageIOHandlerFactoryInterface : public QFactoryInterface
{
virtual QImageIOHandler *create(QIODevice *device, const QByteArray &format = QByteArray()) const = 0;
};


# 124 "/usr/share/qt4/include/QtGui/qimageiohandler.h"
template <> inline const char *qobject_interface_iid<QImageIOHandlerFactoryInterface *>() { return "com.trolltech.Qt.QImageIOHandlerFactoryInterface"; } template <> inline QImageIOHandlerFactoryInterface *qobject_cast<QImageIOHandlerFactoryInterface *>(QObject *object) { return reinterpret_cast<QImageIOHandlerFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QImageIOHandlerFactoryInterface") : 0)); } template <> inline QImageIOHandlerFactoryInterface *qobject_cast<QImageIOHandlerFactoryInterface *>(const QObject *object) { return reinterpret_cast<QImageIOHandlerFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QImageIOHandlerFactoryInterface") : 0)); }

class  QImageIOPlugin : public QObject, public QImageIOHandlerFactoryInterface
{
Q_OBJECT

public:
explicit QImageIOPlugin(QObject *parent = 0);
virtual ~QImageIOPlugin();

enum Capability {
CanRead = 0x1,
CanWrite = 0x2,
CanReadIncremental = 0x4
};
typedef QFlags<Capability> Capabilities;

virtual Capabilities capabilities(QIODevice *device, const QByteArray &format) const = 0;
virtual QStringList keys() const = 0;
virtual QImageIOHandler *create(QIODevice *device, const QByteArray &format = QByteArray()) const = 0;
};

inline QFlags<QImageIOPlugin::Capabilities::enum_type> operator|(QImageIOPlugin::Capabilities::enum_type f1, QImageIOPlugin::Capabilities::enum_type f2) { return QFlags<QImageIOPlugin::Capabilities::enum_type>(f1) | f2; } inline QFlags<QImageIOPlugin::Capabilities::enum_type> operator|(QImageIOPlugin::Capabilities::enum_type f1, QFlags<QImageIOPlugin::Capabilities::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QImageIOPlugin::Capabilities::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }






# 135 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qimagereader.h"












































# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qimagereader.h"

# 1 "/usr/share/qt4/include/QtGui/qimage.h"









































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qimagereader.h"

# 1 "/usr/share/qt4/include/QtGui/qimageiohandler.h"
























































































































































# 47 "/usr/share/qt4/include/QtGui/qimagereader.h"


# 49 "/usr/share/qt4/include/QtGui/qimagereader.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QColor;
class QIODevice;
class QRect;
class QSize;
class QStringList;

class QImageReaderPrivate;
class  QImageReader
{
public:
enum ImageReaderError {
UnknownError,
FileNotFoundError,
DeviceError,
UnsupportedFormatError,
InvalidDataError
};

QImageReader();
explicit QImageReader(QIODevice *device, const QByteArray &format = QByteArray());
explicit QImageReader(const QString &fileName, const QByteArray &format = QByteArray());
~QImageReader();

void setFormat(const QByteArray &format);
QByteArray format() const;

void setAutoDetectImageFormat(bool enabled);
bool autoDetectImageFormat() const;

void setDecideFormatFromContent(bool ignored);
bool decideFormatFromContent() const;

void setDevice(QIODevice *device);
QIODevice *device() const;

void setFileName(const QString &fileName);
QString fileName() const;

QSize size() const;

QImage::Format imageFormat() const;

QStringList textKeys() const;
QString text(const QString &key) const;

void setClipRect(const QRect &rect);
QRect clipRect() const;

void setScaledSize(const QSize &size);
QSize scaledSize() const;

void setQuality(int quality);
int quality() const;

void setScaledClipRect(const QRect &rect);
QRect scaledClipRect() const;

void setBackgroundColor(const QColor &color);
QColor backgroundColor() const;

bool supportsAnimation() const;

bool canRead() const;
QImage read();
bool read(QImage *image);

bool jumpToNextImage();
bool jumpToImage(int imageNumber);
int loopCount() const;
int imageCount() const;
int nextImageDelay() const;
int currentImageNumber() const;
QRect currentImageRect() const;

ImageReaderError error() const;
QString errorString() const;

bool supportsOption(QImageIOHandler::ImageOption option) const;

static QByteArray imageFormat(const QString &fileName);
static QByteArray imageFormat(QIODevice *device);
static QList<QByteArray> supportedImageFormats();

private:
QImageReader(const QImageReader &); QImageReader &operator=(const QImageReader &);
QImageReaderPrivate *d;
};






# 136 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qimagewriter.h"












































# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qimagewriter.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qimagewriter.h"

# 1 "/usr/share/qt4/include/QtGui/qimageiohandler.h"
























































































































































# 47 "/usr/share/qt4/include/QtGui/qimagewriter.h"


# 49 "/usr/share/qt4/include/QtGui/qimagewriter.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QIODevice;
class QImage;

class QImageWriterPrivate;
class  QImageWriter
{
public:
enum ImageWriterError {
UnknownError,
DeviceError,
UnsupportedFormatError
};

QImageWriter();
explicit QImageWriter(QIODevice *device, const QByteArray &format);
explicit QImageWriter(const QString &fileName, const QByteArray &format = QByteArray());
~QImageWriter();

void setFormat(const QByteArray &format);
QByteArray format() const;

void setDevice(QIODevice *device);
QIODevice *device() const;

void setFileName(const QString &fileName);
QString fileName() const;

void setQuality(int quality);
int quality() const;

void setCompression(int compression);
int compression() const;

void setGamma(float gamma);
float gamma() const;


void setDescription(const QString &description);
QString description() const;

void setText(const QString &key, const QString &text);

bool canWrite() const;
bool write(const QImage &image);

ImageWriterError error() const;
QString errorString() const;

bool supportsOption(QImageIOHandler::ImageOption option) const;

static QList<QByteArray> supportedImageFormats();

private:
QImageWriter(const QImageWriter &); QImageWriter &operator=(const QImageWriter &);
QImageWriterPrivate *d;
};






# 137 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmovie.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qmovie.h"




# 1 "/usr/share/qt4/include/QtCore/qbytearray.h"


















































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qmovie.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qmovie.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 51 "/usr/share/qt4/include/QtGui/qmovie.h"

# 1 "/usr/share/qt4/include/QtGui/qimagereader.h"



















































































































































# 52 "/usr/share/qt4/include/QtGui/qmovie.h"







# 59 "/usr/share/qt4/include/QtGui/qmovie.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QByteArray;
class QColor;
class QIODevice;
class QImage;
class QPixmap;
class QRect;
class QSize;

class QMoviePrivate;
class  QMovie : public QObject
{
Q_OBJECT
inline QMoviePrivate* d_func() { return reinterpret_cast<QMoviePrivate *>(qGetPtrHelper(d_ptr)); } inline const QMoviePrivate* d_func() const { return reinterpret_cast<const QMoviePrivate *>(qGetPtrHelper(d_ptr)); } friend class QMoviePrivate;
Q_ENUMS(MovieState CacheMode)
Q_PROPERTY(int speed READ speed WRITE setSpeed)
Q_PROPERTY(CacheMode cacheMode READ cacheMode WRITE setCacheMode)
public:
enum MovieState {
NotRunning,
Paused,
Running
};
enum CacheMode {
CacheNone,
CacheAll
};

QMovie(QObject *parent = 0);
explicit QMovie(QIODevice *device, const QByteArray &format = QByteArray(), QObject *parent = 0);
explicit QMovie(const QString &fileName, const QByteArray &format = QByteArray(), QObject *parent = 0);
~QMovie();

static QList<QByteArray> supportedFormats();

void setDevice(QIODevice *device);
QIODevice *device() const;

void setFileName(const QString &fileName);
QString fileName() const;

void setFormat(const QByteArray &format);
QByteArray format() const;

void setBackgroundColor(const QColor &color);
QColor backgroundColor() const;

MovieState state() const;

QRect frameRect() const;
QImage currentImage() const;
QPixmap currentPixmap() const;

bool isValid() const;

bool jumpToFrame(int frameNumber);
int loopCount() const;
int frameCount() const;
int nextFrameDelay() const;
int currentFrameNumber() const;

int speed() const;

QSize scaledSize();
void setScaledSize(const QSize &size);

CacheMode cacheMode() const;
void setCacheMode(CacheMode mode);

CacheMode cacheMode(); 

signals:
void started();
void resized(const QSize &size);
void updated(const QRect &rect);
void stateChanged(QMovie::MovieState state);
void error(QImageReader::ImageReaderError error);
void finished();
void frameChanged(int frameNumber);

public slots:
void start();
bool jumpToNextFrame();
void setPaused(bool paused);
void stop();
void setSpeed(int percentSpeed);

private:
QMovie(const QMovie &); QMovie &operator=(const QMovie &);
















# 169 "/usr/share/qt4/include/QtGui/qmovie.h"
};








# 138 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpicture.h"












































# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"



































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qpicture.h"

# 1 "/usr/share/qt4/include/QtCore/qsharedpointer.h"



























































































































































# 46 "/usr/share/qt4/include/QtGui/qpicture.h"

# 1 "/usr/share/qt4/include/QtGui/qpaintdevice.h"















































































































































































# 47 "/usr/share/qt4/include/QtGui/qpicture.h"


# 49 "/usr/share/qt4/include/QtGui/qpicture.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 57 "/usr/share/qt4/include/QtGui/qpicture.h"
class QPicturePrivate;
class  QPicture : public QPaintDevice
{
inline QPicturePrivate* d_func() { return reinterpret_cast<QPicturePrivate *>(qGetPtrHelper(d_ptr)); } inline const QPicturePrivate* d_func() const { return reinterpret_cast<const QPicturePrivate *>(qGetPtrHelper(d_ptr)); } friend class QPicturePrivate;
public:
explicit QPicture(int formatVersion = -1);
QPicture(const QPicture &);
~QPicture();

bool isNull() const;

int devType() const;
uint size() const;
const char* data() const;
virtual void setData(const char* data, uint size);

bool play(QPainter *p);

bool load(QIODevice *dev, const char *format = 0);
bool load(const QString &fileName, const char *format = 0);
bool save(QIODevice *dev, const char *format = 0);
bool save(const QString &fileName, const char *format = 0);

QRect boundingRect() const;
void setBoundingRect(const QRect &r);

QPicture& operator=(const QPicture &p);
void detach();
bool isDetached() const;

friend  QDataStream &operator<<(QDataStream &in, const QPicture &p);
friend  QDataStream &operator>>(QDataStream &in, QPicture &p);

static const char* pictureFormat(const QString &fileName);
static QList<QByteArray> inputFormats();
static QList<QByteArray> outputFormats();
static QStringList inputFormatList();
static QStringList outputFormatList();

QPaintEngine *paintEngine() const;

protected:
QPicture(QPicturePrivate &data);

int metric(PaintDeviceMetric m) const;




# 106 "/usr/share/qt4/include/QtGui/qpicture.h"
private:
bool exec(QPainter *p, QDataStream &ds, int i);
void detach_helper();

QExplicitlySharedDataPointer<QPicturePrivate> d_ptr;
friend class QPicturePaintEngine;
friend class Q3Picture;
friend class QAlphaPaintEngine;
friend class QPreviewPaintEngine;

public:
typedef QExplicitlySharedDataPointer<QPicturePrivate> DataPtr;
inline DataPtr &data_ptr() { return d_ptr; }
};

template <> inline bool qIsDetached<QPicture>(QPicture &t) { return t.isDetached(); } template <> inline void qSwap<QPicture>(QPicture &value1, QPicture &value2) { qSwap(value1.data_ptr(), value2.data_ptr()); }



# 125 "/usr/share/qt4/include/QtGui/qpicture.h"
class QIODevice;
class QPictureIO;
typedef void (*picture_io_handler)(QPictureIO *); 

struct QPictureIOData;

class  QPictureIO
{
public:
QPictureIO();
QPictureIO(QIODevice *ioDevice, const char *format);
QPictureIO(const QString &fileName, const char *format);
~QPictureIO();

const QPicture &picture() const;
int status() const;
const char *format() const;
QIODevice *ioDevice() const;
QString fileName() const;
int quality() const;
QString description() const;
const char *parameters() const;
float gamma() const;

void setPicture(const QPicture &);
void setStatus(int);
void setFormat(const char *);
void setIODevice(QIODevice *);
void setFileName(const QString &);
void setQuality(int);
void setDescription(const QString &);
void setParameters(const char *);
void setGamma(float);

bool read();
bool write();

static QByteArray pictureFormat(const QString &fileName);
static QByteArray pictureFormat(QIODevice *);
static QList<QByteArray> inputFormats();
static QList<QByteArray> outputFormats();

static void defineIOHandler(const char *format,
const char *header,
const char *flags,
picture_io_handler read_picture,
picture_io_handler write_picture);

private:
QPictureIO(const QPictureIO &); QPictureIO &operator=(const QPictureIO &);

void init();

QPictureIOData *d;
};




# 184 "/usr/share/qt4/include/QtGui/qpicture.h"





# 189 "/usr/share/qt4/include/QtGui/qpicture.h"
 QDataStream &operator<<(QDataStream &, const QPicture &);
 QDataStream &operator>>(QDataStream &, QPicture &);




# 195 "/usr/share/qt4/include/QtGui/qpicture.h"





# 139 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpictureformatplugin.h"












































# 1 "/usr/share/qt4/include/QtCore/qplugin.h"














































































































# 45 "/usr/share/qt4/include/QtGui/qpictureformatplugin.h"

# 1 "/usr/share/qt4/include/QtCore/qfactoryinterface.h"



































































# 46 "/usr/share/qt4/include/QtGui/qpictureformatplugin.h"


# 48 "/usr/share/qt4/include/QtGui/qpictureformatplugin.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qpictureformatplugin.h"
class QPicture;
class QImage;
class QString;
class QStringList;

struct  QPictureFormatInterface : public QFactoryInterface
{
virtual bool loadPicture(const QString &format, const QString &filename, QPicture *) = 0;
virtual bool savePicture(const QString &format, const QString &filename, const QPicture &) = 0;

virtual bool installIOHandler(const QString &) = 0;
};


# 70 "/usr/share/qt4/include/QtGui/qpictureformatplugin.h"
template <> inline const char *qobject_interface_iid<QPictureFormatInterface *>() { return "com.trolltech.Qt.QPictureFormatInterface"; } template <> inline QPictureFormatInterface *qobject_cast<QPictureFormatInterface *>(QObject *object) { return reinterpret_cast<QPictureFormatInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QPictureFormatInterface") : 0)); } template <> inline QPictureFormatInterface *qobject_cast<QPictureFormatInterface *>(const QObject *object) { return reinterpret_cast<QPictureFormatInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QPictureFormatInterface") : 0)); }


class  QPictureFormatPlugin : public QObject, public QPictureFormatInterface
{
Q_OBJECT

public:
explicit QPictureFormatPlugin(QObject *parent = 0);
~QPictureFormatPlugin();

virtual QStringList keys() const = 0;
virtual bool loadPicture(const QString &format, const QString &filename, QPicture *pic);
virtual bool savePicture(const QString &format, const QString &filename, const QPicture &pic);
virtual bool installIOHandler(const QString &format) = 0;

};



# 90 "/usr/share/qt4/include/QtGui/qpictureformatplugin.h"





# 140 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 141 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpixmapcache.h"












































# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qpixmapcache.h"


# 47 "/usr/share/qt4/include/QtGui/qpixmapcache.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class  QPixmapCache
{
public:
class KeyData;
class  Key
{
public:
Key();
Key(const Key &other);
~Key();
bool operator ==(const Key &key) const;
inline bool operator !=(const Key &key) const
{ return !operator==(key); }
Key &operator =(const Key &other);

private:
KeyData *d;
friend class QPMCache;
friend class QPixmapCache;
};

static int cacheLimit();
static void setCacheLimit(int);
static QPixmap *find(const QString &key);
static bool find(const QString &key, QPixmap &pixmap);
static bool find(const QString &key, QPixmap *pixmap);
static bool find(const Key &key, QPixmap *pixmap);
static bool insert(const QString &key, const QPixmap &pixmap);
static Key insert(const QPixmap &pixmap);
static bool replace(const Key &key, const QPixmap &pixmap);
static void remove(const QString &key);
static void remove(const Key &key);
static void clear();
};






# 142 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"












































# 1 "/usr/share/qt4/include/QtCore/qmetatype.h"































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"

# 1 "/usr/share/qt4/include/QtCore/qdebug.h"




























































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"

# 1 "/usr/share/qt4/include/QtCore/qdatastream.h"


















































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"


# 49 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

template <int N, int M, typename T>
class QGenericMatrix
{
public:
QGenericMatrix();
QGenericMatrix(const QGenericMatrix<N, M, T>& other);
explicit QGenericMatrix(const T *values);

const T& operator()(int row, int column) const;
T& operator()(int row, int column);

bool isIdentity() const;
void setToIdentity();

void fill(T value);

QGenericMatrix<M, N, T> transposed() const;

QGenericMatrix<N, M, T>& operator+=(const QGenericMatrix<N, M, T>& other);
QGenericMatrix<N, M, T>& operator-=(const QGenericMatrix<N, M, T>& other);
QGenericMatrix<N, M, T>& operator*=(T factor);
QGenericMatrix<N, M, T>& operator/=(T divisor);
bool operator==(const QGenericMatrix<N, M, T>& other) const;
bool operator!=(const QGenericMatrix<N, M, T>& other) const;

void copyDataTo(T *values) const;

T *data() { return m[0]; }
const T *data() const { return m[0]; }
const T *constData() const { return m[0]; }


# 87 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"
template<int NN, int MM, typename TT>
friend QGenericMatrix<NN, MM, TT> operator+(const QGenericMatrix<NN, MM, TT>& m1, const QGenericMatrix<NN, MM, TT>& m2);
template<int NN, int MM, typename TT>
friend QGenericMatrix<NN, MM, TT> operator-(const QGenericMatrix<NN, MM, TT>& m1, const QGenericMatrix<NN, MM, TT>& m2);
template<int NN, int M1, int M2, typename TT>
friend QGenericMatrix<M1, M2, TT> operator*(const QGenericMatrix<NN, M2, TT>& m1, const QGenericMatrix<M1, NN, TT>& m2);
template<int NN, int MM, typename TT>
friend QGenericMatrix<NN, MM, TT> operator-(const QGenericMatrix<NN, MM, TT>& matrix);
template<int NN, int MM, typename TT>
friend QGenericMatrix<NN, MM, TT> operator*(TT factor, const QGenericMatrix<NN, MM, TT>& matrix);
template<int NN, int MM, typename TT>
friend QGenericMatrix<NN, MM, TT> operator*(const QGenericMatrix<NN, MM, TT>& matrix, TT factor);
template<int NN, int MM, typename TT>
friend QGenericMatrix<NN, MM, TT> operator/(const QGenericMatrix<NN, MM, TT>& matrix, TT divisor);

private:

# 104 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"
T m[N][M]; 

QGenericMatrix(int) {} 


# 109 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"
template <int NN, int MM, typename TT>
friend class QGenericMatrix;

# 112 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"
};

template <int N, int M, typename T>
inline QGenericMatrix<N, M, T>::QGenericMatrix()
{
setToIdentity();
}

template <int N, int M, typename T>
inline QGenericMatrix<N, M, T>::QGenericMatrix(const QGenericMatrix<N, M, T>& other)
{
for (int col = 0; col < N; ++col)
for (int row = 0; row < M; ++row)
m[col][row] = other.m[col][row];
}

template <int N, int M, typename T>
 QGenericMatrix<N, M, T>::QGenericMatrix(const T *values)
{
for (int col = 0; col < N; ++col)
for (int row = 0; row < M; ++row)
m[col][row] = values[row * N + col];
}

template <int N, int M, typename T>
inline const T& QGenericMatrix<N, M, T>::operator()(int row, int column) const
{
qt_noop();
return m[column][row];
}

template <int N, int M, typename T>
inline T& QGenericMatrix<N, M, T>::operator()(int row, int column)
{
qt_noop();
return m[column][row];
}

template <int N, int M, typename T>
 bool QGenericMatrix<N, M, T>::isIdentity() const
{
for (int col = 0; col < N; ++col) {
for (int row = 0; row < M; ++row) {
if (row == col) {
if (m[col][row] != 1.0f)
return false;
} else {
if (m[col][row] != 0.0f)
return false;
}
}
}
return true;
}

template <int N, int M, typename T>
 void QGenericMatrix<N, M, T>::setToIdentity()
{
for (int col = 0; col < N; ++col) {
for (int row = 0; row < M; ++row) {
if (row == col)
m[col][row] = 1.0f;
else
m[col][row] = 0.0f;
}
}
}

template <int N, int M, typename T>
 void QGenericMatrix<N, M, T>::fill(T value)
{
for (int col = 0; col < N; ++col)
for (int row = 0; row < M; ++row)
m[col][row] = value;
}

template <int N, int M, typename T>
 QGenericMatrix<M, N, T> QGenericMatrix<N, M, T>::transposed() const
{
QGenericMatrix<M, N, T> result(1);
for (int row = 0; row < M; ++row)
for (int col = 0; col < N; ++col)
result.m[row][col] = m[col][row];
return result;
}

template <int N, int M, typename T>
 QGenericMatrix<N, M, T>& QGenericMatrix<N, M, T>::operator+=(const QGenericMatrix<N, M, T>& other)
{
for (int index = 0; index < N * M; ++index)
m[0][index] += other.m[0][index];
return *this;
}

template <int N, int M, typename T>
 QGenericMatrix<N, M, T>& QGenericMatrix<N, M, T>::operator-=(const QGenericMatrix<N, M, T>& other)
{
for (int index = 0; index < N * M; ++index)
m[0][index] -= other.m[0][index];
return *this;
}

template <int N, int M, typename T>
 QGenericMatrix<N, M, T>& QGenericMatrix<N, M, T>::operator*=(T factor)
{
for (int index = 0; index < N * M; ++index)
m[0][index] *= factor;
return *this;
}

template <int N, int M, typename T>
 bool QGenericMatrix<N, M, T>::operator==(const QGenericMatrix<N, M, T>& other) const
{
for (int index = 0; index < N * M; ++index) {
if (m[0][index] != other.m[0][index])
return false;
}
return true;
}

template <int N, int M, typename T>
 bool QGenericMatrix<N, M, T>::operator!=(const QGenericMatrix<N, M, T>& other) const
{
for (int index = 0; index < N * M; ++index) {
if (m[0][index] != other.m[0][index])
return true;
}
return false;
}

template <int N, int M, typename T>
 QGenericMatrix<N, M, T>& QGenericMatrix<N, M, T>::operator/=(T divisor)
{
for (int index = 0; index < N * M; ++index)
m[0][index] /= divisor;
return *this;
}

template <int N, int M, typename T>
 QGenericMatrix<N, M, T> operator+(const QGenericMatrix<N, M, T>& m1, const QGenericMatrix<N, M, T>& m2)
{
QGenericMatrix<N, M, T> result(1);
for (int index = 0; index < N * M; ++index)
result.m[0][index] = m1.m[0][index] + m2.m[0][index];
return result;
}

template <int N, int M, typename T>
 QGenericMatrix<N, M, T> operator-(const QGenericMatrix<N, M, T>& m1, const QGenericMatrix<N, M, T>& m2)
{
QGenericMatrix<N, M, T> result(1);
for (int index = 0; index < N * M; ++index)
result.m[0][index] = m1.m[0][index] - m2.m[0][index];
return result;
}

template <int N, int M1, int M2, typename T>
 QGenericMatrix<M1, M2, T> operator*(const QGenericMatrix<N, M2, T>& m1, const QGenericMatrix<M1, N, T>& m2)
{
QGenericMatrix<M1, M2, T> result(1);
for (int row = 0; row < M2; ++row) {
for (int col = 0; col < M1; ++col) {
T sum(0.0f);
for (int j = 0; j < N; ++j)
sum += m1.m[j][row] * m2.m[col][j];
result.m[col][row] = sum;
}
}
return result;
}

template <int N, int M, typename T>
 QGenericMatrix<N, M, T> operator-(const QGenericMatrix<N, M, T>& matrix)
{
QGenericMatrix<N, M, T> result(1);
for (int index = 0; index < N * M; ++index)
result.m[0][index] = -matrix.m[0][index];
return result;
}

template <int N, int M, typename T>
 QGenericMatrix<N, M, T> operator*(T factor, const QGenericMatrix<N, M, T>& matrix)
{
QGenericMatrix<N, M, T> result(1);
for (int index = 0; index < N * M; ++index)
result.m[0][index] = matrix.m[0][index] * factor;
return result;
}

template <int N, int M, typename T>
 QGenericMatrix<N, M, T> operator*(const QGenericMatrix<N, M, T>& matrix, T factor)
{
QGenericMatrix<N, M, T> result(1);
for (int index = 0; index < N * M; ++index)
result.m[0][index] = matrix.m[0][index] * factor;
return result;
}

template <int N, int M, typename T>
 QGenericMatrix<N, M, T> operator/(const QGenericMatrix<N, M, T>& matrix, T divisor)
{
QGenericMatrix<N, M, T> result(1);
for (int index = 0; index < N * M; ++index)
result.m[0][index] = matrix.m[0][index] / divisor;
return result;
}

template <int N, int M, typename T>
 void QGenericMatrix<N, M, T>::copyDataTo(T *values) const
{
for (int col = 0; col < N; ++col)
for (int row = 0; row < M; ++row)
values[row * N + col] = T(m[col][row]);
}


typedef QGenericMatrix<2, 2, qreal> QMatrix2x2;
typedef QGenericMatrix<2, 3, qreal> QMatrix2x3;
typedef QGenericMatrix<2, 4, qreal> QMatrix2x4;
typedef QGenericMatrix<3, 2, qreal> QMatrix3x2;
typedef QGenericMatrix<3, 3, qreal> QMatrix3x3;
typedef QGenericMatrix<3, 4, qreal> QMatrix3x4;
typedef QGenericMatrix<4, 2, qreal> QMatrix4x2;
typedef QGenericMatrix<4, 3, qreal> QMatrix4x3;



# 339 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"
template <int N, int M, typename T>
QDebug operator<<(QDebug dbg, const QGenericMatrix<N, M, T> &m)
{
dbg.nospace() << "QGenericMatrix<" << N << ", " << M
<< ", " << QTypeInfo<T>::name()
<< ">(" << endl << qSetFieldWidth(10);
for (int row = 0; row < M; ++row) {
for (int col = 0; col < N; ++col)
dbg << m(row, col);
dbg << endl;
}
dbg << qSetFieldWidth(0) << ')';
return dbg.space();
}





# 358 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"
template <int N, int M, typename T>
QDataStream &operator<<(QDataStream &stream, const QGenericMatrix<N, M, T> &matrix)
{
for (int row = 0; row < M; ++row)
for (int col = 0; col < N; ++col)
stream << double(matrix(row, col));
return stream;
}

template <int N, int M, typename T>
QDataStream &operator>>(QDataStream &stream, QGenericMatrix<N, M, T> &matrix)
{
double x;
for (int row = 0; row < M; ++row) {
for (int col = 0; col < N; ++col) {
stream >> x;
matrix(row, col) = T(x);
}
}
return stream;
}



# 382 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"


 template <> struct QMetaTypeId< QMatrix2x2 > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QMatrix2x2 >("QMatrix2x2"); return metatype_id; } }; 
 template <> struct QMetaTypeId< QMatrix2x3 > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QMatrix2x3 >("QMatrix2x3"); return metatype_id; } }; 
 template <> struct QMetaTypeId< QMatrix2x4 > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QMatrix2x4 >("QMatrix2x4"); return metatype_id; } }; 
 template <> struct QMetaTypeId< QMatrix3x2 > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QMatrix3x2 >("QMatrix3x2"); return metatype_id; } }; 
 template <> struct QMetaTypeId< QMatrix3x3 > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QMatrix3x3 >("QMatrix3x3"); return metatype_id; } }; 
 template <> struct QMetaTypeId< QMatrix3x4 > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QMatrix3x4 >("QMatrix3x4"); return metatype_id; } }; 
 template <> struct QMetaTypeId< QMatrix4x2 > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QMatrix4x2 >("QMatrix4x2"); return metatype_id; } }; 
 template <> struct QMetaTypeId< QMatrix4x3 > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QMatrix4x3 >("QMatrix4x3"); return metatype_id; } }; 




# 143 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"












































# 1 "/usr/share/qt4/include/QtGui/qvector3d.h"












































# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qvector3d.h"

# 1 "/usr/share/qt4/include/QtCore/qmetatype.h"































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qvector3d.h"


# 48 "/usr/share/qt4/include/QtGui/qvector3d.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QMatrix4x4;
class QVector2D;
class QVector4D;



# 60 "/usr/share/qt4/include/QtGui/qvector3d.h"
class  QVector3D
{
public:
QVector3D();
QVector3D(qreal xpos, qreal ypos, qreal zpos);
explicit QVector3D(const QPoint& point);
explicit QVector3D(const QPointF& point);

# 68 "/usr/share/qt4/include/QtGui/qvector3d.h"
QVector3D(const QVector2D& vector);
QVector3D(const QVector2D& vector, qreal zpos);


# 72 "/usr/share/qt4/include/QtGui/qvector3d.h"
explicit QVector3D(const QVector4D& vector);


# 75 "/usr/share/qt4/include/QtGui/qvector3d.h"
bool isNull() const;

qreal x() const;
qreal y() const;
qreal z() const;

void setX(qreal x);
void setY(qreal y);
void setZ(qreal z);

qreal length() const;
qreal lengthSquared() const;

QVector3D normalized() const;
void normalize();

QVector3D &operator+=(const QVector3D &vector);
QVector3D &operator-=(const QVector3D &vector);
QVector3D &operator*=(qreal factor);
QVector3D &operator*=(const QVector3D& vector);
QVector3D &operator/=(qreal divisor);

static qreal dotProduct(const QVector3D& v1, const QVector3D& v2);
static QVector3D crossProduct(const QVector3D& v1, const QVector3D& v2);
static QVector3D normal(const QVector3D& v1, const QVector3D& v2);
static QVector3D normal
(const QVector3D& v1, const QVector3D& v2, const QVector3D& v3);

qreal distanceToPlane(const QVector3D& plane, const QVector3D& normal) const;
qreal distanceToPlane(const QVector3D& plane1, const QVector3D& plane2, const QVector3D& plane3) const;
qreal distanceToLine(const QVector3D& point, const QVector3D& direction) const;

friend inline bool operator==(const QVector3D &v1, const QVector3D &v2);
friend inline bool operator!=(const QVector3D &v1, const QVector3D &v2);
friend inline const QVector3D operator+(const QVector3D &v1, const QVector3D &v2);
friend inline const QVector3D operator-(const QVector3D &v1, const QVector3D &v2);
friend inline const QVector3D operator*(qreal factor, const QVector3D &vector);
friend inline const QVector3D operator*(const QVector3D &vector, qreal factor);
friend const QVector3D operator*(const QVector3D &v1, const QVector3D& v2);
friend inline const QVector3D operator-(const QVector3D &vector);
friend inline const QVector3D operator/(const QVector3D &vector, qreal divisor);

friend inline bool qFuzzyCompare(const QVector3D& v1, const QVector3D& v2);


# 120 "/usr/share/qt4/include/QtGui/qvector3d.h"
QVector2D toVector2D() const;


# 123 "/usr/share/qt4/include/QtGui/qvector3d.h"
QVector4D toVector4D() const;


# 126 "/usr/share/qt4/include/QtGui/qvector3d.h"
QPoint toPoint() const;
QPointF toPointF() const;

operator QVariant() const;

private:
float xp, yp, zp;

QVector3D(float xpos, float ypos, float zpos, int dummy);

friend class QVector2D;
friend class QVector4D;

# 139 "/usr/share/qt4/include/QtGui/qvector3d.h"
friend QVector3D operator*(const QVector3D& vector, const QMatrix4x4& matrix);
friend QVector3D operator*(const QMatrix4x4& matrix, const QVector3D& vector);

# 142 "/usr/share/qt4/include/QtGui/qvector3d.h"
};

inline QVector3D::QVector3D() : xp(0.0f), yp(0.0f), zp(0.0f) {}

inline QVector3D::QVector3D(qreal xpos, qreal ypos, qreal zpos) : xp(xpos), yp(ypos), zp(zpos) {}

inline QVector3D::QVector3D(float xpos, float ypos, float zpos, int) : xp(xpos), yp(ypos), zp(zpos) {}

inline QVector3D::QVector3D(const QPoint& point) : xp(point.x()), yp(point.y()), zp(0.0f) {}

inline QVector3D::QVector3D(const QPointF& point) : xp(point.x()), yp(point.y()), zp(0.0f) {}

inline bool QVector3D::isNull() const
{
return qIsNull(xp) && qIsNull(yp) && qIsNull(zp);
}

inline qreal QVector3D::x() const { return qreal(xp); }
inline qreal QVector3D::y() const { return qreal(yp); }
inline qreal QVector3D::z() const { return qreal(zp); }

inline void QVector3D::setX(qreal aX) { xp = aX; }
inline void QVector3D::setY(qreal aY) { yp = aY; }
inline void QVector3D::setZ(qreal aZ) { zp = aZ; }

inline QVector3D &QVector3D::operator+=(const QVector3D &vector)
{
xp += vector.xp;
yp += vector.yp;
zp += vector.zp;
return *this;
}

inline QVector3D &QVector3D::operator-=(const QVector3D &vector)
{
xp -= vector.xp;
yp -= vector.yp;
zp -= vector.zp;
return *this;
}

inline QVector3D &QVector3D::operator*=(qreal factor)
{
xp *= factor;
yp *= factor;
zp *= factor;
return *this;
}

inline QVector3D &QVector3D::operator*=(const QVector3D& vector)
{
xp *= vector.xp;
yp *= vector.yp;
zp *= vector.zp;
return *this;
}

inline QVector3D &QVector3D::operator/=(qreal divisor)
{
xp /= divisor;
yp /= divisor;
zp /= divisor;
return *this;
}

inline bool operator==(const QVector3D &v1, const QVector3D &v2)
{
return v1.xp == v2.xp && v1.yp == v2.yp && v1.zp == v2.zp;
}

inline bool operator!=(const QVector3D &v1, const QVector3D &v2)
{
return v1.xp != v2.xp || v1.yp != v2.yp || v1.zp != v2.zp;
}

inline const QVector3D operator+(const QVector3D &v1, const QVector3D &v2)
{
return QVector3D(v1.xp + v2.xp, v1.yp + v2.yp, v1.zp + v2.zp, 1);
}

inline const QVector3D operator-(const QVector3D &v1, const QVector3D &v2)
{
return QVector3D(v1.xp - v2.xp, v1.yp - v2.yp, v1.zp - v2.zp, 1);
}

inline const QVector3D operator*(qreal factor, const QVector3D &vector)
{
return QVector3D(vector.xp * factor, vector.yp * factor, vector.zp * factor, 1);
}

inline const QVector3D operator*(const QVector3D &vector, qreal factor)
{
return QVector3D(vector.xp * factor, vector.yp * factor, vector.zp * factor, 1);
}

inline const QVector3D operator*(const QVector3D &v1, const QVector3D& v2)
{
return QVector3D(v1.xp * v2.xp, v1.yp * v2.yp, v1.zp * v2.zp, 1);
}

inline const QVector3D operator-(const QVector3D &vector)
{
return QVector3D(-vector.xp, -vector.yp, -vector.zp, 1);
}

inline const QVector3D operator/(const QVector3D &vector, qreal divisor)
{
return QVector3D(vector.xp / divisor, vector.yp / divisor, vector.zp / divisor, 1);
}

inline bool qFuzzyCompare(const QVector3D& v1, const QVector3D& v2)
{
return qFuzzyCompare(v1.xp, v2.xp) &&
qFuzzyCompare(v1.yp, v2.yp) &&
qFuzzyCompare(v1.zp, v2.zp);
}

inline QPoint QVector3D::toPoint() const
{
return QPoint(qRound(xp), qRound(yp));
}

inline QPointF QVector3D::toPointF() const
{
return QPointF(qreal(xp), qreal(yp));
}


# 270 "/usr/share/qt4/include/QtGui/qvector3d.h"
 QDebug operator<<(QDebug dbg, const QVector3D &vector);



# 274 "/usr/share/qt4/include/QtGui/qvector3d.h"
 QDataStream &operator<<(QDataStream &, const QVector3D &);
 QDataStream &operator>>(QDataStream &, QVector3D &);




# 280 "/usr/share/qt4/include/QtGui/qvector3d.h"





# 45 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"

# 1 "/usr/share/qt4/include/QtGui/qvector4d.h"












































# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qvector4d.h"

# 1 "/usr/share/qt4/include/QtCore/qmetatype.h"































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qvector4d.h"


# 48 "/usr/share/qt4/include/QtGui/qvector4d.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QMatrix4x4;
class QVector2D;
class QVector3D;



# 60 "/usr/share/qt4/include/QtGui/qvector4d.h"
class  QVector4D
{
public:
QVector4D();
QVector4D(qreal xpos, qreal ypos, qreal zpos, qreal wpos);
explicit QVector4D(const QPoint& point);
explicit QVector4D(const QPointF& point);

# 68 "/usr/share/qt4/include/QtGui/qvector4d.h"
QVector4D(const QVector2D& vector);
QVector4D(const QVector2D& vector, qreal zpos, qreal wpos);


# 72 "/usr/share/qt4/include/QtGui/qvector4d.h"
QVector4D(const QVector3D& vector);
QVector4D(const QVector3D& vector, qreal wpos);


# 76 "/usr/share/qt4/include/QtGui/qvector4d.h"
bool isNull() const;

qreal x() const;
qreal y() const;
qreal z() const;
qreal w() const;

void setX(qreal x);
void setY(qreal y);
void setZ(qreal z);
void setW(qreal w);

qreal length() const;
qreal lengthSquared() const;

QVector4D normalized() const;
void normalize();

QVector4D &operator+=(const QVector4D &vector);
QVector4D &operator-=(const QVector4D &vector);
QVector4D &operator*=(qreal factor);
QVector4D &operator*=(const QVector4D &vector);
QVector4D &operator/=(qreal divisor);

static qreal dotProduct(const QVector4D& v1, const QVector4D& v2);

friend inline bool operator==(const QVector4D &v1, const QVector4D &v2);
friend inline bool operator!=(const QVector4D &v1, const QVector4D &v2);
friend inline const QVector4D operator+(const QVector4D &v1, const QVector4D &v2);
friend inline const QVector4D operator-(const QVector4D &v1, const QVector4D &v2);
friend inline const QVector4D operator*(qreal factor, const QVector4D &vector);
friend inline const QVector4D operator*(const QVector4D &vector, qreal factor);
friend inline const QVector4D operator*(const QVector4D &v1, const QVector4D& v2);
friend inline const QVector4D operator-(const QVector4D &vector);
friend inline const QVector4D operator/(const QVector4D &vector, qreal divisor);

friend inline bool qFuzzyCompare(const QVector4D& v1, const QVector4D& v2);


# 115 "/usr/share/qt4/include/QtGui/qvector4d.h"
QVector2D toVector2D() const;
QVector2D toVector2DAffine() const;


# 119 "/usr/share/qt4/include/QtGui/qvector4d.h"
QVector3D toVector3D() const;
QVector3D toVector3DAffine() const;


# 123 "/usr/share/qt4/include/QtGui/qvector4d.h"
QPoint toPoint() const;
QPointF toPointF() const;

operator QVariant() const;

private:
float xp, yp, zp, wp;

QVector4D(float xpos, float ypos, float zpos, float wpos, int dummy);

friend class QVector2D;
friend class QVector3D;

# 136 "/usr/share/qt4/include/QtGui/qvector4d.h"
friend QVector4D operator*(const QVector4D& vector, const QMatrix4x4& matrix);
friend QVector4D operator*(const QMatrix4x4& matrix, const QVector4D& vector);

# 139 "/usr/share/qt4/include/QtGui/qvector4d.h"
};

inline QVector4D::QVector4D() : xp(0.0f), yp(0.0f), zp(0.0f), wp(0.0f) {}

inline QVector4D::QVector4D(qreal xpos, qreal ypos, qreal zpos, qreal wpos) : xp(xpos), yp(ypos), zp(zpos), wp(wpos) {}

inline QVector4D::QVector4D(float xpos, float ypos, float zpos, float wpos, int) : xp(xpos), yp(ypos), zp(zpos), wp(wpos) {}

inline QVector4D::QVector4D(const QPoint& point) : xp(point.x()), yp(point.y()), zp(0.0f), wp(0.0f) {}

inline QVector4D::QVector4D(const QPointF& point) : xp(point.x()), yp(point.y()), zp(0.0f), wp(0.0f) {}

inline bool QVector4D::isNull() const
{
return qIsNull(xp) && qIsNull(yp) && qIsNull(zp) && qIsNull(wp);
}

inline qreal QVector4D::x() const { return qreal(xp); }
inline qreal QVector4D::y() const { return qreal(yp); }
inline qreal QVector4D::z() const { return qreal(zp); }
inline qreal QVector4D::w() const { return qreal(wp); }

inline void QVector4D::setX(qreal aX) { xp = aX; }
inline void QVector4D::setY(qreal aY) { yp = aY; }
inline void QVector4D::setZ(qreal aZ) { zp = aZ; }
inline void QVector4D::setW(qreal aW) { wp = aW; }

inline QVector4D &QVector4D::operator+=(const QVector4D &vector)
{
xp += vector.xp;
yp += vector.yp;
zp += vector.zp;
wp += vector.wp;
return *this;
}

inline QVector4D &QVector4D::operator-=(const QVector4D &vector)
{
xp -= vector.xp;
yp -= vector.yp;
zp -= vector.zp;
wp -= vector.wp;
return *this;
}

inline QVector4D &QVector4D::operator*=(qreal factor)
{
xp *= factor;
yp *= factor;
zp *= factor;
wp *= factor;
return *this;
}

inline QVector4D &QVector4D::operator*=(const QVector4D &vector)
{
xp *= vector.xp;
yp *= vector.yp;
zp *= vector.zp;
wp *= vector.wp;
return *this;
}

inline QVector4D &QVector4D::operator/=(qreal divisor)
{
xp /= divisor;
yp /= divisor;
zp /= divisor;
wp /= divisor;
return *this;
}

inline bool operator==(const QVector4D &v1, const QVector4D &v2)
{
return v1.xp == v2.xp && v1.yp == v2.yp && v1.zp == v2.zp && v1.wp == v2.wp;
}

inline bool operator!=(const QVector4D &v1, const QVector4D &v2)
{
return v1.xp != v2.xp || v1.yp != v2.yp || v1.zp != v2.zp || v1.wp != v2.wp;
}

inline const QVector4D operator+(const QVector4D &v1, const QVector4D &v2)
{
return QVector4D(v1.xp + v2.xp, v1.yp + v2.yp, v1.zp + v2.zp, v1.wp + v2.wp, 1);
}

inline const QVector4D operator-(const QVector4D &v1, const QVector4D &v2)
{
return QVector4D(v1.xp - v2.xp, v1.yp - v2.yp, v1.zp - v2.zp, v1.wp - v2.wp, 1);
}

inline const QVector4D operator*(qreal factor, const QVector4D &vector)
{
return QVector4D(vector.xp * factor, vector.yp * factor, vector.zp * factor, vector.wp * factor, 1);
}

inline const QVector4D operator*(const QVector4D &vector, qreal factor)
{
return QVector4D(vector.xp * factor, vector.yp * factor, vector.zp * factor, vector.wp * factor, 1);
}

inline const QVector4D operator*(const QVector4D &v1, const QVector4D& v2)
{
return QVector4D(v1.xp * v2.xp, v1.yp * v2.yp, v1.zp * v2.zp, v1.wp * v2.wp, 1);
}

inline const QVector4D operator-(const QVector4D &vector)
{
return QVector4D(-vector.xp, -vector.yp, -vector.zp, -vector.wp, 1);
}

inline const QVector4D operator/(const QVector4D &vector, qreal divisor)
{
return QVector4D(vector.xp / divisor, vector.yp / divisor, vector.zp / divisor, vector.wp / divisor, 1);
}

inline bool qFuzzyCompare(const QVector4D& v1, const QVector4D& v2)
{
return qFuzzyCompare(v1.xp, v2.xp) &&
qFuzzyCompare(v1.yp, v2.yp) &&
qFuzzyCompare(v1.zp, v2.zp) &&
qFuzzyCompare(v1.wp, v2.wp);
}

inline QPoint QVector4D::toPoint() const
{
return QPoint(qRound(xp), qRound(yp));
}

inline QPointF QVector4D::toPointF() const
{
return QPointF(qreal(xp), qreal(yp));
}


# 275 "/usr/share/qt4/include/QtGui/qvector4d.h"
 QDebug operator<<(QDebug dbg, const QVector4D &vector);



# 279 "/usr/share/qt4/include/QtGui/qvector4d.h"
 QDataStream &operator<<(QDataStream &, const QVector4D &);
 QDataStream &operator>>(QDataStream &, QVector4D &);




# 285 "/usr/share/qt4/include/QtGui/qvector4d.h"





# 46 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"

# 1 "/usr/share/qt4/include/QtGui/qquaternion.h"












































# 1 "/usr/share/qt4/include/QtGui/qvector3d.h"




























































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qquaternion.h"

# 1 "/usr/share/qt4/include/QtGui/qvector4d.h"

































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qquaternion.h"


# 48 "/usr/share/qt4/include/QtGui/qquaternion.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qquaternion.h"
class QMatrix4x4;
class QVariant;

class  QQuaternion
{
public:
QQuaternion();
QQuaternion(qreal scalar, qreal xpos, qreal ypos, qreal zpos);

# 65 "/usr/share/qt4/include/QtGui/qquaternion.h"
QQuaternion(qreal scalar, const QVector3D& vector);


# 68 "/usr/share/qt4/include/QtGui/qquaternion.h"
explicit QQuaternion(const QVector4D& vector);


# 71 "/usr/share/qt4/include/QtGui/qquaternion.h"
bool isNull() const;
bool isIdentity() const;


# 75 "/usr/share/qt4/include/QtGui/qquaternion.h"
QVector3D vector() const;
void setVector(const QVector3D& vector);

# 78 "/usr/share/qt4/include/QtGui/qquaternion.h"
void setVector(qreal x, qreal y, qreal z);

qreal x() const;
qreal y() const;
qreal z() const;
qreal scalar() const;

void setX(qreal x);
void setY(qreal y);
void setZ(qreal z);
void setScalar(qreal scalar);

qreal length() const;
qreal lengthSquared() const;

QQuaternion normalized() const;
void normalize();

QQuaternion conjugate() const;

QVector3D rotatedVector(const QVector3D& vector) const;

QQuaternion &operator+=(const QQuaternion &quaternion);
QQuaternion &operator-=(const QQuaternion &quaternion);
QQuaternion &operator*=(qreal factor);
QQuaternion &operator*=(const QQuaternion &quaternion);
QQuaternion &operator/=(qreal divisor);

friend inline bool operator==(const QQuaternion &q1, const QQuaternion &q2);
friend inline bool operator!=(const QQuaternion &q1, const QQuaternion &q2);
friend inline const QQuaternion operator+(const QQuaternion &q1, const QQuaternion &q2);
friend inline const QQuaternion operator-(const QQuaternion &q1, const QQuaternion &q2);
friend inline const QQuaternion operator*(qreal factor, const QQuaternion &quaternion);
friend inline const QQuaternion operator*(const QQuaternion &quaternion, qreal factor);
friend inline const QQuaternion operator*(const QQuaternion &q1, const QQuaternion& q2);
friend inline const QQuaternion operator-(const QQuaternion &quaternion);
friend inline const QQuaternion operator/(const QQuaternion &quaternion, qreal divisor);

friend inline bool qFuzzyCompare(const QQuaternion& q1, const QQuaternion& q2);


# 119 "/usr/share/qt4/include/QtGui/qquaternion.h"
QVector4D toVector4D() const;


# 122 "/usr/share/qt4/include/QtGui/qquaternion.h"
operator QVariant() const;


# 125 "/usr/share/qt4/include/QtGui/qquaternion.h"
static QQuaternion fromAxisAndAngle(const QVector3D& axis, qreal angle);

# 127 "/usr/share/qt4/include/QtGui/qquaternion.h"
static QQuaternion fromAxisAndAngle
(qreal x, qreal y, qreal z, qreal angle);

static QQuaternion slerp
(const QQuaternion& q1, const QQuaternion& q2, qreal t);
static QQuaternion nlerp
(const QQuaternion& q1, const QQuaternion& q2, qreal t);

private:
qreal wp, xp, yp, zp;
};

inline QQuaternion::QQuaternion() : wp(1.0f), xp(0.0f), yp(0.0f), zp(0.0f) {}

inline QQuaternion::QQuaternion(qreal aScalar, qreal xpos, qreal ypos, qreal zpos) : wp(aScalar), xp(xpos), yp(ypos), zp(zpos) {}


inline bool QQuaternion::isNull() const
{
return qIsNull(xp) && qIsNull(yp) && qIsNull(zp) && qIsNull(wp);
}

inline bool QQuaternion::isIdentity() const
{
return qIsNull(xp) && qIsNull(yp) && qIsNull(zp) && wp == 1.0f;
}

inline qreal QQuaternion::x() const { return qreal(xp); }
inline qreal QQuaternion::y() const { return qreal(yp); }
inline qreal QQuaternion::z() const { return qreal(zp); }
inline qreal QQuaternion::scalar() const { return qreal(wp); }

inline void QQuaternion::setX(qreal aX) { xp = aX; }
inline void QQuaternion::setY(qreal aY) { yp = aY; }
inline void QQuaternion::setZ(qreal aZ) { zp = aZ; }
inline void QQuaternion::setScalar(qreal aScalar) { wp = aScalar; }

inline QQuaternion QQuaternion::conjugate() const
{
return QQuaternion(wp, -xp, -yp, -zp);
}

inline QQuaternion &QQuaternion::operator+=(const QQuaternion &quaternion)
{
xp += quaternion.xp;
yp += quaternion.yp;
zp += quaternion.zp;
wp += quaternion.wp;
return *this;
}

inline QQuaternion &QQuaternion::operator-=(const QQuaternion &quaternion)
{
xp -= quaternion.xp;
yp -= quaternion.yp;
zp -= quaternion.zp;
wp -= quaternion.wp;
return *this;
}

inline QQuaternion &QQuaternion::operator*=(qreal factor)
{
xp *= factor;
yp *= factor;
zp *= factor;
wp *= factor;
return *this;
}

inline const QQuaternion operator*(const QQuaternion &q1, const QQuaternion& q2)
{
qreal ww = (q1.zp + q1.xp) * (q2.xp + q2.yp);
qreal yy = (q1.wp - q1.yp) * (q2.wp + q2.zp);
qreal zz = (q1.wp + q1.yp) * (q2.wp - q2.zp);
qreal xx = ww + yy + zz;
qreal qq = 0.5 * (xx + (q1.zp - q1.xp) * (q2.xp - q2.yp));

qreal w = qq - ww + (q1.zp - q1.yp) * (q2.yp - q2.zp);
qreal x = qq - xx + (q1.xp + q1.wp) * (q2.xp + q2.wp);
qreal y = qq - yy + (q1.wp - q1.xp) * (q2.yp + q2.zp);
qreal z = qq - zz + (q1.zp + q1.yp) * (q2.wp - q2.xp);

return QQuaternion(w, x, y, z);
}

inline QQuaternion &QQuaternion::operator*=(const QQuaternion &quaternion)
{
*this = *this * quaternion;
return *this;
}

inline QQuaternion &QQuaternion::operator/=(qreal divisor)
{
xp /= divisor;
yp /= divisor;
zp /= divisor;
wp /= divisor;
return *this;
}

inline bool operator==(const QQuaternion &q1, const QQuaternion &q2)
{
return q1.xp == q2.xp && q1.yp == q2.yp && q1.zp == q2.zp && q1.wp == q2.wp;
}

inline bool operator!=(const QQuaternion &q1, const QQuaternion &q2)
{
return q1.xp != q2.xp || q1.yp != q2.yp || q1.zp != q2.zp || q1.wp != q2.wp;
}

inline const QQuaternion operator+(const QQuaternion &q1, const QQuaternion &q2)
{
return QQuaternion(q1.wp + q2.wp, q1.xp + q2.xp, q1.yp + q2.yp, q1.zp + q2.zp);
}

inline const QQuaternion operator-(const QQuaternion &q1, const QQuaternion &q2)
{
return QQuaternion(q1.wp - q2.wp, q1.xp - q2.xp, q1.yp - q2.yp, q1.zp - q2.zp);
}

inline const QQuaternion operator*(qreal factor, const QQuaternion &quaternion)
{
return QQuaternion(quaternion.wp * factor, quaternion.xp * factor, quaternion.yp * factor, quaternion.zp * factor);
}

inline const QQuaternion operator*(const QQuaternion &quaternion, qreal factor)
{
return QQuaternion(quaternion.wp * factor, quaternion.xp * factor, quaternion.yp * factor, quaternion.zp * factor);
}

inline const QQuaternion operator-(const QQuaternion &quaternion)
{
return QQuaternion(-quaternion.wp, -quaternion.xp, -quaternion.yp, -quaternion.zp);
}

inline const QQuaternion operator/(const QQuaternion &quaternion, qreal divisor)
{
return QQuaternion(quaternion.wp / divisor, quaternion.xp / divisor, quaternion.yp / divisor, quaternion.zp / divisor);
}

inline bool qFuzzyCompare(const QQuaternion& q1, const QQuaternion& q2)
{
return qFuzzyCompare(q1.xp, q2.xp) &&
qFuzzyCompare(q1.yp, q2.yp) &&
qFuzzyCompare(q1.zp, q2.zp) &&
qFuzzyCompare(q1.wp, q2.wp);
}



# 277 "/usr/share/qt4/include/QtGui/qquaternion.h"
inline QQuaternion::QQuaternion(qreal aScalar, const QVector3D& aVector)
: wp(aScalar), xp(aVector.x()), yp(aVector.y()), zp(aVector.z()) {}

inline void QQuaternion::setVector(const QVector3D& aVector)
{
xp = aVector.x();
yp = aVector.y();
zp = aVector.z();
}

inline QVector3D QQuaternion::vector() const
{
return QVector3D(xp, yp, zp);
}



# 294 "/usr/share/qt4/include/QtGui/qquaternion.h"
inline void QQuaternion::setVector(qreal aX, qreal aY, qreal aZ)
{
xp = aX;
yp = aY;
zp = aZ;
}



# 303 "/usr/share/qt4/include/QtGui/qquaternion.h"
inline QQuaternion::QQuaternion(const QVector4D& aVector)
: wp(aVector.w()), xp(aVector.x()), yp(aVector.y()), zp(aVector.z()) {}

inline QVector4D QQuaternion::toVector4D() const
{
return QVector4D(xp, yp, zp, wp);
}




# 314 "/usr/share/qt4/include/QtGui/qquaternion.h"
 QDebug operator<<(QDebug dbg, const QQuaternion &q);



# 318 "/usr/share/qt4/include/QtGui/qquaternion.h"
 QDataStream &operator<<(QDataStream &, const QQuaternion &);
 QDataStream &operator>>(QDataStream &, QQuaternion &);




# 324 "/usr/share/qt4/include/QtGui/qquaternion.h"





# 47 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"

# 1 "/usr/share/qt4/include/QtGui/qgenericmatrix.h"











































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"


# 51 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 59 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
class QMatrix;
class QTransform;
class QVariant;

class  QMatrix4x4
{
public:
inline QMatrix4x4() { setToIdentity(); }
explicit QMatrix4x4(const qreal *values);
inline QMatrix4x4(qreal m11, qreal m12, qreal m13, qreal m14,
qreal m21, qreal m22, qreal m23, qreal m24,
qreal m31, qreal m32, qreal m33, qreal m34,
qreal m41, qreal m42, qreal m43, qreal m44);

# 73 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
template <int N, int M>
explicit QMatrix4x4(const QGenericMatrix<N, M, qreal>& matrix);

# 76 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
QMatrix4x4(const qreal *values, int cols, int rows);
QMatrix4x4(const QTransform& transform);
QMatrix4x4(const QMatrix& matrix);

inline const qreal& operator()(int row, int column) const;
inline qreal& operator()(int row, int column);

inline QVector4D column(int index) const;
inline void setColumn(int index, const QVector4D& value);

inline QVector4D row(int index) const;
inline void setRow(int index, const QVector4D& value);

inline bool isIdentity() const;
inline void setToIdentity();

inline void fill(qreal value);

qreal determinant() const;
QMatrix4x4 inverted(bool *invertible = 0) const;
QMatrix4x4 transposed() const;
QMatrix3x3 normalMatrix() const;

inline QMatrix4x4& operator+=(const QMatrix4x4& other);
inline QMatrix4x4& operator-=(const QMatrix4x4& other);
inline QMatrix4x4& operator*=(const QMatrix4x4& other);
inline QMatrix4x4& operator*=(qreal factor);
QMatrix4x4& operator/=(qreal divisor);
inline bool operator==(const QMatrix4x4& other) const;
inline bool operator!=(const QMatrix4x4& other) const;

friend QMatrix4x4 operator+(const QMatrix4x4& m1, const QMatrix4x4& m2);
friend QMatrix4x4 operator-(const QMatrix4x4& m1, const QMatrix4x4& m2);
friend QMatrix4x4 operator*(const QMatrix4x4& m1, const QMatrix4x4& m2);

# 111 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
friend QVector3D operator*(const QMatrix4x4& matrix, const QVector3D& vector);
friend QVector3D operator*(const QVector3D& vector, const QMatrix4x4& matrix);


# 115 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
friend QVector4D operator*(const QVector4D& vector, const QMatrix4x4& matrix);
friend QVector4D operator*(const QMatrix4x4& matrix, const QVector4D& vector);

# 118 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
friend QPoint operator*(const QPoint& point, const QMatrix4x4& matrix);
friend QPointF operator*(const QPointF& point, const QMatrix4x4& matrix);
friend QMatrix4x4 operator-(const QMatrix4x4& matrix);
friend QPoint operator*(const QMatrix4x4& matrix, const QPoint& point);
friend QPointF operator*(const QMatrix4x4& matrix, const QPointF& point);
friend QMatrix4x4 operator*(qreal factor, const QMatrix4x4& matrix);
friend QMatrix4x4 operator*(const QMatrix4x4& matrix, qreal factor);
friend  QMatrix4x4 operator/(const QMatrix4x4& matrix, qreal divisor);

friend inline bool qFuzzyCompare(const QMatrix4x4& m1, const QMatrix4x4& m2);


# 130 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
void scale(const QVector3D& vector);
void translate(const QVector3D& vector);
void rotate(qreal angle, const QVector3D& vector);

# 134 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
void scale(qreal x, qreal y);
void scale(qreal x, qreal y, qreal z);
void scale(qreal factor);
void translate(qreal x, qreal y);
void translate(qreal x, qreal y, qreal z);
void rotate(qreal angle, qreal x, qreal y, qreal z = 0.0f);

# 141 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
void rotate(const QQuaternion& quaternion);


# 144 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
void ortho(const QRect& rect);
void ortho(const QRectF& rect);
void ortho(qreal left, qreal right, qreal bottom, qreal top, qreal nearPlane, qreal farPlane);
void frustum(qreal left, qreal right, qreal bottom, qreal top, qreal nearPlane, qreal farPlane);
void perspective(qreal angle, qreal aspect, qreal nearPlane, qreal farPlane);

# 150 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
void lookAt(const QVector3D& eye, const QVector3D& center, const QVector3D& up);

# 152 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
void flipCoordinates();

void copyDataTo(qreal *values) const;

QMatrix toAffine() const;
QTransform toTransform() const;
QTransform toTransform(qreal distanceToPlane) const;

QPoint map(const QPoint& point) const;
QPointF map(const QPointF& point) const;

# 163 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
QVector3D map(const QVector3D& point) const;
QVector3D mapVector(const QVector3D& vector) const;


# 167 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
QVector4D map(const QVector4D& point) const;

# 169 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
QRect mapRect(const QRect& rect) const;
QRectF mapRect(const QRectF& rect) const;


# 173 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
template <int N, int M>
QGenericMatrix<N, M, qreal> toGenericMatrix() const;


# 177 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
inline qreal *data();
inline const qreal *data() const { return m[0]; }
inline const qreal *constData() const { return m[0]; }

void optimize();

operator QVariant() const;


# 186 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
friend  QDebug operator<<(QDebug dbg, const QMatrix4x4 &m);


# 189 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
private:
qreal m[4][4]; 
int flagBits; 

enum {
Identity = 0x0001, 
General = 0x0002, 
Translation = 0x0004, 
Scale = 0x0008, 
Rotation = 0x0010 
};


QMatrix4x4(int) { flagBits = General; }

QMatrix4x4 orthonormalInverse() const;

void projectedRotate(qreal angle, qreal x, qreal y, qreal z);

friend class QGraphicsRotation;
};

inline QMatrix4x4::QMatrix4x4
(qreal m11, qreal m12, qreal m13, qreal m14,
qreal m21, qreal m22, qreal m23, qreal m24,
qreal m31, qreal m32, qreal m33, qreal m34,
qreal m41, qreal m42, qreal m43, qreal m44)
{
m[0][0] = m11; m[0][1] = m21; m[0][2] = m31; m[0][3] = m41;
m[1][0] = m12; m[1][1] = m22; m[1][2] = m32; m[1][3] = m42;
m[2][0] = m13; m[2][1] = m23; m[2][2] = m33; m[2][3] = m43;
m[3][0] = m14; m[3][1] = m24; m[3][2] = m34; m[3][3] = m44;
flagBits = General;
}



# 226 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
template <int N, int M>
inline QMatrix4x4::QMatrix4x4
(const QGenericMatrix<N, M, qreal>& matrix)
{
const qreal *values = matrix.constData();
for (int matrixCol = 0; matrixCol < 4; ++matrixCol) {
for (int matrixRow = 0; matrixRow < 4; ++matrixRow) {
if (matrixCol < N && matrixRow < M)
m[matrixCol][matrixRow] = values[matrixCol * M + matrixRow];
else if (matrixCol == matrixRow)
m[matrixCol][matrixRow] = 1.0f;
else
m[matrixCol][matrixRow] = 0.0f;
}
}
flagBits = General;
}

template <int N, int M>
QGenericMatrix<N, M, qreal> QMatrix4x4::toGenericMatrix() const
{
QGenericMatrix<N, M, qreal> result;
qreal *values = result.data();
for (int matrixCol = 0; matrixCol < N; ++matrixCol) {
for (int matrixRow = 0; matrixRow < M; ++matrixRow) {
if (matrixCol < 4 && matrixRow < 4)
values[matrixCol * M + matrixRow] = m[matrixCol][matrixRow];
else if (matrixCol == matrixRow)
values[matrixCol * M + matrixRow] = 1.0f;
else
values[matrixCol * M + matrixRow] = 0.0f;
}
}
return result;
}



# 264 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
inline const qreal& QMatrix4x4::operator()(int aRow, int aColumn) const
{
qt_noop();
return m[aColumn][aRow];
}

inline qreal& QMatrix4x4::operator()(int aRow, int aColumn)
{
qt_noop();
flagBits = General;
return m[aColumn][aRow];
}

inline QVector4D QMatrix4x4::column(int index) const
{
qt_noop();
return QVector4D(m[index][0], m[index][1], m[index][2], m[index][3]);
}

inline void QMatrix4x4::setColumn(int index, const QVector4D& value)
{
qt_noop();
m[index][0] = value.x();
m[index][1] = value.y();
m[index][2] = value.z();
m[index][3] = value.w();
flagBits = General;
}

inline QVector4D QMatrix4x4::row(int index) const
{
qt_noop();
return QVector4D(m[0][index], m[1][index], m[2][index], m[3][index]);
}

inline void QMatrix4x4::setRow(int index, const QVector4D& value)
{
qt_noop();
m[0][index] = value.x();
m[1][index] = value.y();
m[2][index] = value.z();
m[3][index] = value.w();
flagBits = General;
}

 QMatrix4x4 operator/(const QMatrix4x4& matrix, qreal divisor);

inline bool QMatrix4x4::isIdentity() const
{
if (flagBits == Identity)
return true;
if (m[0][0] != 1.0f || m[0][1] != 0.0f || m[0][2] != 0.0f)
return false;
if (m[0][3] != 0.0f || m[1][0] != 0.0f || m[1][1] != 1.0f)
return false;
if (m[1][2] != 0.0f || m[1][3] != 0.0f || m[2][0] != 0.0f)
return false;
if (m[2][1] != 0.0f || m[2][2] != 1.0f || m[2][3] != 0.0f)
return false;
if (m[3][0] != 0.0f || m[3][1] != 0.0f || m[3][2] != 0.0f)
return false;
return (m[3][3] == 1.0f);
}

inline void QMatrix4x4::setToIdentity()
{
m[0][0] = 1.0f;
m[0][1] = 0.0f;
m[0][2] = 0.0f;
m[0][3] = 0.0f;
m[1][0] = 0.0f;
m[1][1] = 1.0f;
m[1][2] = 0.0f;
m[1][3] = 0.0f;
m[2][0] = 0.0f;
m[2][1] = 0.0f;
m[2][2] = 1.0f;
m[2][3] = 0.0f;
m[3][0] = 0.0f;
m[3][1] = 0.0f;
m[3][2] = 0.0f;
m[3][3] = 1.0f;
flagBits = Identity;
}

inline void QMatrix4x4::fill(qreal value)
{
m[0][0] = value;
m[0][1] = value;
m[0][2] = value;
m[0][3] = value;
m[1][0] = value;
m[1][1] = value;
m[1][2] = value;
m[1][3] = value;
m[2][0] = value;
m[2][1] = value;
m[2][2] = value;
m[2][3] = value;
m[3][0] = value;
m[3][1] = value;
m[3][2] = value;
m[3][3] = value;
flagBits = General;
}

inline QMatrix4x4& QMatrix4x4::operator+=(const QMatrix4x4& other)
{
m[0][0] += other.m[0][0];
m[0][1] += other.m[0][1];
m[0][2] += other.m[0][2];
m[0][3] += other.m[0][3];
m[1][0] += other.m[1][0];
m[1][1] += other.m[1][1];
m[1][2] += other.m[1][2];
m[1][3] += other.m[1][3];
m[2][0] += other.m[2][0];
m[2][1] += other.m[2][1];
m[2][2] += other.m[2][2];
m[2][3] += other.m[2][3];
m[3][0] += other.m[3][0];
m[3][1] += other.m[3][1];
m[3][2] += other.m[3][2];
m[3][3] += other.m[3][3];
flagBits = General;
return *this;
}

inline QMatrix4x4& QMatrix4x4::operator-=(const QMatrix4x4& other)
{
m[0][0] -= other.m[0][0];
m[0][1] -= other.m[0][1];
m[0][2] -= other.m[0][2];
m[0][3] -= other.m[0][3];
m[1][0] -= other.m[1][0];
m[1][1] -= other.m[1][1];
m[1][2] -= other.m[1][2];
m[1][3] -= other.m[1][3];
m[2][0] -= other.m[2][0];
m[2][1] -= other.m[2][1];
m[2][2] -= other.m[2][2];
m[2][3] -= other.m[2][3];
m[3][0] -= other.m[3][0];
m[3][1] -= other.m[3][1];
m[3][2] -= other.m[3][2];
m[3][3] -= other.m[3][3];
flagBits = General;
return *this;
}

inline QMatrix4x4& QMatrix4x4::operator*=(const QMatrix4x4& other)
{
if (flagBits == Identity) {
*this = other;
return *this;
} else if (other.flagBits == Identity) {
return *this;
} else {
*this = *this * other;
return *this;
}
}

inline QMatrix4x4& QMatrix4x4::operator*=(qreal factor)
{
m[0][0] *= factor;
m[0][1] *= factor;
m[0][2] *= factor;
m[0][3] *= factor;
m[1][0] *= factor;
m[1][1] *= factor;
m[1][2] *= factor;
m[1][3] *= factor;
m[2][0] *= factor;
m[2][1] *= factor;
m[2][2] *= factor;
m[2][3] *= factor;
m[3][0] *= factor;
m[3][1] *= factor;
m[3][2] *= factor;
m[3][3] *= factor;
flagBits = General;
return *this;
}

inline bool QMatrix4x4::operator==(const QMatrix4x4& other) const
{
return m[0][0] == other.m[0][0] &&
m[0][1] == other.m[0][1] &&
m[0][2] == other.m[0][2] &&
m[0][3] == other.m[0][3] &&
m[1][0] == other.m[1][0] &&
m[1][1] == other.m[1][1] &&
m[1][2] == other.m[1][2] &&
m[1][3] == other.m[1][3] &&
m[2][0] == other.m[2][0] &&
m[2][1] == other.m[2][1] &&
m[2][2] == other.m[2][2] &&
m[2][3] == other.m[2][3] &&
m[3][0] == other.m[3][0] &&
m[3][1] == other.m[3][1] &&
m[3][2] == other.m[3][2] &&
m[3][3] == other.m[3][3];
}

inline bool QMatrix4x4::operator!=(const QMatrix4x4& other) const
{
return m[0][0] != other.m[0][0] ||
m[0][1] != other.m[0][1] ||
m[0][2] != other.m[0][2] ||
m[0][3] != other.m[0][3] ||
m[1][0] != other.m[1][0] ||
m[1][1] != other.m[1][1] ||
m[1][2] != other.m[1][2] ||
m[1][3] != other.m[1][3] ||
m[2][0] != other.m[2][0] ||
m[2][1] != other.m[2][1] ||
m[2][2] != other.m[2][2] ||
m[2][3] != other.m[2][3] ||
m[3][0] != other.m[3][0] ||
m[3][1] != other.m[3][1] ||
m[3][2] != other.m[3][2] ||
m[3][3] != other.m[3][3];
}

inline QMatrix4x4 operator+(const QMatrix4x4& m1, const QMatrix4x4& m2)
{
QMatrix4x4 m(1);
m.m[0][0] = m1.m[0][0] + m2.m[0][0];
m.m[0][1] = m1.m[0][1] + m2.m[0][1];
m.m[0][2] = m1.m[0][2] + m2.m[0][2];
m.m[0][3] = m1.m[0][3] + m2.m[0][3];
m.m[1][0] = m1.m[1][0] + m2.m[1][0];
m.m[1][1] = m1.m[1][1] + m2.m[1][1];
m.m[1][2] = m1.m[1][2] + m2.m[1][2];
m.m[1][3] = m1.m[1][3] + m2.m[1][3];
m.m[2][0] = m1.m[2][0] + m2.m[2][0];
m.m[2][1] = m1.m[2][1] + m2.m[2][1];
m.m[2][2] = m1.m[2][2] + m2.m[2][2];
m.m[2][3] = m1.m[2][3] + m2.m[2][3];
m.m[3][0] = m1.m[3][0] + m2.m[3][0];
m.m[3][1] = m1.m[3][1] + m2.m[3][1];
m.m[3][2] = m1.m[3][2] + m2.m[3][2];
m.m[3][3] = m1.m[3][3] + m2.m[3][3];
return m;
}

inline QMatrix4x4 operator-(const QMatrix4x4& m1, const QMatrix4x4& m2)
{
QMatrix4x4 m(1);
m.m[0][0] = m1.m[0][0] - m2.m[0][0];
m.m[0][1] = m1.m[0][1] - m2.m[0][1];
m.m[0][2] = m1.m[0][2] - m2.m[0][2];
m.m[0][3] = m1.m[0][3] - m2.m[0][3];
m.m[1][0] = m1.m[1][0] - m2.m[1][0];
m.m[1][1] = m1.m[1][1] - m2.m[1][1];
m.m[1][2] = m1.m[1][2] - m2.m[1][2];
m.m[1][3] = m1.m[1][3] - m2.m[1][3];
m.m[2][0] = m1.m[2][0] - m2.m[2][0];
m.m[2][1] = m1.m[2][1] - m2.m[2][1];
m.m[2][2] = m1.m[2][2] - m2.m[2][2];
m.m[2][3] = m1.m[2][3] - m2.m[2][3];
m.m[3][0] = m1.m[3][0] - m2.m[3][0];
m.m[3][1] = m1.m[3][1] - m2.m[3][1];
m.m[3][2] = m1.m[3][2] - m2.m[3][2];
m.m[3][3] = m1.m[3][3] - m2.m[3][3];
return m;
}

inline QMatrix4x4 operator*(const QMatrix4x4& m1, const QMatrix4x4& m2)
{
if (m1.flagBits == QMatrix4x4::Identity)
return m2;
else if (m2.flagBits == QMatrix4x4::Identity)
return m1;

QMatrix4x4 m(1);
m.m[0][0] = m1.m[0][0] * m2.m[0][0] +
m1.m[1][0] * m2.m[0][1] +
m1.m[2][0] * m2.m[0][2] +
m1.m[3][0] * m2.m[0][3];
m.m[0][1] = m1.m[0][1] * m2.m[0][0] +
m1.m[1][1] * m2.m[0][1] +
m1.m[2][1] * m2.m[0][2] +
m1.m[3][1] * m2.m[0][3];
m.m[0][2] = m1.m[0][2] * m2.m[0][0] +
m1.m[1][2] * m2.m[0][1] +
m1.m[2][2] * m2.m[0][2] +
m1.m[3][2] * m2.m[0][3];
m.m[0][3] = m1.m[0][3] * m2.m[0][0] +
m1.m[1][3] * m2.m[0][1] +
m1.m[2][3] * m2.m[0][2] +
m1.m[3][3] * m2.m[0][3];
m.m[1][0] = m1.m[0][0] * m2.m[1][0] +
m1.m[1][0] * m2.m[1][1] +
m1.m[2][0] * m2.m[1][2] +
m1.m[3][0] * m2.m[1][3];
m.m[1][1] = m1.m[0][1] * m2.m[1][0] +
m1.m[1][1] * m2.m[1][1] +
m1.m[2][1] * m2.m[1][2] +
m1.m[3][1] * m2.m[1][3];
m.m[1][2] = m1.m[0][2] * m2.m[1][0] +
m1.m[1][2] * m2.m[1][1] +
m1.m[2][2] * m2.m[1][2] +
m1.m[3][2] * m2.m[1][3];
m.m[1][3] = m1.m[0][3] * m2.m[1][0] +
m1.m[1][3] * m2.m[1][1] +
m1.m[2][3] * m2.m[1][2] +
m1.m[3][3] * m2.m[1][3];
m.m[2][0] = m1.m[0][0] * m2.m[2][0] +
m1.m[1][0] * m2.m[2][1] +
m1.m[2][0] * m2.m[2][2] +
m1.m[3][0] * m2.m[2][3];
m.m[2][1] = m1.m[0][1] * m2.m[2][0] +
m1.m[1][1] * m2.m[2][1] +
m1.m[2][1] * m2.m[2][2] +
m1.m[3][1] * m2.m[2][3];
m.m[2][2] = m1.m[0][2] * m2.m[2][0] +
m1.m[1][2] * m2.m[2][1] +
m1.m[2][2] * m2.m[2][2] +
m1.m[3][2] * m2.m[2][3];
m.m[2][3] = m1.m[0][3] * m2.m[2][0] +
m1.m[1][3] * m2.m[2][1] +
m1.m[2][3] * m2.m[2][2] +
m1.m[3][3] * m2.m[2][3];
m.m[3][0] = m1.m[0][0] * m2.m[3][0] +
m1.m[1][0] * m2.m[3][1] +
m1.m[2][0] * m2.m[3][2] +
m1.m[3][0] * m2.m[3][3];
m.m[3][1] = m1.m[0][1] * m2.m[3][0] +
m1.m[1][1] * m2.m[3][1] +
m1.m[2][1] * m2.m[3][2] +
m1.m[3][1] * m2.m[3][3];
m.m[3][2] = m1.m[0][2] * m2.m[3][0] +
m1.m[1][2] * m2.m[3][1] +
m1.m[2][2] * m2.m[3][2] +
m1.m[3][2] * m2.m[3][3];
m.m[3][3] = m1.m[0][3] * m2.m[3][0] +
m1.m[1][3] * m2.m[3][1] +
m1.m[2][3] * m2.m[3][2] +
m1.m[3][3] * m2.m[3][3];
return m;
}



# 610 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
inline QVector3D operator*(const QVector3D& vector, const QMatrix4x4& matrix)
{
qreal x, y, z, w;
x = vector.x() * matrix.m[0][0] +
vector.y() * matrix.m[0][1] +
vector.z() * matrix.m[0][2] +
matrix.m[0][3];
y = vector.x() * matrix.m[1][0] +
vector.y() * matrix.m[1][1] +
vector.z() * matrix.m[1][2] +
matrix.m[1][3];
z = vector.x() * matrix.m[2][0] +
vector.y() * matrix.m[2][1] +
vector.z() * matrix.m[2][2] +
matrix.m[2][3];
w = vector.x() * matrix.m[3][0] +
vector.y() * matrix.m[3][1] +
vector.z() * matrix.m[3][2] +
matrix.m[3][3];
if (w == 1.0f)
return QVector3D(x, y, z);
else
return QVector3D(x / w, y / w, z / w);
}

inline QVector3D operator*(const QMatrix4x4& matrix, const QVector3D& vector)
{
qreal x, y, z, w;
if (matrix.flagBits == QMatrix4x4::Identity) {
return vector;
} else if (matrix.flagBits == QMatrix4x4::Translation) {
return QVector3D(vector.x() + matrix.m[3][0],
vector.y() + matrix.m[3][1],
vector.z() + matrix.m[3][2]);
} else if (matrix.flagBits ==
(QMatrix4x4::Translation | QMatrix4x4::Scale)) {
return QVector3D(vector.x() * matrix.m[0][0] + matrix.m[3][0],
vector.y() * matrix.m[1][1] + matrix.m[3][1],
vector.z() * matrix.m[2][2] + matrix.m[3][2]);
} else if (matrix.flagBits == QMatrix4x4::Scale) {
return QVector3D(vector.x() * matrix.m[0][0],
vector.y() * matrix.m[1][1],
vector.z() * matrix.m[2][2]);
} else {
x = vector.x() * matrix.m[0][0] +
vector.y() * matrix.m[1][0] +
vector.z() * matrix.m[2][0] +
matrix.m[3][0];
y = vector.x() * matrix.m[0][1] +
vector.y() * matrix.m[1][1] +
vector.z() * matrix.m[2][1] +
matrix.m[3][1];
z = vector.x() * matrix.m[0][2] +
vector.y() * matrix.m[1][2] +
vector.z() * matrix.m[2][2] +
matrix.m[3][2];
w = vector.x() * matrix.m[0][3] +
vector.y() * matrix.m[1][3] +
vector.z() * matrix.m[2][3] +
matrix.m[3][3];
if (w == 1.0f)
return QVector3D(x, y, z);
else
return QVector3D(x / w, y / w, z / w);
}
}





# 681 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
inline QVector4D operator*(const QVector4D& vector, const QMatrix4x4& matrix)
{
qreal x, y, z, w;
x = vector.x() * matrix.m[0][0] +
vector.y() * matrix.m[0][1] +
vector.z() * matrix.m[0][2] +
vector.w() * matrix.m[0][3];
y = vector.x() * matrix.m[1][0] +
vector.y() * matrix.m[1][1] +
vector.z() * matrix.m[1][2] +
vector.w() * matrix.m[1][3];
z = vector.x() * matrix.m[2][0] +
vector.y() * matrix.m[2][1] +
vector.z() * matrix.m[2][2] +
vector.w() * matrix.m[2][3];
w = vector.x() * matrix.m[3][0] +
vector.y() * matrix.m[3][1] +
vector.z() * matrix.m[3][2] +
vector.w() * matrix.m[3][3];
return QVector4D(x, y, z, w);
}

inline QVector4D operator*(const QMatrix4x4& matrix, const QVector4D& vector)
{
qreal x, y, z, w;
x = vector.x() * matrix.m[0][0] +
vector.y() * matrix.m[1][0] +
vector.z() * matrix.m[2][0] +
vector.w() * matrix.m[3][0];
y = vector.x() * matrix.m[0][1] +
vector.y() * matrix.m[1][1] +
vector.z() * matrix.m[2][1] +
vector.w() * matrix.m[3][1];
z = vector.x() * matrix.m[0][2] +
vector.y() * matrix.m[1][2] +
vector.z() * matrix.m[2][2] +
vector.w() * matrix.m[3][2];
w = vector.x() * matrix.m[0][3] +
vector.y() * matrix.m[1][3] +
vector.z() * matrix.m[2][3] +
vector.w() * matrix.m[3][3];
return QVector4D(x, y, z, w);
}



# 727 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
inline QPoint operator*(const QPoint& point, const QMatrix4x4& matrix)
{
qreal xin, yin;
qreal x, y, w;
xin = point.x();
yin = point.y();
x = xin * matrix.m[0][0] +
yin * matrix.m[0][1] +
matrix.m[0][3];
y = xin * matrix.m[1][0] +
yin * matrix.m[1][1] +
matrix.m[1][3];
w = xin * matrix.m[3][0] +
yin * matrix.m[3][1] +
matrix.m[3][3];
if (w == 1.0f)
return QPoint(qRound(x), qRound(y));
else
return QPoint(qRound(x / w), qRound(y / w));
}

inline QPointF operator*(const QPointF& point, const QMatrix4x4& matrix)
{
qreal xin, yin;
qreal x, y, w;
xin = point.x();
yin = point.y();
x = xin * matrix.m[0][0] +
yin * matrix.m[0][1] +
matrix.m[0][3];
y = xin * matrix.m[1][0] +
yin * matrix.m[1][1] +
matrix.m[1][3];
w = xin * matrix.m[3][0] +
yin * matrix.m[3][1] +
matrix.m[3][3];
if (w == 1.0f) {
return QPointF(qreal(x), qreal(y));
} else {
return QPointF(qreal(x / w), qreal(y / w));
}
}

inline QPoint operator*(const QMatrix4x4& matrix, const QPoint& point)
{
qreal xin, yin;
qreal x, y, w;
xin = point.x();
yin = point.y();
if (matrix.flagBits == QMatrix4x4::Identity) {
return point;
} else if (matrix.flagBits == QMatrix4x4::Translation) {
return QPoint(qRound(xin + matrix.m[3][0]),
qRound(yin + matrix.m[3][1]));
} else if (matrix.flagBits ==
(QMatrix4x4::Translation | QMatrix4x4::Scale)) {
return QPoint(qRound(xin * matrix.m[0][0] + matrix.m[3][0]),
qRound(yin * matrix.m[1][1] + matrix.m[3][1]));
} else if (matrix.flagBits == QMatrix4x4::Scale) {
return QPoint(qRound(xin * matrix.m[0][0]),
qRound(yin * matrix.m[1][1]));
} else {
x = xin * matrix.m[0][0] +
yin * matrix.m[1][0] +
matrix.m[3][0];
y = xin * matrix.m[0][1] +
yin * matrix.m[1][1] +
matrix.m[3][1];
w = xin * matrix.m[0][3] +
yin * matrix.m[1][3] +
matrix.m[3][3];
if (w == 1.0f)
return QPoint(qRound(x), qRound(y));
else
return QPoint(qRound(x / w), qRound(y / w));
}
}

inline QPointF operator*(const QMatrix4x4& matrix, const QPointF& point)
{
qreal xin, yin;
qreal x, y, w;
xin = point.x();
yin = point.y();
if (matrix.flagBits == QMatrix4x4::Identity) {
return point;
} else if (matrix.flagBits == QMatrix4x4::Translation) {
return QPointF(xin + matrix.m[3][0],
yin + matrix.m[3][1]);
} else if (matrix.flagBits ==
(QMatrix4x4::Translation | QMatrix4x4::Scale)) {
return QPointF(xin * matrix.m[0][0] + matrix.m[3][0],
yin * matrix.m[1][1] + matrix.m[3][1]);
} else if (matrix.flagBits == QMatrix4x4::Scale) {
return QPointF(xin * matrix.m[0][0],
yin * matrix.m[1][1]);
} else {
x = xin * matrix.m[0][0] +
yin * matrix.m[1][0] +
matrix.m[3][0];
y = xin * matrix.m[0][1] +
yin * matrix.m[1][1] +
matrix.m[3][1];
w = xin * matrix.m[0][3] +
yin * matrix.m[1][3] +
matrix.m[3][3];
if (w == 1.0f) {
return QPointF(qreal(x), qreal(y));
} else {
return QPointF(qreal(x / w), qreal(y / w));
}
}
}

inline QMatrix4x4 operator-(const QMatrix4x4& matrix)
{
QMatrix4x4 m(1);
m.m[0][0] = -matrix.m[0][0];
m.m[0][1] = -matrix.m[0][1];
m.m[0][2] = -matrix.m[0][2];
m.m[0][3] = -matrix.m[0][3];
m.m[1][0] = -matrix.m[1][0];
m.m[1][1] = -matrix.m[1][1];
m.m[1][2] = -matrix.m[1][2];
m.m[1][3] = -matrix.m[1][3];
m.m[2][0] = -matrix.m[2][0];
m.m[2][1] = -matrix.m[2][1];
m.m[2][2] = -matrix.m[2][2];
m.m[2][3] = -matrix.m[2][3];
m.m[3][0] = -matrix.m[3][0];
m.m[3][1] = -matrix.m[3][1];
m.m[3][2] = -matrix.m[3][2];
m.m[3][3] = -matrix.m[3][3];
return m;
}

inline QMatrix4x4 operator*(qreal factor, const QMatrix4x4& matrix)
{
QMatrix4x4 m(1);
m.m[0][0] = matrix.m[0][0] * factor;
m.m[0][1] = matrix.m[0][1] * factor;
m.m[0][2] = matrix.m[0][2] * factor;
m.m[0][3] = matrix.m[0][3] * factor;
m.m[1][0] = matrix.m[1][0] * factor;
m.m[1][1] = matrix.m[1][1] * factor;
m.m[1][2] = matrix.m[1][2] * factor;
m.m[1][3] = matrix.m[1][3] * factor;
m.m[2][0] = matrix.m[2][0] * factor;
m.m[2][1] = matrix.m[2][1] * factor;
m.m[2][2] = matrix.m[2][2] * factor;
m.m[2][3] = matrix.m[2][3] * factor;
m.m[3][0] = matrix.m[3][0] * factor;
m.m[3][1] = matrix.m[3][1] * factor;
m.m[3][2] = matrix.m[3][2] * factor;
m.m[3][3] = matrix.m[3][3] * factor;
return m;
}

inline QMatrix4x4 operator*(const QMatrix4x4& matrix, qreal factor)
{
QMatrix4x4 m(1);
m.m[0][0] = matrix.m[0][0] * factor;
m.m[0][1] = matrix.m[0][1] * factor;
m.m[0][2] = matrix.m[0][2] * factor;
m.m[0][3] = matrix.m[0][3] * factor;
m.m[1][0] = matrix.m[1][0] * factor;
m.m[1][1] = matrix.m[1][1] * factor;
m.m[1][2] = matrix.m[1][2] * factor;
m.m[1][3] = matrix.m[1][3] * factor;
m.m[2][0] = matrix.m[2][0] * factor;
m.m[2][1] = matrix.m[2][1] * factor;
m.m[2][2] = matrix.m[2][2] * factor;
m.m[2][3] = matrix.m[2][3] * factor;
m.m[3][0] = matrix.m[3][0] * factor;
m.m[3][1] = matrix.m[3][1] * factor;
m.m[3][2] = matrix.m[3][2] * factor;
m.m[3][3] = matrix.m[3][3] * factor;
return m;
}

inline bool qFuzzyCompare(const QMatrix4x4& m1, const QMatrix4x4& m2)
{
return qFuzzyCompare(m1.m[0][0], m2.m[0][0]) &&
qFuzzyCompare(m1.m[0][1], m2.m[0][1]) &&
qFuzzyCompare(m1.m[0][2], m2.m[0][2]) &&
qFuzzyCompare(m1.m[0][3], m2.m[0][3]) &&
qFuzzyCompare(m1.m[1][0], m2.m[1][0]) &&
qFuzzyCompare(m1.m[1][1], m2.m[1][1]) &&
qFuzzyCompare(m1.m[1][2], m2.m[1][2]) &&
qFuzzyCompare(m1.m[1][3], m2.m[1][3]) &&
qFuzzyCompare(m1.m[2][0], m2.m[2][0]) &&
qFuzzyCompare(m1.m[2][1], m2.m[2][1]) &&
qFuzzyCompare(m1.m[2][2], m2.m[2][2]) &&
qFuzzyCompare(m1.m[2][3], m2.m[2][3]) &&
qFuzzyCompare(m1.m[3][0], m2.m[3][0]) &&
qFuzzyCompare(m1.m[3][1], m2.m[3][1]) &&
qFuzzyCompare(m1.m[3][2], m2.m[3][2]) &&
qFuzzyCompare(m1.m[3][3], m2.m[3][3]);
}

inline QPoint QMatrix4x4::map(const QPoint& point) const
{
return *this * point;
}

inline QPointF QMatrix4x4::map(const QPointF& point) const
{
return *this * point;
}



# 939 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
inline QVector3D QMatrix4x4::map(const QVector3D& point) const
{
return *this * point;
}

inline QVector3D QMatrix4x4::mapVector(const QVector3D& vector) const
{
if (flagBits == Identity || flagBits == Translation) {
return vector;
} else if (flagBits == Scale || flagBits == (Translation | Scale)) {
return QVector3D(vector.x() * m[0][0],
vector.y() * m[1][1],
vector.z() * m[2][2]);
} else {
return QVector3D(vector.x() * m[0][0] +
vector.y() * m[1][0] +
vector.z() * m[2][0],
vector.x() * m[0][1] +
vector.y() * m[1][1] +
vector.z() * m[2][1],
vector.x() * m[0][2] +
vector.y() * m[1][2] +
vector.z() * m[2][2]);
}
}





# 969 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
inline QVector4D QMatrix4x4::map(const QVector4D& point) const
{
return *this * point;
}



# 976 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
inline qreal *QMatrix4x4::data()
{


flagBits = General;
return m[0];
}


# 985 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
 QDebug operator<<(QDebug dbg, const QMatrix4x4 &m);



# 989 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
 QDataStream &operator<<(QDataStream &, const QMatrix4x4 &);
 QDataStream &operator>>(QDataStream &, QMatrix4x4 &);


# 993 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
template <int N, int M>
QMatrix4x4 qGenericMatrixToMatrix4x4(const QGenericMatrix<N, M, qreal>& matrix)
{
return QMatrix4x4(matrix.constData(), N, M);
}

template <int N, int M>
QGenericMatrix<N, M, qreal> qGenericMatrixFromMatrix4x4(const QMatrix4x4& matrix)
{
QGenericMatrix<N, M, qreal> result;
const qreal *m = matrix.constData();
qreal *values = result.data();
for (int col = 0; col < N; ++col) {
for (int row = 0; row < M; ++row) {
if (col < 4 && row < 4)
values[col * M + row] = m[col * 4 + row];
else if (col == row)
values[col * M + row] = 1.0f;
else
values[col * M + row] = 0.0f;
}
}
return result;
}



# 1020 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"





# 144 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qquaternion.h"








































































































































































































































































































































# 145 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qvector2d.h"












































# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qvector2d.h"

# 1 "/usr/share/qt4/include/QtCore/qmetatype.h"































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qvector2d.h"


# 48 "/usr/share/qt4/include/QtGui/qvector2d.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QVector3D;
class QVector4D;
class QVariant;



# 60 "/usr/share/qt4/include/QtGui/qvector2d.h"
class  QVector2D
{
public:
QVector2D();
QVector2D(qreal xpos, qreal ypos);
explicit QVector2D(const QPoint& point);
explicit QVector2D(const QPointF& point);

# 68 "/usr/share/qt4/include/QtGui/qvector2d.h"
explicit QVector2D(const QVector3D& vector);


# 71 "/usr/share/qt4/include/QtGui/qvector2d.h"
explicit QVector2D(const QVector4D& vector);


# 74 "/usr/share/qt4/include/QtGui/qvector2d.h"
bool isNull() const;

qreal x() const;
qreal y() const;

void setX(qreal x);
void setY(qreal y);

qreal length() const;
qreal lengthSquared() const;

QVector2D normalized() const;
void normalize();

QVector2D &operator+=(const QVector2D &vector);
QVector2D &operator-=(const QVector2D &vector);
QVector2D &operator*=(qreal factor);
QVector2D &operator*=(const QVector2D &vector);
QVector2D &operator/=(qreal divisor);

static qreal dotProduct(const QVector2D& v1, const QVector2D& v2);

friend inline bool operator==(const QVector2D &v1, const QVector2D &v2);
friend inline bool operator!=(const QVector2D &v1, const QVector2D &v2);
friend inline const QVector2D operator+(const QVector2D &v1, const QVector2D &v2);
friend inline const QVector2D operator-(const QVector2D &v1, const QVector2D &v2);
friend inline const QVector2D operator*(qreal factor, const QVector2D &vector);
friend inline const QVector2D operator*(const QVector2D &vector, qreal factor);
friend inline const QVector2D operator*(const QVector2D &v1, const QVector2D &v2);
friend inline const QVector2D operator-(const QVector2D &vector);
friend inline const QVector2D operator/(const QVector2D &vector, qreal divisor);

friend inline bool qFuzzyCompare(const QVector2D& v1, const QVector2D& v2);


# 109 "/usr/share/qt4/include/QtGui/qvector2d.h"
QVector3D toVector3D() const;


# 112 "/usr/share/qt4/include/QtGui/qvector2d.h"
QVector4D toVector4D() const;


# 115 "/usr/share/qt4/include/QtGui/qvector2d.h"
QPoint toPoint() const;
QPointF toPointF() const;

operator QVariant() const;

private:
float xp, yp;

QVector2D(float xpos, float ypos, int dummy);

friend class QVector3D;
friend class QVector4D;
};

inline QVector2D::QVector2D() : xp(0.0f), yp(0.0f) {}

inline QVector2D::QVector2D(float xpos, float ypos, int) : xp(xpos), yp(ypos) {}

inline QVector2D::QVector2D(qreal xpos, qreal ypos) : xp(xpos), yp(ypos) {}

inline QVector2D::QVector2D(const QPoint& point) : xp(point.x()), yp(point.y()) {}

inline QVector2D::QVector2D(const QPointF& point) : xp(point.x()), yp(point.y()) {}

inline bool QVector2D::isNull() const
{
return qIsNull(xp) && qIsNull(yp);
}

inline qreal QVector2D::x() const { return qreal(xp); }
inline qreal QVector2D::y() const { return qreal(yp); }

inline void QVector2D::setX(qreal aX) { xp = aX; }
inline void QVector2D::setY(qreal aY) { yp = aY; }

inline QVector2D &QVector2D::operator+=(const QVector2D &vector)
{
xp += vector.xp;
yp += vector.yp;
return *this;
}

inline QVector2D &QVector2D::operator-=(const QVector2D &vector)
{
xp -= vector.xp;
yp -= vector.yp;
return *this;
}

inline QVector2D &QVector2D::operator*=(qreal factor)
{
xp *= factor;
yp *= factor;
return *this;
}

inline QVector2D &QVector2D::operator*=(const QVector2D &vector)
{
xp *= vector.xp;
yp *= vector.yp;
return *this;
}

inline QVector2D &QVector2D::operator/=(qreal divisor)
{
xp /= divisor;
yp /= divisor;
return *this;
}

inline bool operator==(const QVector2D &v1, const QVector2D &v2)
{
return v1.xp == v2.xp && v1.yp == v2.yp;
}

inline bool operator!=(const QVector2D &v1, const QVector2D &v2)
{
return v1.xp != v2.xp || v1.yp != v2.yp;
}

inline const QVector2D operator+(const QVector2D &v1, const QVector2D &v2)
{
return QVector2D(v1.xp + v2.xp, v1.yp + v2.yp, 1);
}

inline const QVector2D operator-(const QVector2D &v1, const QVector2D &v2)
{
return QVector2D(v1.xp - v2.xp, v1.yp - v2.yp, 1);
}

inline const QVector2D operator*(qreal factor, const QVector2D &vector)
{
return QVector2D(vector.xp * factor, vector.yp * factor, 1);
}

inline const QVector2D operator*(const QVector2D &vector, qreal factor)
{
return QVector2D(vector.xp * factor, vector.yp * factor, 1);
}

inline const QVector2D operator*(const QVector2D &v1, const QVector2D &v2)
{
return QVector2D(v1.xp * v2.xp, v1.yp * v2.yp, 1);
}

inline const QVector2D operator-(const QVector2D &vector)
{
return QVector2D(-vector.xp, -vector.yp, 1);
}

inline const QVector2D operator/(const QVector2D &vector, qreal divisor)
{
return QVector2D(vector.xp / divisor, vector.yp / divisor, 1);
}

inline bool qFuzzyCompare(const QVector2D& v1, const QVector2D& v2)
{
return qFuzzyCompare(v1.xp, v2.xp) && qFuzzyCompare(v1.yp, v2.yp);
}

inline QPoint QVector2D::toPoint() const
{
return QPoint(qRound(xp), qRound(yp));
}

inline QPointF QVector2D::toPointF() const
{
return QPointF(qreal(xp), qreal(yp));
}


# 246 "/usr/share/qt4/include/QtGui/qvector2d.h"
 QDebug operator<<(QDebug dbg, const QVector2D &vector);



# 250 "/usr/share/qt4/include/QtGui/qvector2d.h"
 QDataStream &operator<<(QDataStream &, const QVector2D &);
 QDataStream &operator>>(QDataStream &, QVector2D &);




# 256 "/usr/share/qt4/include/QtGui/qvector2d.h"





# 146 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qvector3d.h"




























































































































































































































































































# 147 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qvector4d.h"

































































































































































































































































































# 148 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qaction.h"





































































































































































































































































# 149 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qactiongroup.h"
















































































































# 150 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qapplication.h"












































# 1 "/usr/share/qt4/include/QtCore/qcoreapplication.h"












































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qapplication.h"

# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 46 "/usr/share/qt4/include/QtGui/qapplication.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qapplication.h"

# 1 "/usr/share/qt4/include/QtCore/qsize.h"








































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qapplication.h"

# 1 "/usr/share/qt4/include/QtGui/qcursor.h"











































































































































































# 49 "/usr/share/qt4/include/QtGui/qapplication.h"













# 62 "/usr/share/qt4/include/QtGui/qapplication.h"






# 68 "/usr/share/qt4/include/QtGui/qapplication.h"


typedef QtValidLicenseForGuiModule QtGuiModule;

class QSessionManager;
class QDesktopWidget;
class QStyle;
class QEventLoop;
class QIcon;
class QInputContext;
template <typename T> class QList;
class QLocale;







# 87 "/usr/share/qt4/include/QtGui/qapplication.h"
class QApplication;
class QApplicationPrivate;






# 95 "/usr/share/qt4/include/QtGui/qapplication.h"
class  QApplication : public QCoreApplication
{
Q_OBJECT
Q_PROPERTY(Qt::LayoutDirection layoutDirection READ layoutDirection WRITE setLayoutDirection)
Q_PROPERTY(QIcon windowIcon READ windowIcon WRITE setWindowIcon)
Q_PROPERTY(int cursorFlashTime READ cursorFlashTime WRITE setCursorFlashTime)
Q_PROPERTY(int doubleClickInterval READ doubleClickInterval WRITE setDoubleClickInterval)
Q_PROPERTY(int keyboardInputInterval READ keyboardInputInterval WRITE setKeyboardInputInterval)

# 104 "/usr/share/qt4/include/QtGui/qapplication.h"
Q_PROPERTY(int wheelScrollLines READ wheelScrollLines WRITE setWheelScrollLines)

# 106 "/usr/share/qt4/include/QtGui/qapplication.h"
Q_PROPERTY(QSize globalStrut READ globalStrut WRITE setGlobalStrut)
Q_PROPERTY(int startDragTime READ startDragTime WRITE setStartDragTime)
Q_PROPERTY(int startDragDistance READ startDragDistance WRITE setStartDragDistance)
Q_PROPERTY(bool quitOnLastWindowClosed READ quitOnLastWindowClosed WRITE setQuitOnLastWindowClosed)

# 111 "/usr/share/qt4/include/QtGui/qapplication.h"
Q_PROPERTY(QString styleSheet READ styleSheet WRITE setStyleSheet)




# 116 "/usr/share/qt4/include/QtGui/qapplication.h"
Q_PROPERTY(bool autoSipEnabled READ autoSipEnabled WRITE setAutoSipEnabled)

public:
enum Type { Tty, GuiClient, GuiServer };






# 126 "/usr/share/qt4/include/QtGui/qapplication.h"
QApplication(int &argc, char **argv, int = 0x040602);
QApplication(int &argc, char **argv, bool GUIenabled, int = 0x040602);
QApplication(int &argc, char **argv, Type, int = 0x040602);








# 137 "/usr/share/qt4/include/QtGui/qapplication.h"
virtual ~QApplication();

static Type type();

static QStyle *style();
static void setStyle(QStyle*);
static QStyle *setStyle(const QString&);
enum ColorSpec { NormalColor=0, CustomColor=1, ManyColor=2 };
static int colorSpec();
static void setColorSpec(int);
static void setGraphicsSystem(const QString &);


# 150 "/usr/share/qt4/include/QtGui/qapplication.h"
static QCursor *overrideCursor();
static void setOverrideCursor(const QCursor &);
static void changeOverrideCursor(const QCursor &);
static void restoreOverrideCursor();

# 155 "/usr/share/qt4/include/QtGui/qapplication.h"
static QPalette palette();
static QPalette palette(const QWidget *);
static QPalette palette(const char *className);
static void setPalette(const QPalette &, const char* className = 0);
static QFont font();
static QFont font(const QWidget*);
static QFont font(const char *className);
static void setFont(const QFont &, const char* className = 0);
static QFontMetrics fontMetrics();

static void setWindowIcon(const QIcon &icon);
static QIcon windowIcon();







# 174 "/usr/share/qt4/include/QtGui/qapplication.h"
static QWidgetList allWidgets();
static QWidgetList topLevelWidgets();

static QDesktopWidget *desktop();

static QWidget *activePopupWidget();
static QWidget *activeModalWidget();

# 182 "/usr/share/qt4/include/QtGui/qapplication.h"
static QClipboard *clipboard();

# 184 "/usr/share/qt4/include/QtGui/qapplication.h"
static QWidget *focusWidget();

static QWidget *activeWindow();
static void setActiveWindow(QWidget* act);

static QWidget *widgetAt(const QPoint &p);
static inline QWidget *widgetAt(int x, int y) { return widgetAt(QPoint(x, y)); }
static QWidget *topLevelAt(const QPoint &p);
static inline QWidget *topLevelAt(int x, int y) { return topLevelAt(QPoint(x, y)); }

static void syncX();
static void beep();
static void alert(QWidget *widget, int duration = 0);

static Qt::KeyboardModifiers keyboardModifiers();
static Qt::MouseButtons mouseButtons();

static void setDesktopSettingsAware(bool);
static bool desktopSettingsAware();

static void setCursorFlashTime(int);
static int cursorFlashTime();

static void setDoubleClickInterval(int);
static int doubleClickInterval();

static void setKeyboardInputInterval(int);
static int keyboardInputInterval();


# 214 "/usr/share/qt4/include/QtGui/qapplication.h"
static void setWheelScrollLines(int);
static int wheelScrollLines();

# 217 "/usr/share/qt4/include/QtGui/qapplication.h"
static void setGlobalStrut(const QSize &);
static QSize globalStrut();

static void setStartDragTime(int ms);
static int startDragTime();
static void setStartDragDistance(int l);
static int startDragDistance();

static void setLayoutDirection(Qt::LayoutDirection direction);
static Qt::LayoutDirection layoutDirection();

static inline bool isRightToLeft() { return layoutDirection() == Qt::RightToLeft; }
static inline bool isLeftToRight() { return layoutDirection() == Qt::LeftToRight; }

static bool isEffectEnabled(Qt::UIEffect);
static void setEffectEnabled(Qt::UIEffect, bool enable = true);






























# 263 "/usr/share/qt4/include/QtGui/qapplication.h"

bool isSessionRestored() const;
QString sessionId() const;
QString sessionKey() const;
virtual void commitData(QSessionManager& sm);
virtual void saveState(QSessionManager& sm);

# 270 "/usr/share/qt4/include/QtGui/qapplication.h"
void setInputContext(QInputContext *);
QInputContext *inputContext() const;

static QLocale keyboardInputLocale();
static Qt::LayoutDirection keyboardInputDirection();

static int exec();
bool notify(QObject *, QEvent *);


static void setQuitOnLastWindowClosed(bool quit);
static bool quitOnLastWindowClosed();








# 290 "/usr/share/qt4/include/QtGui/qapplication.h"
signals:
void lastWindowClosed();
void focusChanged(QWidget *old, QWidget *now);
void fontDatabaseChanged();

# 295 "/usr/share/qt4/include/QtGui/qapplication.h"
void commitDataRequest(QSessionManager &sessionManager);
void saveStateRequest(QSessionManager &sessionManager);


# 299 "/usr/share/qt4/include/QtGui/qapplication.h"
public:
QString styleSheet() const;
public slots:

# 303 "/usr/share/qt4/include/QtGui/qapplication.h"
void setStyleSheet(const QString& sheet);





# 309 "/usr/share/qt4/include/QtGui/qapplication.h"
void setAutoSipEnabled(const bool enabled);
bool autoSipEnabled() const;
static void closeAllWindows();
static void aboutQt();

protected:



# 318 "/usr/share/qt4/include/QtGui/qapplication.h"
bool event(QEvent *);
bool compressEvent(QEvent *, QObject *receiver, QPostEventList *);






















































# 374 "/usr/share/qt4/include/QtGui/qapplication.h"
private:
QApplication(const QApplication &); QApplication &operator=(const QApplication &);
inline QApplicationPrivate* d_func() { return reinterpret_cast<QApplicationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QApplicationPrivate* d_func() const { return reinterpret_cast<const QApplicationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QApplicationPrivate;

friend class QGraphicsWidget;
friend class QGraphicsScene;
friend class QGraphicsScenePrivate;
friend class QWidget;
friend class QWidgetPrivate;
friend class QETWidget;
friend class Q3AccelManager;
friend class QTranslator;
friend class QWidgetAnimator;

# 388 "/usr/share/qt4/include/QtGui/qapplication.h"
friend class QShortcut;
friend class QLineEdit;
friend class QTextControl;

# 392 "/usr/share/qt4/include/QtGui/qapplication.h"
friend class QAction;
friend class QFontDatabasePrivate;







# 401 "/usr/share/qt4/include/QtGui/qapplication.h"
friend class QGestureManager;







# 409 "/usr/share/qt4/include/QtGui/qapplication.h"
};






# 151 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qboxlayout.h"












































# 1 "/usr/share/qt4/include/QtGui/qlayout.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qlayoutitem.h"












































# 1 "/usr/share/qt4/include/QtGui/qsizepolicy.h"






































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qlayoutitem.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qlayoutitem.h"




# 50 "/usr/share/qt4/include/QtGui/qlayoutitem.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

static const int QLAYOUTSIZE_MAX = INT_MAX/256/16;

class QLayout;
class QLayoutItem;
class QSpacerItem;
class QWidget;
class QSize;

class  QLayoutItem
{
public:
inline explicit QLayoutItem(Qt::Alignment alignment = 0);
virtual ~QLayoutItem();
virtual QSize sizeHint() const = 0;
virtual QSize minimumSize() const = 0;
virtual QSize maximumSize() const = 0;
virtual Qt::Orientations expandingDirections() const = 0;
virtual void setGeometry(const QRect&) = 0;
virtual QRect geometry() const = 0;
virtual bool isEmpty() const = 0;
virtual bool hasHeightForWidth() const;
virtual int heightForWidth(int) const;
virtual int minimumHeightForWidth(int) const;
virtual void invalidate();

virtual QWidget *widget();
virtual QLayout *layout();
virtual QSpacerItem *spacerItem();

Qt::Alignment alignment() const { return align; }
void setAlignment(Qt::Alignment a);
QSizePolicy::ControlTypes controlTypes() const;

protected:
Qt::Alignment align;
};

inline QLayoutItem::QLayoutItem(Qt::Alignment aalignment)
: align(aalignment) { }

class  QSpacerItem : public QLayoutItem
{
public:
QSpacerItem(int w, int h,
QSizePolicy::Policy hData = QSizePolicy::Minimum,
QSizePolicy::Policy vData = QSizePolicy::Minimum)
: width(w), height(h), sizeP(hData, vData) { }
void changeSize(int w, int h,
QSizePolicy::Policy hData = QSizePolicy::Minimum,
QSizePolicy::Policy vData = QSizePolicy::Minimum);
QSize sizeHint() const;
QSize minimumSize() const;
QSize maximumSize() const;
Qt::Orientations expandingDirections() const;
bool isEmpty() const;
void setGeometry(const QRect&);
QRect geometry() const;
QSpacerItem *spacerItem();

private:
int width;
int height;
QSizePolicy sizeP;
QRect rect;
};

class  QWidgetItem : public QLayoutItem
{
QWidgetItem(const QWidgetItem &); QWidgetItem &operator=(const QWidgetItem &);

public:
explicit QWidgetItem(QWidget *w) : wid(w) { }
QSize sizeHint() const;
QSize minimumSize() const;
QSize maximumSize() const;
Qt::Orientations expandingDirections() const;
bool isEmpty() const;
void setGeometry(const QRect&);
QRect geometry() const;
virtual QWidget *widget();

bool hasHeightForWidth() const;
int heightForWidth(int) const;

protected:
QWidget *wid;
};

class  QWidgetItemV2 : public QWidgetItem
{
public:
explicit QWidgetItemV2(QWidget *widget);
~QWidgetItemV2();

QSize sizeHint() const;
QSize minimumSize() const;
QSize maximumSize() const;
int heightForWidth(int width) const;

private:
enum { Dirty = -123, HfwCacheMaxSize = 3 };

inline bool useSizeCache() const;
void updateCacheIfNecessary() const;
inline void invalidateSizeCache() {
q_cachedMinimumSize.setWidth(Dirty);
q_hfwCacheSize = 0;
}

mutable QSize q_cachedMinimumSize;
mutable QSize q_cachedSizeHint;
mutable QSize q_cachedMaximumSize;
mutable QSize q_cachedHfws[HfwCacheMaxSize];
mutable short q_firstCachedHfw;
mutable short q_hfwCacheSize;
void *d;

friend class QWidgetPrivate;

QWidgetItemV2(const QWidgetItemV2 &); QWidgetItemV2 &operator=(const QWidgetItemV2 &);
};






# 46 "/usr/share/qt4/include/QtGui/qlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qsizepolicy.h"






































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qlayout.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qlayout.h"

# 1 "/usr/share/qt4/include/QtCore/qmargins.h"

















































































































































# 49 "/usr/share/qt4/include/QtGui/qlayout.h"




# 53 "/usr/share/qt4/include/QtGui/qlayout.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QLayout;
class QSize;



























# 88 "/usr/share/qt4/include/QtGui/qlayout.h"
class QLayoutPrivate;

class  QLayout : public QObject, public QLayoutItem
{
Q_OBJECT
inline QLayoutPrivate* d_func() { return reinterpret_cast<QLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QLayoutPrivate* d_func() const { return reinterpret_cast<const QLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QLayoutPrivate;

Q_ENUMS(SizeConstraint)
Q_PROPERTY(int margin READ margin WRITE setMargin)
Q_PROPERTY(int spacing READ spacing WRITE setSpacing)
Q_PROPERTY(SizeConstraint sizeConstraint READ sizeConstraint WRITE setSizeConstraint)
public:
enum SizeConstraint {
SetDefaultConstraint,
SetNoConstraint,
SetMinimumSize,
SetFixedSize,
SetMaximumSize,
SetMinAndMaxSize






# 113 "/usr/share/qt4/include/QtGui/qlayout.h"
};

QLayout(QWidget *parent);
QLayout();
~QLayout();

int margin() const;
int spacing() const;

void setMargin(int);
void setSpacing(int);

void setContentsMargins(int left, int top, int right, int bottom);
void setContentsMargins(const QMargins &margins);
void getContentsMargins(int *left, int *top, int *right, int *bottom) const;
QMargins contentsMargins() const;
QRect contentsRect() const;

bool setAlignment(QWidget *w, Qt::Alignment alignment);
bool setAlignment(QLayout *l, Qt::Alignment alignment);

# 134 "/usr/share/qt4/include/QtGui/qlayout.h"
inline void setAlignment(Qt::Alignment alignment) { QLayoutItem::setAlignment(alignment); }




# 139 "/usr/share/qt4/include/QtGui/qlayout.h"
void setSizeConstraint(SizeConstraint);
SizeConstraint sizeConstraint() const;




# 145 "/usr/share/qt4/include/QtGui/qlayout.h"
void setMenuBar(QWidget *w);
QWidget *menuBar() const;

QWidget *parentWidget() const;

void invalidate();
QRect geometry() const;
bool activate();
void update();

void addWidget(QWidget *w);
virtual void addItem(QLayoutItem *) = 0;

void removeWidget(QWidget *w);
void removeItem(QLayoutItem *);

Qt::Orientations expandingDirections() const;
QSize minimumSize() const;
QSize maximumSize() const;
virtual void setGeometry(const QRect&);
virtual QLayoutItem *itemAt(int index) const = 0;
virtual QLayoutItem *takeAt(int index) = 0;
virtual int indexOf(QWidget *) const;
virtual int count() const = 0;
bool isEmpty() const;

int totalHeightForWidth(int w) const;
QSize totalMinimumSize() const;
QSize totalMaximumSize() const;
QSize totalSizeHint() const;
QLayout *layout();

void setEnabled(bool);
bool isEnabled() const;






# 185 "/usr/share/qt4/include/QtGui/qlayout.h"
static QSize closestAcceptableSize(const QWidget *w, const QSize &s);

protected:
void widgetEvent(QEvent *);
void childEvent(QChildEvent *e);
void addChildLayout(QLayout *l);
void addChildWidget(QWidget *w);




# 196 "/usr/share/qt4/include/QtGui/qlayout.h"
QRect alignmentRect(const QRect&) const;
protected:
QLayout(QLayoutPrivate &d, QLayout*, QWidget*);

private:
QLayout(const QLayout &); QLayout &operator=(const QLayout &);

static void activateRecursiveHelper(QLayoutItem *item);

friend class QApplicationPrivate;
friend class QWidget;

















# 224 "/usr/share/qt4/include/QtGui/qlayout.h"
};








# 233 "/usr/share/qt4/include/QtGui/qlayout.h"


# 235 "/usr/share/qt4/include/QtGui/qlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qboxlayout.h"













































































































































































# 236 "/usr/share/qt4/include/QtGui/qlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qgridlayout.h"












































# 1 "/usr/share/qt4/include/QtGui/qlayout.h"





















































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgridlayout.h"







# 52 "/usr/share/qt4/include/QtGui/qgridlayout.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QGridLayoutPrivate;

class  QGridLayout : public QLayout
{
Q_OBJECT
inline QGridLayoutPrivate* d_func() { return reinterpret_cast<QGridLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGridLayoutPrivate* d_func() const { return reinterpret_cast<const QGridLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGridLayoutPrivate;



public:
explicit QGridLayout(QWidget *parent);
QGridLayout();








# 78 "/usr/share/qt4/include/QtGui/qgridlayout.h"
~QGridLayout();

QSize sizeHint() const;
QSize minimumSize() const;
QSize maximumSize() const;

void setHorizontalSpacing(int spacing);
int horizontalSpacing() const;
void setVerticalSpacing(int spacing);
int verticalSpacing() const;
void setSpacing(int spacing);
int spacing() const;

void setRowStretch(int row, int stretch);
void setColumnStretch(int column, int stretch);
int rowStretch(int row) const;
int columnStretch(int column) const;

void setRowMinimumHeight(int row, int minSize);
void setColumnMinimumWidth(int column, int minSize);
int rowMinimumHeight(int row) const;
int columnMinimumWidth(int column) const;

int columnCount() const;
int rowCount() const;

QRect cellRect(int row, int column) const;




# 109 "/usr/share/qt4/include/QtGui/qgridlayout.h"
bool hasHeightForWidth() const;
int heightForWidth(int) const;
int minimumHeightForWidth(int) const;

Qt::Orientations expandingDirections() const;
void invalidate();

inline void addWidget(QWidget *w) { QLayout::addWidget(w); }
void addWidget(QWidget *, int row, int column, Qt::Alignment = 0);
void addWidget(QWidget *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0);
void addLayout(QLayout *, int row, int column, Qt::Alignment = 0);
void addLayout(QLayout *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0);

void setOriginCorner(Qt::Corner);
Qt::Corner originCorner() const;





# 129 "/usr/share/qt4/include/QtGui/qgridlayout.h"
QLayoutItem *itemAt(int index) const;
QLayoutItem *itemAtPosition(int row, int column) const;
QLayoutItem *takeAt(int index);
int count() const;
void setGeometry(const QRect&);

void addItem(QLayoutItem *item, int row, int column, int rowSpan = 1, int columnSpan = 1, Qt::Alignment = 0);

void setDefaultPositioning(int n, Qt::Orientation orient);
void getItemPosition(int idx, int *row, int *column, int *rowSpan, int *columnSpan);

protected:



# 144 "/usr/share/qt4/include/QtGui/qgridlayout.h"
void addItem(QLayoutItem *);

private:
QGridLayout(const QGridLayout &); QGridLayout &operator=(const QGridLayout &);






















# 170 "/usr/share/qt4/include/QtGui/qgridlayout.h"
};






# 237 "/usr/share/qt4/include/QtGui/qlayout.h"

# 238 "/usr/share/qt4/include/QtGui/qlayout.h"



# 241 "/usr/share/qt4/include/QtGui/qlayout.h"





# 45 "/usr/share/qt4/include/QtGui/qboxlayout.h"







# 52 "/usr/share/qt4/include/QtGui/qboxlayout.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QBoxLayoutPrivate;

class  QBoxLayout : public QLayout
{
Q_OBJECT
inline QBoxLayoutPrivate* d_func() { return reinterpret_cast<QBoxLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QBoxLayoutPrivate* d_func() const { return reinterpret_cast<const QBoxLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QBoxLayoutPrivate;
public:
enum Direction { LeftToRight, RightToLeft, TopToBottom, BottomToTop,
Down = TopToBottom, Up = BottomToTop };

explicit QBoxLayout(Direction, QWidget *parent = 0);








# 77 "/usr/share/qt4/include/QtGui/qboxlayout.h"
~QBoxLayout();

Direction direction() const;
void setDirection(Direction);

void addSpacing(int size);
void addStretch(int stretch = 0);
void addSpacerItem(QSpacerItem *spacerItem);
void addWidget(QWidget *, int stretch = 0, Qt::Alignment alignment = 0);
void addLayout(QLayout *layout, int stretch = 0);
void addStrut(int);
void addItem(QLayoutItem *);

void insertSpacing(int index, int size);
void insertStretch(int index, int stretch = 0);
void insertSpacerItem(int index, QSpacerItem *spacerItem);
void insertWidget(int index, QWidget *widget, int stretch = 0, Qt::Alignment alignment = 0);
void insertLayout(int index, QLayout *layout, int stretch = 0);

int spacing() const;
void setSpacing(int spacing);

bool setStretchFactor(QWidget *w, int stretch);
bool setStretchFactor(QLayout *l, int stretch);
void setStretch(int index, int stretch);
int stretch(int index) const;

QSize sizeHint() const;
QSize minimumSize() const;
QSize maximumSize() const;

bool hasHeightForWidth() const;
int heightForWidth(int) const;
int minimumHeightForWidth(int) const;

Qt::Orientations expandingDirections() const;
void invalidate();
QLayoutItem *itemAt(int) const;
QLayoutItem *takeAt(int);
int count() const;
void setGeometry(const QRect&);



# 121 "/usr/share/qt4/include/QtGui/qboxlayout.h"
protected:

void insertItem(int index, QLayoutItem *);

private:
QBoxLayout(const QBoxLayout &); QBoxLayout &operator=(const QBoxLayout &);
};

class  QHBoxLayout : public QBoxLayout
{
Q_OBJECT
public:
QHBoxLayout();
explicit QHBoxLayout(QWidget *parent);
~QHBoxLayout();









# 145 "/usr/share/qt4/include/QtGui/qboxlayout.h"
private:
QHBoxLayout(const QHBoxLayout &); QHBoxLayout &operator=(const QHBoxLayout &);
};

class  QVBoxLayout : public QBoxLayout
{
Q_OBJECT
public:
QVBoxLayout();
explicit QVBoxLayout(QWidget *parent);
~QVBoxLayout();









# 165 "/usr/share/qt4/include/QtGui/qboxlayout.h"
private:
QVBoxLayout(const QVBoxLayout &); QVBoxLayout &operator=(const QVBoxLayout &);
};






# 152 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qclipboard.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qclipboard.h"


# 47 "/usr/share/qt4/include/QtGui/qclipboard.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qclipboard.h"
class QMimeSource;
class QMimeData;
class QImage;
class QPixmap;

class QClipboardPrivate;

class  QClipboard : public QObject
{
Q_OBJECT
inline QClipboardPrivate* d_func() { return reinterpret_cast<QClipboardPrivate *>(qGetPtrHelper(d_ptr)); } inline const QClipboardPrivate* d_func() const { return reinterpret_cast<const QClipboardPrivate *>(qGetPtrHelper(d_ptr)); } friend class QClipboardPrivate;
private:
QClipboard(QObject *parent);
~QClipboard();

public:
enum Mode { Clipboard, Selection, FindBuffer, LastMode = FindBuffer };

void clear(Mode mode = Clipboard);

bool supportsSelection() const;
bool supportsFindBuffer() const;

bool ownsSelection() const;
bool ownsClipboard() const;
bool ownsFindBuffer() const;

QString text(Mode mode = Clipboard) const;
QString text(QString& subtype, Mode mode = Clipboard) const;
void setText(const QString &, Mode mode = Clipboard);





# 90 "/usr/share/qt4/include/QtGui/qclipboard.h"
const QMimeData *mimeData(Mode mode = Clipboard ) const;
void setMimeData(QMimeData *data, Mode mode = Clipboard);

QImage image(Mode mode = Clipboard) const;
QPixmap pixmap(Mode mode = Clipboard) const;
void setImage(const QImage &, Mode mode = Clipboard);
void setPixmap(const QPixmap &, Mode mode = Clipboard);

signals:
void changed(QClipboard::Mode mode);
void selectionChanged();
void findBufferChanged();
void dataChanged();
private slots:
void ownerDestroyed();

protected:
void connectNotify(const char *);
bool event(QEvent *);

friend class QApplication;
friend class QApplicationPrivate;
friend class QBaseApplication;
friend class QDragManager;
friend class QMimeSource;

private:
QClipboard(const QClipboard &); QClipboard &operator=(const QClipboard &);

bool supportsMode(Mode mode) const;
bool ownsMode(Mode mode) const;
void emitChanged(Mode mode);
};



# 126 "/usr/share/qt4/include/QtGui/qclipboard.h"





# 153 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcursor.h"











































































































































































# 154 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qdesktopwidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qdesktopwidget.h"


# 47 "/usr/share/qt4/include/QtGui/qdesktopwidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QApplication;
class QDesktopWidgetPrivate;

class  QDesktopWidget : public QWidget
{
Q_OBJECT
Q_PROPERTY(bool virtualDesktop READ isVirtualDesktop)
Q_PROPERTY(int screenCount READ screenCount NOTIFY screenCountChanged)
Q_PROPERTY(int primaryScreen READ primaryScreen)
public:
QDesktopWidget();
~QDesktopWidget();

bool isVirtualDesktop() const;

int numScreens() const;
int screenCount() const;
int primaryScreen() const;

int screenNumber(const QWidget *widget = 0) const;
int screenNumber(const QPoint &) const;

QWidget *screen(int screen = -1);

const QRect screenGeometry(int screen = -1) const;
const QRect screenGeometry(const QWidget *widget) const;
const QRect screenGeometry(const QPoint &point) const
{ return screenGeometry(screenNumber(point)); }

const QRect availableGeometry(int screen = -1) const;
const QRect availableGeometry(const QWidget *widget) const;
const QRect availableGeometry(const QPoint &point) const
{ return availableGeometry(screenNumber(point)); }

signals:
void resized(int);
void workAreaResized(int);
void screenCountChanged(int);

protected:
void resizeEvent(QResizeEvent *e);

private:
QDesktopWidget(const QDesktopWidget &); QDesktopWidget &operator=(const QDesktopWidget &);
inline QDesktopWidgetPrivate* d_func() { return reinterpret_cast<QDesktopWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDesktopWidgetPrivate* d_func() const { return reinterpret_cast<const QDesktopWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDesktopWidgetPrivate;

friend class QApplication;
friend class QApplicationPrivate;
};

inline int QDesktopWidget::screenCount() const
{ return numScreens(); }






# 155 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qdrag.h"









































































































# 156 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qevent.h"



















































































































































































































































































































































































































































































































































































































































































































































































































































































































# 157 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qformlayout.h"












































# 1 "/usr/share/qt4/include/QtGui/qlayout.h"





















































































































































































































































# 1 "/usr/share/qt4/include/QtGui/QLayout"

# 45 "/usr/share/qt4/include/QtGui/qformlayout.h"


# 47 "/usr/share/qt4/include/QtGui/qformlayout.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QFormLayoutPrivate;

class  QFormLayout : public QLayout
{
Q_OBJECT
Q_ENUMS(FormStyle FieldGrowthPolicy RowWrapPolicy ItemRole)
inline QFormLayoutPrivate* d_func() { return reinterpret_cast<QFormLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QFormLayoutPrivate* d_func() const { return reinterpret_cast<const QFormLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QFormLayoutPrivate;
Q_PROPERTY(FieldGrowthPolicy fieldGrowthPolicy READ fieldGrowthPolicy WRITE setFieldGrowthPolicy RESET resetFieldGrowthPolicy)
Q_PROPERTY(RowWrapPolicy rowWrapPolicy READ rowWrapPolicy WRITE setRowWrapPolicy RESET resetRowWrapPolicy)
Q_PROPERTY(Qt::Alignment labelAlignment READ labelAlignment WRITE setLabelAlignment RESET resetLabelAlignment)
Q_PROPERTY(Qt::Alignment formAlignment READ formAlignment WRITE setFormAlignment RESET resetFormAlignment)
Q_PROPERTY(int horizontalSpacing READ horizontalSpacing WRITE setHorizontalSpacing)
Q_PROPERTY(int verticalSpacing READ verticalSpacing WRITE setVerticalSpacing)

public:
enum FieldGrowthPolicy {
FieldsStayAtSizeHint,
ExpandingFieldsGrow,
AllNonFixedFieldsGrow
};

enum RowWrapPolicy {
DontWrapRows,
WrapLongRows,
WrapAllRows
};

enum ItemRole {
LabelRole = 0,
FieldRole = 1,
SpanningRole = 2
};

explicit QFormLayout(QWidget *parent = 0);
~QFormLayout();

void setFieldGrowthPolicy(FieldGrowthPolicy policy);
FieldGrowthPolicy fieldGrowthPolicy() const;
void setRowWrapPolicy(RowWrapPolicy policy);
RowWrapPolicy rowWrapPolicy() const;
void setLabelAlignment(Qt::Alignment alignment);
Qt::Alignment labelAlignment() const;
void setFormAlignment(Qt::Alignment alignment);
Qt::Alignment formAlignment() const;

void setHorizontalSpacing(int spacing);
int horizontalSpacing() const;
void setVerticalSpacing(int spacing);
int verticalSpacing() const;

int spacing() const;
void setSpacing(int);

void addRow(QWidget *label, QWidget *field);
void addRow(QWidget *label, QLayout *field);
void addRow(const QString &labelText, QWidget *field);
void addRow(const QString &labelText, QLayout *field);
void addRow(QWidget *widget);
void addRow(QLayout *layout);

void insertRow(int row, QWidget *label, QWidget *field);
void insertRow(int row, QWidget *label, QLayout *field);
void insertRow(int row, const QString &labelText, QWidget *field);
void insertRow(int row, const QString &labelText, QLayout *field);
void insertRow(int row, QWidget *widget);
void insertRow(int row, QLayout *layout);

void setItem(int row, ItemRole role, QLayoutItem *item);
void setWidget(int row, ItemRole role, QWidget *widget);
void setLayout(int row, ItemRole role, QLayout *layout);

QLayoutItem *itemAt(int row, ItemRole role) const;
void getItemPosition(int index, int *rowPtr, ItemRole *rolePtr) const;
void getWidgetPosition(QWidget *widget, int *rowPtr, ItemRole *rolePtr) const;
void getLayoutPosition(QLayout *layout, int *rowPtr, ItemRole *rolePtr) const;
QWidget *labelForField(QWidget *field) const;
QWidget *labelForField(QLayout *field) const;


void addItem(QLayoutItem *item);
QLayoutItem *itemAt(int index) const;
QLayoutItem *takeAt(int index);

void setGeometry(const QRect &rect);
QSize minimumSize() const;
QSize sizeHint() const;
void invalidate();

bool hasHeightForWidth() const;
int heightForWidth(int width) const;
Qt::Orientations expandingDirections() const;
int count() const;

int rowCount() const;





# 152 "/usr/share/qt4/include/QtGui/qformlayout.h"
private:
void resetFieldGrowthPolicy();
void resetRowWrapPolicy();
void resetLabelAlignment();
void resetFormAlignment();
};






# 158 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgesture.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgesture.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qgesture.h"

# 1 "/usr/share/qt4/include/QtCore/qdatetime.h"














































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qgesture.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qgesture.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qgesture.h"

# 1 "/usr/share/qt4/include/QtCore/qmetatype.h"































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qgesture.h"


# 52 "/usr/share/qt4/include/QtGui/qgesture.h"


 template <> struct QMetaTypeId< Qt::GestureState > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< Qt::GestureState >("Qt::GestureState"); return metatype_id; } }; 



typedef QtValidLicenseForGuiModule QtGuiModule;

class QGesturePrivate;
class  QGesture : public QObject
{
Q_OBJECT
inline QGesturePrivate* d_func() { return reinterpret_cast<QGesturePrivate *>(qGetPtrHelper(d_ptr)); } inline const QGesturePrivate* d_func() const { return reinterpret_cast<const QGesturePrivate *>(qGetPtrHelper(d_ptr)); } friend class QGesturePrivate;

Q_PROPERTY(Qt::GestureState state READ state)
Q_PROPERTY(Qt::GestureType gestureType READ gestureType)
Q_PROPERTY(QGesture::GestureCancelPolicy gestureCancelPolicy READ gestureCancelPolicy WRITE setGestureCancelPolicy)
Q_PROPERTY(QPointF hotSpot READ hotSpot WRITE setHotSpot RESET unsetHotSpot)
Q_PROPERTY(bool hasHotSpot READ hasHotSpot)

public:
explicit QGesture(QObject *parent = 0);
~QGesture();

Qt::GestureType gestureType() const;

Qt::GestureState state() const;

QPointF hotSpot() const;
void setHotSpot(const QPointF &value);
bool hasHotSpot() const;
void unsetHotSpot();

enum GestureCancelPolicy {
CancelNone = 0,
CancelAllInContext
};

void setGestureCancelPolicy(GestureCancelPolicy policy);
GestureCancelPolicy gestureCancelPolicy() const;

protected:
QGesture(QGesturePrivate &dd, QObject *parent);

private:
friend class QGestureEvent;
friend class QGestureRecognizer;
friend class QGestureManager;
friend class QGraphicsScenePrivate;
};

class QPanGesturePrivate;
class  QPanGesture : public QGesture
{
Q_OBJECT
inline QPanGesturePrivate* d_func() { return reinterpret_cast<QPanGesturePrivate *>(qGetPtrHelper(d_ptr)); } inline const QPanGesturePrivate* d_func() const { return reinterpret_cast<const QPanGesturePrivate *>(qGetPtrHelper(d_ptr)); } friend class QPanGesturePrivate;

Q_PROPERTY(QPointF lastOffset READ lastOffset WRITE setLastOffset)
Q_PROPERTY(QPointF offset READ offset WRITE setOffset)
Q_PROPERTY(QPointF delta READ delta STORED false)
Q_PROPERTY(qreal acceleration READ acceleration WRITE setAcceleration)

public:
QPanGesture(QObject *parent = 0);

QPointF lastOffset() const;
QPointF offset() const;
QPointF delta() const;
qreal acceleration() const;

void setLastOffset(const QPointF &value);
void setOffset(const QPointF &value);
void setAcceleration(qreal value);

friend class QPanGestureRecognizer;
friend class QWinNativePanGestureRecognizer;
};

class QPinchGesturePrivate;
class  QPinchGesture : public QGesture
{
Q_OBJECT
inline QPinchGesturePrivate* d_func() { return reinterpret_cast<QPinchGesturePrivate *>(qGetPtrHelper(d_ptr)); } inline const QPinchGesturePrivate* d_func() const { return reinterpret_cast<const QPinchGesturePrivate *>(qGetPtrHelper(d_ptr)); } friend class QPinchGesturePrivate;

public:
enum ChangeFlag {
ScaleFactorChanged = 0x1,
RotationAngleChanged = 0x2,
CenterPointChanged = 0x4
};
typedef QFlags<ChangeFlag> ChangeFlags;

Q_PROPERTY(ChangeFlags totalChangeFlags READ totalChangeFlags WRITE setTotalChangeFlags)
Q_PROPERTY(ChangeFlags changeFlags READ changeFlags WRITE setChangeFlags)

Q_PROPERTY(qreal totalScaleFactor READ totalScaleFactor WRITE setTotalScaleFactor)
Q_PROPERTY(qreal lastScaleFactor READ lastScaleFactor WRITE setLastScaleFactor)
Q_PROPERTY(qreal scaleFactor READ scaleFactor WRITE setScaleFactor)

Q_PROPERTY(qreal totalRotationAngle READ totalRotationAngle WRITE setTotalRotationAngle)
Q_PROPERTY(qreal lastRotationAngle READ lastRotationAngle WRITE setLastRotationAngle)
Q_PROPERTY(qreal rotationAngle READ rotationAngle WRITE setRotationAngle)

Q_PROPERTY(QPointF startCenterPoint READ startCenterPoint WRITE setStartCenterPoint)
Q_PROPERTY(QPointF lastCenterPoint READ lastCenterPoint WRITE setLastCenterPoint)
Q_PROPERTY(QPointF centerPoint READ centerPoint WRITE setCenterPoint)

public:
QPinchGesture(QObject *parent = 0);

ChangeFlags totalChangeFlags() const;
void setTotalChangeFlags(ChangeFlags value);

ChangeFlags changeFlags() const;
void setChangeFlags(ChangeFlags value);

QPointF startCenterPoint() const;
QPointF lastCenterPoint() const;
QPointF centerPoint() const;
void setStartCenterPoint(const QPointF &value);
void setLastCenterPoint(const QPointF &value);
void setCenterPoint(const QPointF &value);

qreal totalScaleFactor() const;
qreal lastScaleFactor() const;
qreal scaleFactor() const;
void setTotalScaleFactor(qreal value);
void setLastScaleFactor(qreal value);
void setScaleFactor(qreal value);

qreal totalRotationAngle() const;
qreal lastRotationAngle() const;
qreal rotationAngle() const;
void setTotalRotationAngle(qreal value);
void setLastRotationAngle(qreal value);
void setRotationAngle(qreal value);

friend class QPinchGestureRecognizer;
};



 template <> struct QMetaTypeId< QPinchGesture::ChangeFlags > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QPinchGesture::ChangeFlags >("QPinchGesture::ChangeFlags"); return metatype_id; } }; 



class QSwipeGesturePrivate;
class  QSwipeGesture : public QGesture
{
Q_OBJECT
inline QSwipeGesturePrivate* d_func() { return reinterpret_cast<QSwipeGesturePrivate *>(qGetPtrHelper(d_ptr)); } inline const QSwipeGesturePrivate* d_func() const { return reinterpret_cast<const QSwipeGesturePrivate *>(qGetPtrHelper(d_ptr)); } friend class QSwipeGesturePrivate;
Q_ENUMS(SwipeDirection)

Q_PROPERTY(SwipeDirection horizontalDirection READ horizontalDirection STORED false)
Q_PROPERTY(SwipeDirection verticalDirection READ verticalDirection STORED false)
Q_PROPERTY(qreal swipeAngle READ swipeAngle WRITE setSwipeAngle)

public:
enum SwipeDirection { NoDirection, Left, Right, Up, Down };
QSwipeGesture(QObject *parent = 0);

SwipeDirection horizontalDirection() const;
SwipeDirection verticalDirection() const;

qreal swipeAngle() const;
void setSwipeAngle(qreal value);

friend class QSwipeGestureRecognizer;
};

class QTapGesturePrivate;
class  QTapGesture : public QGesture
{
Q_OBJECT
inline QTapGesturePrivate* d_func() { return reinterpret_cast<QTapGesturePrivate *>(qGetPtrHelper(d_ptr)); } inline const QTapGesturePrivate* d_func() const { return reinterpret_cast<const QTapGesturePrivate *>(qGetPtrHelper(d_ptr)); } friend class QTapGesturePrivate;

Q_PROPERTY(QPointF position READ position WRITE setPosition)

public:
QTapGesture(QObject *parent = 0);

QPointF position() const;
void setPosition(const QPointF &pos);

friend class QTapGestureRecognizer;
};

class QTapAndHoldGesturePrivate;
class  QTapAndHoldGesture : public QGesture
{
Q_OBJECT
inline QTapAndHoldGesturePrivate* d_func() { return reinterpret_cast<QTapAndHoldGesturePrivate *>(qGetPtrHelper(d_ptr)); } inline const QTapAndHoldGesturePrivate* d_func() const { return reinterpret_cast<const QTapAndHoldGesturePrivate *>(qGetPtrHelper(d_ptr)); } friend class QTapAndHoldGesturePrivate;

Q_PROPERTY(QPointF position READ position WRITE setPosition)

public:
QTapAndHoldGesture(QObject *parent = 0);

QPointF position() const;
void setPosition(const QPointF &pos);

friend class QTapAndHoldGestureRecognizer;
};



 template <> struct QMetaTypeId< QGesture::GestureCancelPolicy > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QGesture::GestureCancelPolicy >("QGesture::GestureCancelPolicy"); return metatype_id; } }; 



# 159 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgesturerecognizer.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgesturerecognizer.h"

# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qgesturerecognizer.h"


# 48 "/usr/share/qt4/include/QtGui/qgesturerecognizer.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QObject;
class QEvent;
class QGesture;
class  QGestureRecognizer
{
public:
enum ResultFlag
{
Ignore = 0x0001,

MayBeGesture = 0x0002,
TriggerGesture = 0x0004,
FinishGesture = 0x0008,
CancelGesture = 0x0010,

ResultState_Mask = 0x00ff,

ConsumeEventHint = 0x0100,




ResultHint_Mask = 0xff00
};
typedef QFlags<ResultFlag> Result;

QGestureRecognizer();
virtual ~QGestureRecognizer();

virtual QGesture *create(QObject *target);
virtual Result recognize(QGesture *state, QObject *watched,
QEvent *event) = 0;
virtual void reset(QGesture *state);

static Qt::GestureType registerRecognizer(QGestureRecognizer *recognizer);
static void unregisterRecognizer(Qt::GestureType type);
};

inline QFlags<QGestureRecognizer::Result::enum_type> operator|(QGestureRecognizer::Result::enum_type f1, QGestureRecognizer::Result::enum_type f2) { return QFlags<QGestureRecognizer::Result::enum_type>(f1) | f2; } inline QFlags<QGestureRecognizer::Result::enum_type> operator|(QGestureRecognizer::Result::enum_type f1, QFlags<QGestureRecognizer::Result::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QGestureRecognizer::Result::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }






# 160 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgridlayout.h"
















































































































































































# 161 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qkeysequence.h"







































































































































































































































# 162 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qlayout.h"





















































































































































































































































# 163 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qlayoutitem.h"






















































































































































































# 164 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmime.h"








































































































































































# 165 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpalette.h"




































































































































































































































































# 166 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qsessionmanager.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qsessionmanager.h"

# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 46 "/usr/share/qt4/include/QtGui/qsessionmanager.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qsessionmanager.h"

# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"



































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qsessionmanager.h"




# 52 "/usr/share/qt4/include/QtGui/qsessionmanager.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QSessionManagerPrivate;

class  QSessionManager : public QObject
{
Q_OBJECT
inline QSessionManagerPrivate* d_func() { return reinterpret_cast<QSessionManagerPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSessionManagerPrivate* d_func() const { return reinterpret_cast<const QSessionManagerPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSessionManagerPrivate;
QSessionManager(QApplication *app, QString &id, QString &key);
~QSessionManager();
public:
QString sessionId() const;
QString sessionKey() const;




# 73 "/usr/share/qt4/include/QtGui/qsessionmanager.h"
bool allowsInteraction();
bool allowsErrorInteraction();
void release();

void cancel();

enum RestartHint {
RestartIfRunning,
RestartAnyway,
RestartImmediately,
RestartNever
};
void setRestartHint(RestartHint);
RestartHint restartHint() const;

void setRestartCommand(const QStringList&);
QStringList restartCommand() const;
void setDiscardCommand(const QStringList&);
QStringList discardCommand() const;

void setManagerProperty(const QString& name, const QString& value);
void setManagerProperty(const QString& name, const QStringList& value);

bool isPhase2() const;
void requestPhase2();

private:
friend class QApplication;
friend class QApplicationPrivate;
friend class QBaseApplication;
};








# 167 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qshortcut.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qshortcut.h"

# 1 "/usr/share/qt4/include/QtGui/qkeysequence.h"







































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qshortcut.h"


# 48 "/usr/share/qt4/include/QtGui/qshortcut.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qshortcut.h"
class QShortcutPrivate;
class  QShortcut : public QObject
{
Q_OBJECT
inline QShortcutPrivate* d_func() { return reinterpret_cast<QShortcutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QShortcutPrivate* d_func() const { return reinterpret_cast<const QShortcutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QShortcutPrivate;
Q_PROPERTY(QKeySequence key READ key WRITE setKey)
Q_PROPERTY(QString whatsThis READ whatsThis WRITE setWhatsThis)
Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled)
Q_PROPERTY(bool autoRepeat READ autoRepeat WRITE setAutoRepeat)
Q_PROPERTY(Qt::ShortcutContext context READ context WRITE setContext)
public:
explicit QShortcut(QWidget *parent);
QShortcut(const QKeySequence& key, QWidget *parent,
const char *member = 0, const char *ambiguousMember = 0,
Qt::ShortcutContext context = Qt::WindowShortcut);
~QShortcut();

void setKey(const QKeySequence& key);
QKeySequence key() const;

void setEnabled(bool enable);
bool isEnabled() const;

void setContext(Qt::ShortcutContext context);
Qt::ShortcutContext context();

void setWhatsThis(const QString &text);
QString whatsThis() const;

void setAutoRepeat(bool on);
bool autoRepeat() const;

int id() const;

inline QWidget *parentWidget() const
{ return static_cast<QWidget *>(QObject::parent()); }

signals:
void activated();
void activatedAmbiguously();

protected:
bool event(QEvent *e);
};



# 103 "/usr/share/qt4/include/QtGui/qshortcut.h"





# 168 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qsizepolicy.h"






































































































































































































































# 169 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qsound.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qsound.h"


# 47 "/usr/share/qt4/include/QtGui/qsound.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qsound.h"
class QSoundPrivate;

class  QSound : public QObject
{
Q_OBJECT

public:
static bool isAvailable();
static void play(const QString& filename);

explicit QSound(const QString& filename, QObject* parent = 0);
~QSound();

int loops() const;
int loopsRemaining() const;
void setLoops(int);
QString fileName() const;

bool isFinished() const;

public slots:
void play();
void stop();

public:




# 84 "/usr/share/qt4/include/QtGui/qsound.h"
private:
inline QSoundPrivate* d_func() { return reinterpret_cast<QSoundPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSoundPrivate* d_func() const { return reinterpret_cast<const QSoundPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSoundPrivate;
friend class QAuServer;
};



# 91 "/usr/share/qt4/include/QtGui/qsound.h"





# 170 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qstackedlayout.h"












































# 1 "/usr/share/qt4/include/QtGui/qlayout.h"





















































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qstackedlayout.h"


# 47 "/usr/share/qt4/include/QtGui/qstackedlayout.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QStackedLayoutPrivate;

class  QStackedLayout : public QLayout
{
Q_OBJECT
inline QStackedLayoutPrivate* d_func() { return reinterpret_cast<QStackedLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QStackedLayoutPrivate* d_func() const { return reinterpret_cast<const QStackedLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QStackedLayoutPrivate;
Q_ENUMS(StackingMode)
Q_PROPERTY(int currentIndex READ currentIndex WRITE setCurrentIndex NOTIFY currentChanged)
Q_PROPERTY(StackingMode stackingMode READ stackingMode WRITE setStackingMode)


public:
enum StackingMode {
StackOne,
StackAll
};

QStackedLayout();
explicit QStackedLayout(QWidget *parent);
explicit QStackedLayout(QLayout *parentLayout);
~QStackedLayout();

int addWidget(QWidget *w);
int insertWidget(int index, QWidget *w);

QWidget *currentWidget() const;
int currentIndex() const;

# 81 "/usr/share/qt4/include/QtGui/qstackedlayout.h"
inline QWidget *widget() { return QLayout::widget(); }



# 85 "/usr/share/qt4/include/QtGui/qstackedlayout.h"
QWidget *widget(int) const;
int count() const;

StackingMode stackingMode() const;
void setStackingMode(StackingMode stackingMode);


void addItem(QLayoutItem *item);
QSize sizeHint() const;
QSize minimumSize() const;
QLayoutItem *itemAt(int) const;
QLayoutItem *takeAt(int);
void setGeometry(const QRect &rect);

signals:
void widgetRemoved(int index);
void currentChanged(int index);

public slots:
void setCurrentIndex(int index);
void setCurrentWidget(QWidget *w);

private:
QStackedLayout(const QStackedLayout &); QStackedLayout &operator=(const QStackedLayout &);
};






# 171 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qtooltip.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qtooltip.h"


# 47 "/usr/share/qt4/include/QtGui/qtooltip.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qtooltip.h"
class  QToolTip
{
QToolTip();
public:
static void showText(const QPoint &pos, const QString &text, QWidget *w = 0);
static void showText(const QPoint &pos, const QString &text, QWidget *w, const QRect &rect);
static inline void hideText() { showText(QPoint(), QString()); }

static bool isVisible();
static QString text();

static QPalette palette();
static void setPalette(const QPalette &);
static QFont font();
static void setFont(const QFont &);






# 76 "/usr/share/qt4/include/QtGui/qtooltip.h"
};



# 80 "/usr/share/qt4/include/QtGui/qtooltip.h"





# 172 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qwhatsthis.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qwhatsthis.h"

# 1 "/usr/share/qt4/include/QtGui/qcursor.h"











































































































































































# 46 "/usr/share/qt4/include/QtGui/qwhatsthis.h"


# 48 "/usr/share/qt4/include/QtGui/qwhatsthis.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qwhatsthis.h"
class QAction;




# 61 "/usr/share/qt4/include/QtGui/qwhatsthis.h"
class  QWhatsThis
{
QWhatsThis();

public:
static void enterWhatsThisMode();
static bool inWhatsThisMode();
static void leaveWhatsThisMode();

static void showText(const QPoint &pos, const QString &text, QWidget *w = 0);
static void hideText();

static QAction *createAction(QObject *parent = 0);






# 80 "/usr/share/qt4/include/QtGui/qwhatsthis.h"
};



# 84 "/usr/share/qt4/include/QtGui/qwhatsthis.h"





# 173 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 174 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qwidgetaction.h"












































# 1 "/usr/share/qt4/include/QtGui/qaction.h"





































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qwidgetaction.h"


# 47 "/usr/share/qt4/include/QtGui/qwidgetaction.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qwidgetaction.h"
class QWidgetActionPrivate;

class  QWidgetAction : public QAction
{
Q_OBJECT
inline QWidgetActionPrivate* d_func() { return reinterpret_cast<QWidgetActionPrivate *>(qGetPtrHelper(d_ptr)); } inline const QWidgetActionPrivate* d_func() const { return reinterpret_cast<const QWidgetActionPrivate *>(qGetPtrHelper(d_ptr)); } friend class QWidgetActionPrivate;

public:
explicit QWidgetAction(QObject *parent);
virtual ~QWidgetAction();

void setDefaultWidget(QWidget *w);
QWidget *defaultWidget() const;

QWidget *requestWidget(QWidget *parent);
void releaseWidget(QWidget *widget);

protected:
virtual bool event(QEvent *);
virtual bool eventFilter(QObject *, QEvent *);
virtual QWidget *createWidget(QWidget *parent);
virtual void deleteWidget(QWidget *widget);
QList<QWidget *> createdWidgets() const;

private:
QWidgetAction(const QWidgetAction &); QWidgetAction &operator=(const QWidgetAction &);

friend class QToolBar;
};



# 87 "/usr/share/qt4/include/QtGui/qwidgetaction.h"





# 175 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 176 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qaccessible.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qaccessible.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qaccessible.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qaccessible.h"

# 1 "/usr/share/qt4/include/QtCore/qset.h"














































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qaccessible.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qaccessible.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qaccessible.h"

# 1 "/usr/share/qt4/include/QtGui/qcolor.h"

















































































































































































































































































































# 51 "/usr/share/qt4/include/QtGui/qaccessible.h"

# 1 "/usr/share/qt4/include/QtGui/qevent.h"



















































































































































































































































































































































































































































































































































































































































































































































































































































































































# 52 "/usr/share/qt4/include/QtGui/qaccessible.h"


# 54 "/usr/share/qt4/include/QtGui/qaccessible.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 62 "/usr/share/qt4/include/QtGui/qaccessible.h"
class QAccessibleInterface;

class  QAccessible
{
public:
enum Event {
SoundPlayed = 0x0001,
Alert = 0x0002,
ForegroundChanged = 0x0003,
MenuStart = 0x0004,
MenuEnd = 0x0005,
PopupMenuStart = 0x0006,
PopupMenuEnd = 0x0007,
ContextHelpStart = 0x000C,
ContextHelpEnd = 0x000D,
DragDropStart = 0x000E,
DragDropEnd = 0x000F,
DialogStart = 0x0010,
DialogEnd = 0x0011,
ScrollingStart = 0x0012,
ScrollingEnd = 0x0013,

MenuCommand = 0x0018,

ObjectCreated = 0x8000,
ObjectDestroyed = 0x8001,
ObjectShow = 0x8002,
ObjectHide = 0x8003,
ObjectReorder = 0x8004,
Focus = 0x8005,
Selection = 0x8006,
SelectionAdd = 0x8007,
SelectionRemove = 0x8008,
SelectionWithin = 0x8009,
StateChanged = 0x800A,
LocationChanged = 0x800B,
NameChanged = 0x800C,
DescriptionChanged = 0x800D,
ValueChanged = 0x800E,
ParentChanged = 0x800F,
HelpChanged = 0x80A0,
DefaultActionChanged = 0x80B0,
AcceleratorChanged = 0x80C0
};

enum StateFlag {
Normal = 0x00000000,
Unavailable = 0x00000001,
Selected = 0x00000002,
Focused = 0x00000004,
Pressed = 0x00000008,
Checked = 0x00000010,
Mixed = 0x00000020,
ReadOnly = 0x00000040,
HotTracked = 0x00000080,
DefaultButton = 0x00000100,
Expanded = 0x00000200,
Collapsed = 0x00000400,
Busy = 0x00000800,

Marqueed = 0x00002000,
Animated = 0x00004000,
Invisible = 0x00008000,
Offscreen = 0x00010000,
Sizeable = 0x00020000,
Movable = 0x00040000,



# 131 "/usr/share/qt4/include/QtGui/qaccessible.h"
SelfVoicing = 0x00080000,
Focusable = 0x00100000,
Selectable = 0x00200000,
Linked = 0x00400000,
Traversed = 0x00800000,
MultiSelectable = 0x01000000,
ExtSelectable = 0x02000000,



Protected = 0x20000000,
HasPopup = 0x40000000,
Modal = 0x80000000,

HasInvokeExtension = 0x10000000 
};
typedef QFlags<StateFlag> State;

enum Role {
NoRole = 0x00000000,
TitleBar = 0x00000001,
MenuBar = 0x00000002,
ScrollBar = 0x00000003,
Grip = 0x00000004,
Sound = 0x00000005,
Cursor = 0x00000006,
Caret = 0x00000007,
AlertMessage = 0x00000008,
Window = 0x00000009,
Client = 0x0000000A,
PopupMenu = 0x0000000B,
MenuItem = 0x0000000C,
ToolTip = 0x0000000D,
Application = 0x0000000E,
Document = 0x0000000F,
Pane = 0x00000010,
Chart = 0x00000011,
Dialog = 0x00000012,
Border = 0x00000013,
Grouping = 0x00000014,
Separator = 0x00000015,
ToolBar = 0x00000016,
StatusBar = 0x00000017,
Table = 0x00000018,
ColumnHeader = 0x00000019,
RowHeader = 0x0000001A,
Column = 0x0000001B,
Row = 0x0000001C,
Cell = 0x0000001D,
Link = 0x0000001E,
HelpBalloon = 0x0000001F,
Assistant = 0x00000020,
List = 0x00000021,
ListItem = 0x00000022,
Tree = 0x00000023,
TreeItem = 0x00000024,
PageTab = 0x00000025,
PropertyPage = 0x00000026,
Indicator = 0x00000027,
Graphic = 0x00000028,
StaticText = 0x00000029,
EditableText = 0x0000002A, 
PushButton = 0x0000002B,
CheckBox = 0x0000002C,
RadioButton = 0x0000002D,
ComboBox = 0x0000002E,

ProgressBar = 0x00000030,
Dial = 0x00000031,
HotkeyField = 0x00000032,
Slider = 0x00000033,
SpinBox = 0x00000034,
Canvas = 0x00000035,
Animation = 0x00000036,
Equation = 0x00000037,
ButtonDropDown = 0x00000038,
ButtonMenu = 0x00000039,
ButtonDropGrid = 0x0000003A,
Whitespace = 0x0000003B,
PageTabList = 0x0000003C,
Clock = 0x0000003D,
Splitter = 0x0000003E,

LayeredPane = 0x0000003F,
UserRole = 0x0000ffff
};

enum Text {
Name = 0,
Description,
Value,
Help,
Accelerator,
UserText = 0x0000ffff
};

enum RelationFlag {
Unrelated = 0x00000000,
Self = 0x00000001,
Ancestor = 0x00000002,
Child = 0x00000004,
Descendent = 0x00000008,
Sibling = 0x00000010,
HierarchyMask = 0x000000ff,

Up = 0x00000100,
Down = 0x00000200,
Left = 0x00000400,
Right = 0x00000800,
Covers = 0x00001000,
Covered = 0x00002000,
GeometryMask = 0x0000ff00,

FocusChild = 0x00010000,
Label = 0x00020000,
Labelled = 0x00040000,
Controller = 0x00080000,
Controlled = 0x00100000,
LogicalMask = 0x00ff0000
};
typedef QFlags<RelationFlag> Relation;

enum Action {
DefaultAction = 0,
Press = -1,
FirstStandardAction = Press,
SetFocus = -2,
Increase = -3,
Decrease = -4,
Accept = -5,
Cancel = -6,
Select = -7,
ClearSelection = -8,
RemoveSelection = -9,
ExtendSelection = -10,
AddToSelection = -11,
LastStandardAction = AddToSelection
};

enum Method {
ListSupportedMethods = 0,
SetCursorPosition = 1,
GetCursorPosition = 2,
ForegroundColor = 3,
BackgroundColor = 4
};

typedef QAccessibleInterface*(*InterfaceFactory)(const QString &key, QObject*);
typedef void(*UpdateHandler)(QObject*, int who, Event reason);
typedef void(*RootObjectHandler)(QObject*);

static void installFactory(InterfaceFactory);
static void removeFactory(InterfaceFactory);
static UpdateHandler installUpdateHandler(UpdateHandler);
static RootObjectHandler installRootObjectHandler(RootObjectHandler);

static QAccessibleInterface *queryAccessibleInterface(QObject *);
static void updateAccessibility(QObject *, int who, Event reason);
static bool isActive();
static void setRootObject(QObject*);

static void initialize();
static void cleanup();

private:
static UpdateHandler updateHandler;
static RootObjectHandler rootObjectHandler;
};

inline QFlags<QAccessible::State::enum_type> operator|(QAccessible::State::enum_type f1, QAccessible::State::enum_type f2) { return QFlags<QAccessible::State::enum_type>(f1) | f2; } inline QFlags<QAccessible::State::enum_type> operator|(QAccessible::State::enum_type f1, QFlags<QAccessible::State::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QAccessible::State::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<QAccessible::Relation::enum_type> operator|(QAccessible::Relation::enum_type f1, QAccessible::Relation::enum_type f2) { return QFlags<QAccessible::Relation::enum_type>(f1) | f2; } inline QFlags<QAccessible::Relation::enum_type> operator|(QAccessible::Relation::enum_type f1, QFlags<QAccessible::Relation::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QAccessible::Relation::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

 template <> struct QMetaTypeId< QSet<QAccessible::Method> > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QSet<QAccessible::Method> >("QSet<QAccessible::Method>"); return metatype_id; } }; 


namespace QAccessible2
{
enum InterfaceType
{
TextInterface,
EditableTextInterface,
ValueInterface,
TableInterface,
ActionInterface,
ImageInterface
};
}

class QAccessible2Interface;
class QAccessibleTextInterface;
class QAccessibleEditableTextInterface;
class QAccessibleValueInterface;
class QAccessibleTableInterface;
class QAccessibleActionInterface;
class QAccessibleImageInterface;

class  QAccessibleInterface : public QAccessible
{
public:
virtual ~QAccessibleInterface() {}

virtual bool isValid() const = 0;
virtual QObject *object() const = 0;


virtual int childCount() const = 0;
virtual int indexOfChild(const QAccessibleInterface *) const = 0;


virtual Relation relationTo(int child, const QAccessibleInterface *other,
int otherChild) const = 0;
virtual int childAt(int x, int y) const = 0;


virtual int navigate(RelationFlag relation, int index, QAccessibleInterface **iface) const = 0;


virtual QString text(Text t, int child) const = 0;
virtual void setText(Text t, int child, const QString &text) = 0;
virtual QRect rect(int child) const = 0;
virtual Role role(int child) const = 0;
virtual State state(int child) const = 0;


virtual int userActionCount(int child) const = 0;
virtual QString actionText(int action, Text t, int child) const = 0;
virtual bool doAction(int action, int child, const QVariantList &params = QVariantList()) = 0;

QVariant invokeMethod(Method method, int child = 0,
const QVariantList &params = QVariantList());

inline QSet<Method> supportedMethods()
{ return qvariant_cast<QSet<Method> >(invokeMethod(ListSupportedMethods)); }

inline QColor foregroundColor()
{ return qvariant_cast<QColor>(invokeMethod(ForegroundColor)); }

inline QColor backgroundColor()
{ return qvariant_cast<QColor>(invokeMethod(BackgroundColor)); }

inline QAccessibleTextInterface *textInterface()
{ return reinterpret_cast<QAccessibleTextInterface *>(cast_helper(QAccessible2::TextInterface)); }

inline QAccessibleEditableTextInterface *editableTextInterface()
{ return reinterpret_cast<QAccessibleEditableTextInterface *>(cast_helper(QAccessible2::EditableTextInterface)); }

inline QAccessibleValueInterface *valueInterface()
{ return reinterpret_cast<QAccessibleValueInterface *>(cast_helper(QAccessible2::ValueInterface)); }

inline QAccessibleTableInterface *tableInterface()
{ return reinterpret_cast<QAccessibleTableInterface *>(cast_helper(QAccessible2::TableInterface)); }

inline QAccessibleActionInterface *actionInterface()
{ return reinterpret_cast<QAccessibleActionInterface *>(cast_helper(QAccessible2::ActionInterface)); }

inline QAccessibleImageInterface *imageInterface()
{ return reinterpret_cast<QAccessibleImageInterface *>(cast_helper(QAccessible2::ImageInterface)); }

private:
QAccessible2Interface *cast_helper(QAccessible2::InterfaceType);
};

class  QAccessibleInterfaceEx: public QAccessibleInterface
{
public:
virtual QVariant invokeMethodEx(Method method, int child, const QVariantList &params) = 0;
virtual QVariant virtual_hook(const QVariant &data);
virtual QAccessible2Interface *interface_cast(QAccessible2::InterfaceType)
{ return 0; }
};


class  QAccessibleEvent : public QEvent
{
public:
inline QAccessibleEvent(Type type, int child);
inline int child() const { return c; }
inline QString value() const { return val; }
inline void setValue(const QString &aText) { val = aText; }

private:
int c;
QString val;
};

inline QAccessibleEvent::QAccessibleEvent(Type atype, int achild)
: QEvent(atype), c(achild) {}


# 420 "/usr/share/qt4/include/QtGui/qaccessible.h"
template <> inline const char *qobject_interface_iid<QAccessibleInterface *>() { return "com.trolltech.Qt.QAccessibleInterface"; } template <> inline QAccessibleInterface *qobject_cast<QAccessibleInterface *>(QObject *object) { return reinterpret_cast<QAccessibleInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QAccessibleInterface") : 0)); } template <> inline QAccessibleInterface *qobject_cast<QAccessibleInterface *>(const QObject *object) { return reinterpret_cast<QAccessibleInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QAccessibleInterface") : 0)); }



# 424 "/usr/share/qt4/include/QtGui/qaccessible.h"





# 177 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qaccessible2.h"












































# 1 "/usr/share/qt4/include/QtGui/qaccessible.h"












































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qaccessible2.h"


# 47 "/usr/share/qt4/include/QtGui/qaccessible2.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qaccessible2.h"
namespace QAccessible2
{
enum CoordinateType
{
RelativeToScreen = 0,
RelativeToParent = 1
};

enum BoundaryType {
CharBoundary,
WordBoundary,
SentenceBoundary,
ParagraphBoundary,
LineBoundary,
NoBoundary
};
}

class  QAccessible2Interface
{
public:
virtual ~QAccessible2Interface() {}
};


inline QAccessible2Interface *qAccessibleValueCastHelper() { return 0; }
inline QAccessible2Interface *qAccessibleTextCastHelper() { return 0; }
inline QAccessible2Interface *qAccessibleEditableTextCastHelper() { return 0; }
inline QAccessible2Interface *qAccessibleTableCastHelper() { return 0; }
inline QAccessible2Interface *qAccessibleActionCastHelper() { return 0; }
inline QAccessible2Interface *qAccessibleImageCastHelper() { return 0; }



# 109 "/usr/share/qt4/include/QtGui/qaccessible2.h"
class  QAccessibleTextInterface: public QAccessible2Interface
{
public:
inline QAccessible2Interface *qAccessibleTextCastHelper() { return this; }

virtual ~QAccessibleTextInterface() {}

virtual void addSelection(int startOffset, int endOffset) = 0;
virtual QString attributes(int offset, int *startOffset, int *endOffset) = 0;
virtual int cursorPosition() = 0;
virtual QRect characterRect(int offset, QAccessible2::CoordinateType coordType) = 0;
virtual int selectionCount() = 0;
virtual int offsetAtPoint(const QPoint &point, QAccessible2::CoordinateType coordType) = 0;
virtual void selection(int selectionIndex, int *startOffset, int *endOffset) = 0;
virtual QString text(int startOffset, int endOffset) = 0;
virtual QString textBeforeOffset (int offset, QAccessible2::BoundaryType boundaryType,
int *startOffset, int *endOffset) = 0;
virtual QString textAfterOffset(int offset, QAccessible2::BoundaryType boundaryType,
int *startOffset, int *endOffset) = 0;
virtual QString textAtOffset(int offset, QAccessible2::BoundaryType boundaryType,
int *startOffset, int *endOffset) = 0;
virtual void removeSelection(int selectionIndex) = 0;
virtual void setCursorPosition(int position) = 0;
virtual void setSelection(int selectionIndex, int startOffset, int endOffset) = 0;
virtual int characterCount() = 0;
virtual void scrollToSubstring(int startIndex, int endIndex) = 0;
};

class  QAccessibleEditableTextInterface: public QAccessible2Interface
{
public:
inline QAccessible2Interface *qAccessibleEditableTextCastHelper() { return this; }

virtual ~QAccessibleEditableTextInterface() {}

virtual void copyText(int startOffset, int endOffset) = 0;
virtual void deleteText(int startOffset, int endOffset) = 0;
virtual void insertText(int offset, const QString &text) = 0;
virtual void cutText(int startOffset, int endOffset) = 0;
virtual void pasteText(int offset) = 0;
virtual void replaceText(int startOffset, int endOffset, const QString &text) = 0;
virtual void setAttributes(int startOffset, int endOffset, const QString &attributes) = 0;
};

class  QAccessibleSimpleEditableTextInterface: public QAccessibleEditableTextInterface
{
public:
QAccessibleSimpleEditableTextInterface(QAccessibleInterface *accessibleInterface);

void copyText(int startOffset, int endOffset);
void deleteText(int startOffset, int endOffset);
void insertText(int offset, const QString &text);
void cutText(int startOffset, int endOffset);
void pasteText(int offset);
void replaceText(int startOffset, int endOffset, const QString &text);
inline void setAttributes(int, int, const QString &) {}

private:
QAccessibleInterface *iface;
};

class  QAccessibleValueInterface: public QAccessible2Interface
{
public:
inline QAccessible2Interface *qAccessibleValueCastHelper() { return this; }

virtual ~QAccessibleValueInterface() {}

virtual QVariant currentValue() = 0;
virtual void setCurrentValue(const QVariant &value) = 0;
virtual QVariant maximumValue() = 0;
virtual QVariant minimumValue() = 0;
};

class  QAccessibleTableInterface: public QAccessible2Interface
{
public:
inline QAccessible2Interface *qAccessibleTableCastHelper() { return this; }

virtual QAccessibleInterface *accessibleAt(int row, int column) = 0;
virtual QAccessibleInterface *caption() = 0;
virtual int childIndex(int rowIndex, int columnIndex) = 0;
virtual QString columnDescription(int column) = 0;
virtual int columnSpan(int row, int column) = 0;
virtual QAccessibleInterface *columnHeader() = 0;
virtual int columnIndex(int childIndex) = 0;
virtual int columnCount() = 0;
virtual int rowCount() = 0;
virtual int selectedColumnCount() = 0;
virtual int selectedRowCount() = 0;
virtual QString rowDescription(int row) = 0;
virtual int rowSpan(int row, int column) = 0;
virtual QAccessibleInterface *rowHeader() = 0;
virtual int rowIndex(int childIndex) = 0;
virtual int selectedRows(int maxRows, QList<int> *rows) = 0;
virtual int selectedColumns(int maxColumns, QList<int> *columns) = 0;
virtual QAccessibleInterface *summary() = 0;
virtual bool isColumnSelected(int column) = 0;
virtual bool isRowSelected(int row) = 0;
virtual bool isSelected(int row, int column) = 0;
virtual void selectRow(int row) = 0;
virtual void selectColumn(int column) = 0;
virtual void unselectRow(int row) = 0;
virtual void unselectColumn(int column) = 0;
virtual void cellAtIndex(int index, int *row, int *column, int *rowSpan,
int *columnSpan, bool *isSelected) = 0;
};

class  QAccessibleActionInterface : public QAccessible2Interface
{
public:
inline QAccessible2Interface *qAccessibleActionCastHelper() { return this; }

virtual int actionCount() = 0;
virtual void doAction(int actionIndex) = 0;
virtual QString description(int actionIndex) = 0;
virtual QString name(int actionIndex) = 0;
virtual QString localizedName(int actionIndex) = 0;
virtual QStringList keyBindings(int actionIndex) = 0;
};

class  QAccessibleImageInterface : public QAccessible2Interface
{
public:
inline QAccessible2Interface *qAccessibleImageCastHelper() { return this; }

virtual QString imageDescription() = 0;
virtual QSize imageSize() = 0;
virtual QRect imagePosition(QAccessible2::CoordinateType coordType) = 0;
};



# 242 "/usr/share/qt4/include/QtGui/qaccessible2.h"





# 178 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qaccessiblebridge.h"












































# 1 "/usr/share/qt4/include/QtCore/qplugin.h"














































































































# 45 "/usr/share/qt4/include/QtGui/qaccessiblebridge.h"

# 1 "/usr/share/qt4/include/QtCore/qfactoryinterface.h"



































































# 46 "/usr/share/qt4/include/QtGui/qaccessiblebridge.h"


# 48 "/usr/share/qt4/include/QtGui/qaccessiblebridge.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qaccessiblebridge.h"
class QAccessibleInterface;

class QAccessibleBridge
{
public:
virtual ~QAccessibleBridge() {}
virtual void setRootObject(QAccessibleInterface *) = 0;
virtual void notifyAccessibilityUpdate(int, QAccessibleInterface*, int) = 0;
};

struct  QAccessibleBridgeFactoryInterface : public QFactoryInterface
{
virtual QAccessibleBridge *create(const QString& name) = 0;
};


# 72 "/usr/share/qt4/include/QtGui/qaccessiblebridge.h"
template <> inline const char *qobject_interface_iid<QAccessibleBridgeFactoryInterface *>() { return "com.trolltech.Qt.QAccessibleBridgeFactoryInterface"; } template <> inline QAccessibleBridgeFactoryInterface *qobject_cast<QAccessibleBridgeFactoryInterface *>(QObject *object) { return reinterpret_cast<QAccessibleBridgeFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QAccessibleBridgeFactoryInterface") : 0)); } template <> inline QAccessibleBridgeFactoryInterface *qobject_cast<QAccessibleBridgeFactoryInterface *>(const QObject *object) { return reinterpret_cast<QAccessibleBridgeFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QAccessibleBridgeFactoryInterface") : 0)); }

class  QAccessibleBridgePlugin : public QObject, public QAccessibleBridgeFactoryInterface
{
Q_OBJECT

public:
explicit QAccessibleBridgePlugin(QObject *parent = 0);
~QAccessibleBridgePlugin();

virtual QStringList keys() const = 0;
virtual QAccessibleBridge *create(const QString &key) = 0;
};



# 88 "/usr/share/qt4/include/QtGui/qaccessiblebridge.h"





# 179 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qaccessibleobject.h"












































# 1 "/usr/share/qt4/include/QtGui/qaccessible.h"












































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qaccessibleobject.h"


# 47 "/usr/share/qt4/include/QtGui/qaccessibleobject.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qaccessibleobject.h"
class QAccessibleObjectPrivate;
class QObject;

class  QAccessibleObject : public QAccessibleInterface
{
public:
explicit QAccessibleObject(QObject *object);

bool isValid() const;
QObject *object() const;


QRect rect(int child) const;
void setText(Text t, int child, const QString &text);


int userActionCount(int child) const;
bool doAction(int action, int child, const QVariantList &params);
QString actionText(int action, Text t, int child) const;

protected:
virtual ~QAccessibleObject();

private:
friend class QAccessibleObjectEx;
QAccessibleObjectPrivate *d;
QAccessibleObject(const QAccessibleObject &); QAccessibleObject &operator=(const QAccessibleObject &);
};

class  QAccessibleObjectEx : public QAccessibleInterfaceEx
{
public:
explicit QAccessibleObjectEx(QObject *object);

bool isValid() const;
QObject *object() const;


QRect rect(int child) const;
void setText(Text t, int child, const QString &text);


int userActionCount(int child) const;
bool doAction(int action, int child, const QVariantList &params);
QString actionText(int action, Text t, int child) const;

protected:
virtual ~QAccessibleObjectEx();

private:
QAccessibleObjectPrivate *d;
QAccessibleObjectEx(const QAccessibleObjectEx &); QAccessibleObjectEx &operator=(const QAccessibleObjectEx &);
};

class  QAccessibleApplication : public QAccessibleObject
{
public:
QAccessibleApplication();


int childCount() const;
int indexOfChild(const QAccessibleInterface*) const;
Relation relationTo(int, const QAccessibleInterface *, int) const;


int childAt(int x, int y) const;
int navigate(RelationFlag, int, QAccessibleInterface **) const;


QString text(Text t, int child) const;
Role role(int child) const;
State state(int child) const;


int userActionCount(int child) const;
bool doAction(int action, int child, const QVariantList &params);
QString actionText(int action, Text t, int child) const;
};



# 136 "/usr/share/qt4/include/QtGui/qaccessibleobject.h"





# 180 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qaccessibleplugin.h"












































# 1 "/usr/share/qt4/include/QtGui/qaccessible.h"












































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qaccessibleplugin.h"

# 1 "/usr/share/qt4/include/QtCore/qfactoryinterface.h"



































































# 46 "/usr/share/qt4/include/QtGui/qaccessibleplugin.h"


# 48 "/usr/share/qt4/include/QtGui/qaccessibleplugin.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qaccessibleplugin.h"
class QStringList;
class QAccessibleInterface;

struct  QAccessibleFactoryInterface : public QAccessible, public QFactoryInterface
{
virtual QAccessibleInterface* create(const QString &key, QObject *object) = 0;
};


# 65 "/usr/share/qt4/include/QtGui/qaccessibleplugin.h"
template <> inline const char *qobject_interface_iid<QAccessibleFactoryInterface *>() { return "com.trolltech.Qt.QAccessibleFactoryInterface"; } template <> inline QAccessibleFactoryInterface *qobject_cast<QAccessibleFactoryInterface *>(QObject *object) { return reinterpret_cast<QAccessibleFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QAccessibleFactoryInterface") : 0)); } template <> inline QAccessibleFactoryInterface *qobject_cast<QAccessibleFactoryInterface *>(const QObject *object) { return reinterpret_cast<QAccessibleFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QAccessibleFactoryInterface") : 0)); }

class QAccessiblePluginPrivate;

class  QAccessiblePlugin : public QObject, public QAccessibleFactoryInterface
{
Q_OBJECT

public:
explicit QAccessiblePlugin(QObject *parent = 0);
~QAccessiblePlugin();

virtual QStringList keys() const = 0;
virtual QAccessibleInterface *create(const QString &key, QObject *object) = 0;
};



# 83 "/usr/share/qt4/include/QtGui/qaccessibleplugin.h"





# 181 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qaccessiblewidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qaccessibleobject.h"












































































































































# 45 "/usr/share/qt4/include/QtGui/qaccessiblewidget.h"


# 47 "/usr/share/qt4/include/QtGui/qaccessiblewidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qaccessiblewidget.h"
class QAccessibleWidgetPrivate;

class  QAccessibleWidget : public QAccessibleObject
{
public:
explicit QAccessibleWidget(QWidget *o, Role r = Client, const QString& name = QString());

int childCount() const;
int indexOfChild(const QAccessibleInterface *child) const;
Relation relationTo(int child, const QAccessibleInterface *other, int otherChild) const;

int childAt(int x, int y) const;
QRect rect(int child) const;
int navigate(RelationFlag rel, int entry, QAccessibleInterface **target) const;

QString text(Text t, int child) const;
Role role(int child) const;
State state(int child) const;


# 75 "/usr/share/qt4/include/QtGui/qaccessiblewidget.h"
int userActionCount(int child) const;
QString actionText(int action, Text t, int child) const;
bool doAction(int action, int child, const QVariantList &params);


# 80 "/usr/share/qt4/include/QtGui/qaccessiblewidget.h"
protected:
~QAccessibleWidget();
QWidget *widget() const;
QObject *parentObject() const;

void addControllingSignal(const QString &signal);
void setValue(const QString &value);
void setDescription(const QString &desc);
void setHelp(const QString &help);
void setAccelerator(const QString &accel);

private:
friend class QAccessibleWidgetEx;
QAccessibleWidgetPrivate *d;
QAccessibleWidget(const QAccessibleWidget &); QAccessibleWidget &operator=(const QAccessibleWidget &);
};

class  QAccessibleWidgetEx : public QAccessibleObjectEx
{
public:
explicit QAccessibleWidgetEx(QWidget *o, Role r = Client, const QString& name = QString());

int childCount() const;
int indexOfChild(const QAccessibleInterface *child) const;
Relation relationTo(int child, const QAccessibleInterface *other, int otherChild) const;

int childAt(int x, int y) const;
QRect rect(int child) const;
int navigate(RelationFlag rel, int entry, QAccessibleInterface **target) const;

QString text(Text t, int child) const;
Role role(int child) const;
State state(int child) const;

QString actionText(int action, Text t, int child) const;
bool doAction(int action, int child, const QVariantList &params);

QVariant invokeMethodEx(Method method, int child, const QVariantList &params);

protected:
~QAccessibleWidgetEx();
QWidget *widget() const;
QObject *parentObject() const;

void addControllingSignal(const QString &signal);
void setValue(const QString &value);
void setDescription(const QString &desc);
void setHelp(const QString &help);
void setAccelerator(const QString &accel);

private:
QAccessibleWidgetPrivate *d;
QAccessibleWidgetEx(const QAccessibleWidgetEx &); QAccessibleWidgetEx &operator=(const QAccessibleWidgetEx &);
};



# 137 "/usr/share/qt4/include/QtGui/qaccessiblewidget.h"





# 182 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qkeyeventtransition.h"












































# 1 "/usr/share/qt4/include/QtCore/qeventtransition.h"































































































# 45 "/usr/share/qt4/include/QtGui/qkeyeventtransition.h"


# 47 "/usr/share/qt4/include/QtGui/qkeyeventtransition.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qkeyeventtransition.h"
class QKeyEventTransitionPrivate;
class  QKeyEventTransition : public QEventTransition
{
Q_OBJECT
Q_PROPERTY(int key READ key WRITE setKey)
Q_PROPERTY(Qt::KeyboardModifiers modifierMask READ modifierMask WRITE setModifierMask)
public:
QKeyEventTransition(QState *sourceState = 0);
QKeyEventTransition(QObject *object, QEvent::Type type, int key,
QState *sourceState = 0);
~QKeyEventTransition();

int key() const;
void setKey(int key);

Qt::KeyboardModifiers modifierMask() const;
void setModifierMask(Qt::KeyboardModifiers modifiers);

protected:
void onTransition(QEvent *event);
bool eventTest(QEvent *event);

private:
QKeyEventTransition(const QKeyEventTransition &); QKeyEventTransition &operator=(const QKeyEventTransition &);
inline QKeyEventTransitionPrivate* d_func() { return reinterpret_cast<QKeyEventTransitionPrivate *>(qGetPtrHelper(d_ptr)); } inline const QKeyEventTransitionPrivate* d_func() const { return reinterpret_cast<const QKeyEventTransitionPrivate *>(qGetPtrHelper(d_ptr)); } friend class QKeyEventTransitionPrivate;
};



# 84 "/usr/share/qt4/include/QtGui/qkeyeventtransition.h"





# 183 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmouseeventtransition.h"












































# 1 "/usr/share/qt4/include/QtCore/qeventtransition.h"































































































# 45 "/usr/share/qt4/include/QtGui/qmouseeventtransition.h"


# 47 "/usr/share/qt4/include/QtGui/qmouseeventtransition.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qmouseeventtransition.h"
class QMouseEventTransitionPrivate;
class QPainterPath;
class  QMouseEventTransition : public QEventTransition
{
Q_OBJECT
Q_PROPERTY(Qt::MouseButton button READ button WRITE setButton)
Q_PROPERTY(Qt::KeyboardModifiers modifierMask READ modifierMask WRITE setModifierMask)
public:
QMouseEventTransition(QState *sourceState = 0);
QMouseEventTransition(QObject *object, QEvent::Type type,
Qt::MouseButton button, QState *sourceState = 0);
~QMouseEventTransition();

Qt::MouseButton button() const;
void setButton(Qt::MouseButton button);

Qt::KeyboardModifiers modifierMask() const;
void setModifierMask(Qt::KeyboardModifiers modifiers);

QPainterPath hitTestPath() const;
void setHitTestPath(const QPainterPath &path);

protected:
void onTransition(QEvent *event);
bool eventTest(QEvent *event);

private:
QMouseEventTransition(const QMouseEventTransition &); QMouseEventTransition &operator=(const QMouseEventTransition &);
inline QMouseEventTransitionPrivate* d_func() { return reinterpret_cast<QMouseEventTransitionPrivate *>(qGetPtrHelper(d_ptr)); } inline const QMouseEventTransitionPrivate* d_func() const { return reinterpret_cast<const QMouseEventTransitionPrivate *>(qGetPtrHelper(d_ptr)); } friend class QMouseEventTransitionPrivate;
};



# 88 "/usr/share/qt4/include/QtGui/qmouseeventtransition.h"





# 184 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qinputcontext.h"


























































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 59 "/usr/share/qt4/include/QtGui/qinputcontext.h"

# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 60 "/usr/share/qt4/include/QtGui/qinputcontext.h"

# 1 "/usr/share/qt4/include/QtGui/qevent.h"



















































































































































































































































































































































































































































































































































































































































































































































































































































































































# 61 "/usr/share/qt4/include/QtGui/qinputcontext.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 62 "/usr/share/qt4/include/QtGui/qinputcontext.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 63 "/usr/share/qt4/include/QtGui/qinputcontext.h"

# 1 "/usr/share/qt4/include/QtGui/qaction.h"





































































































































































































































































# 64 "/usr/share/qt4/include/QtGui/qinputcontext.h"




# 68 "/usr/share/qt4/include/QtGui/qinputcontext.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QWidget;
class QFont;
class QPopupMenu;
class QInputContextPrivate;




# 82 "/usr/share/qt4/include/QtGui/qinputcontext.h"
class  QInputContext : public QObject
{
Q_OBJECT
inline QInputContextPrivate* d_func() { return reinterpret_cast<QInputContextPrivate *>(qGetPtrHelper(d_ptr)); } inline const QInputContextPrivate* d_func() const { return reinterpret_cast<const QInputContextPrivate *>(qGetPtrHelper(d_ptr)); } friend class QInputContextPrivate;
public:
explicit QInputContext(QObject* parent = 0);
virtual ~QInputContext();

virtual QString identifierName() = 0;
virtual QString language() = 0;

virtual void reset() = 0;
virtual void update();

virtual void mouseHandler( int x, QMouseEvent *event);
virtual QFont font() const;
virtual bool isComposing() const = 0;

QWidget *focusWidget() const;
virtual void setFocusWidget( QWidget *w );

virtual void widgetDestroyed(QWidget *w);

virtual QList<QAction *> actions();







# 113 "/usr/share/qt4/include/QtGui/qinputcontext.h"
virtual bool filterEvent( const QEvent *event );

void sendEvent(const QInputMethodEvent &event);

enum StandardFormat {
PreeditFormat,
SelectionFormat
};
QTextFormat standardFormat(StandardFormat s) const;
private:
friend class QWidget;
friend class QWidgetPrivate;
friend class QInputContextFactory;
friend class QApplication;
private: 
QInputContext( const QInputContext & );
QInputContext &operator=( const QInputContext & );

};








# 185 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qinputcontextfactory.h"


























































# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"



































































































































































































































































# 59 "/usr/share/qt4/include/QtGui/qinputcontextfactory.h"


# 61 "/usr/share/qt4/include/QtGui/qinputcontextfactory.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 69 "/usr/share/qt4/include/QtGui/qinputcontextfactory.h"
class QInputContext;
class QWidget;

class  QInputContextFactory
{
public:
static QStringList keys();
static QInputContext *create( const QString &key, QObject *parent ); 
static QStringList languages( const QString &key );
static QString displayName( const QString &key );
static QString description( const QString &key );
};



# 84 "/usr/share/qt4/include/QtGui/qinputcontextfactory.h"





# 186 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qinputcontextplugin.h"


























































# 1 "/usr/share/qt4/include/QtCore/qplugin.h"














































































































# 59 "/usr/share/qt4/include/QtGui/qinputcontextplugin.h"

# 1 "/usr/share/qt4/include/QtCore/qfactoryinterface.h"



































































# 60 "/usr/share/qt4/include/QtGui/qinputcontextplugin.h"

# 1 "/usr/share/qt4/include/QtCore/qstringlist.h"



































































































































































































































































# 61 "/usr/share/qt4/include/QtGui/qinputcontextplugin.h"


# 63 "/usr/share/qt4/include/QtGui/qinputcontextplugin.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 71 "/usr/share/qt4/include/QtGui/qinputcontextplugin.h"
class QInputContext;
class QInputContextPluginPrivate;

struct  QInputContextFactoryInterface : public QFactoryInterface
{
virtual QInputContext *create( const QString &key ) = 0;
virtual QStringList languages( const QString &key ) = 0;
virtual QString displayName( const QString &key ) = 0;
virtual QString description( const QString &key ) = 0;
};


# 83 "/usr/share/qt4/include/QtGui/qinputcontextplugin.h"
template <> inline const char *qobject_interface_iid<QInputContextFactoryInterface *>() { return "com.trolltech.Qt.QInputContextFactoryInterface"; } template <> inline QInputContextFactoryInterface *qobject_cast<QInputContextFactoryInterface *>(QObject *object) { return reinterpret_cast<QInputContextFactoryInterface *>((object ? object->qt_metacast("com.trolltech.Qt.QInputContextFactoryInterface") : 0)); } template <> inline QInputContextFactoryInterface *qobject_cast<QInputContextFactoryInterface *>(const QObject *object) { return reinterpret_cast<QInputContextFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QInputContextFactoryInterface") : 0)); }

class  QInputContextPlugin : public QObject, public QInputContextFactoryInterface
{
Q_OBJECT

public:
explicit QInputContextPlugin(QObject *parent = 0);
~QInputContextPlugin();

virtual QStringList keys() const = 0;
virtual QInputContext *create( const QString &key ) = 0;
virtual QStringList languages( const QString &key ) = 0;
virtual QString displayName( const QString &key ) = 0;
virtual QString description( const QString &key ) = 0;
};



# 102 "/usr/share/qt4/include/QtGui/qinputcontextplugin.h"





# 187 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qvfbhdr.h"












































# 1 "/usr/share/qt4/include/QtGui/qcolor.h"

















































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qvfbhdr.h"

# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 46 "/usr/share/qt4/include/QtGui/qvfbhdr.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qvfbhdr.h"


# 49 "/usr/share/qt4/include/QtGui/qvfbhdr.h"




typedef QtValidLicenseForGuiModule QtGuiModule;
























# 88 "/usr/share/qt4/include/QtGui/qvfbhdr.h"
struct QVFbHeader
{
int width;
int height;
int depth;
int linestep;
int dataoffset;
QRect update;
bool dirty;
int numcols;
QRgb clut[256];
int viewerVersion;
int serverVersion;
int brightness; 
WId windowId; 
};

struct QVFbKeyData
{
unsigned int keycode;
Qt::KeyboardModifiers modifiers;
unsigned short int unicode;
bool press;
bool repeat;
};






# 188 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qwsembedwidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qwsembedwidget.h"




# 49 "/usr/share/qt4/include/QtGui/qwsembedwidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QWSEmbedWidgetPrivate;

class  QWSEmbedWidget : public QWidget
{
Q_OBJECT

public:
QWSEmbedWidget(WId winId, QWidget *parent = 0);
~QWSEmbedWidget();

protected:
bool eventFilter(QObject *object, QEvent *event);
void changeEvent(QEvent *event);
void resizeEvent(QResizeEvent *event);
void moveEvent(QMoveEvent *event);
void hideEvent(QHideEvent *event);
void showEvent(QShowEvent *event);

private:
inline QWSEmbedWidgetPrivate* d_func() { return reinterpret_cast<QWSEmbedWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QWSEmbedWidgetPrivate* d_func() const { return reinterpret_cast<const QWSEmbedWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QWSEmbedWidgetPrivate;
};







# 189 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qs60mainapplication.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qs60mainapplication.h"



































# 190 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qs60mainappui.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qs60mainappui.h"










































# 191 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qs60maindocument.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qs60maindocument.h"




































# 192 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qabstractpagesetupdialog.h"












































# 1 "/usr/share/qt4/include/QtGui/qdialog.h"












































































































































# 45 "/usr/share/qt4/include/QtGui/qabstractpagesetupdialog.h"


# 47 "/usr/share/qt4/include/QtGui/qabstractpagesetupdialog.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qabstractpagesetupdialog.h"
class QAbstractPageSetupDialogPrivate;
class QPrinter;


class  QAbstractPageSetupDialog : public QDialog
{
inline QAbstractPageSetupDialogPrivate* d_func() { return reinterpret_cast<QAbstractPageSetupDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractPageSetupDialogPrivate* d_func() const { return reinterpret_cast<const QAbstractPageSetupDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractPageSetupDialogPrivate;
Q_OBJECT

public:
explicit QAbstractPageSetupDialog(QPrinter *printer, QWidget *parent = 0);
QAbstractPageSetupDialog(QAbstractPageSetupDialogPrivate &ptr,
QPrinter *printer, QWidget *parent = 0);
~QAbstractPageSetupDialog();

virtual int exec() = 0;
void done(int result);

QPrinter *printer();
};



# 78 "/usr/share/qt4/include/QtGui/qabstractpagesetupdialog.h"





# 193 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qabstractprintdialog.h"












































# 1 "/usr/share/qt4/include/QtGui/qdialog.h"












































































































































# 45 "/usr/share/qt4/include/QtGui/qabstractprintdialog.h"


# 47 "/usr/share/qt4/include/QtGui/qabstractprintdialog.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qabstractprintdialog.h"
class QAbstractPrintDialogPrivate;
class QPrinter;


class  QAbstractPrintDialog : public QDialog
{
inline QAbstractPrintDialogPrivate* d_func() { return reinterpret_cast<QAbstractPrintDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractPrintDialogPrivate* d_func() const { return reinterpret_cast<const QAbstractPrintDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractPrintDialogPrivate;
Q_OBJECT

public:
enum PrintRange {
AllPages,
Selection,
PageRange
};

enum PrintDialogOption {
None = 0x0000, 
PrintToFile = 0x0001,
PrintSelection = 0x0002,
PrintPageRange = 0x0004,
PrintShowPageSize = 0x0008,
PrintCollateCopies = 0x0010,
DontUseSheet = 0x0020
};

typedef QFlags<PrintDialogOption> PrintDialogOptions;


# 84 "/usr/share/qt4/include/QtGui/qabstractprintdialog.h"
explicit QAbstractPrintDialog(QPrinter *printer, QWidget *parent = 0);
~QAbstractPrintDialog();

virtual int exec() = 0;


void addEnabledOption(PrintDialogOption option);
void setEnabledOptions(PrintDialogOptions options);
PrintDialogOptions enabledOptions() const;
bool isOptionEnabled(PrintDialogOption option) const;

void setOptionTabs(const QList<QWidget*> &tabs);

void setPrintRange(PrintRange range);
PrintRange printRange() const;

void setMinMax(int min, int max);
int minPage() const;
int maxPage() const;

void setFromTo(int fromPage, int toPage);
int fromPage() const;
int toPage() const;

QPrinter *printer() const;

protected:
QAbstractPrintDialog(QAbstractPrintDialogPrivate &ptr, QPrinter *printer, QWidget *parent = 0);

private:
QAbstractPrintDialog(const QAbstractPrintDialog &); QAbstractPrintDialog &operator=(const QAbstractPrintDialog &);


# 117 "/usr/share/qt4/include/QtGui/qabstractprintdialog.h"
};

inline QFlags<QAbstractPrintDialog::PrintDialogOptions::enum_type> operator|(QAbstractPrintDialog::PrintDialogOptions::enum_type f1, QAbstractPrintDialog::PrintDialogOptions::enum_type f2) { return QFlags<QAbstractPrintDialog::PrintDialogOptions::enum_type>(f1) | f2; } inline QFlags<QAbstractPrintDialog::PrintDialogOptions::enum_type> operator|(QAbstractPrintDialog::PrintDialogOptions::enum_type f1, QFlags<QAbstractPrintDialog::PrintDialogOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QAbstractPrintDialog::PrintDialogOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 123 "/usr/share/qt4/include/QtGui/qabstractprintdialog.h"





# 194 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcolordialog.h"












































# 1 "/usr/share/qt4/include/QtGui/qdialog.h"












































































































































# 45 "/usr/share/qt4/include/QtGui/qcolordialog.h"


# 47 "/usr/share/qt4/include/QtGui/qcolordialog.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qcolordialog.h"
class QColorDialogPrivate;

class  QColorDialog : public QDialog
{
Q_OBJECT
inline QColorDialogPrivate* d_func() { return reinterpret_cast<QColorDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QColorDialogPrivate* d_func() const { return reinterpret_cast<const QColorDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QColorDialogPrivate;
Q_ENUMS(ColorDialogOption)
Q_PROPERTY(QColor currentColor READ currentColor WRITE setCurrentColor
NOTIFY currentColorChanged)
Q_PROPERTY(ColorDialogOptions options READ options WRITE setOptions)

public:
enum ColorDialogOption {
ShowAlphaChannel = 0x00000001,
NoButtons = 0x00000002,
DontUseNativeDialog = 0x00000004
};

typedef QFlags<ColorDialogOption> ColorDialogOptions;

explicit QColorDialog(QWidget *parent = 0);
explicit QColorDialog(const QColor &initial, QWidget *parent = 0);
~QColorDialog();

void setCurrentColor(const QColor &color);
QColor currentColor() const;

QColor selectedColor() const;

void setOption(ColorDialogOption option, bool on = true);
bool testOption(ColorDialogOption option) const;
void setOptions(ColorDialogOptions options);
ColorDialogOptions options() const;


# 90 "/usr/share/qt4/include/QtGui/qcolordialog.h"
void open() { QDialog::open(); }



# 94 "/usr/share/qt4/include/QtGui/qcolordialog.h"
void open(QObject *receiver, const char *member);

void setVisible(bool visible);


static QColor getColor(const QColor &initial, QWidget *parent, const QString &title,
ColorDialogOptions options = 0);
static QColor getColor(const QColor &initial = Qt::white, QWidget *parent = 0);


static QRgb getRgba(QRgb rgba = 0xffffffff, bool *ok = 0, QWidget *parent = 0);


static int customCount();
static QRgb customColor(int index);
static void setCustomColor(int index, QRgb color);
static void setStandardColor(int index, QRgb color);








# 119 "/usr/share/qt4/include/QtGui/qcolordialog.h"
signals:
void currentColorChanged(const QColor &color);
void colorSelected(const QColor &color);

protected:
void changeEvent(QEvent *event);
void done(int result);

private:
QColorDialog(const QColorDialog &); QColorDialog &operator=(const QColorDialog &);










# 139 "/usr/share/qt4/include/QtGui/qcolordialog.h"
friend class QColorShower;
};

inline QFlags<QColorDialog::ColorDialogOptions::enum_type> operator|(QColorDialog::ColorDialogOptions::enum_type f1, QColorDialog::ColorDialogOptions::enum_type f2) { return QFlags<QColorDialog::ColorDialogOptions::enum_type>(f1) | f2; } inline QFlags<QColorDialog::ColorDialogOptions::enum_type> operator|(QColorDialog::ColorDialogOptions::enum_type f1, QFlags<QColorDialog::ColorDialogOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QColorDialog::ColorDialogOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 146 "/usr/share/qt4/include/QtGui/qcolordialog.h"





# 195 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qdialog.h"












































































































































# 196 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qerrormessage.h"












































# 1 "/usr/share/qt4/include/QtGui/qdialog.h"












































































































































# 45 "/usr/share/qt4/include/QtGui/qerrormessage.h"


# 47 "/usr/share/qt4/include/QtGui/qerrormessage.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qerrormessage.h"
class QErrorMessagePrivate;

class  QErrorMessage: public QDialog
{
Q_OBJECT
inline QErrorMessagePrivate* d_func() { return reinterpret_cast<QErrorMessagePrivate *>(qGetPtrHelper(d_ptr)); } inline const QErrorMessagePrivate* d_func() const { return reinterpret_cast<const QErrorMessagePrivate *>(qGetPtrHelper(d_ptr)); } friend class QErrorMessagePrivate;
public:
explicit QErrorMessage(QWidget* parent = 0);
~QErrorMessage();

static QErrorMessage * qtHandler();

public slots:
void showMessage(const QString &message);
void showMessage(const QString &message, const QString &type);




# 74 "/usr/share/qt4/include/QtGui/qerrormessage.h"
protected:
void done(int);
void changeEvent(QEvent *e);

private:
QErrorMessage(const QErrorMessage &); QErrorMessage &operator=(const QErrorMessage &);
};



# 84 "/usr/share/qt4/include/QtGui/qerrormessage.h"





# 197 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qfiledialog.h"










































































































































































































































































































































# 198 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qfilesystemmodel.h"












































# 1 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"


























































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qfilesystemmodel.h"

# 1 "/usr/share/qt4/include/QtCore/qpair.h"































































































































# 46 "/usr/share/qt4/include/QtGui/qfilesystemmodel.h"

# 1 "/usr/share/qt4/include/QtCore/qdir.h"









































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qfilesystemmodel.h"

# 1 "/usr/share/qt4/include/QtGui/qicon.h"


























































































































































# 48 "/usr/share/qt4/include/QtGui/qfilesystemmodel.h"

# 1 "/usr/share/qt4/include/QtCore/qdiriterator.h"

































































































# 49 "/usr/share/qt4/include/QtGui/qfilesystemmodel.h"


# 51 "/usr/share/qt4/include/QtGui/qfilesystemmodel.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 59 "/usr/share/qt4/include/QtGui/qfilesystemmodel.h"
class ExtendedInformation;
class QFileSystemModelPrivate;
class QFileIconProvider;

class  QFileSystemModel : public QAbstractItemModel
{
Q_OBJECT
Q_PROPERTY(bool resolveSymlinks READ resolveSymlinks WRITE setResolveSymlinks)
Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly)
Q_PROPERTY(bool nameFilterDisables READ nameFilterDisables WRITE setNameFilterDisables)

signals:
void rootPathChanged(const QString &newPath);
void fileRenamed(const QString &path, const QString &oldName, const QString &newName);

public:
enum Roles {
FileIconRole = Qt::DecorationRole,
FilePathRole = Qt::UserRole + 1,
FileNameRole = Qt::UserRole + 2,
FilePermissions = Qt::UserRole + 3
};

explicit QFileSystemModel(QObject *parent = 0);
~QFileSystemModel();

QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
QModelIndex index(const QString &path, int column = 0) const;
QModelIndex parent(const QModelIndex &child) const;
bool hasChildren(const QModelIndex &parent = QModelIndex()) const;
bool canFetchMore(const QModelIndex &parent) const;
void fetchMore(const QModelIndex &parent);

int rowCount(const QModelIndex &parent = QModelIndex()) const;
int columnCount(const QModelIndex &parent = QModelIndex()) const;

QVariant myComputer(int role = Qt::DisplayRole) const;
QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const;

Qt::ItemFlags flags(const QModelIndex &index) const;

void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);

QStringList mimeTypes() const;
QMimeData *mimeData(const QModelIndexList &indexes) const;
bool dropMimeData(const QMimeData *data, Qt::DropAction action,
int row, int column, const QModelIndex &parent);
Qt::DropActions supportedDropActions() const;


QModelIndex setRootPath(const QString &path);
QString rootPath() const;
QDir rootDirectory() const;

void setIconProvider(QFileIconProvider *provider);
QFileIconProvider *iconProvider() const;

void setFilter(QDir::Filters filters);
QDir::Filters filter() const;

void setResolveSymlinks(bool enable);
bool resolveSymlinks() const;

void setReadOnly(bool enable);
bool isReadOnly() const;

void setNameFilterDisables(bool enable);
bool nameFilterDisables() const;

void setNameFilters(const QStringList &filters);
QStringList nameFilters() const;

QString filePath(const QModelIndex &index) const;
bool isDir(const QModelIndex &index) const;
qint64 size(const QModelIndex &index) const;
QString type(const QModelIndex &index) const;
QDateTime lastModified(const QModelIndex &index) const;

QModelIndex mkdir(const QModelIndex &parent, const QString &name);
inline bool rmdir(const QModelIndex &index) const;
inline QString fileName(const QModelIndex &index) const;
inline QIcon fileIcon(const QModelIndex &index) const;
QFile::Permissions permissions(const QModelIndex &index) const;
inline QFileInfo fileInfo(const QModelIndex &index) const;
bool remove(const QModelIndex &index) const;

protected:
QFileSystemModel(QFileSystemModelPrivate &, QObject *parent = 0);
void timerEvent(QTimerEvent *event);
bool event(QEvent *event);

private:
inline QFileSystemModelPrivate* d_func() { return reinterpret_cast<QFileSystemModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QFileSystemModelPrivate* d_func() const { return reinterpret_cast<const QFileSystemModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QFileSystemModelPrivate;
QFileSystemModel(const QFileSystemModel &); QFileSystemModel &operator=(const QFileSystemModel &);






friend class QFileDialogPrivate;
};

inline bool QFileSystemModel::rmdir(const QModelIndex &aindex) const
{ QDir dir; return dir.rmdir(filePath(aindex)); }
inline QString QFileSystemModel::fileName(const QModelIndex &aindex) const
{ return aindex.data(Qt::DisplayRole).toString(); }
inline QIcon QFileSystemModel::fileIcon(const QModelIndex &aindex) const
{ return qvariant_cast<QIcon>(aindex.data(Qt::DecorationRole)); }
inline QFileInfo QFileSystemModel::fileInfo(const QModelIndex &aindex) const
{ return QFileInfo(filePath(aindex)); }



# 176 "/usr/share/qt4/include/QtGui/qfilesystemmodel.h"






# 199 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qfontdialog.h"












































# 1 "/usr/share/qt4/include/QtGui/qwindowdefs.h"





























































































































































# 45 "/usr/share/qt4/include/QtGui/qfontdialog.h"

# 1 "/usr/share/qt4/include/QtGui/qdialog.h"












































































































































# 46 "/usr/share/qt4/include/QtGui/qfontdialog.h"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qfontdialog.h"


# 49 "/usr/share/qt4/include/QtGui/qfontdialog.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 57 "/usr/share/qt4/include/QtGui/qfontdialog.h"
class QFontDialogPrivate;

class  QFontDialog : public QDialog
{
Q_OBJECT
inline QFontDialogPrivate* d_func() { return reinterpret_cast<QFontDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QFontDialogPrivate* d_func() const { return reinterpret_cast<const QFontDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QFontDialogPrivate;
Q_ENUMS(FontDialogOption)
Q_PROPERTY(QFont currentFont READ currentFont WRITE setCurrentFont NOTIFY currentFontChanged)
Q_PROPERTY(FontDialogOptions options READ options WRITE setOptions)

public:
enum FontDialogOption {
NoButtons = 0x00000001,
DontUseNativeDialog = 0x00000002
};

typedef QFlags<FontDialogOption> FontDialogOptions;

explicit QFontDialog(QWidget *parent = 0);
explicit QFontDialog(const QFont &initial, QWidget *parent = 0);
~QFontDialog();

void setCurrentFont(const QFont &font);
QFont currentFont() const;

QFont selectedFont() const;

void setOption(FontDialogOption option, bool on = true);
bool testOption(FontDialogOption option) const;
void setOptions(FontDialogOptions options);
FontDialogOptions options() const;



# 91 "/usr/share/qt4/include/QtGui/qfontdialog.h"
void open() { QDialog::open(); }




# 96 "/usr/share/qt4/include/QtGui/qfontdialog.h"
void open(QObject *receiver, const char *member);

void setVisible(bool visible);


static QFont getFont(bool *ok, const QFont &initial, QWidget *parent, const QString &title,
FontDialogOptions options);
static QFont getFont(bool *ok, const QFont &initial, QWidget *parent, const QString &title);
static QFont getFont(bool *ok, const QFont &initial, QWidget *parent = 0);
static QFont getFont(bool *ok, QWidget *parent = 0);








# 114 "/usr/share/qt4/include/QtGui/qfontdialog.h"
signals:
void currentFontChanged(const QFont &font);
void fontSelected(const QFont &font);

protected:
void changeEvent(QEvent *event);
void done(int result);

private:

bool eventFilter(QObject *object, QEvent *event);

QFontDialog(const QFontDialog &); QFontDialog &operator=(const QFontDialog &);







};

inline QFlags<QFontDialog::FontDialogOptions::enum_type> operator|(QFontDialog::FontDialogOptions::enum_type f1, QFontDialog::FontDialogOptions::enum_type f2) { return QFlags<QFontDialog::FontDialogOptions::enum_type>(f1) | f2; } inline QFlags<QFontDialog::FontDialogOptions::enum_type> operator|(QFontDialog::FontDialogOptions::enum_type f1, QFlags<QFontDialog::FontDialogOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QFontDialog::FontDialogOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 140 "/usr/share/qt4/include/QtGui/qfontdialog.h"





# 200 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qinputdialog.h"












































# 1 "/usr/share/qt4/include/QtGui/qdialog.h"












































































































































# 45 "/usr/share/qt4/include/QtGui/qinputdialog.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qinputdialog.h"

# 1 "/usr/share/qt4/include/QtGui/qlineedit.h"












































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qinputdialog.h"


# 49 "/usr/share/qt4/include/QtGui/qinputdialog.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 57 "/usr/share/qt4/include/QtGui/qinputdialog.h"
class QInputDialogPrivate;

class  QInputDialog : public QDialog
{
Q_OBJECT
inline QInputDialogPrivate* d_func() { return reinterpret_cast<QInputDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QInputDialogPrivate* d_func() const { return reinterpret_cast<const QInputDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QInputDialogPrivate;



















public:
enum InputDialogOption {
NoButtons = 0x00000001,
UseListViewForComboBoxItems = 0x00000002
};

typedef QFlags<InputDialogOption> InputDialogOptions;

enum InputMode {
TextInput,
IntInput,
DoubleInput
};

QInputDialog(QWidget *parent = 0, Qt::WindowFlags flags = 0);
~QInputDialog();

void setInputMode(InputMode mode);
InputMode inputMode() const;

void setLabelText(const QString &text);
QString labelText() const;

void setOption(InputDialogOption option, bool on = true);
bool testOption(InputDialogOption option) const;
void setOptions(InputDialogOptions options);
InputDialogOptions options() const;

void setTextValue(const QString &text);
QString textValue() const;

void setTextEchoMode(QLineEdit::EchoMode mode);
QLineEdit::EchoMode textEchoMode() const;

void setComboBoxEditable(bool editable);
bool isComboBoxEditable() const;

void setComboBoxItems(const QStringList &items);
QStringList comboBoxItems() const;

void setIntValue(int value);
int intValue() const;

void setIntMinimum(int min);
int intMinimum() const;

void setIntMaximum(int max);
int intMaximum() const;

void setIntRange(int min, int max);

void setIntStep(int step);
int intStep() const;

void setDoubleValue(double value);
double doubleValue() const;

void setDoubleMinimum(double min);
double doubleMinimum() const;

void setDoubleMaximum(double max);
double doubleMaximum() const;

void setDoubleRange(double min, double max);

void setDoubleDecimals(int decimals);
int doubleDecimals() const;

void setOkButtonText(const QString &text);
QString okButtonText() const;

void setCancelButtonText(const QString &text);
QString cancelButtonText() const;



# 158 "/usr/share/qt4/include/QtGui/qinputdialog.h"
void open() { QDialog::open(); }




# 163 "/usr/share/qt4/include/QtGui/qinputdialog.h"
void open(QObject *receiver, const char *member);

QSize minimumSizeHint() const;
QSize sizeHint() const;

void setVisible(bool visible);

static QString getText(QWidget *parent, const QString &title, const QString &label,
QLineEdit::EchoMode echo = QLineEdit::Normal,
const QString &text = QString(), bool *ok = 0, Qt::WindowFlags flags = 0);
static int getInt(QWidget *parent, const QString &title, const QString &label, int value = 0,
int minValue = -2147483647, int maxValue = 2147483647,
int step = 1, bool *ok = 0, Qt::WindowFlags flags = 0);
static double getDouble(QWidget *parent, const QString &title, const QString &label, double value = 0,
double minValue = -2147483647, double maxValue = 2147483647,
int decimals = 1, bool *ok = 0, Qt::WindowFlags flags = 0);
static QString getItem(QWidget *parent, const QString &title, const QString &label,
const QStringList &items, int current = 0, bool editable = true,
bool *ok = 0, Qt::WindowFlags flags = 0);


static int getInteger(QWidget *parent, const QString &title, const QString &label, int value = 0,
int minValue = -2147483647, int maxValue = 2147483647,
int step = 1, bool *ok = 0, Qt::WindowFlags flags = 0);























# 210 "/usr/share/qt4/include/QtGui/qinputdialog.h"
signals:

void textValueChanged(const QString &text);
void textValueSelected(const QString &text);
void intValueChanged(int value);
void intValueSelected(int value);
void doubleValueChanged(double value);
void doubleValueSelected(double value);


public:
void done(int result); 

private:
QInputDialog(const QInputDialog &); QInputDialog &operator=(const QInputDialog &);


};

inline QFlags<QInputDialog::InputDialogOptions::enum_type> operator|(QInputDialog::InputDialogOptions::enum_type f1, QInputDialog::InputDialogOptions::enum_type f2) { return QFlags<QInputDialog::InputDialogOptions::enum_type>(f1) | f2; } inline QFlags<QInputDialog::InputDialogOptions::enum_type> operator|(QInputDialog::InputDialogOptions::enum_type f1, QFlags<QInputDialog::InputDialogOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QInputDialog::InputDialogOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 233 "/usr/share/qt4/include/QtGui/qinputdialog.h"





# 201 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qmessagebox.h"












































# 1 "/usr/share/qt4/include/QtGui/qdialog.h"












































































































































# 45 "/usr/share/qt4/include/QtGui/qmessagebox.h"


# 47 "/usr/share/qt4/include/QtGui/qmessagebox.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qmessagebox.h"
class QLabel;
class QMessageBoxPrivate;
class QAbstractButton;

class  QMessageBox : public QDialog
{
Q_OBJECT
Q_ENUMS(Icon)

Q_PROPERTY(QString text READ text WRITE setText)

Q_PROPERTY(Icon icon READ icon WRITE setIcon)
Q_PROPERTY(QPixmap iconPixmap READ iconPixmap WRITE setIconPixmap)
Q_PROPERTY(Qt::TextFormat textFormat READ textFormat WRITE setTextFormat)
Q_PROPERTY(StandardButtons standardButtons READ standardButtons WRITE setStandardButtons)

# 71 "/usr/share/qt4/include/QtGui/qmessagebox.h"
Q_PROPERTY(QString detailedText READ detailedText WRITE setDetailedText)

# 73 "/usr/share/qt4/include/QtGui/qmessagebox.h"
Q_PROPERTY(QString informativeText READ informativeText WRITE setInformativeText)

public:
enum Icon {
NoIcon = 0,
Information = 1,
Warning = 2,
Critical = 3,
Question = 4
};

enum ButtonRole {

InvalidRole = -1,
AcceptRole,
RejectRole,
DestructiveRole,
ActionRole,
HelpRole,
YesRole,
NoRole,
ResetRole,
ApplyRole,

NRoles
};

enum StandardButton {

NoButton = 0x00000000,
Ok = 0x00000400,
Save = 0x00000800,
SaveAll = 0x00001000,
Open = 0x00002000,
Yes = 0x00004000,
YesToAll = 0x00008000,
No = 0x00010000,
NoToAll = 0x00020000,
Abort = 0x00040000,
Retry = 0x00080000,
Ignore = 0x00100000,
Close = 0x00200000,
Cancel = 0x00400000,
Discard = 0x00800000,
Help = 0x01000000,
Apply = 0x02000000,
Reset = 0x04000000,
RestoreDefaults = 0x08000000,

FirstButton = Ok, 
LastButton = RestoreDefaults, 

YesAll = YesToAll, 
NoAll = NoToAll, 

Default = 0x00000100, 
Escape = 0x00000200, 
FlagMask = 0x00000300, 
ButtonMask = ~FlagMask 
};
typedef StandardButton Button; 

typedef QFlags<StandardButton> StandardButtons;

explicit QMessageBox(QWidget *parent = 0);
QMessageBox(Icon icon, const QString &title, const QString &text,
StandardButtons buttons = NoButton, QWidget *parent = 0,
Qt::WindowFlags flags = Qt::Dialog | Qt::MSWindowsFixedSizeDialogHint);
~QMessageBox();

void addButton(QAbstractButton *button, ButtonRole role);
QPushButton *addButton(const QString &text, ButtonRole role);
QPushButton *addButton(StandardButton button);
void removeButton(QAbstractButton *button);







# 154 "/usr/share/qt4/include/QtGui/qmessagebox.h"
void open() { QDialog::open(); }




# 159 "/usr/share/qt4/include/QtGui/qmessagebox.h"
void open(QObject *receiver, const char *member);

QList<QAbstractButton *> buttons() const;
ButtonRole buttonRole(QAbstractButton *button) const;

void setStandardButtons(StandardButtons buttons);
StandardButtons standardButtons() const;
StandardButton standardButton(QAbstractButton *button) const;
QAbstractButton *button(StandardButton which) const;

QPushButton *defaultButton() const;
void setDefaultButton(QPushButton *button);
void setDefaultButton(StandardButton button);

QAbstractButton *escapeButton() const;
void setEscapeButton(QAbstractButton *button);
void setEscapeButton(StandardButton button);

QAbstractButton *clickedButton() const;

QString text() const;
void setText(const QString &text);

Icon icon() const;
void setIcon(Icon);

QPixmap iconPixmap() const;
void setIconPixmap(const QPixmap &pixmap);

Qt::TextFormat textFormat() const;
void setTextFormat(Qt::TextFormat format);

static StandardButton information(QWidget *parent, const QString &title,
const QString &text, StandardButtons buttons = Ok,
StandardButton defaultButton = NoButton);


static StandardButton question(QWidget *parent, const QString &title,
const QString &text, StandardButtons buttons = Ok,
StandardButton defaultButton = NoButton);
static StandardButton warning(QWidget *parent, const QString &title,
const QString &text, StandardButtons buttons = Ok,
StandardButton defaultButton = NoButton);
static StandardButton critical(QWidget *parent, const QString &title,
const QString &text, StandardButtons buttons = Ok,
StandardButton defaultButton = NoButton);
static void about(QWidget *parent, const QString &title, const QString &text);
static void aboutQt(QWidget *parent, const QString &title = QString());

QSize sizeHint() const;



QMessageBox(const QString &title, const QString &text, Icon icon,
int button0, int button1, int button2,
QWidget *parent = 0,
Qt::WindowFlags f = Qt::Dialog | Qt::MSWindowsFixedSizeDialogHint);

static int information(QWidget *parent, const QString &title,
const QString& text,
int button0, int button1 = 0, int button2 = 0);
static int information(QWidget *parent, const QString &title,
const QString& text,
const QString& button0Text,
const QString& button1Text = QString(),
const QString& button2Text = QString(),
int defaultButtonNumber = 0,
int escapeButtonNumber = -1);
inline static StandardButton information(QWidget *parent, const QString &title,
const QString& text,
StandardButton button0, StandardButton button1 = NoButton)
{ return information(parent, title, text, StandardButtons(button0), button1); }

static int question(QWidget *parent, const QString &title,
const QString& text,
int button0, int button1 = 0, int button2 = 0);
static int question(QWidget *parent, const QString &title,
const QString& text,
const QString& button0Text,
const QString& button1Text = QString(),
const QString& button2Text = QString(),
int defaultButtonNumber = 0,
int escapeButtonNumber = -1);
inline static int question(QWidget *parent, const QString &title,
const QString& text,
StandardButton button0, StandardButton button1)
{ return question(parent, title, text, StandardButtons(button0), button1); }

static int warning(QWidget *parent, const QString &title,
const QString& text,
int button0, int button1, int button2 = 0);
static int warning(QWidget *parent, const QString &title,
const QString& text,
const QString& button0Text,
const QString& button1Text = QString(),
const QString& button2Text = QString(),
int defaultButtonNumber = 0,
int escapeButtonNumber = -1);
inline static int warning(QWidget *parent, const QString &title,
const QString& text,
StandardButton button0, StandardButton button1)
{ return warning(parent, title, text, StandardButtons(button0), button1); }

static int critical(QWidget *parent, const QString &title,
const QString& text,
int button0, int button1, int button2 = 0);
static int critical(QWidget *parent, const QString &title,
const QString& text,
const QString& button0Text,
const QString& button1Text = QString(),
const QString& button2Text = QString(),
int defaultButtonNumber = 0,
int escapeButtonNumber = -1);
inline static int critical(QWidget *parent, const QString &title,
const QString& text,
StandardButton button0, StandardButton button1)
{ return critical(parent, title, text, StandardButtons(button0), button1); }

QString buttonText(int button) const;
void setButtonText(int button, const QString &text);

QString informativeText() const;
void setInformativeText(const QString &text);


# 284 "/usr/share/qt4/include/QtGui/qmessagebox.h"
QString detailedText() const;
void setDetailedText(const QString &text);


# 288 "/usr/share/qt4/include/QtGui/qmessagebox.h"
void setWindowTitle(const QString &title);
void setWindowModality(Qt::WindowModality windowModality);



























# 317 "/usr/share/qt4/include/QtGui/qmessagebox.h"
static QPixmap standardIcon(Icon icon);

signals:
void buttonClicked(QAbstractButton *button);






# 327 "/usr/share/qt4/include/QtGui/qmessagebox.h"
protected:
bool event(QEvent *e);
void resizeEvent(QResizeEvent *event);
void showEvent(QShowEvent *event);
void closeEvent(QCloseEvent *event);
void keyPressEvent(QKeyEvent *event);
void changeEvent(QEvent *event);

private:


QMessageBox(const QMessageBox &); QMessageBox &operator=(const QMessageBox &);
inline QMessageBoxPrivate* d_func() { return reinterpret_cast<QMessageBoxPrivate *>(qGetPtrHelper(d_ptr)); } inline const QMessageBoxPrivate* d_func() const { return reinterpret_cast<const QMessageBoxPrivate *>(qGetPtrHelper(d_ptr)); } friend class QMessageBoxPrivate;
};

inline QFlags<QMessageBox::StandardButtons::enum_type> operator|(QMessageBox::StandardButtons::enum_type f1, QMessageBox::StandardButtons::enum_type f2) { return QFlags<QMessageBox::StandardButtons::enum_type>(f1) | f2; } inline QFlags<QMessageBox::StandardButtons::enum_type> operator|(QMessageBox::StandardButtons::enum_type f1, QFlags<QMessageBox::StandardButtons::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QMessageBox::StandardButtons::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }





# 361 "/usr/share/qt4/include/QtGui/qmessagebox.h"





# 202 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qpagesetupdialog.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractpagesetupdialog.h"


















































































# 45 "/usr/share/qt4/include/QtGui/qpagesetupdialog.h"


# 47 "/usr/share/qt4/include/QtGui/qpagesetupdialog.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qpagesetupdialog.h"
class QPageSetupDialogPrivate;

class  QPageSetupDialog : public QAbstractPageSetupDialog
{
Q_OBJECT
inline QPageSetupDialogPrivate* d_func() { return reinterpret_cast<QPageSetupDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPageSetupDialogPrivate* d_func() const { return reinterpret_cast<const QPageSetupDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPageSetupDialogPrivate;
Q_ENUMS(PageSetupDialogOption)
Q_PROPERTY(PageSetupDialogOptions options READ options WRITE setOptions)

public:
enum PageSetupDialogOption {
None = 0x00000000, 
DontUseSheet = 0x00000001,
OwnsPrinter = 0x80000000 
};

typedef QFlags<PageSetupDialogOption> PageSetupDialogOptions;

explicit QPageSetupDialog(QPrinter *printer, QWidget *parent = 0);
explicit QPageSetupDialog(QWidget *parent = 0);


void addEnabledOption(PageSetupDialogOption option);
void setEnabledOptions(PageSetupDialogOptions options);
PageSetupDialogOptions enabledOptions() const;
bool isOptionEnabled(PageSetupDialogOption option) const;

void setOption(PageSetupDialogOption option, bool on = true);
bool testOption(PageSetupDialogOption option) const;
void setOptions(PageSetupDialogOptions options);
PageSetupDialogOptions options() const;




# 90 "/usr/share/qt4/include/QtGui/qpagesetupdialog.h"
virtual int exec();



# 94 "/usr/share/qt4/include/QtGui/qpagesetupdialog.h"
void open() { QDialog::open(); }




# 99 "/usr/share/qt4/include/QtGui/qpagesetupdialog.h"
void open(QObject *receiver, const char *member);




# 104 "/usr/share/qt4/include/QtGui/qpagesetupdialog.h"
};



# 108 "/usr/share/qt4/include/QtGui/qpagesetupdialog.h"





# 203 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qprintdialog.h"












































# 1 "/usr/share/qt4/include/QtGui/qabstractprintdialog.h"































































































































# 45 "/usr/share/qt4/include/QtGui/qprintdialog.h"


# 47 "/usr/share/qt4/include/QtGui/qprintdialog.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qprintdialog.h"
class QPrintDialogPrivate;
class QPushButton;
class QPrinter;























# 81 "/usr/share/qt4/include/QtGui/qprintdialog.h"
class  QPrintDialog : public QAbstractPrintDialog
{
Q_OBJECT
inline QPrintDialogPrivate* d_func() { return reinterpret_cast<QPrintDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPrintDialogPrivate* d_func() const { return reinterpret_cast<const QPrintDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPrintDialogPrivate;
Q_ENUMS(PrintDialogOption)
Q_PROPERTY(PrintDialogOptions options READ options WRITE setOptions)

public:
explicit QPrintDialog(QPrinter *printer, QWidget *parent = 0);
explicit QPrintDialog(QWidget *parent = 0);
~QPrintDialog();

int exec();



# 97 "/usr/share/qt4/include/QtGui/qprintdialog.h"
void done(int result);







# 105 "/usr/share/qt4/include/QtGui/qprintdialog.h"
void setOption(PrintDialogOption option, bool on = true);
bool testOption(PrintDialogOption option) const;
void setOptions(PrintDialogOptions options);
PrintDialogOptions options() const;







# 116 "/usr/share/qt4/include/QtGui/qprintdialog.h"
void open() { QDialog::open(); }




# 121 "/usr/share/qt4/include/QtGui/qprintdialog.h"
void open(QObject *receiver, const char *member);












# 134 "/usr/share/qt4/include/QtGui/qprintdialog.h"
void accepted() { QDialog::accepted(); }





# 140 "/usr/share/qt4/include/QtGui/qprintdialog.h"
signals:
void accepted(QPrinter *printer);

private:

# 145 "/usr/share/qt4/include/QtGui/qprintdialog.h"




















# 165 "/usr/share/qt4/include/QtGui/qprintdialog.h"
friend class QUnixPrintWidget;
};



# 170 "/usr/share/qt4/include/QtGui/qprintdialog.h"





# 204 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qprintpreviewdialog.h"












































# 1 "/usr/share/qt4/include/QtGui/qdialog.h"












































































































































# 45 "/usr/share/qt4/include/QtGui/qprintpreviewdialog.h"




# 49 "/usr/share/qt4/include/QtGui/qprintpreviewdialog.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QGraphicsView;
class QPrintPreviewDialogPrivate;

class  QPrintPreviewDialog : public QDialog
{
Q_OBJECT
inline QPrintPreviewDialogPrivate* d_func() { return reinterpret_cast<QPrintPreviewDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPrintPreviewDialogPrivate* d_func() const { return reinterpret_cast<const QPrintPreviewDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPrintPreviewDialogPrivate;

public:
explicit QPrintPreviewDialog(QWidget *parent = 0, Qt::WindowFlags flags = 0);
explicit QPrintPreviewDialog(QPrinter *printer, QWidget *parent = 0, Qt::WindowFlags flags = 0);
~QPrintPreviewDialog();



# 70 "/usr/share/qt4/include/QtGui/qprintpreviewdialog.h"
void open() { QDialog::open(); }




# 75 "/usr/share/qt4/include/QtGui/qprintpreviewdialog.h"
void open(QObject *receiver, const char *member);

QPrinter *printer();

void setVisible(bool visible);
void done(int result);

signals:
void paintRequested(QPrinter *printer);

private:











void *dummy; 
};









# 205 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qprogressdialog.h"












































# 1 "/usr/share/qt4/include/QtGui/qdialog.h"












































































































































# 45 "/usr/share/qt4/include/QtGui/qprogressdialog.h"


# 47 "/usr/share/qt4/include/QtGui/qprogressdialog.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qprogressdialog.h"
class QPushButton;
class QLabel;
class QProgressBar;
class QTimer;
class QProgressDialogPrivate;

class  QProgressDialog : public QDialog
{
Q_OBJECT
inline QProgressDialogPrivate* d_func() { return reinterpret_cast<QProgressDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QProgressDialogPrivate* d_func() const { return reinterpret_cast<const QProgressDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QProgressDialogPrivate;
Q_PROPERTY(bool wasCanceled READ wasCanceled)
Q_PROPERTY(int minimum READ minimum WRITE setMinimum)
Q_PROPERTY(int maximum READ maximum WRITE setMaximum)
Q_PROPERTY(int value READ value WRITE setValue)
Q_PROPERTY(bool autoReset READ autoReset WRITE setAutoReset)
Q_PROPERTY(bool autoClose READ autoClose WRITE setAutoClose)
Q_PROPERTY(int minimumDuration READ minimumDuration WRITE setMinimumDuration)
Q_PROPERTY(QString labelText READ labelText WRITE setLabelText)

public:
explicit QProgressDialog(QWidget *parent = 0, Qt::WindowFlags flags = 0);
QProgressDialog(const QString &labelText, const QString &cancelButtonText,
int minimum, int maximum, QWidget *parent = 0, Qt::WindowFlags flags = 0);
~QProgressDialog();

void setLabel(QLabel *label);
void setCancelButton(QPushButton *button);
void setBar(QProgressBar *bar);

bool wasCanceled() const;

int minimum() const;
int maximum() const;

int value() const;

QSize sizeHint() const;

QString labelText() const;
int minimumDuration() const;

void setAutoReset(bool reset);
bool autoReset() const;
void setAutoClose(bool close);
bool autoClose() const;



# 103 "/usr/share/qt4/include/QtGui/qprogressdialog.h"
void open() { QDialog::open(); }




# 108 "/usr/share/qt4/include/QtGui/qprogressdialog.h"
void open(QObject *receiver, const char *member);

public slots:
void cancel();
void reset();
void setMaximum(int maximum);
void setMinimum(int minimum);
void setRange(int minimum, int maximum);
void setValue(int progress);
void setLabelText(const QString &text);
void setCancelButtonText(const QString &text);
void setMinimumDuration(int ms);

signals:
void canceled();

protected:
void resizeEvent(QResizeEvent *event);
void closeEvent(QCloseEvent *event);
void changeEvent(QEvent *event);
void showEvent(QShowEvent *event);

protected slots:
void forceShow();

private:
QProgressDialog(const QProgressDialog &); QProgressDialog &operator=(const QProgressDialog &);


};



# 141 "/usr/share/qt4/include/QtGui/qprogressdialog.h"





# 206 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qwizard.h"












































# 1 "/usr/share/qt4/include/QtGui/qdialog.h"












































































































































# 45 "/usr/share/qt4/include/QtGui/qwizard.h"


# 47 "/usr/share/qt4/include/QtGui/qwizard.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qwizard.h"
class QAbstractButton;
class QWizardPage;
class QWizardPrivate;

class  QWizard : public QDialog
{
Q_OBJECT
Q_ENUMS(WizardStyle WizardOption)

Q_PROPERTY(WizardStyle wizardStyle READ wizardStyle WRITE setWizardStyle)
Q_PROPERTY(WizardOptions options READ options WRITE setOptions)
Q_PROPERTY(Qt::TextFormat titleFormat READ titleFormat WRITE setTitleFormat)
Q_PROPERTY(Qt::TextFormat subTitleFormat READ subTitleFormat WRITE setSubTitleFormat)
Q_PROPERTY(int startId READ startId WRITE setStartId)
Q_PROPERTY(int currentId READ currentId NOTIFY currentIdChanged)

public:
enum WizardButton {
BackButton,
NextButton,
CommitButton,
FinishButton,
CancelButton,
HelpButton,
CustomButton1,
CustomButton2,
CustomButton3,
Stretch,

NoButton = -1,
NStandardButtons = 6,
NButtons = 9
};

enum WizardPixmap {
WatermarkPixmap,
LogoPixmap,
BannerPixmap,
BackgroundPixmap,
NPixmaps
};

enum WizardStyle {
ClassicStyle,
ModernStyle,
MacStyle,
AeroStyle,
NStyles
};

enum WizardOption {
IndependentPages = 0x00000001,
IgnoreSubTitles = 0x00000002,
ExtendedWatermarkPixmap = 0x00000004,
NoDefaultButton = 0x00000008,
NoBackButtonOnStartPage = 0x00000010,
NoBackButtonOnLastPage = 0x00000020,
DisabledBackButtonOnLastPage = 0x00000040,
HaveNextButtonOnLastPage = 0x00000080,
HaveFinishButtonOnEarlyPages = 0x00000100,
NoCancelButton = 0x00000200,
CancelButtonOnLeft = 0x00000400,
HaveHelpButton = 0x00000800,
HelpButtonOnRight = 0x00001000,
HaveCustomButton1 = 0x00002000,
HaveCustomButton2 = 0x00004000,
HaveCustomButton3 = 0x00008000
};

typedef QFlags<WizardOption> WizardOptions;

explicit QWizard(QWidget *parent = 0, Qt::WindowFlags flags = 0);
~QWizard();

int addPage(QWizardPage *page);
void setPage(int id, QWizardPage *page);
void removePage(int id);
QWizardPage *page(int id) const;
bool hasVisitedPage(int id) const;
QList<int> visitedPages() const; 
QList<int> pageIds() const;
void setStartId(int id);
int startId() const;
QWizardPage *currentPage() const;
int currentId() const;

virtual bool validateCurrentPage();
virtual int nextId() const;

void setField(const QString &name, const QVariant &value);
QVariant field(const QString &name) const;

void setWizardStyle(WizardStyle style);
WizardStyle wizardStyle() const;

void setOption(WizardOption option, bool on = true);
bool testOption(WizardOption option) const;
void setOptions(WizardOptions options);
WizardOptions options() const;

void setButtonText(WizardButton which, const QString &text);
QString buttonText(WizardButton which) const;
void setButtonLayout(const QList<WizardButton> &layout);
void setButton(WizardButton which, QAbstractButton *button);
QAbstractButton *button(WizardButton which) const;

void setTitleFormat(Qt::TextFormat format);
Qt::TextFormat titleFormat() const;
void setSubTitleFormat(Qt::TextFormat format);
Qt::TextFormat subTitleFormat() const;
void setPixmap(WizardPixmap which, const QPixmap &pixmap);
QPixmap pixmap(WizardPixmap which) const;

void setDefaultProperty(const char *className, const char *property,
const char *changedSignal);

void setVisible(bool visible);
QSize sizeHint() const;

signals:
void currentIdChanged(int id);
void helpRequested();
void customButtonClicked(int which);

public slots:
void back();
void next();
void restart();

protected:
bool event(QEvent *event);
void resizeEvent(QResizeEvent *event);
void paintEvent(QPaintEvent *event);



# 191 "/usr/share/qt4/include/QtGui/qwizard.h"
void done(int result);
virtual void initializePage(int id);
virtual void cleanupPage(int id);

private:
QWizard(const QWizard &); QWizard &operator=(const QWizard &);
inline QWizardPrivate* d_func() { return reinterpret_cast<QWizardPrivate *>(qGetPtrHelper(d_ptr)); } inline const QWizardPrivate* d_func() const { return reinterpret_cast<const QWizardPrivate *>(qGetPtrHelper(d_ptr)); } friend class QWizardPrivate;




friend class QWizardPage;
};

inline QFlags<QWizard::WizardOptions::enum_type> operator|(QWizard::WizardOptions::enum_type f1, QWizard::WizardOptions::enum_type f2) { return QFlags<QWizard::WizardOptions::enum_type>(f1) | f2; } inline QFlags<QWizard::WizardOptions::enum_type> operator|(QWizard::WizardOptions::enum_type f1, QFlags<QWizard::WizardOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QWizard::WizardOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class QWizardPagePrivate;

class  QWizardPage : public QWidget
{
Q_OBJECT
Q_PROPERTY(QString title READ title WRITE setTitle)
Q_PROPERTY(QString subTitle READ subTitle WRITE setSubTitle)

public:
QWizardPage(QWidget *parent = 0);

void setTitle(const QString &title);
QString title() const;
void setSubTitle(const QString &subTitle);
QString subTitle() const;
void setPixmap(QWizard::WizardPixmap which, const QPixmap &pixmap);
QPixmap pixmap(QWizard::WizardPixmap which) const;
void setFinalPage(bool finalPage);
bool isFinalPage() const;
void setCommitPage(bool commitPage);
bool isCommitPage() const;
void setButtonText(QWizard::WizardButton which, const QString &text);
QString buttonText(QWizard::WizardButton which) const;

virtual void initializePage();
virtual void cleanupPage();
virtual bool validatePage();
virtual bool isComplete() const;
virtual int nextId() const;

signals:
void completeChanged();

protected:
void setField(const QString &name, const QVariant &value);
QVariant field(const QString &name) const;
void registerField(const QString &name, QWidget *widget, const char *property = 0,
const char *changedSignal = 0);
QWizard *wizard() const;

private:
QWizardPage(const QWizardPage &); QWizardPage &operator=(const QWizardPage &);
inline QWizardPagePrivate* d_func() { return reinterpret_cast<QWizardPagePrivate *>(qGetPtrHelper(d_ptr)); } inline const QWizardPagePrivate* d_func() const { return reinterpret_cast<const QWizardPagePrivate *>(qGetPtrHelper(d_ptr)); } friend class QWizardPagePrivate;



friend class QWizard;
friend class QWizardPrivate;
};








# 207 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicseffect.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgraphicseffect.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qgraphicseffect.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qgraphicseffect.h"

# 1 "/usr/share/qt4/include/QtGui/qcolor.h"

















































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qgraphicseffect.h"

# 1 "/usr/share/qt4/include/QtGui/qbrush.h"








































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qgraphicseffect.h"



# 52 "/usr/share/qt4/include/QtGui/qgraphicseffect.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QGraphicsItem;
class QStyleOption;
class QPainter;
class QPixmap;

class QGraphicsEffectSource;

class QGraphicsEffectPrivate;
class  QGraphicsEffect : public QObject
{
Q_OBJECT

Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled NOTIFY enabledChanged)
public:
enum ChangeFlag {
SourceAttached = 0x1,
SourceDetached = 0x2,
SourceBoundingRectChanged = 0x4,
SourceInvalidated = 0x8
};
typedef QFlags<ChangeFlag> ChangeFlags;

enum PixmapPadMode {
NoPad,
PadToTransparentBorder,
PadToEffectiveBoundingRect
};

QGraphicsEffect(QObject *parent = 0);
virtual ~QGraphicsEffect();

virtual QRectF boundingRectFor(const QRectF &sourceRect) const;
QRectF boundingRect() const;

bool isEnabled() const;

public slots:
void setEnabled(bool enable);
void update();

signals:
void enabledChanged(bool enabled);

protected:
QGraphicsEffect(QGraphicsEffectPrivate &d, QObject *parent = 0);
virtual void draw(QPainter *painter) = 0;
virtual void sourceChanged(ChangeFlags flags);
void updateBoundingRect();

bool sourceIsPixmap() const;
QRectF sourceBoundingRect(Qt::CoordinateSystem system = Qt::LogicalCoordinates) const;
void drawSource(QPainter *painter);
QPixmap sourcePixmap(Qt::CoordinateSystem system = Qt::LogicalCoordinates,
QPoint *offset = 0,
PixmapPadMode mode = PadToEffectiveBoundingRect) const;

private:
inline QGraphicsEffectPrivate* d_func() { return reinterpret_cast<QGraphicsEffectPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsEffectPrivate* d_func() const { return reinterpret_cast<const QGraphicsEffectPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsEffectPrivate;
QGraphicsEffect(const QGraphicsEffect &); QGraphicsEffect &operator=(const QGraphicsEffect &);
friend class QGraphicsItem;
friend class QGraphicsItemPrivate;
friend class QGraphicsScenePrivate;
friend class QWidget;
friend class QWidgetPrivate;

public:
QGraphicsEffectSource *source() const; 

};
inline QFlags<QGraphicsEffect::ChangeFlags::enum_type> operator|(QGraphicsEffect::ChangeFlags::enum_type f1, QGraphicsEffect::ChangeFlags::enum_type f2) { return QFlags<QGraphicsEffect::ChangeFlags::enum_type>(f1) | f2; } inline QFlags<QGraphicsEffect::ChangeFlags::enum_type> operator|(QGraphicsEffect::ChangeFlags::enum_type f1, QFlags<QGraphicsEffect::ChangeFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QGraphicsEffect::ChangeFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class QGraphicsColorizeEffectPrivate;
class  QGraphicsColorizeEffect: public QGraphicsEffect
{
Q_OBJECT
Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged)
Q_PROPERTY(qreal strength READ strength WRITE setStrength NOTIFY strengthChanged)
public:
QGraphicsColorizeEffect(QObject *parent = 0);
~QGraphicsColorizeEffect();

QColor color() const;
qreal strength() const;

public slots:
void setColor(const QColor &c);
void setStrength(qreal strength);

signals:
void colorChanged(const QColor &color);
void strengthChanged(qreal strength);

protected:
void draw(QPainter *painter);

private:
inline QGraphicsColorizeEffectPrivate* d_func() { return reinterpret_cast<QGraphicsColorizeEffectPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsColorizeEffectPrivate* d_func() const { return reinterpret_cast<const QGraphicsColorizeEffectPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsColorizeEffectPrivate;
QGraphicsColorizeEffect(const QGraphicsColorizeEffect &); QGraphicsColorizeEffect &operator=(const QGraphicsColorizeEffect &);
};

class QGraphicsBlurEffectPrivate;
class  QGraphicsBlurEffect: public QGraphicsEffect
{
Q_OBJECT

Q_PROPERTY(qreal blurRadius READ blurRadius WRITE setBlurRadius NOTIFY blurRadiusChanged)
Q_PROPERTY(BlurHints blurHints READ blurHints WRITE setBlurHints NOTIFY blurHintsChanged)
public:
enum BlurHint {
PerformanceHint = 0x00,
QualityHint = 0x01,
AnimationHint = 0x02
};
typedef QFlags<BlurHint> BlurHints;

QGraphicsBlurEffect(QObject *parent = 0);
~QGraphicsBlurEffect();

QRectF boundingRectFor(const QRectF &rect) const;
qreal blurRadius() const;
BlurHints blurHints() const;

public slots:
void setBlurRadius(qreal blurRadius);
void setBlurHints(BlurHints hints);

signals:
void blurRadiusChanged(qreal blurRadius);
void blurHintsChanged(BlurHints hints);

protected:
void draw(QPainter *painter);

private:
inline QGraphicsBlurEffectPrivate* d_func() { return reinterpret_cast<QGraphicsBlurEffectPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsBlurEffectPrivate* d_func() const { return reinterpret_cast<const QGraphicsBlurEffectPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsBlurEffectPrivate;
QGraphicsBlurEffect(const QGraphicsBlurEffect &); QGraphicsBlurEffect &operator=(const QGraphicsBlurEffect &);
};

inline QFlags<QGraphicsBlurEffect::BlurHints::enum_type> operator|(QGraphicsBlurEffect::BlurHints::enum_type f1, QGraphicsBlurEffect::BlurHints::enum_type f2) { return QFlags<QGraphicsBlurEffect::BlurHints::enum_type>(f1) | f2; } inline QFlags<QGraphicsBlurEffect::BlurHints::enum_type> operator|(QGraphicsBlurEffect::BlurHints::enum_type f1, QFlags<QGraphicsBlurEffect::BlurHints::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QGraphicsBlurEffect::BlurHints::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class QGraphicsDropShadowEffectPrivate;
class  QGraphicsDropShadowEffect: public QGraphicsEffect
{
Q_OBJECT
Q_PROPERTY(QPointF offset READ offset WRITE setOffset NOTIFY offsetChanged)
Q_PROPERTY(qreal xOffset READ xOffset WRITE setXOffset NOTIFY offsetChanged)
Q_PROPERTY(qreal yOffset READ yOffset WRITE setYOffset NOTIFY offsetChanged)
Q_PROPERTY(qreal blurRadius READ blurRadius WRITE setBlurRadius NOTIFY blurRadiusChanged)
Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged)
public:
QGraphicsDropShadowEffect(QObject *parent = 0);
~QGraphicsDropShadowEffect();

QRectF boundingRectFor(const QRectF &rect) const;
QPointF offset() const;

inline qreal xOffset() const
{ return offset().x(); }

inline qreal yOffset() const
{ return offset().y(); }

qreal blurRadius() const;
QColor color() const;

public slots:
void setOffset(const QPointF &ofs);

inline void setOffset(qreal dx, qreal dy)
{ setOffset(QPointF(dx, dy)); }

inline void setOffset(qreal d)
{ setOffset(QPointF(d, d)); }

inline void setXOffset(qreal dx)
{ setOffset(QPointF(dx, yOffset())); }

inline void setYOffset(qreal dy)
{ setOffset(QPointF(xOffset(), dy)); }

void setBlurRadius(qreal blurRadius);
void setColor(const QColor &color);

signals:
void offsetChanged(const QPointF &offset);
void blurRadiusChanged(qreal blurRadius);
void colorChanged(const QColor &color);

protected:
void draw(QPainter *painter);

private:
inline QGraphicsDropShadowEffectPrivate* d_func() { return reinterpret_cast<QGraphicsDropShadowEffectPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsDropShadowEffectPrivate* d_func() const { return reinterpret_cast<const QGraphicsDropShadowEffectPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsDropShadowEffectPrivate;
QGraphicsDropShadowEffect(const QGraphicsDropShadowEffect &); QGraphicsDropShadowEffect &operator=(const QGraphicsDropShadowEffect &);
};

class QGraphicsOpacityEffectPrivate;
class  QGraphicsOpacityEffect: public QGraphicsEffect
{
Q_OBJECT
Q_PROPERTY(qreal opacity READ opacity WRITE setOpacity NOTIFY opacityChanged)
Q_PROPERTY(QBrush opacityMask READ opacityMask WRITE setOpacityMask NOTIFY opacityMaskChanged)
public:
QGraphicsOpacityEffect(QObject *parent = 0);
~QGraphicsOpacityEffect();

qreal opacity() const;
QBrush opacityMask() const;

public slots:
void setOpacity(qreal opacity);
void setOpacityMask(const QBrush &mask);

signals:
void opacityChanged(qreal opacity);
void opacityMaskChanged(const QBrush &mask);

protected:
void draw(QPainter *painter);

private:
inline QGraphicsOpacityEffectPrivate* d_func() { return reinterpret_cast<QGraphicsOpacityEffectPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsOpacityEffectPrivate* d_func() const { return reinterpret_cast<const QGraphicsOpacityEffectPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsOpacityEffectPrivate;
QGraphicsOpacityEffect(const QGraphicsOpacityEffect &); QGraphicsOpacityEffect &operator=(const QGraphicsOpacityEffect &);
};








# 208 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qcompleter.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qcompleter.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qcompleter.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qcompleter.h"

# 1 "/usr/share/qt4/include/QtCore/qabstractitemmodel.h"


























































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qcompleter.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qcompleter.h"


# 51 "/usr/share/qt4/include/QtGui/qcompleter.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 59 "/usr/share/qt4/include/QtGui/qcompleter.h"
class QCompleterPrivate;
class QAbstractItemView;
class QAbstractProxyModel;
class QWidget;

class  QCompleter : public QObject
{
Q_OBJECT
Q_PROPERTY(QString completionPrefix READ completionPrefix WRITE setCompletionPrefix)
Q_PROPERTY(ModelSorting modelSorting READ modelSorting WRITE setModelSorting)
Q_PROPERTY(CompletionMode completionMode READ completionMode WRITE setCompletionMode)
Q_PROPERTY(int completionColumn READ completionColumn WRITE setCompletionColumn)
Q_PROPERTY(int completionRole READ completionRole WRITE setCompletionRole)
Q_PROPERTY(int maxVisibleItems READ maxVisibleItems WRITE setMaxVisibleItems)
Q_PROPERTY(Qt::CaseSensitivity caseSensitivity READ caseSensitivity WRITE setCaseSensitivity)
Q_PROPERTY(bool wrapAround READ wrapAround WRITE setWrapAround)

public:
enum CompletionMode {
PopupCompletion,
UnfilteredPopupCompletion,
InlineCompletion
};

enum ModelSorting {
UnsortedModel = 0,
CaseSensitivelySortedModel,
CaseInsensitivelySortedModel
};

QCompleter(QObject *parent = 0);
QCompleter(QAbstractItemModel *model, QObject *parent = 0);

# 92 "/usr/share/qt4/include/QtGui/qcompleter.h"
QCompleter(const QStringList& completions, QObject *parent = 0);

# 94 "/usr/share/qt4/include/QtGui/qcompleter.h"
~QCompleter();

void setWidget(QWidget *widget);
QWidget *widget() const;

void setModel(QAbstractItemModel *c);
QAbstractItemModel *model() const;

void setCompletionMode(CompletionMode mode);
CompletionMode completionMode() const;

QAbstractItemView *popup() const;
void setPopup(QAbstractItemView *popup);

void setCaseSensitivity(Qt::CaseSensitivity caseSensitivity);
Qt::CaseSensitivity caseSensitivity() const;

void setModelSorting(ModelSorting sorting);
ModelSorting modelSorting() const;

void setCompletionColumn(int column);
int completionColumn() const;

void setCompletionRole(int role);
int completionRole() const;

bool wrapAround() const;

int maxVisibleItems() const;
void setMaxVisibleItems(int maxItems);

int completionCount() const;
bool setCurrentRow(int row);
int currentRow() const;

QModelIndex currentIndex() const;
QString currentCompletion() const;

QAbstractItemModel *completionModel() const;

QString completionPrefix() const;

public slots:
void setCompletionPrefix(const QString &prefix);
void complete(const QRect& rect = QRect());
void setWrapAround(bool wrap);

public:
virtual QString pathFromIndex(const QModelIndex &index) const;
virtual QStringList splitPath(const QString &path) const;

protected:
bool eventFilter(QObject *o, QEvent *e);
bool event(QEvent *);

signals:
void activated(const QString &text);
void activated(const QModelIndex &index);
void highlighted(const QString &text);
void highlighted(const QModelIndex &index);

private:
QCompleter(const QCompleter &); QCompleter &operator=(const QCompleter &);
inline QCompleterPrivate* d_func() { return reinterpret_cast<QCompleterPrivate *>(qGetPtrHelper(d_ptr)); } inline const QCompleterPrivate* d_func() const { return reinterpret_cast<const QCompleterPrivate *>(qGetPtrHelper(d_ptr)); } friend class QCompleterPrivate;




};



# 166 "/usr/share/qt4/include/QtGui/qcompleter.h"





# 209 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qdesktopservices.h"












































# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qdesktopservices.h"


# 47 "/usr/share/qt4/include/QtGui/qdesktopservices.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qdesktopservices.h"
class QStringList;
class QUrl;
class QObject;

class  QDesktopServices
{
public:
static bool openUrl(const QUrl &url);
static void setUrlHandler(const QString &scheme, QObject *receiver, const char *method);
static void unsetUrlHandler(const QString &scheme);

enum StandardLocation {
DesktopLocation,
DocumentsLocation,
FontsLocation,
ApplicationsLocation,
MusicLocation,
MoviesLocation,
PicturesLocation,
TempLocation,
HomeLocation,
DataLocation,
CacheLocation
};

static QString storageLocation(StandardLocation type);
static QString displayName(StandardLocation type);
};



# 86 "/usr/share/qt4/include/QtGui/qdesktopservices.h"






# 210 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qsystemtrayicon.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qsystemtrayicon.h"




# 1 "/usr/share/qt4/include/QtGui/qicon.h"


























































































































































# 49 "/usr/share/qt4/include/QtGui/qsystemtrayicon.h"


# 51 "/usr/share/qt4/include/QtGui/qsystemtrayicon.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QSystemTrayIconPrivate;

class QMenu;
class QEvent;
class QWheelEvent;
class QMouseEvent;
class QPoint;

class  QSystemTrayIcon : public QObject
{
Q_OBJECT
Q_PROPERTY(QString toolTip READ toolTip WRITE setToolTip)
Q_PROPERTY(QIcon icon READ icon WRITE setIcon)
Q_PROPERTY(bool visible READ isVisible WRITE setVisible DESIGNABLE false)

public:
QSystemTrayIcon(QObject *parent = 0);
QSystemTrayIcon(const QIcon &icon, QObject *parent = 0);
~QSystemTrayIcon();

enum ActivationReason {
Unknown,
Context,
DoubleClick,
Trigger,
MiddleClick
};


# 86 "/usr/share/qt4/include/QtGui/qsystemtrayicon.h"
void setContextMenu(QMenu *menu);
QMenu *contextMenu() const;


# 90 "/usr/share/qt4/include/QtGui/qsystemtrayicon.h"
QIcon icon() const;
void setIcon(const QIcon &icon);

QString toolTip() const;
void setToolTip(const QString &tip);

static bool isSystemTrayAvailable();
static bool supportsMessages();

enum MessageIcon { NoIcon, Information, Warning, Critical };
void showMessage(const QString &title, const QString &msg,
MessageIcon icon = Information, int msecs = 10000);

QRect geometry() const;
bool isVisible() const;

public slots:
void setVisible(bool visible);
inline void show() { setVisible(true); }
inline void hide() { setVisible(false); }

signals:
void activated(QSystemTrayIcon::ActivationReason reason);
void messageClicked();

protected:
bool event(QEvent *event);

private:
QSystemTrayIcon(const QSystemTrayIcon &); QSystemTrayIcon &operator=(const QSystemTrayIcon &);
inline QSystemTrayIconPrivate* d_func() { return reinterpret_cast<QSystemTrayIconPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSystemTrayIconPrivate* d_func() const { return reinterpret_cast<const QSystemTrayIconPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSystemTrayIconPrivate;

friend class QSystemTrayIconSys;
friend class QBalloonTip;
friend void qtsystray_sendActivated(QSystemTrayIcon *, int);
};







# 211 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qundogroup.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qundogroup.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qundogroup.h"


# 48 "/usr/share/qt4/include/QtGui/qundogroup.h"




class QUndoGroupPrivate;
class QUndoStack;
class QAction;

typedef QtValidLicenseForGuiModule QtGuiModule;



# 60 "/usr/share/qt4/include/QtGui/qundogroup.h"
class  QUndoGroup : public QObject
{
Q_OBJECT
inline QUndoGroupPrivate* d_func() { return reinterpret_cast<QUndoGroupPrivate *>(qGetPtrHelper(d_ptr)); } inline const QUndoGroupPrivate* d_func() const { return reinterpret_cast<const QUndoGroupPrivate *>(qGetPtrHelper(d_ptr)); } friend class QUndoGroupPrivate;

public:
explicit QUndoGroup(QObject *parent = 0);
~QUndoGroup();

void addStack(QUndoStack *stack);
void removeStack(QUndoStack *stack);
QList<QUndoStack*> stacks() const;
QUndoStack *activeStack() const;


# 75 "/usr/share/qt4/include/QtGui/qundogroup.h"
QAction *createUndoAction(QObject *parent,
const QString &prefix = QString()) const;
QAction *createRedoAction(QObject *parent,
const QString &prefix = QString()) const;

# 80 "/usr/share/qt4/include/QtGui/qundogroup.h"
bool canUndo() const;
bool canRedo() const;
QString undoText() const;
QString redoText() const;
bool isClean() const;

public slots:
void undo();
void redo();
void setActiveStack(QUndoStack *stack);

signals:
void activeStackChanged(QUndoStack *stack);
void indexChanged(int idx);
void cleanChanged(bool clean);
void canUndoChanged(bool canUndo);
void canRedoChanged(bool canRedo);
void undoTextChanged(const QString &undoText);
void redoTextChanged(const QString &redoText);

private:
QUndoGroup(const QUndoGroup &); QUndoGroup &operator=(const QUndoGroup &);
};



# 106 "/usr/share/qt4/include/QtGui/qundogroup.h"





# 212 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qundostack.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qundostack.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qundostack.h"


# 48 "/usr/share/qt4/include/QtGui/qundostack.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QAction;
class QUndoCommandPrivate;
class QUndoStackPrivate;



# 60 "/usr/share/qt4/include/QtGui/qundostack.h"
class  QUndoCommand
{
QUndoCommandPrivate *d;

public:
explicit QUndoCommand(QUndoCommand *parent = 0);
explicit QUndoCommand(const QString &text, QUndoCommand *parent = 0);
virtual ~QUndoCommand();

virtual void undo();
virtual void redo();

QString text() const;
void setText(const QString &text);

virtual int id() const;
virtual bool mergeWith(const QUndoCommand *other);

int childCount() const;
const QUndoCommand *child(int index) const;

private:
QUndoCommand(const QUndoCommand &); QUndoCommand &operator=(const QUndoCommand &);
friend class QUndoStack;
};





# 90 "/usr/share/qt4/include/QtGui/qundostack.h"
class  QUndoStack : public QObject
{
Q_OBJECT
inline QUndoStackPrivate* d_func() { return reinterpret_cast<QUndoStackPrivate *>(qGetPtrHelper(d_ptr)); } inline const QUndoStackPrivate* d_func() const { return reinterpret_cast<const QUndoStackPrivate *>(qGetPtrHelper(d_ptr)); } friend class QUndoStackPrivate;
Q_PROPERTY(bool active READ isActive WRITE setActive)
Q_PROPERTY(int undoLimit READ undoLimit WRITE setUndoLimit)

public:
explicit QUndoStack(QObject *parent = 0);
~QUndoStack();
void clear();

void push(QUndoCommand *cmd);

bool canUndo() const;
bool canRedo() const;
QString undoText() const;
QString redoText() const;

int count() const;
int index() const;
QString text(int idx) const;


# 114 "/usr/share/qt4/include/QtGui/qundostack.h"
QAction *createUndoAction(QObject *parent,
const QString &prefix = QString()) const;
QAction *createRedoAction(QObject *parent,
const QString &prefix = QString()) const;


# 120 "/usr/share/qt4/include/QtGui/qundostack.h"
bool isActive() const;
bool isClean() const;
int cleanIndex() const;

void beginMacro(const QString &text);
void endMacro();

void setUndoLimit(int limit);
int undoLimit() const;

const QUndoCommand *command(int index) const;

public slots:
void setClean();
void setIndex(int idx);
void undo();
void redo();
void setActive(bool active = true);

signals:
void indexChanged(int idx);
void cleanChanged(bool clean);
void canUndoChanged(bool canUndo);
void canRedoChanged(bool canRedo);
void undoTextChanged(const QString &undoText);
void redoTextChanged(const QString &redoText);

private:
QUndoStack(const QUndoStack &); QUndoStack &operator=(const QUndoStack &);
friend class QUndoGroup;
};



# 154 "/usr/share/qt4/include/QtGui/qundostack.h"





# 213 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qundoview.h"












































# 1 "/usr/share/qt4/include/QtGui/qlistview.h"











































































































































































































# 45 "/usr/share/qt4/include/QtGui/qundoview.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qundoview.h"




# 50 "/usr/share/qt4/include/QtGui/qundoview.h"




class QUndoViewPrivate;
class QUndoStack;
class QUndoGroup;
class QIcon;

typedef QtValidLicenseForGuiModule QtGuiModule;

class  QUndoView : public QListView
{
Q_OBJECT
inline QUndoViewPrivate* d_func() { return reinterpret_cast<QUndoViewPrivate *>(qGetPtrHelper(d_ptr)); } inline const QUndoViewPrivate* d_func() const { return reinterpret_cast<const QUndoViewPrivate *>(qGetPtrHelper(d_ptr)); } friend class QUndoViewPrivate;
Q_PROPERTY(QString emptyLabel READ emptyLabel WRITE setEmptyLabel)
Q_PROPERTY(QIcon cleanIcon READ cleanIcon WRITE setCleanIcon)

public:
explicit QUndoView(QWidget *parent = 0);
explicit QUndoView(QUndoStack *stack, QWidget *parent = 0);

# 72 "/usr/share/qt4/include/QtGui/qundoview.h"
explicit QUndoView(QUndoGroup *group, QWidget *parent = 0);

# 74 "/usr/share/qt4/include/QtGui/qundoview.h"
~QUndoView();

QUndoStack *stack() const;

# 78 "/usr/share/qt4/include/QtGui/qundoview.h"
QUndoGroup *group() const;


# 81 "/usr/share/qt4/include/QtGui/qundoview.h"
void setEmptyLabel(const QString &label);
QString emptyLabel() const;

void setCleanIcon(const QIcon &icon);
QIcon cleanIcon() const;

public slots:
void setStack(QUndoStack *stack);

# 90 "/usr/share/qt4/include/QtGui/qundoview.h"
void setGroup(QUndoGroup *group);


# 93 "/usr/share/qt4/include/QtGui/qundoview.h"
private:
QUndoView(const QUndoView &); QUndoView &operator=(const QUndoView &);
};







# 214 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicsanchorlayout.h"












































# 1 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"












































# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

# 1 "/usr/share/qt4/include/QtCore/qvariant.h"







































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 49 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

# 1 "/usr/share/qt4/include/QtGui/qpainterpath.h"












































































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 51 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"


# 53 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
class tst_QGraphicsItem;





typedef QtValidLicenseForGuiModule QtGuiModule;



# 63 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
class QBrush;
class QCursor;
class QFocusEvent;
class QGraphicsEffect;
class QGraphicsItemGroup;
class QGraphicsObject;
class QGraphicsSceneContextMenuEvent;
class QGraphicsSceneDragDropEvent;
class QGraphicsSceneEvent;
class QGraphicsSceneHoverEvent;
class QGraphicsSceneMouseEvent;
class QGraphicsSceneWheelEvent;
class QGraphicsScene;
class QGraphicsTransform;
class QGraphicsWidget;
class QInputMethodEvent;
class QKeyEvent;
class QMatrix;
class QMenu;
class QPainter;
class QPen;
class QPointF;
class QRectF;
class QStyleOptionGraphicsItem;

class QGraphicsItemPrivate;
class  QGraphicsItem
{
public:
enum GraphicsItemFlag {
ItemIsMovable = 0x1,
ItemIsSelectable = 0x2,
ItemIsFocusable = 0x4,
ItemClipsToShape = 0x8,
ItemClipsChildrenToShape = 0x10,
ItemIgnoresTransformations = 0x20,
ItemIgnoresParentOpacity = 0x40,
ItemDoesntPropagateOpacityToChildren = 0x80,
ItemStacksBehindParent = 0x100,
ItemUsesExtendedStyleOption = 0x200,
ItemHasNoContents = 0x400,
ItemSendsGeometryChanges = 0x800,
ItemAcceptsInputMethod = 0x1000,
ItemNegativeZStacksBehindParent = 0x2000,
ItemIsPanel = 0x4000,
ItemIsFocusScope = 0x8000, 
ItemSendsScenePositionChanges = 0x10000

};
typedef QFlags<GraphicsItemFlag> GraphicsItemFlags;

enum GraphicsItemChange {
ItemPositionChange,
ItemMatrixChange,
ItemVisibleChange,
ItemEnabledChange,
ItemSelectedChange,
ItemParentChange,
ItemChildAddedChange,
ItemChildRemovedChange,
ItemTransformChange,
ItemPositionHasChanged,
ItemTransformHasChanged,
ItemSceneChange,
ItemVisibleHasChanged,
ItemEnabledHasChanged,
ItemSelectedHasChanged,
ItemParentHasChanged,
ItemSceneHasChanged,
ItemCursorChange,
ItemCursorHasChanged,
ItemToolTipChange,
ItemToolTipHasChanged,
ItemFlagsChange,
ItemFlagsHaveChanged,
ItemZValueChange,
ItemZValueHasChanged,
ItemOpacityChange,
ItemOpacityHasChanged,
ItemScenePositionHasChanged
};

enum CacheMode {
NoCache,
ItemCoordinateCache,
DeviceCoordinateCache
};

enum PanelModality
{
NonModal,
PanelModal,
SceneModal
};

QGraphicsItem(QGraphicsItem *parent = 0

# 160 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 163 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
virtual ~QGraphicsItem();

QGraphicsScene *scene() const;

QGraphicsItem *parentItem() const;
QGraphicsItem *topLevelItem() const;
QGraphicsObject *parentObject() const;
QGraphicsWidget *parentWidget() const;
QGraphicsWidget *topLevelWidget() const;
QGraphicsWidget *window() const;
QGraphicsItem *panel() const;
void setParentItem(QGraphicsItem *parent);
QList<QGraphicsItem *> children() const; 
QList<QGraphicsItem *> childItems() const;
bool isWidget() const;
bool isWindow() const;
bool isPanel() const;

QGraphicsObject *toGraphicsObject();
const QGraphicsObject *toGraphicsObject() const;

QGraphicsItemGroup *group() const;
void setGroup(QGraphicsItemGroup *group);

GraphicsItemFlags flags() const;
void setFlag(GraphicsItemFlag flag, bool enabled = true);
void setFlags(GraphicsItemFlags flags);

CacheMode cacheMode() const;
void setCacheMode(CacheMode mode, const QSize &cacheSize = QSize());

PanelModality panelModality() const;
void setPanelModality(PanelModality panelModality);
bool isBlockedByModalPanel(QGraphicsItem **blockingPanel = 0) const;


# 200 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
QString toolTip() const;
void setToolTip(const QString &toolTip);



# 205 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
QCursor cursor() const;
void setCursor(const QCursor &cursor);
bool hasCursor() const;
void unsetCursor();


# 211 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
bool isVisible() const;
bool isVisibleTo(const QGraphicsItem *parent) const;
void setVisible(bool visible);
inline void hide() { setVisible(false); }
inline void show() { setVisible(true); }

bool isEnabled() const;
void setEnabled(bool enabled);

bool isSelected() const;
void setSelected(bool selected);

bool acceptDrops() const;
void setAcceptDrops(bool on);

qreal opacity() const;
qreal effectiveOpacity() const;
void setOpacity(qreal opacity);


# 231 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

QGraphicsEffect *graphicsEffect() const;
void setGraphicsEffect(QGraphicsEffect *effect);


# 236 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
Qt::MouseButtons acceptedMouseButtons() const;
void setAcceptedMouseButtons(Qt::MouseButtons buttons);

bool acceptsHoverEvents() const; 
void setAcceptsHoverEvents(bool enabled); 
bool acceptHoverEvents() const;
void setAcceptHoverEvents(bool enabled);
bool acceptTouchEvents() const;
void setAcceptTouchEvents(bool enabled);

bool filtersChildEvents() const;
void setFiltersChildEvents(bool enabled);

bool handlesChildEvents() const;
void setHandlesChildEvents(bool enabled);

bool isActive() const;
void setActive(bool active);

bool hasFocus() const;
void setFocus(Qt::FocusReason focusReason = Qt::OtherFocusReason);
void clearFocus();

QGraphicsItem *focusProxy() const;
void setFocusProxy(QGraphicsItem *item);

QGraphicsItem *focusItem() const;
QGraphicsItem *focusScopeItem() const;

void grabMouse();
void ungrabMouse();
void grabKeyboard();
void ungrabKeyboard();


QPointF pos() const;
inline qreal x() const { return pos().x(); }
void setX(qreal x);
inline qreal y() const { return pos().y(); }
void setY(qreal y);
QPointF scenePos() const;
void setPos(const QPointF &pos);
inline void setPos(qreal x, qreal y);
inline void moveBy(qreal dx, qreal dy) { setPos(pos().x() + dx, pos().y() + dy); }

void ensureVisible(const QRectF &rect = QRectF(), int xmargin = 50, int ymargin = 50);
inline void ensureVisible(qreal x, qreal y, qreal w, qreal h, int xmargin = 50, int ymargin = 50);


QMatrix matrix() const;
QMatrix sceneMatrix() const;
void setMatrix(const QMatrix &matrix, bool combine = false);
void resetMatrix();
QTransform transform() const;
QTransform sceneTransform() const;
QTransform deviceTransform(const QTransform &viewportTransform) const;
QTransform itemTransform(const QGraphicsItem *other, bool *ok = 0) const;
void setTransform(const QTransform &matrix, bool combine = false);
void resetTransform();

void rotate(qreal angle); 
void scale(qreal sx, qreal sy); 
void shear(qreal sh, qreal sv); 
void translate(qreal dx, qreal dy); 

void setRotation(qreal angle);
qreal rotation() const;

void setScale(qreal scale);
qreal scale() const;

QList<QGraphicsTransform *> transformations() const;
void setTransformations(const QList<QGraphicsTransform *> &transformations);

QPointF transformOriginPoint() const;
void setTransformOriginPoint(const QPointF &origin);
inline void setTransformOriginPoint(qreal ax, qreal ay)
{ setTransformOriginPoint(QPointF(ax,ay)); }

virtual void advance(int phase);


qreal zValue() const;
void setZValue(qreal z);
void stackBefore(const QGraphicsItem *sibling);


virtual QRectF boundingRect() const = 0;
QRectF childrenBoundingRect() const;
QRectF sceneBoundingRect() const;
virtual QPainterPath shape() const;
bool isClipped() const;
QPainterPath clipPath() const;
virtual bool contains(const QPointF &point) const;
virtual bool collidesWithItem(const QGraphicsItem *other, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
virtual bool collidesWithPath(const QPainterPath &path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
QList<QGraphicsItem *> collidingItems(Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
bool isObscured() const;
bool isObscured(const QRectF &rect) const; 
inline bool isObscured(qreal x, qreal y, qreal w, qreal h) const;
virtual bool isObscuredBy(const QGraphicsItem *item) const;
virtual QPainterPath opaqueArea() const;

QRegion boundingRegion(const QTransform &itemToDeviceTransform) const;
qreal boundingRegionGranularity() const;
void setBoundingRegionGranularity(qreal granularity);


virtual void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0) = 0;
void update(const QRectF &rect = QRectF());
inline void update(qreal x, qreal y, qreal width, qreal height);
void scroll(qreal dx, qreal dy, const QRectF &rect = QRectF());


QPointF mapToItem(const QGraphicsItem *item, const QPointF &point) const;
QPointF mapToParent(const QPointF &point) const;
QPointF mapToScene(const QPointF &point) const;
QPolygonF mapToItem(const QGraphicsItem *item, const QRectF &rect) const;
QPolygonF mapToParent(const QRectF &rect) const;
QPolygonF mapToScene(const QRectF &rect) const;
QRectF mapRectToItem(const QGraphicsItem *item, const QRectF &rect) const;
QRectF mapRectToParent(const QRectF &rect) const;
QRectF mapRectToScene(const QRectF &rect) const;
QPolygonF mapToItem(const QGraphicsItem *item, const QPolygonF &polygon) const;
QPolygonF mapToParent(const QPolygonF &polygon) const;
QPolygonF mapToScene(const QPolygonF &polygon) const;
QPainterPath mapToItem(const QGraphicsItem *item, const QPainterPath &path) const;
QPainterPath mapToParent(const QPainterPath &path) const;
QPainterPath mapToScene(const QPainterPath &path) const;
QPointF mapFromItem(const QGraphicsItem *item, const QPointF &point) const;
QPointF mapFromParent(const QPointF &point) const;
QPointF mapFromScene(const QPointF &point) const;
QPolygonF mapFromItem(const QGraphicsItem *item, const QRectF &rect) const;
QPolygonF mapFromParent(const QRectF &rect) const;
QPolygonF mapFromScene(const QRectF &rect) const;
QRectF mapRectFromItem(const QGraphicsItem *item, const QRectF &rect) const;
QRectF mapRectFromParent(const QRectF &rect) const;
QRectF mapRectFromScene(const QRectF &rect) const;
QPolygonF mapFromItem(const QGraphicsItem *item, const QPolygonF &polygon) const;
QPolygonF mapFromParent(const QPolygonF &polygon) const;
QPolygonF mapFromScene(const QPolygonF &polygon) const;
QPainterPath mapFromItem(const QGraphicsItem *item, const QPainterPath &path) const;
QPainterPath mapFromParent(const QPainterPath &path) const;
QPainterPath mapFromScene(const QPainterPath &path) const;

inline QPointF mapToItem(const QGraphicsItem *item, qreal x, qreal y) const;
inline QPointF mapToParent(qreal x, qreal y) const;
inline QPointF mapToScene(qreal x, qreal y) const;
inline QPolygonF mapToItem(const QGraphicsItem *item, qreal x, qreal y, qreal w, qreal h) const;
inline QPolygonF mapToParent(qreal x, qreal y, qreal w, qreal h) const;
inline QPolygonF mapToScene(qreal x, qreal y, qreal w, qreal h) const;
inline QRectF mapRectToItem(const QGraphicsItem *item, qreal x, qreal y, qreal w, qreal h) const;
inline QRectF mapRectToParent(qreal x, qreal y, qreal w, qreal h) const;
inline QRectF mapRectToScene(qreal x, qreal y, qreal w, qreal h) const;
inline QPointF mapFromItem(const QGraphicsItem *item, qreal x, qreal y) const;
inline QPointF mapFromParent(qreal x, qreal y) const;
inline QPointF mapFromScene(qreal x, qreal y) const;
inline QPolygonF mapFromItem(const QGraphicsItem *item, qreal x, qreal y, qreal w, qreal h) const;
inline QPolygonF mapFromParent(qreal x, qreal y, qreal w, qreal h) const;
inline QPolygonF mapFromScene(qreal x, qreal y, qreal w, qreal h) const;
inline QRectF mapRectFromItem(const QGraphicsItem *item, qreal x, qreal y, qreal w, qreal h) const;
inline QRectF mapRectFromParent(qreal x, qreal y, qreal w, qreal h) const;
inline QRectF mapRectFromScene(qreal x, qreal y, qreal w, qreal h) const;

bool isAncestorOf(const QGraphicsItem *child) const;
QGraphicsItem *commonAncestorItem(const QGraphicsItem *other) const;
bool isUnderMouse() const;


QVariant data(int key) const;
void setData(int key, const QVariant &value);

Qt::InputMethodHints inputMethodHints() const;
void setInputMethodHints(Qt::InputMethodHints hints);

enum {
Type = 1,
UserType = 65536
};
virtual int type() const;

void installSceneEventFilter(QGraphicsItem *filterItem);
void removeSceneEventFilter(QGraphicsItem *filterItem);

protected:
virtual bool sceneEventFilter(QGraphicsItem *watched, QEvent *event);
virtual bool sceneEvent(QEvent *event);
virtual void contextMenuEvent(QGraphicsSceneContextMenuEvent *event);
virtual void dragEnterEvent(QGraphicsSceneDragDropEvent *event);
virtual void dragLeaveEvent(QGraphicsSceneDragDropEvent *event);
virtual void dragMoveEvent(QGraphicsSceneDragDropEvent *event);
virtual void dropEvent(QGraphicsSceneDragDropEvent *event);
virtual void focusInEvent(QFocusEvent *event);
virtual void focusOutEvent(QFocusEvent *event);
virtual void hoverEnterEvent(QGraphicsSceneHoverEvent *event);
virtual void hoverMoveEvent(QGraphicsSceneHoverEvent *event);
virtual void hoverLeaveEvent(QGraphicsSceneHoverEvent *event);
virtual void keyPressEvent(QKeyEvent *event);
virtual void keyReleaseEvent(QKeyEvent *event);
virtual void mousePressEvent(QGraphicsSceneMouseEvent *event);
virtual void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
virtual void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
virtual void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event);
virtual void wheelEvent(QGraphicsSceneWheelEvent *event);
virtual void inputMethodEvent(QInputMethodEvent *event);
virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const;

virtual QVariant itemChange(GraphicsItemChange change, const QVariant &value);

enum Extension {
UserExtension = 0x80000000
};
virtual bool supportsExtension(Extension extension) const;
virtual void setExtension(Extension extension, const QVariant &variant);
virtual QVariant extension(const QVariant &variant) const;

protected:
QGraphicsItem(QGraphicsItemPrivate &dd,
QGraphicsItem *parent, QGraphicsScene *scene);
QScopedPointer<QGraphicsItemPrivate> d_ptr;

void addToIndex();
void removeFromIndex();
void prepareGeometryChange();

private:
QGraphicsItem(const QGraphicsItem &); QGraphicsItem &operator=(const QGraphicsItem &);
inline QGraphicsItemPrivate* d_func() { return reinterpret_cast<QGraphicsItemPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsItemPrivate* d_func() const { return reinterpret_cast<const QGraphicsItemPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsItemPrivate;
friend class QGraphicsItemGroup;
friend class QGraphicsScene;
friend class QGraphicsScenePrivate;
friend class QGraphicsSceneFindItemBspTreeVisitor;
friend class QGraphicsSceneBspTree;
friend class QGraphicsView;
friend class QGraphicsViewPrivate;
friend class QGraphicsObject;
friend class QGraphicsWidget;
friend class QGraphicsWidgetPrivate;
friend class QGraphicsProxyWidgetPrivate;
friend class QGraphicsSceneIndex;
friend class QGraphicsSceneIndexPrivate;
friend class QGraphicsSceneBspTreeIndex;
friend class QGraphicsSceneBspTreeIndexPrivate;
friend class QGraphicsItemEffectSourcePrivate;
friend class QGraphicsTransformPrivate;
friend class QGestureManager;
friend class ::tst_QGraphicsItem;
friend bool qt_closestLeaf(const QGraphicsItem *, const QGraphicsItem *);
friend bool qt_closestItemFirst(const QGraphicsItem *, const QGraphicsItem *);
};

inline QFlags<QGraphicsItem::GraphicsItemFlags::enum_type> operator|(QGraphicsItem::GraphicsItemFlags::enum_type f1, QGraphicsItem::GraphicsItemFlags::enum_type f2) { return QFlags<QGraphicsItem::GraphicsItemFlags::enum_type>(f1) | f2; } inline QFlags<QGraphicsItem::GraphicsItemFlags::enum_type> operator|(QGraphicsItem::GraphicsItemFlags::enum_type f1, QFlags<QGraphicsItem::GraphicsItemFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QGraphicsItem::GraphicsItemFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
template <> inline const char *qobject_interface_iid<QGraphicsItem *>() { return "com.trolltech.Qt.QGraphicsItem"; } template <> inline QGraphicsItem *qobject_cast<QGraphicsItem *>(QObject *object) { return reinterpret_cast<QGraphicsItem *>((object ? object->qt_metacast("com.trolltech.Qt.QGraphicsItem") : 0)); } template <> inline QGraphicsItem *qobject_cast<QGraphicsItem *>(const QObject *object) { return reinterpret_cast<QGraphicsItem *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QGraphicsItem") : 0)); }

inline void QGraphicsItem::setPos(qreal ax, qreal ay)
{ setPos(QPointF(ax, ay)); }
inline void QGraphicsItem::ensureVisible(qreal ax, qreal ay, qreal w, qreal h, int xmargin, int ymargin)
{ ensureVisible(QRectF(ax, ay, w, h), xmargin, ymargin); }
inline void QGraphicsItem::update(qreal ax, qreal ay, qreal width, qreal height)
{ update(QRectF(ax, ay, width, height)); }
inline bool QGraphicsItem::isObscured(qreal ax, qreal ay, qreal w, qreal h) const
{ return isObscured(QRectF(ax, ay, w, h)); }
inline QPointF QGraphicsItem::mapToItem(const QGraphicsItem *item, qreal ax, qreal ay) const
{ return mapToItem(item, QPointF(ax, ay)); }
inline QPointF QGraphicsItem::mapToParent(qreal ax, qreal ay) const
{ return mapToParent(QPointF(ax, ay)); }
inline QPointF QGraphicsItem::mapToScene(qreal ax, qreal ay) const
{ return mapToScene(QPointF(ax, ay)); }
inline QPointF QGraphicsItem::mapFromItem(const QGraphicsItem *item, qreal ax, qreal ay) const
{ return mapFromItem(item, QPointF(ax, ay)); }
inline QPointF QGraphicsItem::mapFromParent(qreal ax, qreal ay) const
{ return mapFromParent(QPointF(ax, ay)); }
inline QPointF QGraphicsItem::mapFromScene(qreal ax, qreal ay) const
{ return mapFromScene(QPointF(ax, ay)); }
inline QPolygonF QGraphicsItem::mapToItem(const QGraphicsItem *item, qreal ax, qreal ay, qreal w, qreal h) const
{ return mapToItem(item, QRectF(ax, ay, w, h)); }
inline QPolygonF QGraphicsItem::mapToParent(qreal ax, qreal ay, qreal w, qreal h) const
{ return mapToParent(QRectF(ax, ay, w, h)); }
inline QPolygonF QGraphicsItem::mapToScene(qreal ax, qreal ay, qreal w, qreal h) const
{ return mapToScene(QRectF(ax, ay, w, h)); }
inline QRectF QGraphicsItem::mapRectToItem(const QGraphicsItem *item, qreal ax, qreal ay, qreal w, qreal h) const
{ return mapRectToItem(item, QRectF(ax, ay, w, h)); }
inline QRectF QGraphicsItem::mapRectToParent(qreal ax, qreal ay, qreal w, qreal h) const
{ return mapRectToParent(QRectF(ax, ay, w, h)); }
inline QRectF QGraphicsItem::mapRectToScene(qreal ax, qreal ay, qreal w, qreal h) const
{ return mapRectToScene(QRectF(ax, ay, w, h)); }
inline QPolygonF QGraphicsItem::mapFromItem(const QGraphicsItem *item, qreal ax, qreal ay, qreal w, qreal h) const
{ return mapFromItem(item, QRectF(ax, ay, w, h)); }
inline QPolygonF QGraphicsItem::mapFromParent(qreal ax, qreal ay, qreal w, qreal h) const
{ return mapFromParent(QRectF(ax, ay, w, h)); }
inline QPolygonF QGraphicsItem::mapFromScene(qreal ax, qreal ay, qreal w, qreal h) const
{ return mapFromScene(QRectF(ax, ay, w, h)); }
inline QRectF QGraphicsItem::mapRectFromItem(const QGraphicsItem *item, qreal ax, qreal ay, qreal w, qreal h) const
{ return mapRectFromItem(item, QRectF(ax, ay, w, h)); }
inline QRectF QGraphicsItem::mapRectFromParent(qreal ax, qreal ay, qreal w, qreal h) const
{ return mapRectFromParent(QRectF(ax, ay, w, h)); }
inline QRectF QGraphicsItem::mapRectFromScene(qreal ax, qreal ay, qreal w, qreal h) const
{ return mapRectFromScene(QRectF(ax, ay, w, h)); }


class  QGraphicsObject : public QObject, public QGraphicsItem
{
Q_OBJECT
Q_PROPERTY(QGraphicsObject * parent READ parentObject WRITE setParentItem NOTIFY parentChanged DESIGNABLE false)
Q_PROPERTY(qreal opacity READ opacity WRITE setOpacity NOTIFY opacityChanged FINAL)
Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled NOTIFY enabledChanged)
Q_PROPERTY(bool visible READ isVisible WRITE setVisible NOTIFY visibleChanged FINAL)
Q_PROPERTY(QPointF pos READ pos WRITE setPos)
Q_PROPERTY(qreal x READ x WRITE setX NOTIFY xChanged)
Q_PROPERTY(qreal y READ y WRITE setY NOTIFY yChanged)
Q_PROPERTY(qreal z READ zValue WRITE setZValue NOTIFY zChanged)
Q_PROPERTY(qreal rotation READ rotation WRITE setRotation NOTIFY rotationChanged)
Q_PROPERTY(qreal scale READ scale WRITE setScale NOTIFY scaleChanged)
Q_PROPERTY(QPointF transformOriginPoint READ transformOriginPoint WRITE setTransformOriginPoint)

public:
QGraphicsObject(QGraphicsItem *parent = 0);



# 556 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
const QObjectList &children() const { return QObject::children(); }




# 561 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
void grabGesture(Qt::GestureType type, Qt::GestureFlags flags = Qt::GestureFlags());
void ungrabGesture(Qt::GestureType type);

signals:
void parentChanged();
void opacityChanged();
void visibleChanged();
void enabledChanged();
void xChanged();
void yChanged();
void zChanged();
void rotationChanged();
void scaleChanged();

protected:
QGraphicsObject(QGraphicsItemPrivate &dd, QGraphicsItem *parent, QGraphicsScene *scene);
private:
friend class QGraphicsItem;
friend class QGraphicsItemPrivate;
};


class QAbstractGraphicsShapeItemPrivate;
class  QAbstractGraphicsShapeItem : public QGraphicsItem
{
public:
QAbstractGraphicsShapeItem(QGraphicsItem *parent = 0

# 589 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 592 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
~QAbstractGraphicsShapeItem();

QPen pen() const;
void setPen(const QPen &pen);

QBrush brush() const;
void setBrush(const QBrush &brush);

bool isObscuredBy(const QGraphicsItem *item) const;
QPainterPath opaqueArea() const;

protected:
QAbstractGraphicsShapeItem(QAbstractGraphicsShapeItemPrivate &dd,
QGraphicsItem *parent, QGraphicsScene *scene);

private:
QAbstractGraphicsShapeItem(const QAbstractGraphicsShapeItem &); QAbstractGraphicsShapeItem &operator=(const QAbstractGraphicsShapeItem &);
inline QAbstractGraphicsShapeItemPrivate* d_func() { return reinterpret_cast<QAbstractGraphicsShapeItemPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractGraphicsShapeItemPrivate* d_func() const { return reinterpret_cast<const QAbstractGraphicsShapeItemPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractGraphicsShapeItemPrivate;
};

class QGraphicsPathItemPrivate;
class  QGraphicsPathItem : public QAbstractGraphicsShapeItem
{
public:
QGraphicsPathItem(QGraphicsItem *parent = 0

# 619 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 622 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
QGraphicsPathItem(const QPainterPath &path, QGraphicsItem *parent = 0

# 625 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 628 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
~QGraphicsPathItem();

QPainterPath path() const;
void setPath(const QPainterPath &path);

QRectF boundingRect() const;
QPainterPath shape() const;
bool contains(const QPointF &point) const;

void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0);

bool isObscuredBy(const QGraphicsItem *item) const;
QPainterPath opaqueArea() const;

enum { Type = 2 };
int type() const;

protected:
bool supportsExtension(Extension extension) const;
void setExtension(Extension extension, const QVariant &variant);
QVariant extension(const QVariant &variant) const;

private:
QGraphicsPathItem(const QGraphicsPathItem &); QGraphicsPathItem &operator=(const QGraphicsPathItem &);
inline QGraphicsPathItemPrivate* d_func() { return reinterpret_cast<QGraphicsPathItemPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsPathItemPrivate* d_func() const { return reinterpret_cast<const QGraphicsPathItemPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsPathItemPrivate;
};

class QGraphicsRectItemPrivate;
class  QGraphicsRectItem : public QAbstractGraphicsShapeItem
{
public:
QGraphicsRectItem(QGraphicsItem *parent = 0

# 662 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 665 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
QGraphicsRectItem(const QRectF &rect, QGraphicsItem *parent = 0

# 668 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 671 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
QGraphicsRectItem(qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent = 0

# 674 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 677 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
~QGraphicsRectItem();

QRectF rect() const;
void setRect(const QRectF &rect);
inline void setRect(qreal x, qreal y, qreal w, qreal h);

QRectF boundingRect() const;
QPainterPath shape() const;
bool contains(const QPointF &point) const;

void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0);

bool isObscuredBy(const QGraphicsItem *item) const;
QPainterPath opaqueArea() const;

enum { Type = 3 };
int type() const;

protected:
bool supportsExtension(Extension extension) const;
void setExtension(Extension extension, const QVariant &variant);
QVariant extension(const QVariant &variant) const;

private:
QGraphicsRectItem(const QGraphicsRectItem &); QGraphicsRectItem &operator=(const QGraphicsRectItem &);
inline QGraphicsRectItemPrivate* d_func() { return reinterpret_cast<QGraphicsRectItemPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsRectItemPrivate* d_func() const { return reinterpret_cast<const QGraphicsRectItemPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsRectItemPrivate;
};

inline void QGraphicsRectItem::setRect(qreal ax, qreal ay, qreal w, qreal h)
{ setRect(QRectF(ax, ay, w, h)); }

class QGraphicsEllipseItemPrivate;
class  QGraphicsEllipseItem : public QAbstractGraphicsShapeItem
{
public:
QGraphicsEllipseItem(QGraphicsItem *parent = 0

# 715 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 718 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
QGraphicsEllipseItem(const QRectF &rect, QGraphicsItem *parent = 0

# 721 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 724 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
QGraphicsEllipseItem(qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent = 0

# 727 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 730 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
~QGraphicsEllipseItem();

QRectF rect() const;
void setRect(const QRectF &rect);
inline void setRect(qreal x, qreal y, qreal w, qreal h);

int startAngle() const;
void setStartAngle(int angle);

int spanAngle() const;
void setSpanAngle(int angle);

QRectF boundingRect() const;
QPainterPath shape() const;
bool contains(const QPointF &point) const;

void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0);

bool isObscuredBy(const QGraphicsItem *item) const;
QPainterPath opaqueArea() const;

enum { Type = 4 };
int type() const;

protected:
bool supportsExtension(Extension extension) const;
void setExtension(Extension extension, const QVariant &variant);
QVariant extension(const QVariant &variant) const;

private:
QGraphicsEllipseItem(const QGraphicsEllipseItem &); QGraphicsEllipseItem &operator=(const QGraphicsEllipseItem &);
inline QGraphicsEllipseItemPrivate* d_func() { return reinterpret_cast<QGraphicsEllipseItemPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsEllipseItemPrivate* d_func() const { return reinterpret_cast<const QGraphicsEllipseItemPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsEllipseItemPrivate;
};

inline void QGraphicsEllipseItem::setRect(qreal ax, qreal ay, qreal w, qreal h)
{ setRect(QRectF(ax, ay, w, h)); }

class QGraphicsPolygonItemPrivate;
class  QGraphicsPolygonItem : public QAbstractGraphicsShapeItem
{
public:
QGraphicsPolygonItem(QGraphicsItem *parent = 0

# 774 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 777 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
QGraphicsPolygonItem(const QPolygonF &polygon,
QGraphicsItem *parent = 0

# 781 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 784 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
~QGraphicsPolygonItem();

QPolygonF polygon() const;
void setPolygon(const QPolygonF &polygon);

Qt::FillRule fillRule() const;
void setFillRule(Qt::FillRule rule);

QRectF boundingRect() const;
QPainterPath shape() const;
bool contains(const QPointF &point) const;

void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0);

bool isObscuredBy(const QGraphicsItem *item) const;
QPainterPath opaqueArea() const;

enum { Type = 5 };
int type() const;

protected:
bool supportsExtension(Extension extension) const;
void setExtension(Extension extension, const QVariant &variant);
QVariant extension(const QVariant &variant) const;

private:
QGraphicsPolygonItem(const QGraphicsPolygonItem &); QGraphicsPolygonItem &operator=(const QGraphicsPolygonItem &);
inline QGraphicsPolygonItemPrivate* d_func() { return reinterpret_cast<QGraphicsPolygonItemPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsPolygonItemPrivate* d_func() const { return reinterpret_cast<const QGraphicsPolygonItemPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsPolygonItemPrivate;
};

class QGraphicsLineItemPrivate;
class  QGraphicsLineItem : public QGraphicsItem
{
public:
QGraphicsLineItem(QGraphicsItem *parent = 0

# 821 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 824 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
QGraphicsLineItem(const QLineF &line, QGraphicsItem *parent = 0

# 827 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 830 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
QGraphicsLineItem(qreal x1, qreal y1, qreal x2, qreal y2, QGraphicsItem *parent = 0

# 833 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 836 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
~QGraphicsLineItem();

QPen pen() const;
void setPen(const QPen &pen);

QLineF line() const;
void setLine(const QLineF &line);
inline void setLine(qreal x1, qreal y1, qreal x2, qreal y2)
{ setLine(QLineF(x1, y1, x2, y2)); }

QRectF boundingRect() const;
QPainterPath shape() const;
bool contains(const QPointF &point) const;

void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0);

bool isObscuredBy(const QGraphicsItem *item) const;
QPainterPath opaqueArea() const;

enum { Type = 6 };
int type() const;

protected:
bool supportsExtension(Extension extension) const;
void setExtension(Extension extension, const QVariant &variant);
QVariant extension(const QVariant &variant) const;

private:
QGraphicsLineItem(const QGraphicsLineItem &); QGraphicsLineItem &operator=(const QGraphicsLineItem &);
inline QGraphicsLineItemPrivate* d_func() { return reinterpret_cast<QGraphicsLineItemPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsLineItemPrivate* d_func() const { return reinterpret_cast<const QGraphicsLineItemPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsLineItemPrivate;
};

class QGraphicsPixmapItemPrivate;
class  QGraphicsPixmapItem : public QGraphicsItem
{
public:
enum ShapeMode {
MaskShape,
BoundingRectShape,
HeuristicMaskShape
};

QGraphicsPixmapItem(QGraphicsItem *parent = 0

# 881 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 884 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
QGraphicsPixmapItem(const QPixmap &pixmap, QGraphicsItem *parent = 0

# 887 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 890 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
~QGraphicsPixmapItem();

QPixmap pixmap() const;
void setPixmap(const QPixmap &pixmap);

Qt::TransformationMode transformationMode() const;
void setTransformationMode(Qt::TransformationMode mode);

QPointF offset() const;
void setOffset(const QPointF &offset);
inline void setOffset(qreal x, qreal y);

QRectF boundingRect() const;
QPainterPath shape() const;
bool contains(const QPointF &point) const;

void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);

bool isObscuredBy(const QGraphicsItem *item) const;
QPainterPath opaqueArea() const;

enum { Type = 7 };
int type() const;

ShapeMode shapeMode() const;
void setShapeMode(ShapeMode mode);

protected:
bool supportsExtension(Extension extension) const;
void setExtension(Extension extension, const QVariant &variant);
QVariant extension(const QVariant &variant) const;

private:
QGraphicsPixmapItem(const QGraphicsPixmapItem &); QGraphicsPixmapItem &operator=(const QGraphicsPixmapItem &);
inline QGraphicsPixmapItemPrivate* d_func() { return reinterpret_cast<QGraphicsPixmapItemPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsPixmapItemPrivate* d_func() const { return reinterpret_cast<const QGraphicsPixmapItemPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsPixmapItemPrivate;
};

inline void QGraphicsPixmapItem::setOffset(qreal ax, qreal ay)
{ setOffset(QPointF(ax, ay)); }

class QGraphicsTextItemPrivate;
class QTextDocument;
class QTextCursor;
class  QGraphicsTextItem : public QGraphicsObject
{
Q_OBJECT



public:
QGraphicsTextItem(QGraphicsItem *parent = 0

# 943 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 946 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
QGraphicsTextItem(const QString &text, QGraphicsItem *parent = 0

# 949 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 952 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
~QGraphicsTextItem();

QString toHtml() const;
void setHtml(const QString &html);

QString toPlainText() const;
void setPlainText(const QString &text);

QFont font() const;
void setFont(const QFont &font);

void setDefaultTextColor(const QColor &c);
QColor defaultTextColor() const;

QRectF boundingRect() const;
QPainterPath shape() const;
bool contains(const QPointF &point) const;

void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);

bool isObscuredBy(const QGraphicsItem *item) const;
QPainterPath opaqueArea() const;

enum { Type = 8 };
int type() const;

void setTextWidth(qreal width);
qreal textWidth() const;

void adjustSize();

void setDocument(QTextDocument *document);
QTextDocument *document() const;

void setTextInteractionFlags(Qt::TextInteractionFlags flags);
Qt::TextInteractionFlags textInteractionFlags() const;

void setTabChangesFocus(bool b);
bool tabChangesFocus() const;

void setOpenExternalLinks(bool open);
bool openExternalLinks() const;

void setTextCursor(const QTextCursor &cursor);
QTextCursor textCursor() const;

signals:
void linkActivated(const QString &);
void linkHovered(const QString &);

protected:
bool sceneEvent(QEvent *event);
void mousePressEvent(QGraphicsSceneMouseEvent *event);
void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event);
void contextMenuEvent(QGraphicsSceneContextMenuEvent *event);
void keyPressEvent(QKeyEvent *event);
void keyReleaseEvent(QKeyEvent *event);
void focusInEvent(QFocusEvent *event);
void focusOutEvent(QFocusEvent *event);
void dragEnterEvent(QGraphicsSceneDragDropEvent *event);
void dragLeaveEvent(QGraphicsSceneDragDropEvent *event);
void dragMoveEvent(QGraphicsSceneDragDropEvent *event);
void dropEvent(QGraphicsSceneDragDropEvent *event);
void inputMethodEvent(QInputMethodEvent *event);
void hoverEnterEvent(QGraphicsSceneHoverEvent *event);
void hoverMoveEvent(QGraphicsSceneHoverEvent *event);
void hoverLeaveEvent(QGraphicsSceneHoverEvent *event);

QVariant inputMethodQuery(Qt::InputMethodQuery query) const;

bool supportsExtension(Extension extension) const;
void setExtension(Extension extension, const QVariant &variant);
QVariant extension(const QVariant &variant) const;

private:
QGraphicsTextItem(const QGraphicsTextItem &); QGraphicsTextItem &operator=(const QGraphicsTextItem &);



QGraphicsTextItemPrivate *dd;
friend class QGraphicsTextItemPrivate;
};

class QGraphicsSimpleTextItemPrivate;
class  QGraphicsSimpleTextItem : public QAbstractGraphicsShapeItem
{
public:
QGraphicsSimpleTextItem(QGraphicsItem *parent = 0

# 1044 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 1047 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
QGraphicsSimpleTextItem(const QString &text, QGraphicsItem *parent = 0

# 1050 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 1053 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
~QGraphicsSimpleTextItem();

void setText(const QString &text);
QString text() const;

void setFont(const QFont &font);
QFont font() const;

QRectF boundingRect() const;
QPainterPath shape() const;
bool contains(const QPointF &point) const;

void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);

bool isObscuredBy(const QGraphicsItem *item) const;
QPainterPath opaqueArea() const;

enum { Type = 9 };
int type() const;

protected:
bool supportsExtension(Extension extension) const;
void setExtension(Extension extension, const QVariant &variant);
QVariant extension(const QVariant &variant) const;

private:
QGraphicsSimpleTextItem(const QGraphicsSimpleTextItem &); QGraphicsSimpleTextItem &operator=(const QGraphicsSimpleTextItem &);
inline QGraphicsSimpleTextItemPrivate* d_func() { return reinterpret_cast<QGraphicsSimpleTextItemPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsSimpleTextItemPrivate* d_func() const { return reinterpret_cast<const QGraphicsSimpleTextItemPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsSimpleTextItemPrivate;
};

class QGraphicsItemGroupPrivate;
class  QGraphicsItemGroup : public QGraphicsItem
{
public:
QGraphicsItemGroup(QGraphicsItem *parent = 0

# 1090 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"

, QGraphicsScene *scene = 0

# 1093 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
);
~QGraphicsItemGroup();

void addToGroup(QGraphicsItem *item);
void removeFromGroup(QGraphicsItem *item);

QRectF boundingRect() const;
void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0);

bool isObscuredBy(const QGraphicsItem *item) const;
QPainterPath opaqueArea() const;

enum { Type = 10 };
int type() const;

private:
QGraphicsItemGroup(const QGraphicsItemGroup &); QGraphicsItemGroup &operator=(const QGraphicsItemGroup &);
inline QGraphicsItemGroupPrivate* d_func() { return reinterpret_cast<QGraphicsItemGroupPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsItemGroupPrivate* d_func() const { return reinterpret_cast<const QGraphicsItemGroupPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsItemGroupPrivate;
};

template <class T> inline T qgraphicsitem_cast(QGraphicsItem *item)
{
return int(static_cast<T>(0)->Type) == int(QGraphicsItem::Type)
|| (item && int(static_cast<T>(0)->Type) == item->type()) ? static_cast<T>(item) : 0;
}

template <class T> inline T qgraphicsitem_cast(const QGraphicsItem *item)
{
return int(static_cast<T>(0)->Type) == int(QGraphicsItem::Type)
|| (item && int(static_cast<T>(0)->Type) == item->type()) ? static_cast<T>(item) : 0;
}


# 1126 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"
 QDebug operator<<(QDebug debug, QGraphicsItem *item);
 QDebug operator<<(QDebug debug, QGraphicsObject *item);
 QDebug operator<<(QDebug debug, QGraphicsItem::GraphicsItemChange change);
 QDebug operator<<(QDebug debug, QGraphicsItem::GraphicsItemFlag flag);
 QDebug operator<<(QDebug debug, QGraphicsItem::GraphicsItemFlags flags);


# 1133 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"


 template <> struct QMetaTypeId< QGraphicsItem * > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QGraphicsItem * >("QGraphicsItem *"); return metatype_id; } }; 
 template <> struct QMetaTypeId< QGraphicsScene * > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (!metatype_id) metatype_id = qRegisterMetaType< QGraphicsScene * >("QGraphicsScene *"); return metatype_id; } }; 





# 1142 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"





# 45 "/usr/share/qt4/include/QtGui/qgraphicsanchorlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qgraphicslayout.h"












































# 1 "/usr/share/qt4/include/QtGui/qgraphicslayoutitem.h"












































# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgraphicslayoutitem.h"

# 1 "/usr/share/qt4/include/QtGui/qsizepolicy.h"






































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qgraphicslayoutitem.h"

# 1 "/usr/share/qt4/include/QtGui/qevent.h"



















































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qgraphicslayoutitem.h"


# 49 "/usr/share/qt4/include/QtGui/qgraphicslayoutitem.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 57 "/usr/share/qt4/include/QtGui/qgraphicslayoutitem.h"
class QGraphicsLayoutItemPrivate;
class QGraphicsItem;
class  QGraphicsLayoutItem
{
public:
QGraphicsLayoutItem(QGraphicsLayoutItem *parent = 0, bool isLayout = false);
virtual ~QGraphicsLayoutItem();

void setSizePolicy(const QSizePolicy &policy);
void setSizePolicy(QSizePolicy::Policy hPolicy, QSizePolicy::Policy vPolicy, QSizePolicy::ControlType controlType = QSizePolicy::DefaultType);
QSizePolicy sizePolicy() const;

void setMinimumSize(const QSizeF &size);
inline void setMinimumSize(qreal w, qreal h);
QSizeF minimumSize() const;
void setMinimumWidth(qreal width);
inline qreal minimumWidth() const;
void setMinimumHeight(qreal height);
inline qreal minimumHeight() const;

void setPreferredSize(const QSizeF &size);
inline void setPreferredSize(qreal w, qreal h);
QSizeF preferredSize() const;
void setPreferredWidth(qreal width);
inline qreal preferredWidth() const;
void setPreferredHeight(qreal height);
inline qreal preferredHeight() const;

void setMaximumSize(const QSizeF &size);
inline void setMaximumSize(qreal w, qreal h);
QSizeF maximumSize() const;
void setMaximumWidth(qreal width);
inline qreal maximumWidth() const;
void setMaximumHeight(qreal height);
inline qreal maximumHeight() const;

virtual void setGeometry(const QRectF &rect);
QRectF geometry() const;
virtual void getContentsMargins(qreal *left, qreal *top, qreal *right, qreal *bottom) const;
QRectF contentsRect() const;

QSizeF effectiveSizeHint(Qt::SizeHint which, const QSizeF &constraint = QSizeF()) const;

virtual void updateGeometry(); 

QGraphicsLayoutItem *parentLayoutItem() const;
void setParentLayoutItem(QGraphicsLayoutItem *parent);

bool isLayout() const;

QGraphicsItem *graphicsItem() const;
bool ownedByLayout() const;

protected:
void setGraphicsItem(QGraphicsItem *item);
void setOwnedByLayout(bool ownedByLayout);
QGraphicsLayoutItem(QGraphicsLayoutItemPrivate &dd);

virtual QSizeF sizeHint(Qt::SizeHint which, const QSizeF &constraint = QSizeF()) const = 0;
QScopedPointer<QGraphicsLayoutItemPrivate> d_ptr;

private:
QSizeF *effectiveSizeHints(const QSizeF &constraint) const;
inline QGraphicsLayoutItemPrivate* d_func() { return reinterpret_cast<QGraphicsLayoutItemPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsLayoutItemPrivate* d_func() const { return reinterpret_cast<const QGraphicsLayoutItemPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsLayoutItemPrivate;

friend class QGraphicsLayout;
};

template <> inline const char *qobject_interface_iid<QGraphicsLayoutItem *>() { return "com.trolltech.Qt.QGraphicsLayoutItem"; } template <> inline QGraphicsLayoutItem *qobject_cast<QGraphicsLayoutItem *>(QObject *object) { return reinterpret_cast<QGraphicsLayoutItem *>((object ? object->qt_metacast("com.trolltech.Qt.QGraphicsLayoutItem") : 0)); } template <> inline QGraphicsLayoutItem *qobject_cast<QGraphicsLayoutItem *>(const QObject *object) { return reinterpret_cast<QGraphicsLayoutItem *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QGraphicsLayoutItem") : 0)); }

inline void QGraphicsLayoutItem::setMinimumSize(qreal aw, qreal ah)
{ setMinimumSize(QSizeF(aw, ah)); }
inline void QGraphicsLayoutItem::setPreferredSize(qreal aw, qreal ah)
{ setPreferredSize(QSizeF(aw, ah)); }
inline void QGraphicsLayoutItem::setMaximumSize(qreal aw, qreal ah)
{ setMaximumSize(QSizeF(aw, ah)); }

inline qreal QGraphicsLayoutItem::minimumWidth() const
{ return effectiveSizeHint(Qt::MinimumSize).width(); }
inline qreal QGraphicsLayoutItem::minimumHeight() const
{ return effectiveSizeHint(Qt::MinimumSize).height(); }

inline qreal QGraphicsLayoutItem::preferredWidth() const
{ return effectiveSizeHint(Qt::PreferredSize).width(); }
inline qreal QGraphicsLayoutItem::preferredHeight() const
{ return effectiveSizeHint(Qt::PreferredSize).height(); }

inline qreal QGraphicsLayoutItem::maximumWidth() const
{ return effectiveSizeHint(Qt::MaximumSize).width(); }
inline qreal QGraphicsLayoutItem::maximumHeight() const
{ return effectiveSizeHint(Qt::MaximumSize).height(); }



# 151 "/usr/share/qt4/include/QtGui/qgraphicslayoutitem.h"





# 45 "/usr/share/qt4/include/QtGui/qgraphicslayout.h"


# 47 "/usr/share/qt4/include/QtGui/qgraphicslayout.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qgraphicslayout.h"
class QGraphicsLayoutPrivate;
class QGraphicsLayoutItem;
class QGraphicsWidget;

class  QGraphicsLayout : public QGraphicsLayoutItem
{
public:
QGraphicsLayout(QGraphicsLayoutItem *parent = 0);
~QGraphicsLayout();

void setContentsMargins(qreal left, qreal top, qreal right, qreal bottom);
void getContentsMargins(qreal *left, qreal *top, qreal *right, qreal *bottom) const;

void activate();
bool isActivated() const;
virtual void invalidate();
virtual void updateGeometry();

virtual void widgetEvent(QEvent *e);

virtual int count() const = 0;
virtual QGraphicsLayoutItem *itemAt(int i) const = 0;
virtual void removeAt(int index) = 0;

protected:
QGraphicsLayout(QGraphicsLayoutPrivate &, QGraphicsLayoutItem *);
void addChildLayoutItem(QGraphicsLayoutItem *layoutItem);

private:
QGraphicsLayout(const QGraphicsLayout &); QGraphicsLayout &operator=(const QGraphicsLayout &);
inline QGraphicsLayoutPrivate* d_func() { return reinterpret_cast<QGraphicsLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsLayoutPrivate* d_func() const { return reinterpret_cast<const QGraphicsLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsLayoutPrivate;
friend class QGraphicsWidget;
};

template <> inline const char *qobject_interface_iid<QGraphicsLayout *>() { return "com.trolltech.Qt.QGraphicsLayout"; } template <> inline QGraphicsLayout *qobject_cast<QGraphicsLayout *>(QObject *object) { return reinterpret_cast<QGraphicsLayout *>((object ? object->qt_metacast("com.trolltech.Qt.QGraphicsLayout") : 0)); } template <> inline QGraphicsLayout *qobject_cast<QGraphicsLayout *>(const QObject *object) { return reinterpret_cast<QGraphicsLayout *>((object ? const_cast<QObject *>(object)->qt_metacast("com.trolltech.Qt.QGraphicsLayout") : 0)); }



# 93 "/usr/share/qt4/include/QtGui/qgraphicslayout.h"






# 46 "/usr/share/qt4/include/QtGui/qgraphicsanchorlayout.h"



# 49 "/usr/share/qt4/include/QtGui/qgraphicsanchorlayout.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 57 "/usr/share/qt4/include/QtGui/qgraphicsanchorlayout.h"
class QGraphicsAnchorPrivate;
class QGraphicsAnchorLayout;
class QGraphicsAnchorLayoutPrivate;

class  QGraphicsAnchor : public QObject
{
Q_OBJECT
Q_PROPERTY(qreal spacing READ spacing WRITE setSpacing RESET unsetSpacing)
Q_PROPERTY(QSizePolicy::Policy sizePolicy READ sizePolicy WRITE setSizePolicy)
public:
void setSpacing(qreal spacing);
void unsetSpacing();
qreal spacing() const;
void setSizePolicy(QSizePolicy::Policy policy);
QSizePolicy::Policy sizePolicy() const;
~QGraphicsAnchor();
private:
QGraphicsAnchor(QGraphicsAnchorLayout *parent);

inline QGraphicsAnchorPrivate* d_func() { return reinterpret_cast<QGraphicsAnchorPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsAnchorPrivate* d_func() const { return reinterpret_cast<const QGraphicsAnchorPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsAnchorPrivate;

friend class QGraphicsAnchorLayoutPrivate;
friend struct AnchorData;
};

class  QGraphicsAnchorLayout : public QGraphicsLayout
{
public:
QGraphicsAnchorLayout(QGraphicsLayoutItem *parent = 0);
virtual ~QGraphicsAnchorLayout();

QGraphicsAnchor *addAnchor(QGraphicsLayoutItem *firstItem, Qt::AnchorPoint firstEdge,
QGraphicsLayoutItem *secondItem, Qt::AnchorPoint secondEdge);
QGraphicsAnchor *anchor(QGraphicsLayoutItem *firstItem, Qt::AnchorPoint firstEdge,
QGraphicsLayoutItem *secondItem, Qt::AnchorPoint secondEdge);

void addCornerAnchors(QGraphicsLayoutItem *firstItem, Qt::Corner firstCorner,
QGraphicsLayoutItem *secondItem, Qt::Corner secondCorner);

void addAnchors(QGraphicsLayoutItem *firstItem,
QGraphicsLayoutItem *secondItem,
Qt::Orientations orientations = Qt::Horizontal | Qt::Vertical);

void setHorizontalSpacing(qreal spacing);
void setVerticalSpacing(qreal spacing);
void setSpacing(qreal spacing);
qreal horizontalSpacing() const;
qreal verticalSpacing() const;

void removeAt(int index);
void setGeometry(const QRectF &rect);
int count() const;
QGraphicsLayoutItem *itemAt(int index) const;

void invalidate();
protected:
QSizeF sizeHint(Qt::SizeHint which, const QSizeF &constraint = QSizeF()) const;

private:
QGraphicsAnchorLayout(const QGraphicsAnchorLayout &); QGraphicsAnchorLayout &operator=(const QGraphicsAnchorLayout &);
inline QGraphicsAnchorLayoutPrivate* d_func() { return reinterpret_cast<QGraphicsAnchorLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsAnchorLayoutPrivate* d_func() const { return reinterpret_cast<const QGraphicsAnchorLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsAnchorLayoutPrivate;

friend class QGraphicsAnchor;
};



# 124 "/usr/share/qt4/include/QtGui/qgraphicsanchorlayout.h"





# 215 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicsgridlayout.h"












































# 1 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgraphicsgridlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qgraphicslayout.h"


































































































# 46 "/usr/share/qt4/include/QtGui/qgraphicsgridlayout.h"


# 48 "/usr/share/qt4/include/QtGui/qgraphicsgridlayout.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qgraphicsgridlayout.h"
class QGraphicsGridLayoutPrivate;

class  QGraphicsGridLayout : public QGraphicsLayout
{
public:
QGraphicsGridLayout(QGraphicsLayoutItem *parent = 0);
virtual ~QGraphicsGridLayout();

void addItem(QGraphicsLayoutItem *item, int row, int column, int rowSpan, int columnSpan,
Qt::Alignment alignment = 0);
inline void addItem(QGraphicsLayoutItem *item, int row, int column, Qt::Alignment alignment = 0);

void setHorizontalSpacing(qreal spacing);
qreal horizontalSpacing() const;
void setVerticalSpacing(qreal spacing);
qreal verticalSpacing() const;
void setSpacing(qreal spacing);

void setRowSpacing(int row, qreal spacing);
qreal rowSpacing(int row) const;
void setColumnSpacing(int column, qreal spacing);
qreal columnSpacing(int column) const;

void setRowStretchFactor(int row, int stretch);
int rowStretchFactor(int row) const;
void setColumnStretchFactor(int column, int stretch);
int columnStretchFactor(int column) const;

void setRowMinimumHeight(int row, qreal height);
qreal rowMinimumHeight(int row) const;
void setRowPreferredHeight(int row, qreal height);
qreal rowPreferredHeight(int row) const;
void setRowMaximumHeight(int row, qreal height);
qreal rowMaximumHeight(int row) const;
void setRowFixedHeight(int row, qreal height);

void setColumnMinimumWidth(int column, qreal width);
qreal columnMinimumWidth(int column) const;
void setColumnPreferredWidth(int column, qreal width);
qreal columnPreferredWidth(int column) const;
void setColumnMaximumWidth(int column, qreal width);
qreal columnMaximumWidth(int column) const;
void setColumnFixedWidth(int column, qreal width);

void setRowAlignment(int row, Qt::Alignment alignment);
Qt::Alignment rowAlignment(int row) const;
void setColumnAlignment(int column, Qt::Alignment alignment);
Qt::Alignment columnAlignment(int column) const;

void setAlignment(QGraphicsLayoutItem *item, Qt::Alignment alignment);
Qt::Alignment alignment(QGraphicsLayoutItem *item) const;

int rowCount() const;
int columnCount() const;

QGraphicsLayoutItem *itemAt(int row, int column) const;


int count() const;
QGraphicsLayoutItem *itemAt(int index) const;
void removeAt(int index);

void invalidate();


void setGeometry(const QRectF &rect);
QSizeF sizeHint(Qt::SizeHint which, const QSizeF &constraint = QSizeF()) const;





private:
QGraphicsGridLayout(const QGraphicsGridLayout &); QGraphicsGridLayout &operator=(const QGraphicsGridLayout &);
inline QGraphicsGridLayoutPrivate* d_func() { return reinterpret_cast<QGraphicsGridLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsGridLayoutPrivate* d_func() const { return reinterpret_cast<const QGraphicsGridLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsGridLayoutPrivate;
};

inline void QGraphicsGridLayout::addItem(QGraphicsLayoutItem *aitem, int arow, int acolumn, Qt::Alignment aalignment)
{ addItem(aitem, arow, acolumn, 1, 1, aalignment); }



# 138 "/usr/share/qt4/include/QtGui/qgraphicsgridlayout.h"






# 216 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 217 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicsitemanimation.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgraphicsitemanimation.h"




# 49 "/usr/share/qt4/include/QtGui/qgraphicsitemanimation.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QGraphicsItem;
class QMatrix;
class QPointF;
class QTimeLine;
template <class T1, class T2> struct QPair;

class QGraphicsItemAnimationPrivate;
class  QGraphicsItemAnimation : public QObject
{
Q_OBJECT
public:
QGraphicsItemAnimation(QObject *parent = 0);
virtual ~QGraphicsItemAnimation();

QGraphicsItem *item() const;
void setItem(QGraphicsItem *item);

QTimeLine *timeLine() const;
void setTimeLine(QTimeLine *timeLine);

QPointF posAt(qreal step) const;
QList<QPair<qreal, QPointF> > posList() const;
void setPosAt(qreal step, const QPointF &pos);

QMatrix matrixAt(qreal step) const;

qreal rotationAt(qreal step) const;
QList<QPair<qreal, qreal> > rotationList() const;
void setRotationAt(qreal step, qreal angle);

qreal xTranslationAt(qreal step) const;
qreal yTranslationAt(qreal step) const;
QList<QPair<qreal, QPointF> > translationList() const;
void setTranslationAt(qreal step, qreal dx, qreal dy);

qreal verticalScaleAt(qreal step) const;
qreal horizontalScaleAt(qreal step) const;
QList<QPair<qreal, QPointF> > scaleList() const;
void setScaleAt(qreal step, qreal sx, qreal sy);

qreal verticalShearAt(qreal step) const;
qreal horizontalShearAt(qreal step) const;
QList<QPair<qreal, QPointF> > shearList() const;
void setShearAt(qreal step, qreal sh, qreal sv);

void clear();

public slots:
void setStep(qreal x);
void reset();

protected:
virtual void beforeAnimationStep(qreal step);
virtual void afterAnimationStep(qreal step);

private:
QGraphicsItemAnimation(const QGraphicsItemAnimation &); QGraphicsItemAnimation &operator=(const QGraphicsItemAnimation &);
QGraphicsItemAnimationPrivate *d;
};







# 218 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicslayout.h"


































































































# 219 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicslayoutitem.h"



























































































































































# 220 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicslinearlayout.h"












































# 1 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgraphicslinearlayout.h"

# 1 "/usr/share/qt4/include/QtGui/qgraphicslayout.h"


































































































# 46 "/usr/share/qt4/include/QtGui/qgraphicslinearlayout.h"


# 48 "/usr/share/qt4/include/QtGui/qgraphicslinearlayout.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 56 "/usr/share/qt4/include/QtGui/qgraphicslinearlayout.h"
class QGraphicsLinearLayoutPrivate;

class  QGraphicsLinearLayout : public QGraphicsLayout
{
public:
QGraphicsLinearLayout(QGraphicsLayoutItem *parent = 0);
QGraphicsLinearLayout(Qt::Orientation orientation, QGraphicsLayoutItem *parent = 0);
virtual ~QGraphicsLinearLayout();

void setOrientation(Qt::Orientation orientation);
Qt::Orientation orientation() const;

inline void addItem(QGraphicsLayoutItem *item) { insertItem(-1, item); }
inline void addStretch(int stretch = 1) { insertStretch(-1, stretch); }

void insertItem(int index, QGraphicsLayoutItem *item);
void insertStretch(int index, int stretch = 1);

void removeItem(QGraphicsLayoutItem *item);
void removeAt(int index);

void setSpacing(qreal spacing);
qreal spacing() const;
void setItemSpacing(int index, qreal spacing);
qreal itemSpacing(int index) const;

void setStretchFactor(QGraphicsLayoutItem *item, int stretch);
int stretchFactor(QGraphicsLayoutItem *item) const;

void setAlignment(QGraphicsLayoutItem *item, Qt::Alignment alignment);
Qt::Alignment alignment(QGraphicsLayoutItem *item) const;

void setGeometry(const QRectF &rect);

int count() const;
QGraphicsLayoutItem *itemAt(int index) const;

void invalidate();
QSizeF sizeHint(Qt::SizeHint which, const QSizeF &constraint = QSizeF()) const;





# 100 "/usr/share/qt4/include/QtGui/qgraphicslinearlayout.h"
void dump(int indent = 0) const;

protected:




# 107 "/usr/share/qt4/include/QtGui/qgraphicslinearlayout.h"
private:
QGraphicsLinearLayout(const QGraphicsLinearLayout &); QGraphicsLinearLayout &operator=(const QGraphicsLinearLayout &);
inline QGraphicsLinearLayoutPrivate* d_func() { return reinterpret_cast<QGraphicsLinearLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsLinearLayoutPrivate* d_func() const { return reinterpret_cast<const QGraphicsLinearLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsLinearLayoutPrivate;
};



# 114 "/usr/share/qt4/include/QtGui/qgraphicslinearlayout.h"






# 221 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicsproxywidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"












































# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"

# 1 "/usr/share/qt4/include/QtGui/qgraphicslayoutitem.h"



























































































































































# 46 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"

# 1 "/usr/share/qt4/include/QtGui/qgraphicsitem.h"


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"

# 1 "/usr/share/qt4/include/QtGui/qpalette.h"




































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"


# 50 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QFont;
class QFontMetrics;
class QGraphicsLayout;
class QGraphicsSceneMoveEvent;
class QGraphicsWidgetPrivate;
class QGraphicsSceneResizeEvent;
class QStyle;
class QStyleOption;



# 67 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"
class QGraphicsWidgetPrivate;

class  QGraphicsWidget : public QGraphicsObject, public QGraphicsLayoutItem
{
Q_OBJECT

Q_PROPERTY(QPalette palette READ palette WRITE setPalette)
Q_PROPERTY(QFont font READ font WRITE setFont)
Q_PROPERTY(Qt::LayoutDirection layoutDirection READ layoutDirection WRITE setLayoutDirection RESET unsetLayoutDirection)
Q_PROPERTY(QSizeF size READ size WRITE resize)
Q_PROPERTY(QSizeF minimumSize READ minimumSize WRITE setMinimumSize)
Q_PROPERTY(QSizeF preferredSize READ preferredSize WRITE setPreferredSize)
Q_PROPERTY(QSizeF maximumSize READ maximumSize WRITE setMaximumSize)
Q_PROPERTY(QSizePolicy sizePolicy READ sizePolicy WRITE setSizePolicy)
Q_PROPERTY(Qt::FocusPolicy focusPolicy READ focusPolicy WRITE setFocusPolicy)
Q_PROPERTY(Qt::WindowFlags windowFlags READ windowFlags WRITE setWindowFlags)
Q_PROPERTY(QString windowTitle READ windowTitle WRITE setWindowTitle)
Q_PROPERTY(QRectF geometry READ geometry WRITE setGeometry)
public:
QGraphicsWidget(QGraphicsItem *parent = 0, Qt::WindowFlags wFlags = 0);
~QGraphicsWidget();

QGraphicsLayout *layout() const;
void setLayout(QGraphicsLayout *layout);
void adjustSize();

Qt::LayoutDirection layoutDirection() const;
void setLayoutDirection(Qt::LayoutDirection direction);
void unsetLayoutDirection();

QStyle *style() const;
void setStyle(QStyle *style);

QFont font() const;
void setFont(const QFont &font);

QPalette palette() const;
void setPalette(const QPalette &palette);

void resize(const QSizeF &size);
inline void resize(qreal w, qreal h) { resize(QSizeF(w, h)); }
QSizeF size() const;

void setGeometry(const QRectF &rect);
inline void setGeometry(qreal x, qreal y, qreal w, qreal h);
inline QRectF rect() const { return QRectF(QPointF(), size()); }

void setContentsMargins(qreal left, qreal top, qreal right, qreal bottom);
void getContentsMargins(qreal *left, qreal *top, qreal *right, qreal *bottom) const;

void setWindowFrameMargins(qreal left, qreal top, qreal right, qreal bottom);
void getWindowFrameMargins(qreal *left, qreal *top, qreal *right, qreal *bottom) const;
void unsetWindowFrameMargins();
QRectF windowFrameGeometry() const;
QRectF windowFrameRect() const;


Qt::WindowFlags windowFlags() const;
Qt::WindowType windowType() const;
void setWindowFlags(Qt::WindowFlags wFlags);
bool isActiveWindow() const;
void setWindowTitle(const QString &title);
QString windowTitle() const;


Qt::FocusPolicy focusPolicy() const;
void setFocusPolicy(Qt::FocusPolicy policy);
static void setTabOrder(QGraphicsWidget *first, QGraphicsWidget *second);
QGraphicsWidget *focusWidget() const;


# 138 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"
int grabShortcut(const QKeySequence &sequence, Qt::ShortcutContext context = Qt::WindowShortcut);
void releaseShortcut(int id);
void setShortcutEnabled(int id, bool enabled = true);
void setShortcutAutoRepeat(int id, bool enabled = true);



# 145 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"

void addAction(QAction *action);
void addActions(QList<QAction*> actions);
void insertAction(QAction *before, QAction *action);
void insertActions(QAction *before, QList<QAction*> actions);
void removeAction(QAction *action);
QList<QAction*> actions() const;


# 154 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"
void setAttribute(Qt::WidgetAttribute attribute, bool on = true);
bool testAttribute(Qt::WidgetAttribute attribute) const;

enum {
Type = 11
};
int type() const;

void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0);
virtual void paintWindowFrame(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0);
QRectF boundingRect() const;
QPainterPath shape() const;





# 171 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"


# 173 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"
const QObjectList &children() const { return QObject::children(); }




# 178 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"
public slots:
bool close();

protected:
virtual void initStyleOption(QStyleOption *option) const;

QSizeF sizeHint(Qt::SizeHint which, const QSizeF &constraint = QSizeF()) const;
void updateGeometry();


QVariant itemChange(GraphicsItemChange change, const QVariant &value);
virtual QVariant propertyChange(const QString &propertyName, const QVariant &value);


bool sceneEvent(QEvent *event);
virtual bool windowFrameEvent(QEvent *e);
virtual Qt::WindowFrameSection windowFrameSectionAt(const QPointF& pos) const;


bool event(QEvent *event);

virtual void changeEvent(QEvent *event);
virtual void closeEvent(QCloseEvent *event);


void focusInEvent(QFocusEvent *event);
virtual bool focusNextPrevChild(bool next);
void focusOutEvent(QFocusEvent *event);
virtual void hideEvent(QHideEvent *event);


virtual void moveEvent(QGraphicsSceneMoveEvent *event);
virtual void polishEvent();


virtual void resizeEvent(QGraphicsSceneResizeEvent *event);
virtual void showEvent(QShowEvent *event);



virtual void hoverMoveEvent(QGraphicsSceneHoverEvent *event);
virtual void hoverLeaveEvent(QGraphicsSceneHoverEvent *event);
virtual void grabMouseEvent(QEvent *event);
virtual void ungrabMouseEvent(QEvent *event);
virtual void grabKeyboardEvent(QEvent *event);
virtual void ungrabKeyboardEvent(QEvent *event);
QGraphicsWidget(QGraphicsWidgetPrivate &, QGraphicsItem *parent, QGraphicsScene *, Qt::WindowFlags wFlags = 0);

private:
QGraphicsWidget(const QGraphicsWidget &); QGraphicsWidget &operator=(const QGraphicsWidget &);
inline QGraphicsWidgetPrivate* d_func() { return reinterpret_cast<QGraphicsWidgetPrivate *>(QGraphicsItem::d_ptr.data()); } inline const QGraphicsWidgetPrivate* d_func() const { return reinterpret_cast<const QGraphicsWidgetPrivate *>(QGraphicsItem::d_ptr.data()); } friend class QGraphicsWidgetPrivate;
friend class QGraphicsScene;
friend class QGraphicsScenePrivate;
friend class QGraphicsView;
friend class QGraphicsItem;
friend class QGraphicsItemPrivate;
friend class QGraphicsLayout;
friend class QWidget;
friend class QApplication;
};

inline void QGraphicsWidget::setGeometry(qreal ax, qreal ay, qreal aw, qreal ah)
{ setGeometry(QRectF(ax, ay, aw, ah)); }



# 244 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"






# 45 "/usr/share/qt4/include/QtGui/qgraphicsproxywidget.h"


# 47 "/usr/share/qt4/include/QtGui/qgraphicsproxywidget.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 55 "/usr/share/qt4/include/QtGui/qgraphicsproxywidget.h"
class QGraphicsProxyWidgetPrivate;

class  QGraphicsProxyWidget : public QGraphicsWidget
{
Q_OBJECT
public:
QGraphicsProxyWidget(QGraphicsItem *parent = 0, Qt::WindowFlags wFlags = 0);
~QGraphicsProxyWidget();

void setWidget(QWidget *widget);
QWidget *widget() const;

QRectF subWidgetRect(const QWidget *widget) const;

void setGeometry(const QRectF &rect);

void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);

enum {
Type = 12
};
int type() const;

QGraphicsProxyWidget *createProxyForChildWidget(QWidget *child);

protected:
QVariant itemChange(GraphicsItemChange change, const QVariant &value);

bool event(QEvent *event);
bool eventFilter(QObject *object, QEvent *event);

void showEvent(QShowEvent *event);
void hideEvent(QHideEvent *event);


# 90 "/usr/share/qt4/include/QtGui/qgraphicsproxywidget.h"
void contextMenuEvent(QGraphicsSceneContextMenuEvent *event);



# 94 "/usr/share/qt4/include/QtGui/qgraphicsproxywidget.h"
void dragEnterEvent(QGraphicsSceneDragDropEvent *event);
void dragLeaveEvent(QGraphicsSceneDragDropEvent *event);
void dragMoveEvent(QGraphicsSceneDragDropEvent *event);
void dropEvent(QGraphicsSceneDragDropEvent *event);


# 100 "/usr/share/qt4/include/QtGui/qgraphicsproxywidget.h"
void hoverEnterEvent(QGraphicsSceneHoverEvent *event);
void hoverLeaveEvent(QGraphicsSceneHoverEvent *event);
void hoverMoveEvent(QGraphicsSceneHoverEvent *event);
void grabMouseEvent(QEvent *event);
void ungrabMouseEvent(QEvent *event);

void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
void mousePressEvent(QGraphicsSceneMouseEvent *event);
void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event);

# 111 "/usr/share/qt4/include/QtGui/qgraphicsproxywidget.h"
void wheelEvent(QGraphicsSceneWheelEvent *event);


# 114 "/usr/share/qt4/include/QtGui/qgraphicsproxywidget.h"
void keyPressEvent(QKeyEvent *event);
void keyReleaseEvent(QKeyEvent *event);

void focusInEvent(QFocusEvent *event);
void focusOutEvent(QFocusEvent *event);
bool focusNextPrevChild(bool next);




QSizeF sizeHint(Qt::SizeHint which, const QSizeF &constraint = QSizeF()) const;
void resizeEvent(QGraphicsSceneResizeEvent *event);

protected slots:
QGraphicsProxyWidget *newProxyWidget(const QWidget *);

private:
QGraphicsProxyWidget(const QGraphicsProxyWidget &); QGraphicsProxyWidget &operator=(const QGraphicsProxyWidget &);
inline QGraphicsProxyWidgetPrivate* d_func() { return reinterpret_cast<QGraphicsProxyWidgetPrivate *>(QGraphicsItem::d_ptr.data()); } inline const QGraphicsProxyWidgetPrivate* d_func() const { return reinterpret_cast<const QGraphicsProxyWidgetPrivate *>(QGraphicsItem::d_ptr.data()); } friend class QGraphicsProxyWidgetPrivate;


friend class QWidget;
friend class QWidgetPrivate;
friend class QGraphicsItem;
};



# 142 "/usr/share/qt4/include/QtGui/qgraphicsproxywidget.h"






# 222 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 47 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"

# 1 "/usr/share/qt4/include/QtGui/qbrush.h"








































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 49 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"

# 1 "/usr/share/qt4/include/QtGui/qtransform.h"











































































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"

# 1 "/usr/share/qt4/include/QtGui/qmatrix.h"












































































































































































































# 51 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"

# 1 "/usr/share/qt4/include/QtGui/qpen.h"












































































































































# 52 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"


# 54 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 62 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"
template<typename T> class QList;
class QFocusEvent;
class QFont;
class QFontMetrics;
class QGraphicsEllipseItem;
class QGraphicsItem;
class QGraphicsItemGroup;
class QGraphicsLineItem;
class QGraphicsPathItem;
class QGraphicsPixmapItem;
class QGraphicsPolygonItem;
class QGraphicsProxyWidget;
class QGraphicsRectItem;
class QGraphicsSceneContextMenuEvent;
class QGraphicsSceneDragDropEvent;
class QGraphicsSceneEvent;
class QGraphicsSceneHelpEvent;
class QGraphicsSceneHoverEvent;
class QGraphicsSceneMouseEvent;
class QGraphicsSceneWheelEvent;
class QGraphicsSimpleTextItem;
class QGraphicsTextItem;
class QGraphicsView;
class QGraphicsWidget;
class QGraphicsSceneIndex;
class QHelpEvent;
class QInputMethodEvent;
class QKeyEvent;
class QLineF;
class QPainterPath;
class QPixmap;
class QPointF;
class QPolygonF;
class QRectF;
class QSizeF;
class QStyle;
class QStyleOptionGraphicsItem;

class QGraphicsScenePrivate;
class  QGraphicsScene : public QObject
{
Q_OBJECT
Q_PROPERTY(QBrush backgroundBrush READ backgroundBrush WRITE setBackgroundBrush)
Q_PROPERTY(QBrush foregroundBrush READ foregroundBrush WRITE setForegroundBrush)
Q_PROPERTY(ItemIndexMethod itemIndexMethod READ itemIndexMethod WRITE setItemIndexMethod)
Q_PROPERTY(QRectF sceneRect READ sceneRect WRITE setSceneRect)
Q_PROPERTY(int bspTreeDepth READ bspTreeDepth WRITE setBspTreeDepth)
Q_PROPERTY(QPalette palette READ palette WRITE setPalette)
Q_PROPERTY(QFont font READ font WRITE setFont)
Q_PROPERTY(bool sortCacheEnabled READ isSortCacheEnabled WRITE setSortCacheEnabled)
Q_PROPERTY(bool stickyFocus READ stickyFocus WRITE setStickyFocus)

public:
enum ItemIndexMethod {
BspTreeIndex,
NoIndex = -1
};

enum SceneLayer {
ItemLayer = 0x1,
BackgroundLayer = 0x2,
ForegroundLayer = 0x4,
AllLayers = 0xffff
};
typedef QFlags<SceneLayer> SceneLayers;

QGraphicsScene(QObject *parent = 0);
QGraphicsScene(const QRectF &sceneRect, QObject *parent = 0);
QGraphicsScene(qreal x, qreal y, qreal width, qreal height, QObject *parent = 0);
virtual ~QGraphicsScene();

QRectF sceneRect() const;
inline qreal width() const { return sceneRect().width(); }
inline qreal height() const { return sceneRect().height(); }
void setSceneRect(const QRectF &rect);
inline void setSceneRect(qreal x, qreal y, qreal w, qreal h)
{ setSceneRect(QRectF(x, y, w, h)); }

void render(QPainter *painter,
const QRectF &target = QRectF(), const QRectF &source = QRectF(),
Qt::AspectRatioMode aspectRatioMode = Qt::KeepAspectRatio);

ItemIndexMethod itemIndexMethod() const;
void setItemIndexMethod(ItemIndexMethod method);

bool isSortCacheEnabled() const;
void setSortCacheEnabled(bool enabled);

int bspTreeDepth() const;
void setBspTreeDepth(int depth);

QRectF itemsBoundingRect() const;

QList<QGraphicsItem *> items() const;
QList<QGraphicsItem *> items(Qt::SortOrder order) const; 

QList<QGraphicsItem *> items(const QPointF &pos, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform = QTransform()) const;
QList<QGraphicsItem *> items(const QRectF &rect, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform = QTransform()) const;
QList<QGraphicsItem *> items(const QPolygonF &polygon, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform = QTransform()) const;
QList<QGraphicsItem *> items(const QPainterPath &path, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform = QTransform()) const;

QList<QGraphicsItem *> items(const QPointF &pos) const; 
QList<QGraphicsItem *> items(const QRectF &rect, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const; 
QList<QGraphicsItem *> items(const QPolygonF &polygon, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const; 
QList<QGraphicsItem *> items(const QPainterPath &path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const; 

QList<QGraphicsItem *> collidingItems(const QGraphicsItem *item, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;

QGraphicsItem *itemAt(const QPointF &pos) const; 
QGraphicsItem *itemAt(const QPointF &pos, const QTransform &deviceTransform) const;

inline QList<QGraphicsItem *> items(qreal x, qreal y, qreal w, qreal h, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const
{ return items(QRectF(x, y, w, h), mode); } 
inline QList<QGraphicsItem *> items(qreal x, qreal y, qreal w, qreal h, Qt::ItemSelectionMode mode, Qt::SortOrder order,
const QTransform &deviceTransform = QTransform()) const
{ return items(QRectF(x, y, w, h), mode, order, deviceTransform); }
inline QGraphicsItem *itemAt(qreal x, qreal y) const 
{ return itemAt(QPointF(x, y)); }
inline QGraphicsItem *itemAt(qreal x, qreal y, const QTransform &deviceTransform) const
{ return itemAt(QPointF(x, y), deviceTransform); }

QList<QGraphicsItem *> selectedItems() const;
QPainterPath selectionArea() const;
void setSelectionArea(const QPainterPath &path); 
void setSelectionArea(const QPainterPath &path, const QTransform &deviceTransform);
void setSelectionArea(const QPainterPath &path, Qt::ItemSelectionMode mode); 
void setSelectionArea(const QPainterPath &path, Qt::ItemSelectionMode mode, const QTransform &deviceTransform);

QGraphicsItemGroup *createItemGroup(const QList<QGraphicsItem *> &items);
void destroyItemGroup(QGraphicsItemGroup *group);

void addItem(QGraphicsItem *item);
QGraphicsEllipseItem *addEllipse(const QRectF &rect, const QPen &pen = QPen(), const QBrush &brush = QBrush());
QGraphicsLineItem *addLine(const QLineF &line, const QPen &pen = QPen());
QGraphicsPathItem *addPath(const QPainterPath &path, const QPen &pen = QPen(), const QBrush &brush = QBrush());
QGraphicsPixmapItem *addPixmap(const QPixmap &pixmap);
QGraphicsPolygonItem *addPolygon(const QPolygonF &polygon, const QPen &pen = QPen(), const QBrush &brush = QBrush());
QGraphicsRectItem *addRect(const QRectF &rect, const QPen &pen = QPen(), const QBrush &brush = QBrush());
QGraphicsTextItem *addText(const QString &text, const QFont &font = QFont());
QGraphicsSimpleTextItem *addSimpleText(const QString &text, const QFont &font = QFont());
QGraphicsProxyWidget *addWidget(QWidget *widget, Qt::WindowFlags wFlags = 0);
inline QGraphicsEllipseItem *addEllipse(qreal x, qreal y, qreal w, qreal h, const QPen &pen = QPen(), const QBrush &brush = QBrush())
{ return addEllipse(QRectF(x, y, w, h), pen, brush); }
inline QGraphicsLineItem *addLine(qreal x1, qreal y1, qreal x2, qreal y2, const QPen &pen = QPen())
{ return addLine(QLineF(x1, y1, x2, y2), pen); }
inline QGraphicsRectItem *addRect(qreal x, qreal y, qreal w, qreal h, const QPen &pen = QPen(), const QBrush &brush = QBrush())
{ return addRect(QRectF(x, y, w, h), pen, brush); }
void removeItem(QGraphicsItem *item);

QGraphicsItem *focusItem() const;
void setFocusItem(QGraphicsItem *item, Qt::FocusReason focusReason = Qt::OtherFocusReason);
bool hasFocus() const;
void setFocus(Qt::FocusReason focusReason = Qt::OtherFocusReason);
void clearFocus();

void setStickyFocus(bool enabled);
bool stickyFocus() const;

QGraphicsItem *mouseGrabberItem() const;

QBrush backgroundBrush() const;
void setBackgroundBrush(const QBrush &brush);

QBrush foregroundBrush() const;
void setForegroundBrush(const QBrush &brush);

virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const;

QList <QGraphicsView *> views() const;

inline void update(qreal x, qreal y, qreal w, qreal h)
{ update(QRectF(x, y, w, h)); }
inline void invalidate(qreal x, qreal y, qreal w, qreal h, SceneLayers layers = AllLayers)
{ invalidate(QRectF(x, y, w, h), layers); }

QStyle *style() const;
void setStyle(QStyle *style);

QFont font() const;
void setFont(const QFont &font);

QPalette palette() const;
void setPalette(const QPalette &palette);

bool isActive() const;
QGraphicsItem *activePanel() const;
void setActivePanel(QGraphicsItem *item);
QGraphicsWidget *activeWindow() const;
void setActiveWindow(QGraphicsWidget *widget);

bool sendEvent(QGraphicsItem *item, QEvent *event);

public slots:
void update(const QRectF &rect = QRectF());
void invalidate(const QRectF &rect = QRectF(), SceneLayers layers = AllLayers);
void advance();
void clearSelection();
void clear();

protected:
bool event(QEvent *event);
bool eventFilter(QObject *watched, QEvent *event);
virtual void contextMenuEvent(QGraphicsSceneContextMenuEvent *event);
virtual void dragEnterEvent(QGraphicsSceneDragDropEvent *event);
virtual void dragMoveEvent(QGraphicsSceneDragDropEvent *event);
virtual void dragLeaveEvent(QGraphicsSceneDragDropEvent *event);
virtual void dropEvent(QGraphicsSceneDragDropEvent *event);
virtual void focusInEvent(QFocusEvent *event);
virtual void focusOutEvent(QFocusEvent *event);
virtual void helpEvent(QGraphicsSceneHelpEvent *event);
virtual void keyPressEvent(QKeyEvent *event);
virtual void keyReleaseEvent(QKeyEvent *event);
virtual void mousePressEvent(QGraphicsSceneMouseEvent *event);
virtual void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
virtual void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
virtual void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event);
virtual void wheelEvent(QGraphicsSceneWheelEvent *event);
virtual void inputMethodEvent(QInputMethodEvent *event);

virtual void drawBackground(QPainter *painter, const QRectF &rect);
virtual void drawForeground(QPainter *painter, const QRectF &rect);
virtual void drawItems(QPainter *painter, int numItems,
QGraphicsItem *items[],
const QStyleOptionGraphicsItem options[],
QWidget *widget = 0);

protected slots:
bool focusNextPrevChild(bool next);

signals:
void changed(const QList<QRectF> &region);
void sceneRectChanged(const QRectF &rect);
void selectionChanged();

private:
inline QGraphicsScenePrivate* d_func() { return reinterpret_cast<QGraphicsScenePrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsScenePrivate* d_func() const { return reinterpret_cast<const QGraphicsScenePrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsScenePrivate;
QGraphicsScene(const QGraphicsScene &); QGraphicsScene &operator=(const QGraphicsScene &);




friend class QGraphicsItem;
friend class QGraphicsItemPrivate;
friend class QGraphicsView;
friend class QGraphicsViewPrivate;
friend class QGraphicsWidget;
friend class QGraphicsWidgetPrivate;
friend class QGraphicsEffect;
friend class QGraphicsSceneIndex;
friend class QGraphicsSceneIndexPrivate;
friend class QGraphicsSceneBspTreeIndex;
friend class QGraphicsSceneBspTreeIndexPrivate;
friend class QGraphicsItemEffectSourcePrivate;
friend class QGesture;
};

inline QFlags<QGraphicsScene::SceneLayers::enum_type> operator|(QGraphicsScene::SceneLayers::enum_type f1, QGraphicsScene::SceneLayers::enum_type f2) { return QFlags<QGraphicsScene::SceneLayers::enum_type>(f1) | f2; } inline QFlags<QGraphicsScene::SceneLayers::enum_type> operator|(QGraphicsScene::SceneLayers::enum_type f1, QFlags<QGraphicsScene::SceneLayers::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QGraphicsScene::SceneLayers::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



# 322 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"





# 223 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicssceneevent.h"












































# 1 "/usr/share/qt4/include/QtCore/qcoreevent.h"
































































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgraphicssceneevent.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qgraphicssceneevent.h"

# 1 "/usr/share/qt4/include/QtCore/qscopedpointer.h"























































































































































































































# 47 "/usr/share/qt4/include/QtGui/qgraphicssceneevent.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qgraphicssceneevent.h"

# 1 "/usr/share/qt4/include/QtGui/qpolygon.h"




















































































































































































# 49 "/usr/share/qt4/include/QtGui/qgraphicssceneevent.h"

# 1 "/usr/share/qt4/include/QtCore/qset.h"














































































































































































































































































































































































# 50 "/usr/share/qt4/include/QtGui/qgraphicssceneevent.h"

# 1 "/usr/share/qt4/include/QtCore/qhash.h"






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 51 "/usr/share/qt4/include/QtGui/qgraphicssceneevent.h"


# 53 "/usr/share/qt4/include/QtGui/qgraphicssceneevent.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 61 "/usr/share/qt4/include/QtGui/qgraphicssceneevent.h"
class QMimeData;
class QPointF;
class QSizeF;
class QWidget;

class QGraphicsSceneEventPrivate;
class  QGraphicsSceneEvent : public QEvent
{
public:
QGraphicsSceneEvent(Type type);
~QGraphicsSceneEvent();

QWidget *widget() const;
void setWidget(QWidget *widget);

protected:
QGraphicsSceneEvent(QGraphicsSceneEventPrivate &dd, Type type = None);
QScopedPointer<QGraphicsSceneEventPrivate> d_ptr;
inline QGraphicsSceneEventPrivate* d_func() { return reinterpret_cast<QGraphicsSceneEventPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsSceneEventPrivate* d_func() const { return reinterpret_cast<const QGraphicsSceneEventPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsSceneEventPrivate;
};

class QGraphicsSceneMouseEventPrivate;
class  QGraphicsSceneMouseEvent : public QGraphicsSceneEvent
{
public:
QGraphicsSceneMouseEvent(Type type = None);
~QGraphicsSceneMouseEvent();

QPointF pos() const;
void setPos(const QPointF &pos);

QPointF scenePos() const;
void setScenePos(const QPointF &pos);

QPoint screenPos() const;
void setScreenPos(const QPoint &pos);

QPointF buttonDownPos(Qt::MouseButton button) const;
void setButtonDownPos(Qt::MouseButton button, const QPointF &pos);

QPointF buttonDownScenePos(Qt::MouseButton button) const;
void setButtonDownScenePos(Qt::MouseButton button, const QPointF &pos);

QPoint buttonDownScreenPos(Qt::MouseButton button) const;
void setButtonDownScreenPos(Qt::MouseButton button, const QPoint &pos);

QPointF lastPos() const;
void setLastPos(const QPointF &pos);

QPointF lastScenePos() const;
void setLastScenePos(const QPointF &pos);

QPoint lastScreenPos() const;
void setLastScreenPos(const QPoint &pos);

Qt::MouseButtons buttons() const;
void setButtons(Qt::MouseButtons buttons);

Qt::MouseButton button() const;
void setButton(Qt::MouseButton button);

Qt::KeyboardModifiers modifiers() const;
void setModifiers(Qt::KeyboardModifiers modifiers);

private:
inline QGraphicsSceneMouseEventPrivate* d_func() { return reinterpret_cast<QGraphicsSceneMouseEventPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsSceneMouseEventPrivate* d_func() const { return reinterpret_cast<const QGraphicsSceneMouseEventPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsSceneMouseEventPrivate;
};

class QGraphicsSceneWheelEventPrivate;
class  QGraphicsSceneWheelEvent : public QGraphicsSceneEvent
{
public:
QGraphicsSceneWheelEvent(Type type = None);
~QGraphicsSceneWheelEvent();

QPointF pos() const;
void setPos(const QPointF &pos);

QPointF scenePos() const;
void setScenePos(const QPointF &pos);

QPoint screenPos() const;
void setScreenPos(const QPoint &pos);

Qt::MouseButtons buttons() const;
void setButtons(Qt::MouseButtons buttons);

Qt::KeyboardModifiers modifiers() const;
void setModifiers(Qt::KeyboardModifiers modifiers);

int delta() const;
void setDelta(int delta);

Qt::Orientation orientation() const;
void setOrientation(Qt::Orientation orientation);

private:
inline QGraphicsSceneWheelEventPrivate* d_func() { return reinterpret_cast<QGraphicsSceneWheelEventPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsSceneWheelEventPrivate* d_func() const { return reinterpret_cast<const QGraphicsSceneWheelEventPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsSceneWheelEventPrivate;
};

class QGraphicsSceneContextMenuEventPrivate;
class  QGraphicsSceneContextMenuEvent : public QGraphicsSceneEvent
{
public:
enum Reason { Mouse, Keyboard, Other };

QGraphicsSceneContextMenuEvent(Type type = None);
~QGraphicsSceneContextMenuEvent();

QPointF pos() const;
void setPos(const QPointF &pos);

QPointF scenePos() const;
void setScenePos(const QPointF &pos);

QPoint screenPos() const;
void setScreenPos(const QPoint &pos);

Qt::KeyboardModifiers modifiers() const;
void setModifiers(Qt::KeyboardModifiers modifiers);

Reason reason() const;
void setReason(Reason reason);

private:
inline QGraphicsSceneContextMenuEventPrivate* d_func() { return reinterpret_cast<QGraphicsSceneContextMenuEventPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsSceneContextMenuEventPrivate* d_func() const { return reinterpret_cast<const QGraphicsSceneContextMenuEventPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsSceneContextMenuEventPrivate;
};

class QGraphicsSceneHoverEventPrivate;
class  QGraphicsSceneHoverEvent : public QGraphicsSceneEvent
{
public:
QGraphicsSceneHoverEvent(Type type = None);
~QGraphicsSceneHoverEvent();

QPointF pos() const;
void setPos(const QPointF &pos);

QPointF scenePos() const;
void setScenePos(const QPointF &pos);

QPoint screenPos() const;
void setScreenPos(const QPoint &pos);

QPointF lastPos() const;
void setLastPos(const QPointF &pos);

QPointF lastScenePos() const;
void setLastScenePos(const QPointF &pos);

QPoint lastScreenPos() const;
void setLastScreenPos(const QPoint &pos);

Qt::KeyboardModifiers modifiers() const;
void setModifiers(Qt::KeyboardModifiers modifiers);

private:
inline QGraphicsSceneHoverEventPrivate* d_func() { return reinterpret_cast<QGraphicsSceneHoverEventPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsSceneHoverEventPrivate* d_func() const { return reinterpret_cast<const QGraphicsSceneHoverEventPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsSceneHoverEventPrivate;
};

class QGraphicsSceneHelpEventPrivate;
class  QGraphicsSceneHelpEvent : public QGraphicsSceneEvent
{
public:
QGraphicsSceneHelpEvent(Type type = None);
~QGraphicsSceneHelpEvent();

QPointF scenePos() const;
void setScenePos(const QPointF &pos);

QPoint screenPos() const;
void setScreenPos(const QPoint &pos);

private:
inline QGraphicsSceneHelpEventPrivate* d_func() { return reinterpret_cast<QGraphicsSceneHelpEventPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsSceneHelpEventPrivate* d_func() const { return reinterpret_cast<const QGraphicsSceneHelpEventPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsSceneHelpEventPrivate;
};

class QGraphicsSceneDragDropEventPrivate;
class  QGraphicsSceneDragDropEvent : public QGraphicsSceneEvent
{
public:
QGraphicsSceneDragDropEvent(Type type = None);
~QGraphicsSceneDragDropEvent();

QPointF pos() const;
void setPos(const QPointF &pos);

QPointF scenePos() const;
void setScenePos(const QPointF &pos);

QPoint screenPos() const;
void setScreenPos(const QPoint &pos);

Qt::MouseButtons buttons() const;
void setButtons(Qt::MouseButtons buttons);

Qt::KeyboardModifiers modifiers() const;
void setModifiers(Qt::KeyboardModifiers modifiers);

Qt::DropActions possibleActions() const;
void setPossibleActions(Qt::DropActions actions);

Qt::DropAction proposedAction() const;
void setProposedAction(Qt::DropAction action);
void acceptProposedAction();

Qt::DropAction dropAction() const;
void setDropAction(Qt::DropAction action);

QWidget *source() const;
void setSource(QWidget *source);

const QMimeData *mimeData() const;
void setMimeData(const QMimeData *data);

private:
inline QGraphicsSceneDragDropEventPrivate* d_func() { return reinterpret_cast<QGraphicsSceneDragDropEventPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsSceneDragDropEventPrivate* d_func() const { return reinterpret_cast<const QGraphicsSceneDragDropEventPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsSceneDragDropEventPrivate;
};

class QGraphicsSceneResizeEventPrivate;
class  QGraphicsSceneResizeEvent : public QGraphicsSceneEvent
{
inline QGraphicsSceneResizeEventPrivate* d_func() { return reinterpret_cast<QGraphicsSceneResizeEventPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsSceneResizeEventPrivate* d_func() const { return reinterpret_cast<const QGraphicsSceneResizeEventPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsSceneResizeEventPrivate;
public:
QGraphicsSceneResizeEvent();
~QGraphicsSceneResizeEvent();

QSizeF oldSize() const;
void setOldSize(const QSizeF &size);

QSizeF newSize() const;
void setNewSize(const QSizeF &size);
};

class QGraphicsSceneMoveEventPrivate;
class  QGraphicsSceneMoveEvent : public QGraphicsSceneEvent
{
inline QGraphicsSceneMoveEventPrivate* d_func() { return reinterpret_cast<QGraphicsSceneMoveEventPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsSceneMoveEventPrivate* d_func() const { return reinterpret_cast<const QGraphicsSceneMoveEventPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsSceneMoveEventPrivate;
public:
QGraphicsSceneMoveEvent();
~QGraphicsSceneMoveEvent();

QPointF oldPos() const;
void setOldPos(const QPointF &pos);

QPointF newPos() const;
void setNewPos(const QPointF &pos);
};



# 312 "/usr/share/qt4/include/QtGui/qgraphicssceneevent.h"





# 224 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicstransform.h"












































# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 1 "/usr/share/qt4/include/QtCore/QObject"

# 45 "/usr/share/qt4/include/QtGui/qgraphicstransform.h"

# 1 "/usr/share/qt4/include/QtGui/qvector3d.h"




























































































































































































































































































# 1 "/usr/share/qt4/include/QtGui/QVector3D"

# 46 "/usr/share/qt4/include/QtGui/qgraphicstransform.h"

# 1 "/usr/share/qt4/include/QtGui/qtransform.h"











































































































































































































































































































































































































# 1 "/usr/share/qt4/include/QtGui/QTransform"

# 47 "/usr/share/qt4/include/QtGui/qgraphicstransform.h"

# 1 "/usr/share/qt4/include/QtGui/qmatrix4x4.h"
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 1 "/usr/share/qt4/include/QtGui/QMatrix4x4"

# 48 "/usr/share/qt4/include/QtGui/qgraphicstransform.h"



# 51 "/usr/share/qt4/include/QtGui/qgraphicstransform.h"




typedef QtValidLicenseForGuiModule QtGuiModule;

class QGraphicsItem;
class QGraphicsTransformPrivate;

class  QGraphicsTransform : public QObject
{
Q_OBJECT
public:
QGraphicsTransform(QObject *parent = 0);
~QGraphicsTransform();

virtual void applyTo(QMatrix4x4 *matrix) const = 0;

protected slots:
void update();

protected:
QGraphicsTransform(QGraphicsTransformPrivate &p, QObject *parent);

private:
friend class QGraphicsItem;
friend class QGraphicsItemPrivate;
inline QGraphicsTransformPrivate* d_func() { return reinterpret_cast<QGraphicsTransformPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsTransformPrivate* d_func() const { return reinterpret_cast<const QGraphicsTransformPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsTransformPrivate;
};

class QGraphicsScalePrivate;

class  QGraphicsScale : public QGraphicsTransform
{
Q_OBJECT

Q_PROPERTY(QVector3D origin READ origin WRITE setOrigin NOTIFY originChanged)
Q_PROPERTY(qreal xScale READ xScale WRITE setXScale NOTIFY scaleChanged)
Q_PROPERTY(qreal yScale READ yScale WRITE setYScale NOTIFY scaleChanged)
Q_PROPERTY(qreal zScale READ zScale WRITE setZScale NOTIFY scaleChanged)
public:
QGraphicsScale(QObject *parent = 0);
~QGraphicsScale();

QVector3D origin() const;
void setOrigin(const QVector3D &point);

qreal xScale() const;
void setXScale(qreal);

qreal yScale() const;
void setYScale(qreal);

qreal zScale() const;
void setZScale(qreal);

void applyTo(QMatrix4x4 *matrix) const;

signals:
void originChanged();
void scaleChanged();

private:
inline QGraphicsScalePrivate* d_func() { return reinterpret_cast<QGraphicsScalePrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsScalePrivate* d_func() const { return reinterpret_cast<const QGraphicsScalePrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsScalePrivate;
};

class QGraphicsRotationPrivate;

class  QGraphicsRotation : public QGraphicsTransform
{
Q_OBJECT

Q_PROPERTY(QVector3D origin READ origin WRITE setOrigin NOTIFY originChanged)
Q_PROPERTY(qreal angle READ angle WRITE setAngle NOTIFY angleChanged)
Q_PROPERTY(QVector3D axis READ axis WRITE setAxis NOTIFY axisChanged)
public:
QGraphicsRotation(QObject *parent = 0);
~QGraphicsRotation();

QVector3D origin() const;
void setOrigin(const QVector3D &point);

qreal angle() const;
void setAngle(qreal);

QVector3D axis() const;
void setAxis(const QVector3D &axis);
void setAxis(Qt::Axis axis);

void applyTo(QMatrix4x4 *matrix) const;

signals:
void originChanged();
void angleChanged();
void axisChanged();

private:
inline QGraphicsRotationPrivate* d_func() { return reinterpret_cast<QGraphicsRotationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsRotationPrivate* d_func() const { return reinterpret_cast<const QGraphicsRotationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsRotationPrivate;
};







# 225 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicsview.h"












































# 1 "/usr/share/qt4/include/QtCore/qmetatype.h"































































































































































































































































































































































# 45 "/usr/share/qt4/include/QtGui/qgraphicsview.h"

# 1 "/usr/share/qt4/include/QtGui/qpainter.h"
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 46 "/usr/share/qt4/include/QtGui/qgraphicsview.h"

# 1 "/usr/share/qt4/include/QtGui/qscrollarea.h"





































































































# 47 "/usr/share/qt4/include/QtGui/qgraphicsview.h"

# 1 "/usr/share/qt4/include/QtGui/qgraphicsscene.h"






































































































































































































































































































































# 48 "/usr/share/qt4/include/QtGui/qgraphicsview.h"


# 50 "/usr/share/qt4/include/QtGui/qgraphicsview.h"




typedef QtValidLicenseForGuiModule QtGuiModule;



# 58 "/usr/share/qt4/include/QtGui/qgraphicsview.h"
class QGraphicsItem;
class QPainterPath;
class QPolygonF;
class QStyleOptionGraphicsItem;

class QGraphicsViewPrivate;
class  QGraphicsView : public QAbstractScrollArea
{
Q_OBJECT

Q_ENUMS(ViewportAnchor DragMode ViewportUpdateMode)
Q_PROPERTY(QBrush backgroundBrush READ backgroundBrush WRITE setBackgroundBrush)
Q_PROPERTY(QBrush foregroundBrush READ foregroundBrush WRITE setForegroundBrush)
Q_PROPERTY(bool interactive READ isInteractive WRITE setInteractive)
Q_PROPERTY(QRectF sceneRect READ sceneRect WRITE setSceneRect)
Q_PROPERTY(Qt::Alignment alignment READ alignment WRITE setAlignment)
Q_PROPERTY(QPainter::RenderHints renderHints READ renderHints WRITE setRenderHints)
Q_PROPERTY(DragMode dragMode READ dragMode WRITE setDragMode)
Q_PROPERTY(CacheMode cacheMode READ cacheMode WRITE setCacheMode)
Q_PROPERTY(ViewportAnchor transformationAnchor READ transformationAnchor WRITE setTransformationAnchor)
Q_PROPERTY(ViewportAnchor resizeAnchor READ resizeAnchor WRITE setResizeAnchor)
Q_PROPERTY(ViewportUpdateMode viewportUpdateMode READ viewportUpdateMode WRITE setViewportUpdateMode)

# 81 "/usr/share/qt4/include/QtGui/qgraphicsview.h"
Q_PROPERTY(Qt::ItemSelectionMode rubberBandSelectionMode READ rubberBandSelectionMode WRITE setRubberBandSelectionMode)

# 83 "/usr/share/qt4/include/QtGui/qgraphicsview.h"
Q_PROPERTY(OptimizationFlags optimizationFlags READ optimizationFlags WRITE setOptimizationFlags)

public:
enum ViewportAnchor {
NoAnchor,
AnchorViewCenter,
AnchorUnderMouse
};

enum CacheModeFlag {
CacheNone = 0x0,
CacheBackground = 0x1
};
typedef QFlags<CacheModeFlag> CacheMode;

enum DragMode {
NoDrag,
ScrollHandDrag,
RubberBandDrag
};

enum ViewportUpdateMode {
FullViewportUpdate,
MinimalViewportUpdate,
SmartViewportUpdate,
NoViewportUpdate,
BoundingRectViewportUpdate
};

enum OptimizationFlag {
DontClipPainter = 0x1, 
DontSavePainterState = 0x2,
DontAdjustForAntialiasing = 0x4,
IndirectPainting = 0x8
};
typedef QFlags<OptimizationFlag> OptimizationFlags;

QGraphicsView(QWidget *parent = 0);
QGraphicsView(QGraphicsScene *scene, QWidget *parent = 0);
~QGraphicsView();

QSize sizeHint() const;

QPainter::RenderHints renderHints() const;
void setRenderHint(QPainter::RenderHint hint, bool enabled = true);
void setRenderHints(QPainter::RenderHints hints);

Qt::Alignment alignment() const;
void setAlignment(Qt::Alignment alignment);

ViewportAnchor transformationAnchor() const;
void setTransformationAnchor(ViewportAnchor anchor);

ViewportAnchor resizeAnchor() const;
void setResizeAnchor(ViewportAnchor anchor);

ViewportUpdateMode viewportUpdateMode() const;
void setViewportUpdateMode(ViewportUpdateMode mode);

OptimizationFlags optimizationFlags() const;
void setOptimizationFlag(OptimizationFlag flag, bool enabled = true);
void setOptimizationFlags(OptimizationFlags flags);

DragMode dragMode() const;
void setDragMode(DragMode mode);


# 150 "/usr/share/qt4/include/QtGui/qgraphicsview.h"
Qt::ItemSelectionMode rubberBandSelectionMode() const;
void setRubberBandSelectionMode(Qt::ItemSelectionMode mode);


# 154 "/usr/share/qt4/include/QtGui/qgraphicsview.h"
CacheMode cacheMode() const;
void setCacheMode(CacheMode mode);
void resetCachedContent();

bool isInteractive() const;
void setInteractive(bool allowed);

QGraphicsScene *scene() const;
void setScene(QGraphicsScene *scene);

QRectF sceneRect() const;
void setSceneRect(const QRectF &rect);
inline void setSceneRect(qreal x, qreal y, qreal w, qreal h);

QMatrix matrix() const;
void setMatrix(const QMatrix &matrix, bool combine = false);
void resetMatrix();
QTransform transform() const;
QTransform viewportTransform() const;
bool isTransformed() const;
void setTransform(const QTransform &matrix, bool combine = false);
void resetTransform();
void rotate(qreal angle);
void scale(qreal sx, qreal sy);
void shear(qreal sh, qreal sv);
void translate(qreal dx, qreal dy);

void centerOn(const QPointF &pos);
inline void centerOn(qreal x, qreal y);
void centerOn(const QGraphicsItem *item);
void ensureVisible(const QRectF &rect, int xmargin = 50, int ymargin = 50);
inline void ensureVisible(qreal x, qreal y, qreal w, qreal h, int xmargin = 50, int ymargin = 50);
void ensureVisible(const QGraphicsItem *item, int xmargin = 50, int ymargin = 50);
void fitInView(const QRectF &rect, Qt::AspectRatioMode aspectRadioMode = Qt::IgnoreAspectRatio);
inline void fitInView(qreal x, qreal y, qreal w, qreal h,
Qt::AspectRatioMode aspectRadioMode = Qt::IgnoreAspectRatio);
void fitInView(const QGraphicsItem *item,
Qt::AspectRatioMode aspectRadioMode = Qt::IgnoreAspectRatio);

void render(QPainter *painter, const QRectF &target = QRectF(), const QRect &source = QRect(),
Qt::AspectRatioMode aspectRatioMode = Qt::KeepAspectRatio);

QList<QGraphicsItem *> items() const;
QList<QGraphicsItem *> items(const QPoint &pos) const;
inline QList<QGraphicsItem *> items(int x, int y) const;
QList<QGraphicsItem *> items(const QRect &rect, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
inline QList<QGraphicsItem *> items(int x, int y, int w, int h, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
QList<QGraphicsItem *> items(const QPolygon &polygon, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
QList<QGraphicsItem *> items(const QPainterPath &path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
QGraphicsItem *itemAt(const QPoint &pos) const;
inline QGraphicsItem *itemAt(int x, int y) const;

QPointF mapToScene(const QPoint &point) const;
QPolygonF mapToScene(const QRect &rect) const;
QPolygonF mapToScene(const QPolygon &polygon) const;
QPainterPath mapToScene(const QPainterPath &path) const;
QPoint mapFromScene(const QPointF &point) const;
QPolygon mapFromScene(const QRectF &rect) const;
QPolygon mapFromScene(const QPolygonF &polygon) const;
QPainterPath mapFromScene(const QPainterPath &path) const;
inline QPointF mapToScene(int x, int y) const;
inline QPolygonF mapToScene(int x, int y, int w, int h) const;
inline QPoint mapFromScene(qreal x, qreal y) const;
inline QPolygon mapFromScene(qreal x, qreal y, qreal w, qreal h) const;

QVariant inputMethodQuery(Qt::InputMethodQuery query) const;

QBrush backgroundBrush() const;
void setBackgroundBrush(const QBrush &brush);

QBrush foregroundBrush() const;
void setForegroundBrush(const QBrush &brush);

public slots:
void updateScene(const QList<QRectF> &rects);
void invalidateScene(const QRectF &rect = QRectF(), QGraphicsScene::SceneLayers layers = QGraphicsScene::AllLayers);
void updateSceneRect(const QRectF &rect);

protected slots:
void setupViewport(QWidget *widget);

protected:
QGraphicsView(QGraphicsViewPrivate &, QWidget *parent = 0);
bool event(QEvent *event);
bool viewportEvent(QEvent *event);


# 241 "/usr/share/qt4/include/QtGui/qgraphicsview.h"
void contextMenuEvent(QContextMenuEvent *event);

# 243 "/usr/share/qt4/include/QtGui/qgraphicsview.h"
void dragEnterEvent(QDragEnterEvent *event);
void dragLeaveEvent(QDragLeaveEvent *event);
void dragMoveEvent(QDragMoveEvent *event);
void dropEvent(QDropEvent *event);
void focusInEvent(QFocusEvent *event);
bool focusNextPrevChild(bool next);
void focusOutEvent(QFocusEvent *event);
void keyPressEvent(QKeyEvent *event);
void keyReleaseEvent(QKeyEvent *event);
void mouseDoubleClickEvent(QMouseEvent *event);
void mousePressEvent(QMouseEvent *event);
void mouseMoveEvent(QMouseEvent *event);
void mouseReleaseEvent(QMouseEvent *event);

# 257 "/usr/share/qt4/include/QtGui/qgraphicsview.h"
void wheelEvent(QWheelEvent *event);

# 259 "/usr/share/qt4/include/QtGui/qgraphicsview.h"
void paintEvent(QPaintEvent *event);
void resizeEvent(QResizeEvent *event);
void scrollContentsBy(int dx, int dy);
void showEvent(QShowEvent *event);
void inputMethodEvent(QInputMethodEvent *event);

virtual void drawBackground(QPainter *painter, const QRectF &rect);
virtual void drawForeground(QPainter *painter, const QRectF &rect);
virtual void drawItems(QPainter *painter, int numItems,
QGraphicsItem *items[],
const QStyleOptionGraphicsItem options[]);

private:
inline QGraphicsViewPrivate* d_func() { return reinterpret_cast<QGraphicsViewPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGraphicsViewPrivate* d_func() const { return reinterpret_cast<const QGraphicsViewPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGraphicsViewPrivate;
QGraphicsView(const QGraphicsView &); QGraphicsView &operator=(const QGraphicsView &);

# 275 "/usr/share/qt4/include/QtGui/qgraphicsview.h"



# 278 "/usr/share/qt4/include/QtGui/qgraphicsview.h"
friend class QGraphicsSceneWidget;
friend class QGraphicsScene;
friend class QGraphicsScenePrivate;
friend class QGraphicsItemPrivate;
};

inline QFlags<QGraphicsView::CacheMode::enum_type> operator|(QGraphicsView::CacheMode::enum_type f1, QGraphicsView::CacheMode::enum_type f2) { return QFlags<QGraphicsView::CacheMode::enum_type>(f1) | f2; } inline QFlags<QGraphicsView::CacheMode::enum_type> operator|(QGraphicsView::CacheMode::enum_type f1, QFlags<QGraphicsView::CacheMode::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QGraphicsView::CacheMode::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<QGraphicsView::OptimizationFlags::enum_type> operator|(QGraphicsView::OptimizationFlags::enum_type f1, QGraphicsView::OptimizationFlags::enum_type f2) { return QFlags<QGraphicsView::OptimizationFlags::enum_type>(f1) | f2; } inline QFlags<QGraphicsView::OptimizationFlags::enum_type> operator|(QGraphicsView::OptimizationFlags::enum_type f1, QFlags<QGraphicsView::OptimizationFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QGraphicsView::OptimizationFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

inline void QGraphicsView::setSceneRect(qreal ax, qreal ay, qreal aw, qreal ah)
{ setSceneRect(QRectF(ax, ay, aw, ah)); }
inline void QGraphicsView::centerOn(qreal ax, qreal ay)
{ centerOn(QPointF(ax, ay)); }
inline void QGraphicsView::ensureVisible(qreal ax, qreal ay, qreal aw, qreal ah, int xmargin, int ymargin)
{ ensureVisible(QRectF(ax, ay, aw, ah), xmargin, ymargin); }
inline void QGraphicsView::fitInView(qreal ax, qreal ay, qreal w, qreal h, Qt::AspectRatioMode mode)
{ fitInView(QRectF(ax, ay, w, h), mode); }
inline QList<QGraphicsItem *> QGraphicsView::items(int ax, int ay) const
{ return items(QPoint(ax, ay)); }
inline QList<QGraphicsItem *> QGraphicsView::items(int ax, int ay, int w, int h, Qt::ItemSelectionMode mode) const
{ return items(QRect(ax, ay, w, h), mode); }
inline QGraphicsItem *QGraphicsView::itemAt(int ax, int ay) const
{ return itemAt(QPoint(ax, ay)); }
inline QPointF QGraphicsView::mapToScene(int ax, int ay) const
{ return mapToScene(QPoint(ax, ay)); }
inline QPolygonF QGraphicsView::mapToScene(int ax, int ay, int w, int h) const
{ return mapToScene(QRect(ax, ay, w, h)); }
inline QPoint QGraphicsView::mapFromScene(qreal ax, qreal ay) const
{ return mapFromScene(QPointF(ax, ay)); }
inline QPolygon QGraphicsView::mapFromScene(qreal ax, qreal ay, qreal w, qreal h) const
{ return mapFromScene(QRectF(ax, ay, w, h)); }



# 312 "/usr/share/qt4/include/QtGui/qgraphicsview.h"





# 226 "/usr/share/qt4/include/QtGui/QtGui"

# 1 "/usr/share/qt4/include/QtGui/qgraphicswidget.h"

























































































































































































































































# 227 "/usr/share/qt4/include/QtGui/QtGui"


# 6 "qwt.h"


# 1 "./../src/qwt.h"












# 1 "./../src/qwt_global.h"












# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 13 "./../src/qwt_global.h"


# 15 "./../src/qwt_global.h"





























# 44 "./../src/qwt_global.h"



# 13 "./../src/qwt.h"


# 15 "./../src/qwt.h"



namespace Qwt
{
};


# 8 "qwt.h"

# 1 "./../src/qwt_abstract_scale_draw.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_abstract_scale_draw.h"

# 1 "./../src/qwt_scale_div.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_scale_div.h"

# 1 "./../src/qwt_interval.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_interval.h"


# 1 "/usr/share/qt4/include/QtCore/qdebug.h"




























































































































































































































































































# 15 "./../src/qwt_interval.h"



# 18 "./../src/qwt_interval.h"






class  QwtInterval
{
public:




enum BorderFlag
{

IncludeBorders = 0x00,


ExcludeMinimum = 0x01,


ExcludeMaximum = 0x02,


ExcludeBorders = ExcludeMinimum | ExcludeMaximum
};


typedef QFlags<BorderFlag> BorderFlags;

QwtInterval();
QwtInterval( double minValue, double maxValue,
BorderFlags = IncludeBorders );

void setInterval( double minValue, double maxValue,
BorderFlags = IncludeBorders );

QwtInterval normalized() const;
QwtInterval inverted() const;
QwtInterval limited( double minValue, double maxValue ) const;

bool operator==( const QwtInterval & ) const;
bool operator!=( const QwtInterval & ) const;

void setBorderFlags( BorderFlags );
BorderFlags borderFlags() const;

double minValue() const;
double maxValue() const;

double width() const;

void setMinValue( double );
void setMaxValue( double );

bool contains( double value ) const;

bool intersects( const QwtInterval & ) const;
QwtInterval intersect( const QwtInterval & ) const;
QwtInterval unite( const QwtInterval & ) const;

QwtInterval operator|( const QwtInterval & ) const;
QwtInterval operator&( const QwtInterval & ) const;

QwtInterval &operator|=( const QwtInterval & );
QwtInterval &operator&=( const QwtInterval & );

QwtInterval extend( double value ) const;
QwtInterval operator|( double ) const;
QwtInterval &operator|=( double );

bool isValid() const;
bool isNull() const;
void invalidate();

QwtInterval symmetrize( double value ) const;

private:
double d_minValue;
double d_maxValue;
BorderFlags d_borderFlags;
};

template <> class QTypeInfo<QwtInterval > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QwtInterval)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QwtInterval"; } };







inline QwtInterval::QwtInterval():
d_minValue( 0.0 ),
d_maxValue( -1.0 ),
d_borderFlags( IncludeBorders )
{
}










inline QwtInterval::QwtInterval(
double minValue, double maxValue, BorderFlags borderFlags ):
d_minValue( minValue ),
d_maxValue( maxValue ),
d_borderFlags( borderFlags )
{
}








inline void QwtInterval::setInterval(
double minValue, double maxValue, BorderFlags borderFlags )
{
d_minValue = minValue;
d_maxValue = maxValue;
d_borderFlags = borderFlags;
}







inline void QwtInterval::setBorderFlags( BorderFlags borderFlags )
{
d_borderFlags = borderFlags;
}





inline QwtInterval::BorderFlags QwtInterval::borderFlags() const
{
return d_borderFlags;
}






inline void QwtInterval::setMinValue( double minValue )
{
d_minValue = minValue;
}






inline void QwtInterval::setMaxValue( double maxValue )
{
d_maxValue = maxValue;
}


inline double QwtInterval::minValue() const
{
return d_minValue;
}


inline double QwtInterval::maxValue() const
{
return d_maxValue;
}








inline double QwtInterval::width() const
{
return isValid() ? ( d_maxValue - d_minValue ) : 0.0;
}





inline QwtInterval QwtInterval::operator&(
const QwtInterval &interval ) const
{
return intersect( interval );
}





inline QwtInterval QwtInterval::operator|(
const QwtInterval &interval ) const
{
return unite( interval );
}


inline bool QwtInterval::operator==( const QwtInterval &other ) const
{
return ( d_minValue == other.d_minValue ) &&
( d_maxValue == other.d_maxValue ) &&
( d_borderFlags == other.d_borderFlags );
}


inline bool QwtInterval::operator!=( const QwtInterval &other ) const
{
return ( !( *this == other ) );
}








inline QwtInterval QwtInterval::operator|( double value ) const
{
return extend( value );
}


inline bool QwtInterval::isNull() const
{
return isValid() && d_minValue >= d_maxValue;
}






inline bool QwtInterval::isValid() const
{
if ( ( d_borderFlags & ExcludeBorders ) == 0 )
return d_minValue <= d_maxValue;
else
return d_minValue < d_maxValue;
}







inline void QwtInterval::invalidate()
{
d_minValue = 0.0;
d_maxValue = -1.0;
}

inline QFlags<QwtInterval::BorderFlags ::enum_type> operator|(QwtInterval::BorderFlags ::enum_type f1, QwtInterval::BorderFlags ::enum_type f2) { return QFlags<QwtInterval::BorderFlags ::enum_type>(f1) | f2; } inline QFlags<QwtInterval::BorderFlags ::enum_type> operator|(QwtInterval::BorderFlags ::enum_type f1, QFlags<QwtInterval::BorderFlags ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtInterval::BorderFlags ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 293 "./../src/qwt_interval.h"
 QDebug operator<<( QDebug, const QwtInterval & );



# 14 "./../src/qwt_scale_div.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 15 "./../src/qwt_scale_div.h"


# 17 "./../src/qwt_scale_div.h"
class QwtInterval;












class  QwtScaleDiv
{
public:

enum TickType
{

NoTick = -1,


MinorTick,


MediumTick,


MajorTick,


NTickTypes
};

explicit QwtScaleDiv();
explicit QwtScaleDiv( const QwtInterval &, QList<double>[NTickTypes] );
explicit QwtScaleDiv( 
double lowerBound, double upperBound, QList<double>[NTickTypes] );

bool operator==( const QwtScaleDiv &s ) const;
bool operator!=( const QwtScaleDiv &s ) const;

void setInterval( double lowerBound, double upperBound );
void setInterval( const QwtInterval & );
QwtInterval interval() const;

double lowerBound() const;
double upperBound() const;
double range() const;

bool contains( double v ) const;

void setTicks( int type, const QList<double> & );
const QList<double> &ticks( int type ) const;

void invalidate();
bool isValid() const;

void invert();

private:
double d_lowerBound;
double d_upperBound;
QList<double> d_ticks[NTickTypes];

bool d_isValid;
};

template <> class QTypeInfo<QwtScaleDiv > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QwtScaleDiv)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QwtScaleDiv"; } };






inline void QwtScaleDiv::setInterval( double lowerBound, double upperBound )
{
d_lowerBound = lowerBound;
d_upperBound = upperBound;
}




inline QwtInterval QwtScaleDiv::interval() const
{
return QwtInterval( d_lowerBound, d_upperBound );
}





inline double QwtScaleDiv::lowerBound() const
{
return d_lowerBound;
}





inline double QwtScaleDiv::upperBound() const
{
return d_upperBound;
}




inline double QwtScaleDiv::range() const
{
return d_upperBound - d_lowerBound;
}

# 14 "./../src/qwt_abstract_scale_draw.h"

# 1 "./../src/qwt_text.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_text.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 14 "./../src/qwt_text.h"

# 1 "/usr/share/qt4/include/QtCore/qsize.h"








































































































































































































































































































































































# 15 "./../src/qwt_text.h"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 16 "./../src/qwt_text.h"


# 18 "./../src/qwt_text.h"
class QColor;
class QPen;
class QBrush;
class QRectF;
class QPainter;
class QwtTextEngine;

























class  QwtText
{
public:










enum TextFormat
{






AutoText = 0,


PlainText,


RichText,









MathMLText,





TeXText,





OtherFormat = 100
};







enum PaintAttribute
{

PaintUsingTextFont = 0x01,


PaintUsingTextColor = 0x02,


PaintBackground = 0x04
};


typedef QFlags<PaintAttribute> PaintAttributes;





enum LayoutAttribute
{






MinimumLayout = 0x01
};


typedef QFlags<LayoutAttribute> LayoutAttributes;

QwtText( const QString & = QString::null,
TextFormat textFormat = AutoText );
QwtText( const QwtText & );
~QwtText();

QwtText &operator=( const QwtText & );

bool operator==( const QwtText & ) const;
bool operator!=( const QwtText & ) const;

void setText( const QString &,
QwtText::TextFormat textFormat = AutoText );
QString text() const;

bool isNull() const;
bool isEmpty() const;

void setFont( const QFont & );
QFont font() const;

QFont usedFont( const QFont & ) const;

void setRenderFlags( int flags );
int renderFlags() const;

void setColor( const QColor & );
QColor color() const;

QColor usedColor( const QColor & ) const;

void setBackgroundPen( const QPen & );
QPen backgroundPen() const;

void setBackgroundBrush( const QBrush & );
QBrush backgroundBrush() const;

void setPaintAttribute( PaintAttribute, bool on = true );
bool testPaintAttribute( PaintAttribute ) const;

void setLayoutAttribute( LayoutAttribute, bool on = true );
bool testLayoutAttribute( LayoutAttribute ) const;

double heightForWidth( double width, const QFont & = QFont() ) const;
QSizeF textSize( const QFont & = QFont() ) const;

void draw( QPainter *painter, const QRectF &rect ) const;

static const QwtTextEngine *textEngine( 
const QString &text, QwtText::TextFormat = AutoText );

static const QwtTextEngine *textEngine( QwtText::TextFormat );
static void setTextEngine( QwtText::TextFormat, QwtTextEngine * );

private:
class PrivateData;
PrivateData *d_data;

class LayoutCache;
LayoutCache *d_layoutCache;
};


inline bool QwtText::isNull() const
{
return text().isNull();
}


inline bool QwtText::isEmpty() const
{
return text().isEmpty();
}

inline QFlags<QwtText::PaintAttributes ::enum_type> operator|(QwtText::PaintAttributes ::enum_type f1, QwtText::PaintAttributes ::enum_type f2) { return QFlags<QwtText::PaintAttributes ::enum_type>(f1) | f2; } inline QFlags<QwtText::PaintAttributes ::enum_type> operator|(QwtText::PaintAttributes ::enum_type f1, QFlags<QwtText::PaintAttributes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtText::PaintAttributes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<QwtText::LayoutAttributes ::enum_type> operator|(QwtText::LayoutAttributes ::enum_type f1, QwtText::LayoutAttributes ::enum_type f2) { return QFlags<QwtText::LayoutAttributes ::enum_type>(f1) | f2; } inline QFlags<QwtText::LayoutAttributes ::enum_type> operator|(QwtText::LayoutAttributes ::enum_type f1, QFlags<QwtText::LayoutAttributes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtText::LayoutAttributes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 15 "./../src/qwt_abstract_scale_draw.h"


# 17 "./../src/qwt_abstract_scale_draw.h"
class QPalette;
class QPainter;
class QFont;
class QwtScaleTransformation;
class QwtScaleMap;










class  QwtAbstractScaleDraw
{
public:





enum ScaleComponent
{

Backbone = 0x01,


Ticks = 0x02,


Labels = 0x04
};


typedef QFlags<ScaleComponent> ScaleComponents;

QwtAbstractScaleDraw();
virtual ~QwtAbstractScaleDraw();

void setScaleDiv( const QwtScaleDiv &s );
const QwtScaleDiv& scaleDiv() const;

void setTransformation( QwtScaleTransformation * );
const QwtScaleMap &scaleMap() const;
QwtScaleMap &scaleMap();

void enableComponent( ScaleComponent, bool enable = true );
bool hasComponent( ScaleComponent ) const;

void setTickLength( QwtScaleDiv::TickType, double length );
double tickLength( QwtScaleDiv::TickType ) const;
double maxTickLength() const;

void setSpacing( double margin );
double spacing() const;

void setPenWidth( int width );
int penWidth() const;

virtual void draw( QPainter *, const QPalette & ) const;

virtual QwtText label( double ) const;










virtual double extent( const QFont & ) const = 0;

void setMinimumExtent( double );
double minimumExtent() const;

protected:









virtual void drawTick( QPainter *painter, double value, double len ) const = 0;







virtual void drawBackbone( QPainter *painter ) const = 0;









virtual void drawLabel( QPainter *painter, double value ) const = 0;

void invalidateCache();
const QwtText &tickLabel( const QFont &, double value ) const;

private:
QwtAbstractScaleDraw( const QwtAbstractScaleDraw & );
QwtAbstractScaleDraw &operator=( const QwtAbstractScaleDraw & );

class PrivateData;
PrivateData *d_data;
};

inline QFlags<QwtAbstractScaleDraw::ScaleComponents ::enum_type> operator|(QwtAbstractScaleDraw::ScaleComponents ::enum_type f1, QwtAbstractScaleDraw::ScaleComponents ::enum_type f2) { return QFlags<QwtAbstractScaleDraw::ScaleComponents ::enum_type>(f1) | f2; } inline QFlags<QwtAbstractScaleDraw::ScaleComponents ::enum_type> operator|(QwtAbstractScaleDraw::ScaleComponents ::enum_type f1, QFlags<QwtAbstractScaleDraw::ScaleComponents ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtAbstractScaleDraw::ScaleComponents ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 9 "qwt.h"

# 1 "./../src/qwt_interval_symbol.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_interval_symbol.h"

# 1 "/usr/share/qt4/include/QtGui/qpen.h"












































































































































# 14 "./../src/qwt_interval_symbol.h"

# 1 "/usr/share/qt4/include/QtCore/qsize.h"








































































































































































































































































































































































# 15 "./../src/qwt_interval_symbol.h"


# 17 "./../src/qwt_interval_symbol.h"
class QPainter;
class QRect;
class QPointF;






class  QwtIntervalSymbol
{
public:

enum Style
{

NoSymbol = -1,





Bar,






Box,






UserSymbol = 1000
};

public:
QwtIntervalSymbol( Style = NoSymbol );
QwtIntervalSymbol( const QwtIntervalSymbol & );
virtual ~QwtIntervalSymbol();

QwtIntervalSymbol &operator=( const QwtIntervalSymbol & );
bool operator==( const QwtIntervalSymbol & ) const;
bool operator!=( const QwtIntervalSymbol & ) const;

void setWidth( int );
int width() const;

void setBrush( const QBrush& b );
const QBrush& brush() const;

void setPen( const QPen & );
const QPen& pen() const;

void setStyle( Style );
Style style() const;

virtual void draw( QPainter *, Qt::Orientation,
const QPointF& from, const QPointF& to ) const;

private:

class PrivateData;
PrivateData* d_data;
};


# 10 "qwt.h"

# 1 "./../src/qwt_clipper.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_clipper.h"

# 1 "./../src/qwt_interval.h"



































































































































































































































# 14 "./../src/qwt_clipper.h"

# 1 "/usr/share/qt4/include/QtGui/qpolygon.h"




















































































































































































# 15 "./../src/qwt_clipper.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 16 "./../src/qwt_clipper.h"


# 18 "./../src/qwt_clipper.h"
class QRect;
class QRectF;





class  QwtClipper
{
public:
static QPolygon clipPolygon( const QRect &, 
const QPolygon &, bool closePolygon = false );
static QPolygonF clipPolygonF( const QRectF &, 
const QPolygonF &, bool closePolygon = false );

static QVector<QwtInterval> clipCircle(
const QRectF &, const QPointF &, double radius );
};


# 11 "qwt.h"

# 1 "./../src/qwt_color_map.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_color_map.h"

# 1 "./../src/qwt_interval.h"



































































































































































































































# 14 "./../src/qwt_color_map.h"

# 1 "/usr/share/qt4/include/QtGui/qcolor.h"

















































































































































































































































































































# 15 "./../src/qwt_color_map.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 16 "./../src/qwt_color_map.h"


# 18 "./../src/qwt_color_map.h"















class  QwtColorMap
{
public:





enum Format
{

RGB,





Indexed
};

QwtColorMap( Format = QwtColorMap::RGB );
virtual ~QwtColorMap();

Format format() const;







virtual QRgb rgb( const QwtInterval &interval,
double value ) const = 0;







virtual unsigned char colorIndex(
const QwtInterval &interval, double value ) const = 0;

QColor color( const QwtInterval &, double value ) const;
virtual QVector<QRgb> colorTable( const QwtInterval & ) const;

private:
Format d_format;
};








class  QwtLinearColorMap: public QwtColorMap
{
public:




enum Mode
{

FixedColors,


ScaledColors
};

QwtLinearColorMap( QwtColorMap::Format = QwtColorMap::RGB );
QwtLinearColorMap( const QColor &from, const QColor &to,
QwtColorMap::Format = QwtColorMap::RGB );

virtual ~QwtLinearColorMap();

void setMode( Mode );
Mode mode() const;

void setColorInterval( const QColor &color1, const QColor &color2 );
void addColorStop( double value, const QColor& );
QVector<double> colorStops() const;

QColor color1() const;
QColor color2() const;

virtual QRgb rgb( const QwtInterval &, double value ) const;
virtual unsigned char colorIndex(
const QwtInterval &, double value ) const;

class ColorStops;

private:

QwtLinearColorMap( const QwtLinearColorMap & );
QwtLinearColorMap &operator=( const QwtLinearColorMap & );

class PrivateData;
PrivateData *d_data;
};




class  QwtAlphaColorMap: public QwtColorMap
{
public:
QwtAlphaColorMap( const QColor & = QColor( Qt::gray ) );
virtual ~QwtAlphaColorMap();

void setColor( const QColor & );
QColor color() const;

virtual QRgb rgb( const QwtInterval &, double value ) const;

private:
QwtAlphaColorMap( const QwtAlphaColorMap & );
QwtAlphaColorMap &operator=( const QwtAlphaColorMap & );

virtual unsigned char colorIndex(
const QwtInterval &, double value ) const;

class PrivateData;
PrivateData *d_data;
};














inline QColor QwtColorMap::color(
const QwtInterval &interval, double value ) const
{
if ( d_format == RGB )
{
return QColor( rgb( interval, value ) );
}
else
{
const unsigned int index = colorIndex( interval, value );
return colorTable( interval )[index]; 
}
}





inline QwtColorMap::Format QwtColorMap::format() const
{
return d_format;
}


# 12 "qwt.h"

# 1 "./../src/qwt_compat.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_compat.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 14 "./../src/qwt_compat.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 15 "./../src/qwt_compat.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 16 "./../src/qwt_compat.h"

# 1 "/usr/share/qt4/include/QtCore/qsize.h"








































































































































































































































































































































































# 17 "./../src/qwt_compat.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 18 "./../src/qwt_compat.h"

# 1 "/usr/share/qt4/include/QtGui/qpolygon.h"




















































































































































































# 19 "./../src/qwt_compat.h"


# 21 "./../src/qwt_compat.h"









# 30 "./../src/qwt_compat.h"
typedef QList<double> QwtValueList;
typedef QPointF QwtDoublePoint;
typedef QSizeF QwtDoubleSize;
typedef QRectF QwtDoubleRect;

typedef QPolygon QwtPolygon;
typedef QPolygonF QwtPolygonF;
typedef QwtInterval QwtDoubleInterval;
typedef QwtPoint3D QwtDoublePoint3D;


# 13 "qwt.h"

# 1 "./../src/qwt_column_symbol.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_column_symbol.h"

# 1 "./../src/qwt_interval.h"



































































































































































































































# 14 "./../src/qwt_column_symbol.h"

# 1 "/usr/share/qt4/include/QtGui/qpen.h"












































































































































# 15 "./../src/qwt_column_symbol.h"

# 1 "/usr/share/qt4/include/QtCore/qsize.h"








































































































































































































































































































































































# 16 "./../src/qwt_column_symbol.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 17 "./../src/qwt_column_symbol.h"


# 19 "./../src/qwt_column_symbol.h"
class QPainter;
class QPalette;
class QRect;
class QwtText;





class  QwtColumnRect
{
public:

enum Direction
{

LeftToRight,


RightToLeft,


BottomToTop,


TopToBottom
};


QwtColumnRect():
direction( BottomToTop )
{
}


QRectF toRect() const
{
QRectF r( hInterval.minValue(), vInterval.minValue(),
hInterval.maxValue() - hInterval.minValue(),
vInterval.maxValue() - vInterval.minValue() );
r = r.normalized();

if ( hInterval.borderFlags() & QwtInterval::ExcludeMinimum )
r.adjust( 1, 0, 0, 0 );
if ( hInterval.borderFlags() & QwtInterval::ExcludeMaximum )
r.adjust( 0, 0, -1, 0 );
if ( vInterval.borderFlags() & QwtInterval::ExcludeMinimum )
r.adjust( 0, 1, 0, 0 );
if ( vInterval.borderFlags() & QwtInterval::ExcludeMaximum )
r.adjust( 0, 0, 0, -1 );

return r;
}


Qt::Orientation orientation() const
{
if ( direction == LeftToRight || direction == RightToLeft )
return Qt::Horizontal;

return Qt::Vertical;
}


QwtInterval hInterval;


QwtInterval vInterval;


Direction direction;
};


class  QwtColumnSymbol
{
public:




enum Style
{

NoStyle = -1,





Box,






UserStyle = 1000
};





enum FrameStyle
{

NoFrame,


Plain,


Raised
};

public:
QwtColumnSymbol( Style = NoStyle );
virtual ~QwtColumnSymbol();

void setFrameStyle( FrameStyle style );
FrameStyle frameStyle() const;

void setLineWidth( int width );
int lineWidth() const;

void setPalette( const QPalette & );
const QPalette &palette() const;

void setStyle( Style );
Style style() const;

virtual void draw( QPainter *, const QwtColumnRect & ) const;

protected:
void drawBox( QPainter *, const QwtColumnRect & ) const;

private:
class PrivateData;
PrivateData* d_data;
};


# 14 "qwt.h"

# 1 "./../src/qwt_interval.h"



































































































































































































































# 15 "qwt.h"

# 1 "./../src/qwt_dyngrid_layout.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_dyngrid_layout.h"

# 1 "/usr/share/qt4/include/QtGui/qlayout.h"





















































































































































































































































# 14 "./../src/qwt_dyngrid_layout.h"

# 1 "/usr/share/qt4/include/QtCore/qsize.h"








































































































































































































































































































































































# 15 "./../src/qwt_dyngrid_layout.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 16 "./../src/qwt_dyngrid_layout.h"


# 18 "./../src/qwt_dyngrid_layout.h"









class  QwtDynGridLayout : public QLayout
{
Q_OBJECT
public:
explicit QwtDynGridLayout( QWidget *, int margin = 0, int space = -1 );
explicit QwtDynGridLayout( int space = -1 );

virtual ~QwtDynGridLayout();

virtual void invalidate();

void setMaxCols( uint maxCols );
uint maxCols() const;

uint numRows () const;
uint numCols () const;

virtual void addItem( QLayoutItem * );

virtual QLayoutItem *itemAt( int index ) const;
virtual QLayoutItem *takeAt( int index );
virtual int count() const;

void setExpandingDirections( Qt::Orientations );
virtual Qt::Orientations expandingDirections() const;
QList<QRect> layoutItems( const QRect &, uint numCols ) const;

virtual int maxItemWidth() const;

virtual void setGeometry( const QRect &rect );

virtual bool hasHeightForWidth() const;
virtual int heightForWidth( int ) const;

virtual QSize sizeHint() const;

virtual bool isEmpty() const;
uint itemCount() const;

virtual uint columnsForWidth( int width ) const;

protected:

void layoutGrid( uint numCols,
QVector<int>& rowHeight, QVector<int>& colWidth ) const;
void stretchGrid( const QRect &rect, uint numCols,
QVector<int>& rowHeight, QVector<int>& colWidth ) const;

private:
void init();
int maxRowWidth( int numCols ) const;

class PrivateData;
PrivateData *d_data;
};


# 16 "qwt.h"

# 1 "./../src/qwt_global.h"














































# 17 "qwt.h"

# 1 "./../src/qwt_math.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_math.h"







# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 26 "./../src/qwt_math.h"

# 1 "/usr/share/qt4/include/QtCore/qmath.h"
































































































































































































































































































# 27 "./../src/qwt_math.h"

# 1 "./../src/qwt_global.h"














































# 28 "./../src/qwt_math.h"



















# 47 "./../src/qwt_math.h"





# 52 "./../src/qwt_math.h"
























































# 108 "./../src/qwt_math.h"
 double qwtGetMin( const double *array, int size );
 double qwtGetMax( const double *array, int size );













inline int qwtFuzzyCompare( double value1, double value2, double intervalSize )
{
const double eps = qAbs( 1.0e-6 * intervalSize );

if ( value2 - value1 > eps )
return -1;

if ( value1 - value2 > eps )
return 1;

return 0;
}


inline bool qwtFuzzyGreaterOrEqual( double d1, double d2 )
{
return ( d1 >= d2 ) || qFuzzyCompare( d1, d2 );
}

inline bool qwtFuzzyLessOrEqual( double d1, double d2 )
{
return ( d1 <= d2 ) || qFuzzyCompare( d1, d2 );
}


inline int qwtSign( double x )
{
if ( x > 0.0 )
return 1;
else if ( x < 0.0 )
return ( -1 );
else
return 0;
}


inline double qwtSqr( double x )
{
return x * x;
}


inline double qwtRoundF(double d)
{ 
return ::floor( d + 0.5 );
}


inline double qwtFloorF(double d)
{ 
return ::floor( d );
}


inline double qwtCeilF(double d)
{ 
return ::ceil( d );
}


# 18 "qwt.h"

# 1 "./../src/qwt_magnifier.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_magnifier.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 14 "./../src/qwt_magnifier.h"


# 16 "./../src/qwt_magnifier.h"
class QWidget;
class QMouseEvent;
class QWheelEvent;
class QKeyEvent;







class  QwtMagnifier: public QObject
{
Q_OBJECT

public:
explicit QwtMagnifier( QWidget * );
virtual ~QwtMagnifier();

QWidget *parentWidget();
const QWidget *parentWidget() const;

void setEnabled( bool );
bool isEnabled() const;


void setMouseFactor( double );
double mouseFactor() const;

void setMouseButton( int button, int buttonState = Qt::NoButton );
void getMouseButton( int &button, int &buttonState ) const;


void setWheelFactor( double );
double wheelFactor() const;

void setWheelButtonState( int buttonState );
int wheelButtonState() const;


void setKeyFactor( double );
double keyFactor() const;

void setZoomInKey( int key, int modifiers );
void getZoomInKey( int &key, int &modifiers ) const;

void setZoomOutKey( int key, int modifiers );
void getZoomOutKey( int &key, int &modifiers ) const;

virtual bool eventFilter( QObject *, QEvent * );

protected:




virtual void rescale( double factor ) = 0;

virtual void widgetMousePressEvent( QMouseEvent * );
virtual void widgetMouseReleaseEvent( QMouseEvent * );
virtual void widgetMouseMoveEvent( QMouseEvent * );
virtual void widgetWheelEvent( QWheelEvent * );
virtual void widgetKeyPressEvent( QKeyEvent * );
virtual void widgetKeyReleaseEvent( QKeyEvent * );

private:
class PrivateData;
PrivateData *d_data;
};


# 19 "qwt.h"

# 1 "./../src/qwt_null_paintdevice.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_null_paintdevice.h"

# 1 "/usr/share/qt4/include/QtGui/qpaintdevice.h"















































































































































































# 14 "./../src/qwt_null_paintdevice.h"

# 1 "/usr/share/qt4/include/QtGui/qpaintengine.h"







































































































































































































































































































































































# 15 "./../src/qwt_null_paintdevice.h"


# 17 "./../src/qwt_null_paintdevice.h"














class  QwtNullPaintDevice: public QPaintDevice
{
public:
QwtNullPaintDevice( QPaintEngine::PaintEngineFeatures );
QwtNullPaintDevice( const QSize &size,
QPaintEngine::PaintEngineFeatures );

virtual ~QwtNullPaintDevice();

void setSize( const QSize &);
QSize size() const;

virtual QPaintEngine *paintEngine() const;
virtual int metric( PaintDeviceMetric metric ) const;

virtual void drawRects(const QRect *, int );
virtual void drawRects(const QRectF *, int );

virtual void drawLines(const QLine *, int );
virtual void drawLines(const QLineF *, int );

virtual void drawEllipse(const QRectF &);
virtual void drawEllipse(const QRect &);

virtual void drawPath(const QPainterPath &);

virtual void drawPoints(const QPointF *, int );
virtual void drawPoints(const QPoint *, int );

virtual void drawPolygon(
const QPointF *, int , QPaintEngine::PolygonDrawMode );

virtual void drawPolygon(
const QPoint *, int , QPaintEngine::PolygonDrawMode );

virtual void drawPixmap(const QRectF &,
const QPixmap &, const QRectF &);

virtual void drawTextItem(const QPointF &, const QTextItem &);

virtual void drawTiledPixmap(const QRectF &,
const QPixmap &, const QPointF &s);

virtual void drawImage(const QRectF &,
const QImage &, const QRectF &, Qt::ImageConversionFlags );

virtual void updateState( const QPaintEngineState &state );

private:
void init( QPaintEngine::PaintEngineFeatures );

class PaintEngine;
PaintEngine *d_engine;

class PrivateData;
PrivateData *d_data;
};


# 20 "qwt.h"

# 1 "./../src/qwt_painter.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_painter.h"


# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 15 "./../src/qwt_painter.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 16 "./../src/qwt_painter.h"

# 1 "/usr/share/qt4/include/QtGui/qpen.h"












































































































































# 17 "./../src/qwt_painter.h"

# 1 "/usr/share/qt4/include/QtCore/qline.h"
































































































































































































































































































































































































































# 18 "./../src/qwt_painter.h"


# 20 "./../src/qwt_painter.h"
class QPainter;
class QBrush;
class QColor;
class QWidget;
class QPolygonF;
class QRectF;
class QImage;
class QPixmap;
class QwtScaleMap;
class QwtColorMap;
class QwtInterval;

class QPalette;
class QTextDocument;
class QPainterPath;




class  QwtPainter
{
public:
static void setPolylineSplitting( bool );
static bool polylineSplitting();

static void setRoundingAlignment( bool );
static bool roundingAlignment();
static bool roundingAlignment(QPainter *);

static void drawText( QPainter *, double x, double y, const QString & );
static void drawText( QPainter *, const QPointF &, const QString & );
static void drawText( QPainter *, double x, double y, double w, double h,
int flags, const QString & );
static void drawText( QPainter *, const QRectF &, 
int flags, const QString & );


# 57 "./../src/qwt_painter.h"
static void drawSimpleRichText( QPainter *, const QRectF &,
int flags, const QTextDocument & );


# 61 "./../src/qwt_painter.h"
static void drawRect( QPainter *, double x, double y, double w, double h );
static void drawRect( QPainter *, const QRectF &rect );
static void fillRect( QPainter *, const QRectF &, const QBrush & );

static void drawEllipse( QPainter *, const QRectF & );
static void drawPie( QPainter *, const QRectF & r, int a, int alen );

static void drawLine( QPainter *, double x1, double y1, double x2, double y2 );
static void drawLine( QPainter *, const QPointF &p1, const QPointF &p2 );
static void drawLine( QPainter *, const QLineF & );

static void drawPolygon( QPainter *, const QPolygonF &pa );
static void drawPolyline( QPainter *, const QPolygonF &pa );
static void drawPolyline( QPainter *, const QPointF *, int pointCount );

static void drawPoint( QPainter *, double x, double y );
static void drawPoint( QPainter *, const QPointF & );

static void drawPath( QPainter *, const QPainterPath & );
static void drawImage( QPainter *, const QRectF &, const QImage & );
static void drawPixmap( QPainter *, const QRectF &, const QPixmap & );

static void drawRoundedFrame( QPainter *, 
const QRectF &, double xRadius, double yRadius,
const QPalette &, int lineWidth, int frameStyle );

static void drawFocusRect( QPainter *, QWidget * );
static void drawFocusRect( QPainter *, QWidget *, const QRect & );

static void drawColorBar( QPainter *painter,
const QwtColorMap &, const QwtInterval &,
const QwtScaleMap &, Qt::Orientation, const QRectF & );

static bool isAligning( QPainter *painter );

private:
static bool d_polylineSplitting;
static bool d_roundingAlignment;
};


inline void QwtPainter::drawPoint( QPainter *painter, double x, double y )
{
QwtPainter::drawPoint( painter, QPointF( x, y ) );
}


inline void QwtPainter::drawLine( QPainter *painter,
double x1, double y1, double x2, double y2 )
{
QwtPainter::drawLine( painter, QPointF( x1, y1 ), QPointF( x2, y2 ) );
}


inline void QwtPainter::drawLine( QPainter *painter, const QLineF &line )
{
QwtPainter::drawLine( painter, line.p1(), line.p2() );
}





inline bool QwtPainter::polylineSplitting()
{
return d_polylineSplitting;
}








inline bool QwtPainter::roundingAlignment()
{
return d_roundingAlignment;
}





inline bool QwtPainter::roundingAlignment(QPainter *painter)
{
return d_roundingAlignment && isAligning(painter);
}

# 21 "qwt.h"

# 1 "./../src/qwt_panner.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_panner.h"

# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 14 "./../src/qwt_panner.h"

# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 15 "./../src/qwt_panner.h"


# 17 "./../src/qwt_panner.h"
class QCursor;

















class  QwtPanner: public QWidget
{
Q_OBJECT

public:
QwtPanner( QWidget* parent );
virtual ~QwtPanner();

void setEnabled( bool );
bool isEnabled() const;

void setMouseButton( int button, int buttonState = Qt::NoButton );
void getMouseButton( int &button, int &buttonState ) const;
void setAbortKey( int key, int state = Qt::NoButton );
void getAbortKey( int &key, int &state ) const;

void setCursor( const QCursor & );
const QCursor cursor() const;

void setOrientations( Qt::Orientations );
Qt::Orientations orientations() const;

bool isOrientationEnabled( Qt::Orientation ) const;

virtual bool eventFilter( QObject *, QEvent * );

signals:






void panned( int dx, int dy );








void moved( int dx, int dy );

protected:
virtual void widgetMousePressEvent( QMouseEvent * );
virtual void widgetMouseReleaseEvent( QMouseEvent * );
virtual void widgetMouseMoveEvent( QMouseEvent * );
virtual void widgetKeyPressEvent( QKeyEvent * );
virtual void widgetKeyReleaseEvent( QKeyEvent * );

virtual void paintEvent( QPaintEvent * );

virtual QBitmap contentsMask() const;
virtual QPixmap grab() const;

private:

# 93 "./../src/qwt_panner.h"
void showCursor( bool );


# 96 "./../src/qwt_panner.h"
class PrivateData;
PrivateData *d_data;
};


# 22 "qwt.h"

# 1 "./../src/qwt_picker.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_picker.h"

# 1 "./../src/qwt_text.h"




























































































































































# 14 "./../src/qwt_picker.h"

# 1 "./../src/qwt_event_pattern.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_event_pattern.h"

# 1 "/usr/share/qt4/include/QtCore/qnamespace.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 14 "./../src/qwt_event_pattern.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 15 "./../src/qwt_event_pattern.h"


# 17 "./../src/qwt_event_pattern.h"
class QMouseEvent;
class QKeyEvent;










class  QwtEventPattern
{
public:
















































enum MousePatternCode
{
MouseSelect1,
MouseSelect2,
MouseSelect3,
MouseSelect4,
MouseSelect5,
MouseSelect6,

MousePatternCount
};




























enum KeyPatternCode
{
KeySelect1,
KeySelect2,
KeyAbort,

KeyLeft,
KeyRight,
KeyUp,
KeyDown,

KeyRedo,
KeyUndo,
KeyHome,

KeyPatternCount
};


class MousePattern
{
public:

MousePattern( int btn = Qt::NoButton, int st = Qt::NoButton )
{
button = btn;
state = st;
}


int button;


int state;
};


class KeyPattern
{
public:

KeyPattern( int k = 0, int st = Qt::NoButton )
{
key = k;
state = st;
}


int key;


int state;
};

QwtEventPattern();
virtual ~QwtEventPattern();

void initMousePattern( int numButtons );
void initKeyPattern();

void setMousePattern( uint pattern, int button, int state = Qt::NoButton );
void setKeyPattern( uint pattern, int key, int state = Qt::NoButton );

void setMousePattern( const QVector<MousePattern> & );
void setKeyPattern( const QVector<KeyPattern> & );

const QVector<MousePattern> &mousePattern() const;
const QVector<KeyPattern> &keyPattern() const;

QVector<MousePattern> &mousePattern();
QVector<KeyPattern> &keyPattern();

bool mouseMatch( uint pattern, const QMouseEvent * ) const;
bool keyMatch( uint pattern, const QKeyEvent * ) const;

protected:
virtual bool mouseMatch( const MousePattern &, const QMouseEvent * ) const;
virtual bool keyMatch( const KeyPattern &, const QKeyEvent * ) const;

private:





# 204 "./../src/qwt_event_pattern.h"
QVector<MousePattern> d_mousePattern;
QVector<KeyPattern> d_keyPattern;



# 209 "./../src/qwt_event_pattern.h"
};


inline bool operator==( QwtEventPattern::MousePattern b1,
QwtEventPattern::MousePattern b2 )
{
return b1.button == b2.button && b1.state == b2.state;
}


inline bool operator==( QwtEventPattern::KeyPattern b1,
QwtEventPattern::KeyPattern b2 )
{
return b1.key == b2.key && b1.state == b2.state;
}


# 15 "./../src/qwt_picker.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 16 "./../src/qwt_picker.h"

# 1 "/usr/share/qt4/include/QtGui/qpen.h"












































































































































# 17 "./../src/qwt_picker.h"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 18 "./../src/qwt_picker.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 19 "./../src/qwt_picker.h"


# 21 "./../src/qwt_picker.h"
class QWidget;
class QMouseEvent;
class QWheelEvent;
class QKeyEvent;
class QwtPickerMachine;



































































class  QwtPicker: public QObject, public QwtEventPattern
{
Q_OBJECT

Q_ENUMS( RubberBand )
Q_ENUMS( DisplayMode )
Q_ENUMS( ResizeMode )

Q_PROPERTY( bool isEnabled READ isEnabled WRITE setEnabled )
Q_PROPERTY( ResizeMode resizeMode READ resizeMode WRITE setResizeMode )

Q_PROPERTY( DisplayMode trackerMode READ trackerMode WRITE setTrackerMode )
Q_PROPERTY( QPen trackerPen READ trackerPen WRITE setTrackerPen )
Q_PROPERTY( QFont trackerFont READ trackerFont WRITE setTrackerFont )

Q_PROPERTY( RubberBand rubberBand READ rubberBand WRITE setRubberBand )
Q_PROPERTY( QPen rubberBandPen READ rubberBandPen WRITE setRubberBandPen )

public:







enum RubberBand
{

NoRubberBand = 0,


HLineRubberBand,


VLineRubberBand,


CrossRubberBand,


RectRubberBand,


EllipseRubberBand,


PolygonRubberBand,





UserRubberBand = 100
};





enum DisplayMode
{

AlwaysOff,


AlwaysOn,


ActiveOnly
};









enum ResizeMode
{

Stretch,


KeepSize
};

explicit QwtPicker( QWidget *parent );
explicit QwtPicker( RubberBand rubberBand,
DisplayMode trackerMode, QWidget * );

virtual ~QwtPicker();

void setStateMachine( QwtPickerMachine * );
const QwtPickerMachine *stateMachine() const;
QwtPickerMachine *stateMachine();

void setRubberBand( RubberBand );
RubberBand rubberBand() const;

void setTrackerMode( DisplayMode );
DisplayMode trackerMode() const;

void setResizeMode( ResizeMode );
ResizeMode resizeMode() const;

void setRubberBandPen( const QPen & );
QPen rubberBandPen() const;

void setTrackerPen( const QPen & );
QPen trackerPen() const;

void setTrackerFont( const QFont & );
QFont trackerFont() const;

bool isEnabled() const;
bool isActive() const;

virtual bool eventFilter( QObject *, QEvent * );

QWidget *parentWidget();
const QWidget *parentWidget() const;

virtual QRect pickRect() const;

virtual void drawRubberBand( QPainter * ) const;
virtual void drawTracker( QPainter * ) const;

virtual QwtText trackerText( const QPoint &pos ) const;
QPoint trackerPosition() const;
virtual QRect trackerRect( const QFont & ) const;

QPolygon selection() const;

public slots:
void setEnabled( bool );

signals:







void activated( bool on );







void selected( const QPolygon &polygon );







void appended( const QPoint &pos );








void moved( const QPoint &pos );







void removed( const QPoint &pos );







void changed( const QPolygon &selection );

protected:
virtual QPolygon adjustedPoints( const QPolygon & ) const;

virtual void transition( const QEvent * );

virtual void begin();
virtual void append( const QPoint & );
virtual void move( const QPoint & );
virtual void remove();
virtual bool end( bool ok = true );

virtual bool accept( QPolygon & ) const;
virtual void reset();

virtual void widgetMousePressEvent( QMouseEvent * );
virtual void widgetMouseReleaseEvent( QMouseEvent * );
virtual void widgetMouseDoubleClickEvent( QMouseEvent * );
virtual void widgetMouseMoveEvent( QMouseEvent * );
virtual void widgetWheelEvent( QWheelEvent * );
virtual void widgetKeyPressEvent( QKeyEvent * );
virtual void widgetKeyReleaseEvent( QKeyEvent * );
virtual void widgetEnterEvent( QEvent * );
virtual void widgetLeaveEvent( QEvent * );

virtual void stretchSelection( const QSize &oldSize,
const QSize &newSize );

virtual void updateDisplay();

const QWidget *rubberBandWidget() const;
const QWidget *trackerWidget() const;

const QPolygon &pickedPoints() const;

private:
void init( QWidget *, RubberBand rubberBand, DisplayMode trackerMode );

void setMouseTracking( bool );

class PickerWidget;
class PrivateData;
PrivateData *d_data;
};


# 23 "qwt.h"

# 1 "./../src/qwt_picker_machine.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_picker_machine.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 14 "./../src/qwt_picker_machine.h"


# 16 "./../src/qwt_picker_machine.h"
class QEvent;
class QwtEventPattern;










class  QwtPickerMachine
{
public:




enum SelectionType
{

NoSelection = -1,


PointSelection,


RectSelection,


PolygonSelection
};


enum Command
{
Begin,
Append,
Move,
Remove,
End
};

QwtPickerMachine( SelectionType );
virtual ~QwtPickerMachine();


virtual QList<Command> transition(
const QwtEventPattern &, const QEvent * ) = 0;
void reset();

int state() const;
void setState( int );

SelectionType selectionType() const;

private:
const SelectionType d_selectionType;
int d_state;
};








class  QwtPickerTrackerMachine: public QwtPickerMachine
{
public:
QwtPickerTrackerMachine();

virtual QList<Command> transition(
const QwtEventPattern &, const QEvent * );
};









class  QwtPickerClickPointMachine: public QwtPickerMachine
{
public:
QwtPickerClickPointMachine();

virtual QList<Command> transition(
const QwtEventPattern &, const QEvent * );
};








class  QwtPickerDragPointMachine: public QwtPickerMachine
{
public:
QwtPickerDragPointMachine();

virtual QList<Command> transition(
const QwtEventPattern &, const QEvent * );
};














class  QwtPickerClickRectMachine: public QwtPickerMachine
{
public:
QwtPickerClickRectMachine();

virtual QList<Command> transition(
const QwtEventPattern &, const QEvent * );
};













class  QwtPickerDragRectMachine: public QwtPickerMachine
{
public:
QwtPickerDragRectMachine();

virtual QList<Command> transition(
const QwtEventPattern &, const QEvent * );
};












class  QwtPickerPolygonMachine: public QwtPickerMachine
{
public:
QwtPickerPolygonMachine();

virtual QList<Command> transition(
const QwtEventPattern &, const QEvent * );
};


# 24 "qwt.h"

# 1 "./../src/qwt_point_3d.h"













# 1 "./../src/qwt_global.h"














































# 14 "./../src/qwt_point_3d.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 15 "./../src/qwt_point_3d.h"


# 1 "/usr/share/qt4/include/QtCore/qdebug.h"




























































































































































































































































































# 17 "./../src/qwt_point_3d.h"



# 20 "./../src/qwt_point_3d.h"




class  QwtPoint3D
{
public:
QwtPoint3D();
QwtPoint3D( double x, double y, double z );
QwtPoint3D( const QwtPoint3D & );
QwtPoint3D( const QPointF & );

bool isNull() const;

double x() const;
double y() const;
double z() const;

double &rx();
double &ry();
double &rz();

void setX( double x );
void setY( double y );
void setZ( double y );

QPointF toPoint() const;

bool operator==( const QwtPoint3D & ) const;
bool operator!=( const QwtPoint3D & ) const;

private:
double d_x;
double d_y;
double d_z;
};

template <> class QTypeInfo<QwtPoint3D > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QwtPoint3D)>sizeof(void*)), isPointer = false, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0) }; static inline const char *name() { return "QwtPoint3D"; } };


# 60 "./../src/qwt_point_3d.h"
 QDebug operator<<( QDebug, const QwtPoint3D & );


# 63 "./../src/qwt_point_3d.h"




inline QwtPoint3D::QwtPoint3D():
d_x( 0.0 ),
d_y( 0.0 ),
d_z( 0.0 )
{
}


inline QwtPoint3D::QwtPoint3D( double x, double y, double z = 0.0 ):
d_x( x ),
d_y( y ),
d_z( z )
{
}





inline QwtPoint3D::QwtPoint3D( const QwtPoint3D &other ):
d_x( other.d_x ),
d_y( other.d_y ),
d_z( other.d_z )
{
}





inline QwtPoint3D::QwtPoint3D( const QPointF &other ):
d_x( other.x() ),
d_y( other.y() ),
d_z( 0.0 )
{
}







inline bool QwtPoint3D::isNull() const
{
return d_x == 0.0 && d_y == 0.0 && d_z == 0;
}


inline double QwtPoint3D::x() const
{
return d_x;
}


inline double QwtPoint3D::y() const
{
return d_y;
}


inline double QwtPoint3D::z() const
{
return d_z;
}


inline double &QwtPoint3D::rx()
{
return d_x;
}


inline double &QwtPoint3D::ry()
{
return d_y;
}


inline double &QwtPoint3D::rz()
{
return d_z;
}


inline void QwtPoint3D::setX( double x )
{
d_x = x;
}


inline void QwtPoint3D::setY( double y )
{
d_y = y;
}


inline void QwtPoint3D::setZ( double z )
{
d_z = z;
}




inline QPointF QwtPoint3D::toPoint() const
{
return QPointF( d_x, d_y );
}


inline bool QwtPoint3D::operator==( const QwtPoint3D &other ) const
{
return ( d_x == other.d_x ) && ( d_y == other.d_y ) && ( d_z == other.d_z );
}


inline bool QwtPoint3D::operator!=( const QwtPoint3D &other ) const
{
return !operator==( other );
}


# 25 "qwt.h"

# 1 "./../src/qwt_point_polar.h"













# 1 "./../src/qwt_global.h"














































# 14 "./../src/qwt_point_polar.h"

# 1 "./../src/qwt_math.h"





































































































































































# 15 "./../src/qwt_point_polar.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 16 "./../src/qwt_point_polar.h"


# 1 "/usr/share/qt4/include/QtCore/qdebug.h"




























































































































































































































































































# 18 "./../src/qwt_point_polar.h"



# 21 "./../src/qwt_point_polar.h"







class  QwtPointPolar
{
public:
QwtPointPolar();
QwtPointPolar( double azimuth, double radius );
QwtPointPolar( const QwtPointPolar & );
QwtPointPolar( const QPointF & );

void setPoint( const QPointF & );
QPointF toPoint() const;

bool isValid() const;
bool isNull() const;

double radius() const;
double azimuth() const;

double &rRadius();
double &rAzimuth();

void setRadius( double );
void setAzimuth( double );

bool operator==( const QwtPointPolar & ) const;
bool operator!=( const QwtPointPolar & ) const;

QwtPointPolar normalized() const;

private:
double d_azimuth;
double d_radius;
};





inline QwtPointPolar::QwtPointPolar():
d_azimuth( 0.0 ),
d_radius( 0.0 )
{
}







inline QwtPointPolar::QwtPointPolar( double azimuth, double radius ):
d_azimuth( azimuth ),
d_radius( radius )
{
}





inline QwtPointPolar::QwtPointPolar( const QwtPointPolar &other ):
d_azimuth( other.d_azimuth ),
d_radius( other.d_radius )
{
}


inline bool QwtPointPolar::isValid() const
{
return d_radius >= 0.0;
}


inline bool QwtPointPolar::isNull() const
{
return d_radius == 0.0;
}


inline double QwtPointPolar::radius() const
{
return d_radius;
}


inline double QwtPointPolar::azimuth() const
{
return d_azimuth;
}


inline double &QwtPointPolar::rRadius()
{
return d_radius;
}


inline double &QwtPointPolar::rAzimuth()
{
return d_azimuth;
}


inline void QwtPointPolar::setRadius( double radius )
{
d_radius = radius;
}


inline void QwtPointPolar::setAzimuth( double azimuth )
{
d_azimuth = azimuth;
}


# 142 "./../src/qwt_point_polar.h"
 QDebug operator<<( QDebug, const QwtPointPolar & );


# 145 "./../src/qwt_point_polar.h"
inline QPoint qwtPolar2Pos( const QPoint &pole,
double radius, double angle )
{
const double x = pole.x() + radius * qCos( angle );
const double y = pole.y() - radius * qSin( angle );

return QPoint( qRound( x ), qRound( y ) );
}

inline QPoint qwtDegree2Pos( const QPoint &pole,
double radius, double angle )
{
return qwtPolar2Pos( pole, radius, angle / 180.0 * (3.14159265358979323846) );
}

inline QPointF qwtPolar2Pos( const QPointF &pole,
double radius, double angle )
{
const double x = pole.x() + radius * qCos( angle );
const double y = pole.y() - radius * qSin( angle );

return QPointF( x, y);
}

inline QPointF qwtDegree2Pos( const QPointF &pole,
double radius, double angle )
{
return qwtPolar2Pos( pole, radius, angle / 180.0 * (3.14159265358979323846) );
}

inline QPointF qwtFastPolar2Pos( const QPointF &pole,
double radius, double angle )
{




# 182 "./../src/qwt_point_polar.h"
const double x = pole.x() + radius * qFastCos( angle );
const double y = pole.y() - radius * qFastSin( angle );


# 186 "./../src/qwt_point_polar.h"
return QPointF( x, y);
}

inline QPointF qwtFastDegree2Pos( const QPointF &pole,
double radius, double angle )
{ 
return qwtFastPolar2Pos( pole, radius, angle / 180.0 * (3.14159265358979323846) );
} 


# 26 "qwt.h"

# 1 "./../src/qwt_round_scale_draw.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_round_scale_draw.h"

# 1 "./../src/qwt_abstract_scale_draw.h"




































































































# 14 "./../src/qwt_round_scale_draw.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 15 "./../src/qwt_round_scale_draw.h"


# 17 "./../src/qwt_round_scale_draw.h"
class QPen;














class  QwtRoundScaleDraw: public QwtAbstractScaleDraw
{
public:
QwtRoundScaleDraw();
virtual ~QwtRoundScaleDraw();

void setRadius( int radius );
int radius() const;

void moveCenter( double x, double y );
void moveCenter( const QPointF & );
QPointF center() const;

void setAngleRange( double angle1, double angle2 );

virtual double extent( const QFont & ) const;

protected:
virtual void drawTick( QPainter *p, double val, double len ) const;
virtual void drawBackbone( QPainter *p ) const;
virtual void drawLabel( QPainter *p, double val ) const;

private:
QwtRoundScaleDraw( const QwtRoundScaleDraw & );
QwtRoundScaleDraw &operator=( const QwtRoundScaleDraw &other );

class PrivateData;
PrivateData *d_data;
};


inline void QwtRoundScaleDraw::moveCenter( double x, double y )
{
moveCenter( QPointF( x, y ) );
}


# 27 "qwt.h"

# 1 "./../src/qwt_scale_div.h"













































































































# 28 "qwt.h"

# 1 "./../src/qwt_scale_draw.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_scale_draw.h"

# 1 "./../src/qwt_abstract_scale_draw.h"




































































































# 14 "./../src/qwt_scale_draw.h"

# 1 "/usr/share/qt4/include/QtCore/qpoint.h"



































































































































































































































































































































































# 15 "./../src/qwt_scale_draw.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 16 "./../src/qwt_scale_draw.h"

# 1 "/usr/share/qt4/include/QtGui/qtransform.h"











































































































































































































































































































































































































# 17 "./../src/qwt_scale_draw.h"


# 19 "./../src/qwt_scale_draw.h"













class  QwtScaleDraw: public QwtAbstractScaleDraw
{
public:




enum Alignment 
{ 

BottomScale, 


TopScale, 


LeftScale, 


RightScale 
};

QwtScaleDraw();
virtual ~QwtScaleDraw();

void getBorderDistHint( const QFont &, int &start, int &end ) const;
int minLabelDist( const QFont & ) const;

int minLength( const QFont & ) const;
virtual double extent( const QFont & ) const;

void move( double x, double y );
void move( const QPointF & );
void setLength( double length );

Alignment alignment() const;
void setAlignment( Alignment );

Qt::Orientation orientation() const;

QPointF pos() const;
double length() const;

void setLabelAlignment( Qt::Alignment );
Qt::Alignment labelAlignment() const;

void setLabelRotation( double rotation );
double labelRotation() const;

int maxLabelHeight( const QFont & ) const;
int maxLabelWidth( const QFont & ) const;

QPointF labelPosition( double val ) const;

QRectF labelRect( const QFont &, double val ) const;
QSizeF labelSize( const QFont &, double val ) const;

QRect boundingLabelRect( const QFont &, double val ) const;

protected:
QTransform labelTransformation( const QPointF &, const QSizeF & ) const;

virtual void drawTick( QPainter *, double val, double len ) const;
virtual void drawBackbone( QPainter * ) const;
virtual void drawLabel( QPainter *, double val ) const;

private:
QwtScaleDraw( const QwtScaleDraw & );
QwtScaleDraw &operator=( const QwtScaleDraw &other );

void updateMap();

class PrivateData;
PrivateData *d_data;
};





inline void QwtScaleDraw::move( double x, double y )
{
move( QPointF( x, y ) );
}


# 29 "qwt.h"

# 1 "./../src/qwt_scale_engine.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_scale_engine.h"

# 1 "./../src/qwt_scale_div.h"













































































































# 14 "./../src/qwt_scale_engine.h"

# 1 "./../src/qwt_interval.h"



































































































































































































































# 15 "./../src/qwt_scale_engine.h"


# 17 "./../src/qwt_scale_engine.h"
class QwtScaleTransformation;




class  QwtScaleArithmetic
{
public:
static double ceilEps( double value, double intervalSize );
static double floorEps( double value, double intervalSize );

static double divideEps( double interval, double steps );

static double ceil125( double x );
static double floor125( double x );
};














class  QwtScaleEngine
{
public:






enum Attribute
{

NoAttribute = 0x00,


IncludeReference = 0x01,


Symmetric = 0x02,








Floating = 0x04,


Inverted = 0x08
};


typedef QFlags<Attribute> Attributes;

explicit QwtScaleEngine();
virtual ~QwtScaleEngine();

void setAttribute( Attribute, bool on = true );
bool testAttribute( Attribute ) const;

void setAttributes( Attributes );
Attributes attributes() const;

void setReference( double reference );
double reference() const;

void setMargins( double lower, double upper );
double lowerMargin() const;
double upperMargin() const;









virtual void autoScale( int maxNumSteps,
double &x1, double &x2, double &stepSize ) const = 0;











virtual QwtScaleDiv divideScale( double x1, double x2,
int maxMajSteps, int maxMinSteps,
double stepSize = 0.0 ) const = 0;


virtual QwtScaleTransformation *transformation() const = 0;

protected:
bool contains( const QwtInterval &, double val ) const;
QList<double> strip( const QList<double>&, const QwtInterval & ) const;
double divideInterval( double interval, int numSteps ) const;

QwtInterval buildInterval( double v ) const;

private:
class PrivateData;
PrivateData *d_data;
};








class  QwtLinearScaleEngine: public QwtScaleEngine
{
public:
virtual void autoScale( int maxSteps,
double &x1, double &x2, double &stepSize ) const;

virtual QwtScaleDiv divideScale( double x1, double x2,
int numMajorSteps, int numMinorSteps,
double stepSize = 0.0 ) const;

virtual QwtScaleTransformation *transformation() const;

protected:
QwtInterval align( const QwtInterval&, double stepSize ) const;

void buildTicks(
const QwtInterval &, double stepSize, int maxMinSteps,
QList<double> ticks[QwtScaleDiv::NTickTypes] ) const;

QList<double> buildMajorTicks(
const QwtInterval &interval, double stepSize ) const;

void buildMinorTicks(
const QList<double>& majorTicks,
int maxMinMark, double step,
QList<double> &, QList<double> & ) const;
};












class  QwtLog10ScaleEngine: public QwtScaleEngine
{
public:
virtual void autoScale( int maxSteps,
double &x1, double &x2, double &stepSize ) const;

virtual QwtScaleDiv divideScale( double x1, double x2,
int numMajorSteps, int numMinorSteps,
double stepSize = 0.0 ) const;

virtual QwtScaleTransformation *transformation() const;

protected:
QwtInterval log10( const QwtInterval& ) const;
QwtInterval pow10( const QwtInterval& ) const;

QwtInterval align( const QwtInterval&, double stepSize ) const;

void buildTicks(
const QwtInterval &, double stepSize, int maxMinSteps,
QList<double> ticks[QwtScaleDiv::NTickTypes] ) const;

QList<double> buildMajorTicks(
const QwtInterval &interval, double stepSize ) const;

QList<double> buildMinorTicks(
const QList<double>& majorTicks,
int maxMinMark, double step ) const;
};

inline QFlags<QwtScaleEngine::Attributes ::enum_type> operator|(QwtScaleEngine::Attributes ::enum_type f1, QwtScaleEngine::Attributes ::enum_type f2) { return QFlags<QwtScaleEngine::Attributes ::enum_type>(f1) | f2; } inline QFlags<QwtScaleEngine::Attributes ::enum_type> operator|(QwtScaleEngine::Attributes ::enum_type f1, QFlags<QwtScaleEngine::Attributes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtScaleEngine::Attributes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 30 "qwt.h"

# 1 "./../src/qwt_scale_map.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_scale_map.h"

# 1 "./../src/qwt_math.h"





































































































































































# 14 "./../src/qwt_scale_map.h"


# 1 "/usr/share/qt4/include/QtCore/qdebug.h"




























































































































































































































































































# 16 "./../src/qwt_scale_map.h"



# 19 "./../src/qwt_scale_map.h"
class QRectF;








class  QwtScaleTransformation
{
public:

enum Type
{

Linear,


Log10,


Other
};

QwtScaleTransformation( Type type );
virtual ~QwtScaleTransformation();

virtual double xForm( double x, double s1, double s2,
double p1, double p2 ) const;
virtual double invXForm( double x, double p1, double p2,
double s1, double s2 ) const;

Type type() const;

virtual QwtScaleTransformation *copy() const;

private:
QwtScaleTransformation();
QwtScaleTransformation &operator=( const QwtScaleTransformation );

const Type d_type;
};


inline QwtScaleTransformation::Type QwtScaleTransformation::type() const
{
return d_type;
}








class  QwtScaleMap
{
public:
QwtScaleMap();
QwtScaleMap( const QwtScaleMap& );

~QwtScaleMap();

QwtScaleMap &operator=( const QwtScaleMap & );

void setTransformation( QwtScaleTransformation * );
const QwtScaleTransformation *transformation() const;

void setPaintInterval( double p1, double p2 );
void setScaleInterval( double s1, double s2 );

double transform( double s ) const;
double invTransform( double p ) const;

double p1() const;
double p2() const;

double s1() const;
double s2() const;

double pDist() const;
double sDist() const;

static const double LogMin;
static const double LogMax;

static QRectF transform( const QwtScaleMap &,
const QwtScaleMap &, const QRectF & );
static QRectF invTransform( const QwtScaleMap &,
const QwtScaleMap &, const QRectF & );

static QPointF transform( const QwtScaleMap &,
const QwtScaleMap &, const QPointF & );
static QPointF invTransform( const QwtScaleMap &,
const QwtScaleMap &, const QPointF & );

bool isInverting() const;

private:
void newFactor();

double d_s1, d_s2; 
double d_p1, d_p2; 

double d_cnv; 

QwtScaleTransformation *d_transformation;
};




inline double QwtScaleMap::s1() const
{
return d_s1;
}




inline double QwtScaleMap::s2() const
{
return d_s2;
}




inline double QwtScaleMap::p1() const
{
return d_p1;
}




inline double QwtScaleMap::p2() const
{
return d_p2;
}




inline double QwtScaleMap::pDist() const
{
return qAbs( d_p2 - d_p1 );
}




inline double QwtScaleMap::sDist() const
{
return qAbs( d_s2 - d_s1 );
}







inline double QwtScaleMap::transform( double s ) const
{


if ( d_transformation->type() == QwtScaleTransformation::Linear )
return d_p1 + ( s - d_s1 ) * d_cnv;

if ( d_transformation->type() == QwtScaleTransformation::Log10 )
return d_p1 + log( s / d_s1 ) * d_cnv;

return d_transformation->xForm( s, d_s1, d_s2, d_p1, d_p2 );
}








inline double QwtScaleMap::invTransform( double p ) const
{
return d_transformation->invXForm( p, d_p1, d_p2, d_s1, d_s2 );
}


inline bool QwtScaleMap::isInverting() const
{
return ( ( d_p1 < d_p2 ) != ( d_s1 < d_s2 ) );
}


# 216 "./../src/qwt_scale_map.h"
 QDebug operator<<( QDebug, const QwtScaleMap & );



# 31 "qwt.h"

# 1 "./../src/qwt_spline.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_spline.h"

# 1 "/usr/share/qt4/include/QtGui/qpolygon.h"




















































































































































































# 14 "./../src/qwt_spline.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 15 "./../src/qwt_spline.h"


# 17 "./../src/qwt_spline.h"








































class  QwtSpline
{
public:

enum SplineType
{

Natural,


Periodic
};

QwtSpline();
QwtSpline( const QwtSpline & );

~QwtSpline();

QwtSpline &operator=( const QwtSpline & );

void setSplineType( SplineType );
SplineType splineType() const;

bool setPoints( const QPolygonF& points );
QPolygonF points() const;

void reset();

bool isValid() const;
double value( double x ) const;

const QVector<double> &coefficientsA() const;
const QVector<double> &coefficientsB() const;
const QVector<double> &coefficientsC() const;

protected:
bool buildNaturalSpline( const QPolygonF & );
bool buildPeriodicSpline( const QPolygonF & );

private:
class PrivateData;
PrivateData *d_data;
};


# 32 "qwt.h"

# 1 "./../src/qwt_symbol.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_symbol.h"

# 1 "/usr/share/qt4/include/QtGui/qpolygon.h"




















































































































































































# 1 "/usr/share/qt4/include/QtGui/QPolygonF"

# 14 "./../src/qwt_symbol.h"


# 16 "./../src/qwt_symbol.h"
class QPainter;
class QRect;
class QSize;
class QBrush;
class QPen;
class QColor;
class QPointF;


class  QwtSymbol
{
public:




enum Style
{

NoSymbol = -1,


Ellipse,


Rect,


Diamond,


Triangle,


DTriangle,


UTriangle,


LTriangle,


RTriangle,


Cross,


XCross,


HLine,


VLine,


Star1,


Star2,


Hexagon,






UserStyle = 1000
};

public:
QwtSymbol( Style = NoSymbol );
QwtSymbol( Style, const QBrush &, const QPen &, const QSize & );
QwtSymbol( const QwtSymbol & );
virtual ~QwtSymbol();

QwtSymbol &operator=( const QwtSymbol & );
bool operator==( const QwtSymbol & ) const;
bool operator!=( const QwtSymbol & ) const;

void setSize( const QSize & );
void setSize( int width, int height = -1 );
const QSize& size() const;

virtual void setColor( const QColor & );

void setBrush( const QBrush& b );
const QBrush& brush() const;

void setPen( const QPen & );
const QPen& pen() const;

void setStyle( Style );
Style style() const;

void drawSymbol( QPainter *, const QPointF & ) const;
void drawSymbols( QPainter *, const QPolygonF & ) const;

virtual QSize boundingSize() const;

protected:
virtual void drawSymbols( QPainter *,
const QPointF *, int numPoints ) const;

private:
class PrivateData;
PrivateData *d_data;
};







inline void QwtSymbol::drawSymbol(
QPainter *painter, const QPointF &pos ) const
{
drawSymbols( painter, &pos, 1 );
}








inline void QwtSymbol::drawSymbols(
QPainter *painter, const QPolygonF &points ) const
{
drawSymbols( painter, points.data(), points.size() );
}


# 33 "qwt.h"

# 1 "./../src/qwt_system_clock.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_system_clock.h"


# 15 "./../src/qwt_system_clock.h"















class  QwtSystemClock
{
public:
QwtSystemClock();
virtual ~QwtSystemClock();

bool isNull() const;

void start();
double restart();
double elapsed() const;

static double precision();

private:
class PrivateData;
PrivateData *d_data;
};


# 34 "qwt.h"

# 1 "./../src/qwt_text_engine.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_text_engine.h"

# 1 "/usr/share/qt4/include/QtCore/qsize.h"








































































































































































































































































































































































# 14 "./../src/qwt_text_engine.h"


# 16 "./../src/qwt_text_engine.h"
class QFont;
class QRectF;
class QString;
class QPainter;















class  QwtTextEngine
{
public:
virtual ~QwtTextEngine();











virtual double heightForWidth( const QFont &font, int flags,
const QString &text, double width ) const = 0;










virtual QSizeF textSize( const QFont &font, int flags,
const QString &text ) const = 0;







virtual bool mightRender( const QString &text ) const = 0;
















virtual void textMargins( const QFont &font, const QString &text,
double &left, double &right, double &top, double &bottom ) const = 0;









virtual void draw( QPainter *painter, const QRectF &rect,
int flags, const QString &text ) const = 0;

protected:
QwtTextEngine();
};








class  QwtPlainTextEngine: public QwtTextEngine
{
public:
QwtPlainTextEngine();
virtual ~QwtPlainTextEngine();

virtual double heightForWidth( const QFont &font, int flags,
const QString &text, double width ) const;

virtual QSizeF textSize( const QFont &font, int flags,
const QString &text ) const;

virtual void draw( QPainter *painter, const QRectF &rect,
int flags, const QString &text ) const;

virtual bool mightRender( const QString & ) const;

virtual void textMargins( const QFont &, const QString &,
double &left, double &right, double &top, double &bottom ) const;

private:
class PrivateData;
PrivateData *d_data;
};




# 141 "./../src/qwt_text_engine.h"






class  QwtRichTextEngine: public QwtTextEngine
{
public:
QwtRichTextEngine();

virtual double heightForWidth( const QFont &font, int flags,
const QString &text, double width ) const;

virtual QSizeF textSize( const QFont &font, int flags,
const QString &text ) const;

virtual void draw( QPainter *painter, const QRectF &rect,
int flags, const QString &text ) const;

virtual bool mightRender( const QString & ) const;

virtual void textMargins( const QFont &, const QString &,
double &left, double &right, double &top, double &bottom ) const;

private:
QString taggedText( const QString &, int flags ) const;
};




# 35 "qwt.h"

# 1 "./../src/qwt_text_label.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_text_label.h"

# 1 "./../src/qwt_text.h"




























































































































































# 14 "./../src/qwt_text_label.h"

# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 15 "./../src/qwt_text_label.h"


# 17 "./../src/qwt_text_label.h"
class QString;
class QPaintEvent;
class QPainter;





class  QwtTextLabel : public QFrame
{
Q_OBJECT

Q_PROPERTY( int indent READ indent WRITE setIndent )
Q_PROPERTY( int margin READ margin WRITE setMargin )

public:
explicit QwtTextLabel( QWidget *parent = 0 );
explicit QwtTextLabel( const QwtText &, QWidget *parent = 0 );
virtual ~QwtTextLabel();

public slots:
void setText( const QString &,
QwtText::TextFormat textFormat = QwtText::AutoText );
virtual void setText( const QwtText & );

void clear();

public:
const QwtText &text() const;

int indent() const;
void setIndent( int );

int margin() const;
void setMargin( int );

virtual QSize sizeHint() const;
virtual QSize minimumSizeHint() const;
virtual int heightForWidth( int ) const;

QRect textRect() const;

protected:
virtual void paintEvent( QPaintEvent *e );
virtual void drawContents( QPainter * );
virtual void drawText( QPainter *, const QRect & );

private:
void init();
int defaultIndent() const;

class PrivateData;
PrivateData *d_data;
};


# 36 "qwt.h"

# 1 "./../src/qwt_text.h"




























































































































































# 37 "qwt.h"



# 1 "./../src/qwt_curve_fitter.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_curve_fitter.h"

# 1 "/usr/share/qt4/include/QtGui/qpolygon.h"




















































































































































































# 14 "./../src/qwt_curve_fitter.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 15 "./../src/qwt_curve_fitter.h"


# 17 "./../src/qwt_curve_fitter.h"
class QwtSpline;




class  QwtCurveFitter
{
public:
virtual ~QwtCurveFitter();







virtual QPolygonF fitCurve( const QPolygonF &polygon ) const = 0;

protected:
QwtCurveFitter();

private:
QwtCurveFitter( const QwtCurveFitter & );
QwtCurveFitter &operator=( const QwtCurveFitter & );
};




class  QwtSplineCurveFitter: public QwtCurveFitter
{
public:





enum FitMode
{





Auto,


Spline,


ParametricSpline
};

QwtSplineCurveFitter();
virtual ~QwtSplineCurveFitter();

void setFitMode( FitMode );
FitMode fitMode() const;

void setSpline( const QwtSpline& );
const QwtSpline &spline() const;
QwtSpline &spline();

void setSplineSize( int size );
int splineSize() const;

virtual QPolygonF fitCurve( const QPolygonF & ) const;

private:
QPolygonF fitSpline( const QPolygonF & ) const;
QPolygonF fitParametric( const QPolygonF & ) const;

class PrivateData;
PrivateData *d_data;
};


















class  QwtWeedingCurveFitter: public QwtCurveFitter
{
public:
QwtWeedingCurveFitter( double tolerance = 1.0 );
virtual ~QwtWeedingCurveFitter();

void setTolerance( double );
double tolerance() const;

virtual QPolygonF fitCurve( const QPolygonF & ) const;

private:
class Line;

class PrivateData;
PrivateData *d_data;
};


# 40 "qwt.h"

# 1 "./../src/qwt_event_pattern.h"

















































































































































# 41 "qwt.h"

# 1 "./../src/qwt_legend.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_legend.h"

# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 14 "./../src/qwt_legend.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 15 "./../src/qwt_legend.h"


# 17 "./../src/qwt_legend.h"
class QScrollBar;
class QwtLegendItemManager;











class  QwtLegend : public QFrame
{
Q_OBJECT

public:










enum LegendItemMode
{

ReadOnlyItem,


ClickableItem,


CheckableItem
};

explicit QwtLegend( QWidget *parent = 0 );
virtual ~QwtLegend();

void setItemMode( LegendItemMode );
LegendItemMode itemMode() const;

QWidget *contentsWidget();
const QWidget *contentsWidget() const;

void insert( const QwtLegendItemManager *, QWidget * );
void remove( const QwtLegendItemManager * );

QWidget *find( const QwtLegendItemManager * ) const;
QwtLegendItemManager *find( const QWidget * ) const;

virtual QList<QWidget *> legendItems() const;

void clear();

bool isEmpty() const;
uint itemCount() const;

virtual bool eventFilter( QObject *, QEvent * );

virtual QSize sizeHint() const;
virtual int heightForWidth( int w ) const;

QScrollBar *horizontalScrollBar() const;
QScrollBar *verticalScrollBar() const;

protected:
virtual void layoutContents();

private:
class PrivateData;
PrivateData *d_data;
};


# 42 "qwt.h"

# 1 "./../src/qwt_legend_item.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_legend_item.h"

# 1 "./../src/qwt_legend.h"















































































# 14 "./../src/qwt_legend_item.h"

# 1 "./../src/qwt_text.h"




























































































































































# 15 "./../src/qwt_legend_item.h"

# 1 "./../src/qwt_text_label.h"






































































# 16 "./../src/qwt_legend_item.h"

# 1 "/usr/share/qt4/include/QtGui/qpixmap.h"





































































































































































































































































































































# 17 "./../src/qwt_legend_item.h"


# 19 "./../src/qwt_legend_item.h"



class  QwtLegendItem: public QwtTextLabel
{
Q_OBJECT
public:
explicit QwtLegendItem( QWidget *parent = 0 );
virtual ~QwtLegendItem();

void setItemMode( QwtLegend::LegendItemMode );
QwtLegend::LegendItemMode itemMode() const;

void setSpacing( int spacing );
int spacing() const;

virtual void setText( const QwtText & );

void setIdentifier( const QPixmap & );
QPixmap identifier() const;

void setIdentifierSize( const QSize & );
QSize identifierSize() const;

virtual QSize sizeHint() const;

bool isChecked() const;

public slots:
void setChecked( bool on );

signals:

void clicked();


void pressed();


void released();


void checked( bool );

protected:
void setDown( bool );
bool isDown() const;

virtual void paintEvent( QPaintEvent * );
virtual void mousePressEvent( QMouseEvent * );
virtual void mouseReleaseEvent( QMouseEvent * );
virtual void keyPressEvent( QKeyEvent * );
virtual void keyReleaseEvent( QKeyEvent * );

private:
class PrivateData;
PrivateData *d_data;
};


# 43 "qwt.h"

# 1 "./../src/qwt_legend_itemmanager.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_legend_itemmanager.h"


# 15 "./../src/qwt_legend_itemmanager.h"
class QwtLegend;
class QWidget;
class QRectF;
class QPainter;





class  QwtLegendItemManager
{
public:

QwtLegendItemManager()
{
}


virtual ~QwtLegendItemManager()
{
}






virtual void updateLegend( QwtLegend *legend ) const = 0;







virtual QWidget *legendItem() const = 0;









virtual void drawLegendIdentifier( QPainter *, const QRectF & ) const
{
}
};



# 44 "qwt.h"

# 1 "./../src/qwt_plot.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot.h"

# 1 "./../src/qwt_text.h"




























































































































































# 14 "./../src/qwt_plot.h"

# 1 "./../src/qwt_plot_dict.h"













# 1 "./../src/qwt_global.h"














































# 14 "./../src/qwt_plot_dict.h"

# 1 "./../src/qwt_plot_item.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_item.h"

# 1 "./../src/qwt_legend_itemmanager.h"

















































# 14 "./../src/qwt_plot_item.h"

# 1 "./../src/qwt_text.h"




























































































































































# 15 "./../src/qwt_plot_item.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 16 "./../src/qwt_plot_item.h"


# 18 "./../src/qwt_plot_item.h"
class QString;
class QPainter;
class QWidget;
class QwtPlot;
class QwtLegend;
class QwtScaleMap;
class QwtScaleDiv;







































class  QwtPlotItem: public QwtLegendItemManager
{
public:






enum RttiValues
{
Rtti_PlotItem = 0,

Rtti_PlotGrid,
Rtti_PlotScale,
Rtti_PlotMarker,
Rtti_PlotCurve,
Rtti_PlotSpectroCurve,
Rtti_PlotIntervalCurve,
Rtti_PlotHistogram,
Rtti_PlotSpectrogram,
Rtti_PlotSVG,

Rtti_PlotUserItem = 1000
};





enum ItemAttribute
{

Legend = 0x01,





AutoScale = 0x02
};


typedef QFlags<ItemAttribute> ItemAttributes;


enum RenderHint
{

RenderAntialiased = 1
};


typedef QFlags<RenderHint> RenderHints;

explicit QwtPlotItem( const QwtText &title = QwtText() );
virtual ~QwtPlotItem();

void attach( QwtPlot *plot );
void detach();

QwtPlot *plot() const;

void setTitle( const QString &title );
void setTitle( const QwtText &title );
const QwtText &title() const;

virtual int rtti() const;

void setItemAttribute( ItemAttribute, bool on = true );
bool testItemAttribute( ItemAttribute ) const;

void setRenderHint( RenderHint, bool on = true );
bool testRenderHint( RenderHint ) const;

double z() const;
void setZ( double z );

void show();
void hide();
virtual void setVisible( bool );
bool isVisible () const;

void setAxes( int xAxis, int yAxis );

void setXAxis( int axis );
int xAxis() const;

void setYAxis( int axis );
int yAxis() const;

virtual void itemChanged();









virtual void draw( QPainter *painter,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect ) const = 0;

virtual QRectF boundingRect() const;

virtual void updateLegend( QwtLegend * ) const;
virtual void updateScaleDiv( 
const QwtScaleDiv&, const QwtScaleDiv& );

virtual QWidget *legendItem() const;

QRectF scaleRect( const QwtScaleMap &, const QwtScaleMap & ) const;
QRectF paintRect( const QwtScaleMap &, const QwtScaleMap & ) const;

private:

QwtPlotItem( const QwtPlotItem & );
QwtPlotItem &operator=( const QwtPlotItem & );

class PrivateData;
PrivateData *d_data;
};

inline QFlags<QwtPlotItem::ItemAttributes ::enum_type> operator|(QwtPlotItem::ItemAttributes ::enum_type f1, QwtPlotItem::ItemAttributes ::enum_type f2) { return QFlags<QwtPlotItem::ItemAttributes ::enum_type>(f1) | f2; } inline QFlags<QwtPlotItem::ItemAttributes ::enum_type> operator|(QwtPlotItem::ItemAttributes ::enum_type f1, QFlags<QwtPlotItem::ItemAttributes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotItem::ItemAttributes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<QwtPlotItem::RenderHints ::enum_type> operator|(QwtPlotItem::RenderHints ::enum_type f1, QwtPlotItem::RenderHints ::enum_type f2) { return QFlags<QwtPlotItem::RenderHints ::enum_type>(f1) | f2; } inline QFlags<QwtPlotItem::RenderHints ::enum_type> operator|(QwtPlotItem::RenderHints ::enum_type f1, QFlags<QwtPlotItem::RenderHints ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotItem::RenderHints ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 15 "./../src/qwt_plot_dict.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 16 "./../src/qwt_plot_dict.h"


# 18 "./../src/qwt_plot_dict.h"


typedef QList<QwtPlotItem *> QwtPlotItemList;
typedef QList<QwtPlotItem *>::ConstIterator QwtPlotItemIterator;










class  QwtPlotDict
{
public:
explicit QwtPlotDict();
virtual ~QwtPlotDict();

void setAutoDelete( bool );
bool autoDelete() const;

const QwtPlotItemList& itemList() const;
QwtPlotItemList itemList( int rtti ) const;

void detachItems( int rtti = QwtPlotItem::Rtti_PlotItem,
bool autoDelete = true );

private:
friend class QwtPlotItem;

void attachItem( QwtPlotItem *, bool );

class PrivateData;
PrivateData *d_data;
};


# 15 "./../src/qwt_plot.h"

# 1 "./../src/qwt_scale_map.h"
























































































































































































# 16 "./../src/qwt_plot.h"

# 1 "./../src/qwt_interval.h"



































































































































































































































# 17 "./../src/qwt_plot.h"

# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 18 "./../src/qwt_plot.h"


# 20 "./../src/qwt_plot.h"
class QwtPlotLayout;
class QwtLegend;
class QwtScaleWidget;
class QwtScaleEngine;
class QwtScaleDiv;
class QwtScaleDraw;
class QwtTextLabel;
class QwtPlotCanvas;










































class  QwtPlot: public QFrame, public QwtPlotDict
{
Q_OBJECT
Q_PROPERTY( QString propertiesDocument
READ grabProperties WRITE applyProperties )

public:

enum Axis
{

yLeft,


yRight,


xBottom,


xTop,


axisCnt
};








enum LegendPosition
{

LeftLegend,


RightLegend,


BottomLegend,


TopLegend,







ExternalLegend
};

explicit QwtPlot( QWidget * = 0 );
explicit QwtPlot( const QwtText &title, QWidget *p = 0 );

virtual ~QwtPlot();

void applyProperties( const QString & );
QString grabProperties() const;

void setAutoReplot( bool tf = true );
bool autoReplot() const;



QwtPlotLayout *plotLayout();
const QwtPlotLayout *plotLayout() const;



void setTitle( const QString & );
void setTitle( const QwtText &t );
QwtText title() const;

QwtTextLabel *titleLabel();
const QwtTextLabel *titleLabel() const;



QwtPlotCanvas *canvas();
const QwtPlotCanvas *canvas() const;

void setCanvasBackground( const QBrush & );
QBrush canvasBackground() const;

void setCanvasLineWidth( int w );
int canvasLineWidth() const;

virtual QwtScaleMap canvasMap( int axisId ) const;

double invTransform( int axisId, int pos ) const;
double transform( int axisId, double value ) const;



QwtScaleEngine *axisScaleEngine( int axisId );
const QwtScaleEngine *axisScaleEngine( int axisId ) const;
void setAxisScaleEngine( int axisId, QwtScaleEngine * );

void setAxisAutoScale( int axisId, bool on = true );
bool axisAutoScale( int axisId ) const;

void enableAxis( int axisId, bool tf = true );
bool axisEnabled( int axisId ) const;

void setAxisFont( int axisId, const QFont &f );
QFont axisFont( int axisId ) const;

void setAxisScale( int axisId, double min, double max, double step = 0 );
void setAxisScaleDiv( int axisId, const QwtScaleDiv & );
void setAxisScaleDraw( int axisId, QwtScaleDraw * );

double axisStepSize( int axisId ) const;
QwtInterval axisInterval( int axisId ) const;

const QwtScaleDiv *axisScaleDiv( int axisId ) const;
QwtScaleDiv *axisScaleDiv( int axisId );

const QwtScaleDraw *axisScaleDraw( int axisId ) const;
QwtScaleDraw *axisScaleDraw( int axisId );

const QwtScaleWidget *axisWidget( int axisId ) const;
QwtScaleWidget *axisWidget( int axisId );

void setAxisLabelAlignment( int axisId, Qt::Alignment );
void setAxisLabelRotation( int axisId, double rotation );

void setAxisTitle( int axisId, const QString & );
void setAxisTitle( int axisId, const QwtText & );
QwtText axisTitle( int axisId ) const;

void setAxisMaxMinor( int axisId, int maxMinor );
int axisMaxMinor( int axisId ) const;

void setAxisMaxMajor( int axisId, int maxMajor );
int axisMaxMajor( int axisId ) const;



void insertLegend( QwtLegend *, LegendPosition = QwtPlot::RightLegend,
double ratio = -1.0 );

QwtLegend *legend();
const QwtLegend *legend() const;



virtual QSize sizeHint() const;
virtual QSize minimumSizeHint() const;

virtual void updateLayout();
virtual void drawCanvas( QPainter * );

void updateAxes();

virtual bool event( QEvent * );

virtual void drawItems( QPainter *, const QRectF &,
const QwtScaleMap maps[axisCnt] ) const;

signals:










void legendClicked( QwtPlotItem *plotItem );













void legendChecked( QwtPlotItem *plotItem, bool on );

public slots:
virtual void replot();
void autoRefresh();

protected slots:
virtual void legendItemClicked();
virtual void legendItemChecked( bool );

protected:
static bool axisValid( int axisId );

virtual void updateTabOrder();

virtual void resizeEvent( QResizeEvent *e );

private:
void initAxesData();
void deleteAxesData();
void updateScaleDiv();

void initPlot( const QwtText &title );

class AxisData;
AxisData *d_axisData[axisCnt];

class PrivateData;
PrivateData *d_data;
};


# 45 "qwt.h"

# 1 "./../src/qwt_plot_renderer.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_renderer.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 14 "./../src/qwt_plot_renderer.h"


# 16 "./../src/qwt_plot_renderer.h"
class QwtPlot;
class QwtScaleMap;
class QSizeF;
class QRectF;
class QPainter;
class QPaintDevice;


# 24 "./../src/qwt_plot_renderer.h"
class QPrinter;








# 33 "./../src/qwt_plot_renderer.h"




class  QwtPlotRenderer: public QObject
{
Q_OBJECT

public:

enum DiscardFlag
{

DiscardNone = 0x00,


DiscardBackground = 0x01,


DiscardTitle = 0x02,


DiscardLegend = 0x04,


DiscardCanvasBackground = 0x08
};


typedef QFlags<DiscardFlag> DiscardFlags;





enum LayoutFlag
{

DefaultLayout = 0x00,


KeepFrames = 0x01,





FrameWithScales = 0x02
};


typedef QFlags<LayoutFlag> LayoutFlags;

explicit QwtPlotRenderer( QObject * = 0 );
virtual ~QwtPlotRenderer();

void setDiscardFlag( DiscardFlag flag, bool on = true );
bool testDiscardFlag( DiscardFlag flag ) const;

void setDiscardFlags( DiscardFlags flags );
DiscardFlags discardFlags() const;

void setLayoutFlag( LayoutFlag flag, bool on = true );
bool testLayoutFlag( LayoutFlag flag ) const;

void setLayoutFlags( LayoutFlags flags );
LayoutFlags layoutFlags() const;

void renderDocument( QwtPlot *, const QString &format,
const QSizeF &sizeMM, int resolution = 85 );

void renderDocument( QwtPlot *,
const QString &title, const QString &format,
const QSizeF &sizeMM, int resolution = 85 );










# 117 "./../src/qwt_plot_renderer.h"
void renderTo( QwtPlot *, QPrinter & ) const;


# 120 "./../src/qwt_plot_renderer.h"
void renderTo( QwtPlot *, QPaintDevice &p ) const;

virtual void render( QwtPlot *,
QPainter *, const QRectF &rect ) const;

virtual void renderLegendItem( const QwtPlot *, 
QPainter *, const QWidget *, const QRectF & ) const;

virtual void renderTitle( const QwtPlot *,
QPainter *, const QRectF & ) const;

virtual void renderScale( const QwtPlot *, QPainter *,
int axisId, int startDist, int endDist,
int baseDist, const QRectF & ) const;

virtual void renderCanvas( const QwtPlot *,
QPainter *, const QRectF &canvasRect,
const QwtScaleMap* maps ) const;

virtual void renderLegend( 
const QwtPlot *, QPainter *, const QRectF & ) const;

protected:
void buildCanvasMaps( const QwtPlot *,
const QRectF &, QwtScaleMap maps[] ) const;

private:
class PrivateData;
PrivateData *d_data;
};

inline QFlags<QwtPlotRenderer::DiscardFlags ::enum_type> operator|(QwtPlotRenderer::DiscardFlags ::enum_type f1, QwtPlotRenderer::DiscardFlags ::enum_type f2) { return QFlags<QwtPlotRenderer::DiscardFlags ::enum_type>(f1) | f2; } inline QFlags<QwtPlotRenderer::DiscardFlags ::enum_type> operator|(QwtPlotRenderer::DiscardFlags ::enum_type f1, QFlags<QwtPlotRenderer::DiscardFlags ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotRenderer::DiscardFlags ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<QwtPlotRenderer::LayoutFlags ::enum_type> operator|(QwtPlotRenderer::LayoutFlags ::enum_type f1, QwtPlotRenderer::LayoutFlags ::enum_type f2) { return QFlags<QwtPlotRenderer::LayoutFlags ::enum_type>(f1) | f2; } inline QFlags<QwtPlotRenderer::LayoutFlags ::enum_type> operator|(QwtPlotRenderer::LayoutFlags ::enum_type f1, QFlags<QwtPlotRenderer::LayoutFlags ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotRenderer::LayoutFlags ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 46 "qwt.h"

# 1 "./../src/qwt_plot_curve.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_curve.h"

# 1 "./../src/qwt_plot_seriesitem.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_seriesitem.h"

# 1 "./../src/qwt_plot_item.h"










































































































































# 14 "./../src/qwt_plot_seriesitem.h"

# 1 "./../src/qwt_scale_div.h"













































































































# 15 "./../src/qwt_plot_seriesitem.h"

# 1 "./../src/qwt_series_data.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_series_data.h"

# 1 "./../src/qwt_interval.h"



































































































































































































































# 14 "./../src/qwt_series_data.h"

# 1 "./../src/qwt_point_3d.h"











































































































































































# 15 "./../src/qwt_series_data.h"

# 1 "./../src/qwt_point_polar.h"



















































































































































































# 16 "./../src/qwt_series_data.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 17 "./../src/qwt_series_data.h"

# 1 "/usr/share/qt4/include/QtCore/qrect.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































# 18 "./../src/qwt_series_data.h"


# 20 "./../src/qwt_series_data.h"

class  QwtIntervalSample
{
public:
QwtIntervalSample();
QwtIntervalSample( double, const QwtInterval & );
QwtIntervalSample( double value, double min, double max );

bool operator==( const QwtIntervalSample & ) const;
bool operator!=( const QwtIntervalSample & ) const;


double value;


QwtInterval interval;
};





inline QwtIntervalSample::QwtIntervalSample():
value( 0.0 )
{
}


inline QwtIntervalSample::QwtIntervalSample(
double v, const QwtInterval &intv ):
value( v ),
interval( intv )
{
}


inline QwtIntervalSample::QwtIntervalSample(
double v, double min, double max ):
value( v ),
interval( min, max )
{
}


inline bool QwtIntervalSample::operator==( 
const QwtIntervalSample &other ) const
{
return value == other.value && interval == other.interval;
}


inline bool QwtIntervalSample::operator!=( 
const QwtIntervalSample &other ) const
{
return !( *this == other );
}


class  QwtSetSample
{
public:
QwtSetSample();
bool operator==( const QwtSetSample &other ) const;
bool operator!=( const QwtSetSample &other ) const;


double value;


QVector<double> set;
};





inline QwtSetSample::QwtSetSample():
value( 0.0 )
{
}


inline bool QwtSetSample::operator==( const QwtSetSample &other ) const
{
return value == other.value && set == other.set;
}


inline bool QwtSetSample::operator!=( const QwtSetSample &other ) const
{
return !( *this == other );
}









template <typename T>
class QwtSeriesData
{
public:
QwtSeriesData();
virtual ~QwtSeriesData();


virtual size_t size() const = 0;






virtual T sample( size_t i ) const = 0;











virtual QRectF boundingRect() const = 0;

virtual void setRectOfInterest( const QRectF & );

protected:

mutable QRectF d_boundingRect;

private:
QwtSeriesData<T> &operator=( const QwtSeriesData<T> & );
};


template <typename T>
QwtSeriesData<T>::QwtSeriesData():
d_boundingRect( 0.0, 0.0, -1.0, -1.0 )
{
}


template <typename T>
QwtSeriesData<T>::~QwtSeriesData()
{
}










template <typename T>
void QwtSeriesData<T>::setRectOfInterest( const QRectF & )
{
}







template <typename T>
class QwtArraySeriesData: public QwtSeriesData<T>
{
public:
QwtArraySeriesData();
QwtArraySeriesData( const QVector<T> & );

void setSamples( const QVector<T> & );
const QVector<T> samples() const;

virtual size_t size() const;
virtual T sample( size_t ) const;

protected:

QVector<T> d_samples;
};


template <typename T>
QwtArraySeriesData<T>::QwtArraySeriesData()
{
}





template <typename T>
QwtArraySeriesData<T>::QwtArraySeriesData( const QVector<T> &samples ):
d_samples( samples )
{
}





template <typename T>
void QwtArraySeriesData<T>::setSamples( const QVector<T> &samples )
{
QwtSeriesData<T>::d_boundingRect = QRectF( 0.0, 0.0, -1.0, -1.0 );
d_samples = samples;
}


template <typename T>
const QVector<T> QwtArraySeriesData<T>::samples() const
{
return d_samples;
}


template <typename T>
size_t QwtArraySeriesData<T>::size() const
{
return d_samples.size();
}






template <typename T>
T QwtArraySeriesData<T>::sample( size_t i ) const
{
return d_samples[i];
}


class  QwtPointSeriesData: public QwtArraySeriesData<QPointF>
{
public:
QwtPointSeriesData(
const QVector<QPointF> & = QVector<QPointF>() );

virtual QRectF boundingRect() const;
};


class  QwtPoint3DSeriesData: public QwtArraySeriesData<QwtPoint3D>
{
public:
QwtPoint3DSeriesData(
const QVector<QwtPoint3D> & = QVector<QwtPoint3D>() );
virtual QRectF boundingRect() const;
};


class  QwtIntervalSeriesData: public QwtArraySeriesData<QwtIntervalSample>
{
public:
QwtIntervalSeriesData(
const QVector<QwtIntervalSample> & = QVector<QwtIntervalSample>() );

virtual QRectF boundingRect() const;
};


class  QwtSetSeriesData: public QwtArraySeriesData<QwtSetSample>
{
public:
QwtSetSeriesData(
const QVector<QwtSetSample> & = QVector<QwtSetSample>() );

virtual QRectF boundingRect() const;
};




class  QwtPointArrayData: public QwtSeriesData<QPointF>
{
public:
QwtPointArrayData( const QVector<double> &x, const QVector<double> &y );
QwtPointArrayData( const double *x, const double *y, size_t size );

virtual QRectF boundingRect() const;

virtual size_t size() const;
virtual QPointF sample( size_t i ) const;

const QVector<double> &xData() const;
const QVector<double> &yData() const;

private:
QVector<double> d_x;
QVector<double> d_y;
};




class  QwtCPointerData: public QwtSeriesData<QPointF>
{
public:
QwtCPointerData( const double *x, const double *y, size_t size );

virtual QRectF boundingRect() const;
virtual size_t size() const;
virtual QPointF sample( size_t i ) const;

const double *xData() const;
const double *yData() const;

private:
const double *d_x;
const double *d_y;
size_t d_size;
};





















































class  QwtSyntheticPointData: public QwtSeriesData<QPointF>
{
public:
QwtSyntheticPointData( size_t size,
const QwtInterval & = QwtInterval() );

void setSize( size_t size );
size_t size() const;

void setInterval( const QwtInterval& );
QwtInterval interval() const;

virtual QRectF boundingRect() const;
virtual QPointF sample( size_t i ) const;







virtual double y( double x ) const = 0;
virtual double x( uint index ) const;

virtual void setRectOfInterest( const QRectF & );
QRectF rectOfInterest() const;

private:
size_t d_size;
QwtInterval d_interval;
QRectF d_rectOfInterest;
QwtInterval d_intervalOfInterest;
};

 QRectF qwtBoundingRect(
const QwtSeriesData<QPointF> &, int from = 0, int to = -1 );
 QRectF qwtBoundingRect(
const QwtSeriesData<QwtPoint3D> &, int from = 0, int to = -1 );
 QRectF qwtBoundingRect(
const QwtSeriesData<QwtPointPolar> &, int from = 0, int to = -1 );
 QRectF qwtBoundingRect(
const QwtSeriesData<QwtIntervalSample> &, int from = 0, int to = -1 );
 QRectF qwtBoundingRect(
const QwtSeriesData<QwtSetSample> &, int from = 0, int to = -1 );


# 16 "./../src/qwt_plot_seriesitem.h"


# 18 "./../src/qwt_plot_seriesitem.h"



class  QwtPlotAbstractSeriesItem: public QwtPlotItem
{
public:
explicit QwtPlotAbstractSeriesItem( const QString &title = QString::null );
explicit QwtPlotAbstractSeriesItem( const QwtText &title );

virtual ~QwtPlotAbstractSeriesItem();

void setOrientation( Qt::Orientation );
Qt::Orientation orientation() const;

virtual void draw( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF & ) const;












virtual void drawSeries( QPainter *painter,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const = 0;

private:
class PrivateData;
PrivateData *d_data;
};




template <typename T>
class QwtPlotSeriesItem: public QwtPlotAbstractSeriesItem
{
public:
explicit QwtPlotSeriesItem<T>( const QString &title = QString::null );
explicit QwtPlotSeriesItem<T>( const QwtText &title );

virtual ~QwtPlotSeriesItem<T>();

void setData( QwtSeriesData<T> * );

QwtSeriesData<T> *data();
const QwtSeriesData<T> *data() const;

size_t dataSize() const;
T sample( int index ) const;

virtual QRectF boundingRect() const;
virtual void updateScaleDiv( const QwtScaleDiv &,
const QwtScaleDiv & );

protected:

QwtSeriesData<T> *d_series;
};





template <typename T>
QwtPlotSeriesItem<T>::QwtPlotSeriesItem( const QString &title ):
QwtPlotAbstractSeriesItem( QwtText( title ) ),
d_series( 0 )
{
}





template <typename T>
QwtPlotSeriesItem<T>::QwtPlotSeriesItem( const QwtText &title ):
QwtPlotAbstractSeriesItem( title ),
d_series( 0 )
{
}


template <typename T>
QwtPlotSeriesItem<T>::~QwtPlotSeriesItem()
{
delete d_series;
}


template <typename T>
inline QwtSeriesData<T> *QwtPlotSeriesItem<T>::data()
{
return d_series;
}


template <typename T>
inline const QwtSeriesData<T> *QwtPlotSeriesItem<T>::data() const
{
return d_series;
}





template <typename T>
inline T QwtPlotSeriesItem<T>::sample( int index ) const
{
return d_series ? d_series->sample( index ) : T();
}








template <typename T>
void QwtPlotSeriesItem<T>::setData( QwtSeriesData<T> *data )
{
if ( d_series != data )
{
delete d_series;
d_series = data;
itemChanged();
}
}





template <typename T>
size_t QwtPlotSeriesItem<T>::dataSize() const
{
if ( d_series == 0 )
return 0;

return d_series->size();
}







template <typename T>
QRectF QwtPlotSeriesItem<T>::boundingRect() const
{
if ( d_series == 0 )
return QRectF( 1.0, 1.0, -2.0, -2.0 ); 

return d_series->boundingRect();
}









template <typename T>
void QwtPlotSeriesItem<T>::updateScaleDiv( 
const QwtScaleDiv &xScaleDiv, const QwtScaleDiv &yScaleDiv )
{
const QRectF rect = QRectF(
xScaleDiv.lowerBound(), yScaleDiv.lowerBound(),
xScaleDiv.range(), yScaleDiv.range() );

d_series->setRectOfInterest( rect );
}


# 14 "./../src/qwt_plot_curve.h"

# 1 "./../src/qwt_series_data.h"













































































































































































































































































































































# 15 "./../src/qwt_plot_curve.h"

# 1 "./../src/qwt_text.h"




























































































































































# 16 "./../src/qwt_plot_curve.h"

# 1 "/usr/share/qt4/include/QtGui/qpen.h"












































































































































# 17 "./../src/qwt_plot_curve.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 18 "./../src/qwt_plot_curve.h"


# 20 "./../src/qwt_plot_curve.h"
class QPainter;
class QPolygonF;
class QwtScaleMap;
class QwtSymbol;
class QwtCurveFitter;






























class  QwtPlotCurve: public QwtPlotSeriesItem<QPointF>
{
public:




enum CurveStyle
{



NoCurve = -1,






Lines,





Sticks,






Steps,







Dots,






UserCurve = 100
};





enum CurveAttribute
{




Inverted = 0x01,











Fitted = 0x02
};


typedef QFlags<CurveAttribute> CurveAttributes;








enum LegendAttribute
{




LegendNoAttribute = 0x00,





LegendShowLine = 0x01,




LegendShowSymbol = 0x02,





LegendShowBrush = 0x04
};


typedef QFlags<LegendAttribute> LegendAttributes;







enum PaintAttribute
{





ClipPolygons = 0x01,







CacheSymbols = 0x02
};


typedef QFlags<PaintAttribute> PaintAttributes;

explicit QwtPlotCurve( const QString &title = QString::null );
explicit QwtPlotCurve( const QwtText &title );

virtual ~QwtPlotCurve();

virtual int rtti() const;

void setPaintAttribute( PaintAttribute, bool on = true );
bool testPaintAttribute( PaintAttribute ) const;

void setLegendAttribute( LegendAttribute, bool on = true );
bool testLegendAttribute( LegendAttribute ) const;


# 210 "./../src/qwt_plot_curve.h"
void setRawSamples( const double *xData, const double *yData, int size );
void setSamples( const double *xData, const double *yData, int size );
void setSamples( const QVector<double> &xData, const QVector<double> &yData );

# 214 "./../src/qwt_plot_curve.h"
void setSamples( const QVector<QPointF> & );

int closestPoint( const QPoint &pos, double *dist = 0 ) const;

double minXValue() const;
double maxXValue() const;
double minYValue() const;
double maxYValue() const;

void setCurveAttribute( CurveAttribute, bool on = true );
bool testCurveAttribute( CurveAttribute ) const;

void setPen( const QPen & );
const QPen &pen() const;

void setBrush( const QBrush & );
const QBrush &brush() const;

void setBaseline( double ref );
double baseline() const;

void setStyle( CurveStyle style );
CurveStyle style() const;

void setSymbol( const QwtSymbol *s );
const QwtSymbol *symbol() const;

void setCurveFitter( QwtCurveFitter * );
QwtCurveFitter *curveFitter() const;

virtual void drawSeries( QPainter *,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

virtual void updateLegend( QwtLegend * ) const;
virtual void drawLegendIdentifier( QPainter *, const QRectF & ) const;

protected:

void init();

virtual void drawCurve( QPainter *p, int style,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

virtual void drawSymbols( QPainter *p, const QwtSymbol &,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

void drawLines( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

void drawSticks( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

void drawDots( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

void drawSteps( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

virtual void fillCurve( QPainter *,
const QwtScaleMap &, const QwtScaleMap &, 
const QRectF &canvasRect, QPolygonF & ) const;

void closePolyline( QPainter *,
const QwtScaleMap &, const QwtScaleMap &, QPolygonF & ) const;

private:
class PrivateData;
PrivateData *d_data;
};


inline double QwtPlotCurve::minXValue() const
{
return boundingRect().left();
}


inline double QwtPlotCurve::maxXValue() const
{
return boundingRect().right();
}


inline double QwtPlotCurve::minYValue() const
{
return boundingRect().top();
}


inline double QwtPlotCurve::maxYValue() const
{
return boundingRect().bottom();
}

inline QFlags<QwtPlotCurve::PaintAttributes ::enum_type> operator|(QwtPlotCurve::PaintAttributes ::enum_type f1, QwtPlotCurve::PaintAttributes ::enum_type f2) { return QFlags<QwtPlotCurve::PaintAttributes ::enum_type>(f1) | f2; } inline QFlags<QwtPlotCurve::PaintAttributes ::enum_type> operator|(QwtPlotCurve::PaintAttributes ::enum_type f1, QFlags<QwtPlotCurve::PaintAttributes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotCurve::PaintAttributes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<QwtPlotCurve::LegendAttributes ::enum_type> operator|(QwtPlotCurve::LegendAttributes ::enum_type f1, QwtPlotCurve::LegendAttributes ::enum_type f2) { return QFlags<QwtPlotCurve::LegendAttributes ::enum_type>(f1) | f2; } inline QFlags<QwtPlotCurve::LegendAttributes ::enum_type> operator|(QwtPlotCurve::LegendAttributes ::enum_type f1, QFlags<QwtPlotCurve::LegendAttributes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotCurve::LegendAttributes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
inline QFlags<QwtPlotCurve::CurveAttributes ::enum_type> operator|(QwtPlotCurve::CurveAttributes ::enum_type f1, QwtPlotCurve::CurveAttributes ::enum_type f2) { return QFlags<QwtPlotCurve::CurveAttributes ::enum_type>(f1) | f2; } inline QFlags<QwtPlotCurve::CurveAttributes ::enum_type> operator|(QwtPlotCurve::CurveAttributes ::enum_type f1, QFlags<QwtPlotCurve::CurveAttributes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotCurve::CurveAttributes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 47 "qwt.h"

# 1 "./../src/qwt_plot_dict.h"
















































# 48 "qwt.h"

# 1 "./../src/qwt_plot_directpainter.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_directpainter.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 14 "./../src/qwt_plot_directpainter.h"


# 16 "./../src/qwt_plot_directpainter.h"
class QRegion;
class QwtPlotAbstractSeriesItem;





















class  QwtPlotDirectPainter: public QObject
{
public:




enum Attribute
{






AtomicPainter = 0x01,





FullRepaint = 0x02,









CopyBackingStore = 0x04
};


typedef QFlags<Attribute> Attributes;

QwtPlotDirectPainter( QObject *parent = 0 );
virtual ~QwtPlotDirectPainter();

void setAttribute( Attribute, bool on );
bool testAttribute( Attribute ) const;

void setClipping( bool );
bool hasClipping() const;

void setClipRegion( const QRegion & );
QRegion clipRegion() const;

void drawSeries( QwtPlotAbstractSeriesItem *, int from, int to );
void reset();

virtual bool eventFilter( QObject *, QEvent * );

private:
class PrivateData;
PrivateData *d_data;
};

inline QFlags<QwtPlotDirectPainter::Attributes ::enum_type> operator|(QwtPlotDirectPainter::Attributes ::enum_type f1, QwtPlotDirectPainter::Attributes ::enum_type f2) { return QFlags<QwtPlotDirectPainter::Attributes ::enum_type>(f1) | f2; } inline QFlags<QwtPlotDirectPainter::Attributes ::enum_type> operator|(QwtPlotDirectPainter::Attributes ::enum_type f1, QFlags<QwtPlotDirectPainter::Attributes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotDirectPainter::Attributes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 49 "qwt.h"

# 1 "./../src/qwt_plot_grid.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_grid.h"

# 1 "./../src/qwt_plot_item.h"










































































































































# 14 "./../src/qwt_plot_grid.h"

# 1 "./../src/qwt_scale_div.h"













































































































# 15 "./../src/qwt_plot_grid.h"


# 17 "./../src/qwt_plot_grid.h"
class QPainter;
class QPen;
class QwtScaleMap;
class QwtScaleDiv;













class  QwtPlotGrid: public QwtPlotItem
{
public:
explicit QwtPlotGrid();
virtual ~QwtPlotGrid();

virtual int rtti() const;

void enableX( bool tf );
bool xEnabled() const;

void enableY( bool tf );
bool yEnabled() const;

void enableXMin( bool tf );
bool xMinEnabled() const;

void enableYMin( bool tf );
bool yMinEnabled() const;

void setXDiv( const QwtScaleDiv &sx );
const QwtScaleDiv &xScaleDiv() const;

void setYDiv( const QwtScaleDiv &sy );
const QwtScaleDiv &yScaleDiv() const;

void setPen( const QPen &p );

void setMajPen( const QPen &p );
const QPen& majPen() const;

void setMinPen( const QPen &p );
const QPen& minPen() const;

virtual void draw( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &rect ) const;

virtual void updateScaleDiv( 
const QwtScaleDiv &xMap, const QwtScaleDiv &yMap );

private:
void drawLines( QPainter *painter, const QRectF &,
Qt::Orientation orientation, const QwtScaleMap &,
const QList<double> & ) const;

class PrivateData;
PrivateData *d_data;
};


# 50 "qwt.h"

# 1 "./../src/qwt_plot_histogram.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_histogram.h"

# 1 "./../src/qwt_plot_seriesitem.h"































































































































































# 14 "./../src/qwt_plot_histogram.h"

# 1 "./../src/qwt_column_symbol.h"

















































































































































# 15 "./../src/qwt_plot_histogram.h"

# 1 "/usr/share/qt4/include/QtGui/qcolor.h"

















































































































































































































































































































# 16 "./../src/qwt_plot_histogram.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 17 "./../src/qwt_plot_histogram.h"


# 19 "./../src/qwt_plot_histogram.h"
class QwtIntervalData;
class QString;
class QPolygonF;















class  QwtPlotHistogram: public QwtPlotSeriesItem<QwtIntervalSample>
{
public:






enum HistogramStyle
{






Outline,






Columns,




Lines,






UserStyle = 100
};

explicit QwtPlotHistogram( const QString &title = QString::null );
explicit QwtPlotHistogram( const QwtText &title );
virtual ~QwtPlotHistogram();

virtual int rtti() const;

void setPen( const QPen & );
const QPen &pen() const;

void setBrush( const QBrush & );
const QBrush &brush() const;

void setSamples( const QVector<QwtIntervalSample> & );

void setBaseline( double reference );
double baseline() const;

void setStyle( HistogramStyle style );
HistogramStyle style() const;

void setSymbol( const QwtColumnSymbol * );
const QwtColumnSymbol *symbol() const;

virtual void drawSeries( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

virtual QRectF boundingRect() const;

virtual void drawLegendIdentifier( QPainter *, const QRectF & ) const;

protected:
virtual QwtColumnRect columnRect( const QwtIntervalSample &,
const QwtScaleMap &, const QwtScaleMap & ) const;

virtual void drawColumn( QPainter *, const QwtColumnRect &,
const QwtIntervalSample & ) const;

void drawColumns( QPainter *,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
int from, int to ) const;

void drawOutline( QPainter *,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
int from, int to ) const;

void drawLines( QPainter *,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
int from, int to ) const;

private:
void init();
void flushPolygon( QPainter *, double baseLine, QPolygonF & ) const;

class PrivateData;
PrivateData *d_data;
};


# 51 "qwt.h"

# 1 "./../src/qwt_plot_item.h"










































































































































# 52 "qwt.h"

# 1 "./../src/qwt_plot_intervalcurve.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_intervalcurve.h"

# 1 "./../src/qwt_plot_seriesitem.h"































































































































































# 14 "./../src/qwt_plot_intervalcurve.h"

# 1 "./../src/qwt_series_data.h"













































































































































































































































































































































# 15 "./../src/qwt_plot_intervalcurve.h"


# 17 "./../src/qwt_plot_intervalcurve.h"
class QwtIntervalSymbol;










class  QwtPlotIntervalCurve: public QwtPlotSeriesItem<QwtIntervalSample>
{
public:







enum CurveStyle
{



NoCurve,






Tube,






UserCurve = 100
};





enum PaintAttribute
{





ClipPolygons = 0x01,


ClipSymbol = 0x02
};


typedef QFlags<PaintAttribute> PaintAttributes;

explicit QwtPlotIntervalCurve( const QString &title = QString::null );
explicit QwtPlotIntervalCurve( const QwtText &title );

virtual ~QwtPlotIntervalCurve();

virtual int rtti() const;

void setPaintAttribute( PaintAttribute, bool on = true );
bool testPaintAttribute( PaintAttribute ) const;

void setSamples( const QVector<QwtIntervalSample> & );

void setPen( const QPen & );
const QPen &pen() const;

void setBrush( const QBrush & );
const QBrush &brush() const;

void setStyle( CurveStyle style );
CurveStyle style() const;

void setSymbol( const QwtIntervalSymbol * );
const QwtIntervalSymbol *symbol() const;

virtual void drawSeries( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

virtual QRectF boundingRect() const;
virtual void drawLegendIdentifier( QPainter *, const QRectF & ) const;

protected:

void init();

virtual void drawTube( QPainter *,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

virtual void drawSymbols( QPainter *, const QwtIntervalSymbol &,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

private:
class PrivateData;
PrivateData *d_data;
};

inline QFlags<QwtPlotIntervalCurve::PaintAttributes ::enum_type> operator|(QwtPlotIntervalCurve::PaintAttributes ::enum_type f1, QwtPlotIntervalCurve::PaintAttributes ::enum_type f2) { return QFlags<QwtPlotIntervalCurve::PaintAttributes ::enum_type>(f1) | f2; } inline QFlags<QwtPlotIntervalCurve::PaintAttributes ::enum_type> operator|(QwtPlotIntervalCurve::PaintAttributes ::enum_type f1, QFlags<QwtPlotIntervalCurve::PaintAttributes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotIntervalCurve::PaintAttributes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 53 "qwt.h"

# 1 "./../src/qwt_plot_layout.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_layout.h"

# 1 "./../src/qwt_plot.h"





























































































































































































































# 14 "./../src/qwt_plot_layout.h"


# 16 "./../src/qwt_plot_layout.h"








class  QwtPlotLayout
{
public:




enum Option
{

AlignScales = 0x01,





IgnoreScrollbars = 0x02,


IgnoreFrames = 0x04,


IgnoreLegend = 0x08
};


typedef QFlags<Option> Options;

explicit QwtPlotLayout();
virtual ~QwtPlotLayout();

void setCanvasMargin( int margin, int axis = -1 );
int canvasMargin( int axis ) const;

void setAlignCanvasToScales( bool );
bool alignCanvasToScales() const;

void setSpacing( int );
int spacing() const;

void setLegendPosition( QwtPlot::LegendPosition pos, double ratio );
void setLegendPosition( QwtPlot::LegendPosition pos );
QwtPlot::LegendPosition legendPosition() const;

void setLegendRatio( double ratio );
double legendRatio() const;

virtual QSize minimumSizeHint( const QwtPlot * ) const;

virtual void activate( const QwtPlot *,
const QRectF &rect, Options options = 0x00 );

virtual void invalidate();

const QRectF &titleRect() const;
const QRectF &legendRect() const;
const QRectF &scaleRect( int axis ) const;
const QRectF &canvasRect() const;

class LayoutData;

protected:

QRectF layoutLegend( Options options, const QRectF & ) const;
QRectF alignLegend( const QRectF &canvasRect,
const QRectF &legendRect ) const;

void expandLineBreaks( int options, const QRectF &rect,
int &dimTitle, int dimAxes[QwtPlot::axisCnt] ) const;

void alignScales( int options, QRectF &canvasRect,
QRectF scaleRect[QwtPlot::axisCnt] ) const;

private:
class PrivateData;

PrivateData *d_data;
};

inline QFlags<QwtPlotLayout::Options ::enum_type> operator|(QwtPlotLayout::Options ::enum_type f1, QwtPlotLayout::Options ::enum_type f2) { return QFlags<QwtPlotLayout::Options ::enum_type>(f1) | f2; } inline QFlags<QwtPlotLayout::Options ::enum_type> operator|(QwtPlotLayout::Options ::enum_type f1, QFlags<QwtPlotLayout::Options ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotLayout::Options ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 54 "qwt.h"

# 1 "./../src/qwt_plot_marker.h"












# 1 "/usr/share/qt4/include/QtGui/qpen.h"












































































































































# 13 "./../src/qwt_plot_marker.h"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 14 "./../src/qwt_plot_marker.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 15 "./../src/qwt_plot_marker.h"

# 1 "/usr/share/qt4/include/QtGui/qbrush.h"








































































































































































































































































































































# 16 "./../src/qwt_plot_marker.h"

# 1 "./../src/qwt_global.h"














































# 17 "./../src/qwt_plot_marker.h"

# 1 "./../src/qwt_plot_item.h"










































































































































# 18 "./../src/qwt_plot_marker.h"


# 20 "./../src/qwt_plot_marker.h"
class QRectF;
class QwtText;
class QwtSymbol;





















class  QwtPlotMarker: public QwtPlotItem
{
public:





enum LineStyle
{

NoLine,


HLine,


VLine,


Cross
};

explicit QwtPlotMarker();
virtual ~QwtPlotMarker();

virtual int rtti() const;

double xValue() const;
double yValue() const;
QPointF value() const;

void setXValue( double );
void setYValue( double );
void setValue( double, double );
void setValue( const QPointF & );

void setLineStyle( LineStyle st );
LineStyle lineStyle() const;

void setLinePen( const QPen &p );
const QPen &linePen() const;

void setSymbol( const QwtSymbol * );
const QwtSymbol *symbol() const;

void setLabel( const QwtText& );
QwtText label() const;

void setLabelAlignment( Qt::Alignment );
Qt::Alignment labelAlignment() const;

void setLabelOrientation( Qt::Orientation );
Qt::Orientation labelOrientation() const;

void setSpacing( int );
int spacing() const;

virtual void draw( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF & ) const;

virtual QRectF boundingRect() const;

virtual void updateLegend( QwtLegend * ) const;
virtual void drawLegendIdentifier( QPainter *, const QRectF & ) const;

protected:
virtual void drawLines( QPainter *, 
const QRectF &, const QPointF & ) const;

virtual void drawLabel( QPainter *, 
const QRectF &, const QPointF & ) const;

private:

class PrivateData;
PrivateData *d_data;
};


# 55 "qwt.h"

# 1 "./../src/qwt_plot_rasteritem.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_rasteritem.h"

# 1 "./../src/qwt_plot_item.h"










































































































































# 14 "./../src/qwt_plot_rasteritem.h"

# 1 "./../src/qwt_interval.h"



































































































































































































































# 15 "./../src/qwt_plot_rasteritem.h"

# 1 "/usr/share/qt4/include/QtCore/qglobal.h"

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 16 "./../src/qwt_plot_rasteritem.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 17 "./../src/qwt_plot_rasteritem.h"

# 1 "/usr/share/qt4/include/QtGui/qimage.h"









































































































































































































































































































































































# 18 "./../src/qwt_plot_rasteritem.h"


# 20 "./../src/qwt_plot_rasteritem.h"

















class  QwtPlotRasterItem: public QwtPlotItem
{
public:












enum CachePolicy
{
NoCache,
PaintCache
};





enum PaintAttribute
{












PaintInDeviceResolution = 1
};


typedef QFlags<PaintAttribute> PaintAttributes;

explicit QwtPlotRasterItem( const QString& title = QString::null );
explicit QwtPlotRasterItem( const QwtText& title );
virtual ~QwtPlotRasterItem();

void setPaintAttribute( PaintAttribute, bool on = true );
bool testPaintAttribute( PaintAttribute ) const;

void setAlpha( int alpha );
int alpha() const;

void setCachePolicy( CachePolicy );
CachePolicy cachePolicy() const;

void invalidateCache();

virtual void draw( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &rect ) const;

virtual QRectF pixelHint( const QRectF & ) const;

virtual QwtInterval interval(Qt::Axis) const;
virtual QRectF boundingRect() const;

protected:














virtual QImage renderImage( const QwtScaleMap &xMap,
const QwtScaleMap &yMap, const QRectF &area,
const QSize &imageSize ) const = 0;

virtual QwtScaleMap imageMap( Qt::Orientation,
const QwtScaleMap &map, const QRectF &area,
const QSize &imageSize, double pixelSize) const;

private:
QwtPlotRasterItem( const QwtPlotRasterItem & );
QwtPlotRasterItem &operator=( const QwtPlotRasterItem & );

void init();

QImage compose( const QwtScaleMap &, const QwtScaleMap &,
const QRectF &imageArea, const QRectF &paintRect,
const QSize &imageSize, bool doCache) const;


class PrivateData;
PrivateData *d_data;
};

inline QFlags<QwtPlotRasterItem::PaintAttributes ::enum_type> operator|(QwtPlotRasterItem::PaintAttributes ::enum_type f1, QwtPlotRasterItem::PaintAttributes ::enum_type f2) { return QFlags<QwtPlotRasterItem::PaintAttributes ::enum_type>(f1) | f2; } inline QFlags<QwtPlotRasterItem::PaintAttributes ::enum_type> operator|(QwtPlotRasterItem::PaintAttributes ::enum_type f1, QFlags<QwtPlotRasterItem::PaintAttributes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotRasterItem::PaintAttributes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 56 "qwt.h"

# 1 "./../src/qwt_plot_spectrogram.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_spectrogram.h"

# 1 "./../src/qwt_raster_data.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_raster_data.h"

# 1 "./../src/qwt_interval.h"



































































































































































































































# 14 "./../src/qwt_raster_data.h"

# 1 "/usr/share/qt4/include/QtCore/qmap.h"




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 15 "./../src/qwt_raster_data.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 16 "./../src/qwt_raster_data.h"

# 1 "/usr/share/qt4/include/QtGui/qpolygon.h"




















































































































































































# 17 "./../src/qwt_raster_data.h"


# 19 "./../src/qwt_raster_data.h"
class QwtScaleMap;












class  QwtRasterData
{
public:

typedef QMap<double, QPolygonF> ContourLines;


enum ConrecFlag
{

IgnoreAllVerticesOnLevel = 0x01,


IgnoreOutOfRange = 0x02
};


typedef QFlags<ConrecFlag> ConrecFlags;

QwtRasterData();
virtual ~QwtRasterData();

virtual void setInterval( Qt::Axis, const QwtInterval & );
const QwtInterval &interval(Qt::Axis) const;

virtual QRectF pixelHint( const QRectF & ) const;

virtual void initRaster( const QRectF &, const QSize& raster );
virtual void discardRaster();






virtual double value( double x, double y ) const = 0;

virtual ContourLines contourLines( const QRectF &rect,
const QSize &raster, const QList<double> &levels,
ConrecFlags ) const;

class Contour3DPoint;
class ContourPlane;

private:

QwtRasterData( const QwtRasterData & );
QwtRasterData &operator=( const QwtRasterData & );

QwtInterval d_intervals[3];
};





inline const QwtInterval &QwtRasterData::interval( Qt::Axis axis) const
{
return d_intervals[axis];
}

inline QFlags<QwtRasterData::ConrecFlags ::enum_type> operator|(QwtRasterData::ConrecFlags ::enum_type f1, QwtRasterData::ConrecFlags ::enum_type f2) { return QFlags<QwtRasterData::ConrecFlags ::enum_type>(f1) | f2; } inline QFlags<QwtRasterData::ConrecFlags ::enum_type> operator|(QwtRasterData::ConrecFlags ::enum_type f1, QFlags<QwtRasterData::ConrecFlags ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtRasterData::ConrecFlags ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 14 "./../src/qwt_plot_spectrogram.h"

# 1 "./../src/qwt_plot_rasteritem.h"






























































































# 15 "./../src/qwt_plot_spectrogram.h"

# 1 "/usr/share/qt4/include/QtCore/qlist.h"
















































































































































































































































































































































































































































































































































































































































































































































































































# 16 "./../src/qwt_plot_spectrogram.h"


# 18 "./../src/qwt_plot_spectrogram.h"
class QwtColorMap;















class  QwtPlotSpectrogram: public QwtPlotRasterItem
{
public:





enum DisplayMode
{

ImageMode = 0x01,


ContourMode = 0x02
};


typedef QFlags<DisplayMode> DisplayModes;

explicit QwtPlotSpectrogram( const QString &title = QString::null );
virtual ~QwtPlotSpectrogram();

void setRenderThreadCount( uint numThreads );
uint renderThreadCount() const;

void setDisplayMode( DisplayMode, bool on = true );
bool testDisplayMode( DisplayMode ) const;

void setData( QwtRasterData *data );
const QwtRasterData *data() const;
QwtRasterData *data();

void setColorMap( QwtColorMap * );
const QwtColorMap *colorMap() const;

virtual QwtInterval interval(Qt::Axis) const;
virtual QRectF pixelHint( const QRectF & ) const;

void setDefaultContourPen( const QPen & );
QPen defaultContourPen() const;

virtual QPen contourPen( double level ) const;

void setConrecFlag( QwtRasterData::ConrecFlag, bool on );
bool testConrecFlag( QwtRasterData::ConrecFlag ) const;

void setContourLevels( const QList<double> & );
QList<double> contourLevels() const;

virtual int rtti() const;

virtual void draw( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &rect ) const;

protected:
virtual QImage renderImage(
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &area, const QSize &imageSize ) const;

virtual QSize contourRasterSize(
const QRectF &, const QRect & ) const;

virtual QwtRasterData::ContourLines renderContourLines(
const QRectF &rect, const QSize &raster ) const;

virtual void drawContourLines( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QwtRasterData::ContourLines& lines ) const;

void renderTile( const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRect &imageRect, QImage *image ) const;

private:
class PrivateData;
PrivateData *d_data;
};

inline QFlags<QwtPlotSpectrogram::DisplayModes ::enum_type> operator|(QwtPlotSpectrogram::DisplayModes ::enum_type f1, QwtPlotSpectrogram::DisplayModes ::enum_type f2) { return QFlags<QwtPlotSpectrogram::DisplayModes ::enum_type>(f1) | f2; } inline QFlags<QwtPlotSpectrogram::DisplayModes ::enum_type> operator|(QwtPlotSpectrogram::DisplayModes ::enum_type f1, QFlags<QwtPlotSpectrogram::DisplayModes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotSpectrogram::DisplayModes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 57 "qwt.h"

# 1 "./../src/qwt_plot_spectrocurve.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_spectrocurve.h"

# 1 "./../src/qwt_plot_seriesitem.h"































































































































































# 14 "./../src/qwt_plot_spectrocurve.h"

# 1 "./../src/qwt_series_data.h"













































































































































































































































































































































# 15 "./../src/qwt_plot_spectrocurve.h"


# 17 "./../src/qwt_plot_spectrocurve.h"
class QwtSymbol;
class QwtColorMap;





class  QwtPlotSpectroCurve: public QwtPlotSeriesItem<QwtPoint3D>
{
public:

enum PaintAttribute
{

ClipPoints = 1
};


typedef QFlags<PaintAttribute> PaintAttributes;

explicit QwtPlotSpectroCurve( const QString &title = QString::null );
explicit QwtPlotSpectroCurve( const QwtText &title );

virtual ~QwtPlotSpectroCurve();

virtual int rtti() const;

void setPaintAttribute( PaintAttribute, bool on = true );
bool testPaintAttribute( PaintAttribute ) const;

void setSamples( const QVector<QwtPoint3D> & );

void setColorMap( QwtColorMap * );
const QwtColorMap *colorMap() const;

void setColorRange( const QwtInterval & );
QwtInterval & colorRange() const;

virtual void drawSeries( QPainter *,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

void setPenWidth(double width);
double penWidth() const;

protected:
virtual void drawDots( QPainter *,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &canvasRect, int from, int to ) const;

private:
void init();

class PrivateData;
PrivateData *d_data;
};

inline QFlags<QwtPlotSpectroCurve::PaintAttributes ::enum_type> operator|(QwtPlotSpectroCurve::PaintAttributes ::enum_type f1, QwtPlotSpectroCurve::PaintAttributes ::enum_type f2) { return QFlags<QwtPlotSpectroCurve::PaintAttributes ::enum_type>(f1) | f2; } inline QFlags<QwtPlotSpectroCurve::PaintAttributes ::enum_type> operator|(QwtPlotSpectroCurve::PaintAttributes ::enum_type f1, QFlags<QwtPlotSpectroCurve::PaintAttributes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotSpectroCurve::PaintAttributes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 58 "qwt.h"

# 1 "./../src/qwt_plot_scaleitem.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_scaleitem.h"

# 1 "./../src/qwt_plot_item.h"










































































































































# 14 "./../src/qwt_plot_scaleitem.h"

# 1 "./../src/qwt_scale_draw.h"




































































































# 15 "./../src/qwt_plot_scaleitem.h"


# 17 "./../src/qwt_plot_scaleitem.h"
class QPalette;





























class  QwtPlotScaleItem: public QwtPlotItem
{
public:
explicit QwtPlotScaleItem(
QwtScaleDraw::Alignment = QwtScaleDraw::BottomScale,
const double pos = 0.0 );

virtual ~QwtPlotScaleItem();

virtual int rtti() const;

void setScaleDiv( const QwtScaleDiv& );
const QwtScaleDiv& scaleDiv() const;

void setScaleDivFromAxis( bool on );
bool isScaleDivFromAxis() const;

void setPalette( const QPalette & );
QPalette palette() const;

void setFont( const QFont& );
QFont font() const;

void setScaleDraw( QwtScaleDraw * );

const QwtScaleDraw *scaleDraw() const;
QwtScaleDraw *scaleDraw();

void setPosition( double pos );
double position() const;

void setBorderDistance( int numPixels );
int borderDistance() const;

void setAlignment( QwtScaleDraw::Alignment );

virtual void draw( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &rect ) const;

virtual void updateScaleDiv( const QwtScaleDiv &, const QwtScaleDiv & );

private:
class PrivateData;
PrivateData *d_data;
};


# 59 "qwt.h"

# 1 "./../src/qwt_plot_seriesitem.h"































































































































































# 60 "qwt.h"

# 1 "./../src/qwt_plot_canvas.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_canvas.h"

# 1 "/usr/share/qt4/include/QtGui/qframe.h"




















































































































































# 14 "./../src/qwt_plot_canvas.h"

# 1 "/usr/share/qt4/include/QtGui/qpen.h"












































































































































# 15 "./../src/qwt_plot_canvas.h"

# 1 "/usr/share/qt4/include/QtGui/qpainterpath.h"












































































































































































































































































































































































































































# 16 "./../src/qwt_plot_canvas.h"

# 1 "/usr/share/qt4/include/QtGui/qbitmap.h"












































































































# 17 "./../src/qwt_plot_canvas.h"


# 19 "./../src/qwt_plot_canvas.h"
class QwtPlot;
class QPixmap;





class  QwtPlotCanvas : public QFrame
{
Q_OBJECT

public:








enum PaintAttribute
{











BackingStore = 1,
















Opaque = 2,
















HackStyledBackground = 4,







ImmediatePaint = 8
};


typedef QFlags<PaintAttribute> PaintAttributes;



















enum FocusIndicator
{
NoFocusIndicator,
CanvasFocusIndicator,
ItemFocusIndicator
};

explicit QwtPlotCanvas( QwtPlot * );
virtual ~QwtPlotCanvas();

QwtPlot *plot();
const QwtPlot *plot() const;

void setFocusIndicator( FocusIndicator );
FocusIndicator focusIndicator() const;

void setBorderRadius( double );
double borderRadius() const;

QPainterPath borderPath( const QRect &rect ) const;
QBitmap borderMask( const QSize & ) const;

void setPaintAttribute( PaintAttribute, bool on = true );
bool testPaintAttribute( PaintAttribute ) const;

const QPixmap *backingStore() const;
void invalidateBackingStore();

void replot();

virtual bool event( QEvent * );

protected:
virtual void paintEvent( QPaintEvent * );
virtual void resizeEvent( QResizeEvent * );

virtual void drawFocusIndicator( QPainter * );
virtual void drawBorder( QPainter * );

void updateStyleSheetInfo();

private:
void drawCanvas( QPainter *, bool withBackground );

class PrivateData;
PrivateData *d_data;
};

inline QFlags<QwtPlotCanvas::PaintAttributes ::enum_type> operator|(QwtPlotCanvas::PaintAttributes ::enum_type f1, QwtPlotCanvas::PaintAttributes ::enum_type f2) { return QFlags<QwtPlotCanvas::PaintAttributes ::enum_type>(f1) | f2; } inline QFlags<QwtPlotCanvas::PaintAttributes ::enum_type> operator|(QwtPlotCanvas::PaintAttributes ::enum_type f1, QFlags<QwtPlotCanvas::PaintAttributes ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtPlotCanvas::PaintAttributes ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 61 "qwt.h"

# 1 "./../src/qwt_plot_panner.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_panner.h"

# 1 "./../src/qwt_panner.h"










































































# 14 "./../src/qwt_plot_panner.h"


# 16 "./../src/qwt_plot_panner.h"
class QwtPlotCanvas;
class QwtPlot;














class  QwtPlotPanner: public QwtPanner
{
Q_OBJECT

public:
explicit QwtPlotPanner( QwtPlotCanvas * );
virtual ~QwtPlotPanner();

QwtPlotCanvas *canvas();
const QwtPlotCanvas *canvas() const;

QwtPlot *plot();
const QwtPlot *plot() const;

void setAxisEnabled( int axis, bool on );
bool isAxisEnabled( int axis ) const;

protected slots:
virtual void moveCanvas( int dx, int dy );

protected:
virtual QBitmap contentsMask() const;

private:
class PrivateData;
PrivateData *d_data;
};


# 62 "qwt.h"

# 1 "./../src/qwt_plot_picker.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_picker.h"

# 1 "./../src/qwt_plot_canvas.h"




































































































# 14 "./../src/qwt_plot_picker.h"

# 1 "./../src/qwt_picker.h"





















































































































































































































# 15 "./../src/qwt_plot_picker.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 16 "./../src/qwt_plot_picker.h"


# 18 "./../src/qwt_plot_picker.h"
class QwtPlot;









class  QwtPlotPicker: public QwtPicker
{
Q_OBJECT

public:
explicit QwtPlotPicker( QwtPlotCanvas * );
virtual ~QwtPlotPicker();

explicit QwtPlotPicker( int xAxis, int yAxis, QwtPlotCanvas * );

explicit QwtPlotPicker( int xAxis, int yAxis,
RubberBand rubberBand, DisplayMode trackerMode,
QwtPlotCanvas * );

virtual void setAxis( int xAxis, int yAxis );

int xAxis() const;
int yAxis() const;

QwtPlot *plot();
const QwtPlot *plot() const;

QwtPlotCanvas *canvas();
const QwtPlotCanvas *canvas() const;

signals:





void selected( const QPointF &pos );





void selected( const QRectF &rect );







void selected( const QVector<QPointF> &pa );







void appended( const QPointF &pos );








void moved( const QPointF &pos );

protected:
QRectF scaleRect() const;

QRectF invTransform( const QRect & ) const;
QRect transform( const QRectF & ) const;

QPointF invTransform( const QPoint & ) const;
QPoint transform( const QPointF & ) const;

virtual QwtText trackerText( const QPoint & ) const;
virtual QwtText trackerTextF( const QPointF & ) const;

virtual void move( const QPoint & );
virtual void append( const QPoint & );
virtual bool end( bool ok = true );

private:
int d_xAxis;
int d_yAxis;
};


# 63 "qwt.h"

# 1 "./../src/qwt_plot_zoomer.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_zoomer.h"

# 1 "./../src/qwt_plot_picker.h"





















































































# 14 "./../src/qwt_plot_zoomer.h"

# 1 "/usr/share/qt4/include/QtCore/qstack.h"


















































































# 15 "./../src/qwt_plot_zoomer.h"


# 17 "./../src/qwt_plot_zoomer.h"
























class  QwtPlotZoomer: public QwtPlotPicker
{
Q_OBJECT
public:
explicit QwtPlotZoomer( QwtPlotCanvas *, bool doReplot = true );
explicit QwtPlotZoomer( int xAxis, int yAxis,
QwtPlotCanvas *, bool doReplot = true );

virtual ~QwtPlotZoomer();

virtual void setZoomBase( bool doReplot = true );
virtual void setZoomBase( const QRectF & );

QRectF zoomBase() const;
QRectF zoomRect() const;

virtual void setAxis( int xAxis, int yAxis );

void setMaxStackDepth( int );
int maxStackDepth() const;

const QStack<QRectF> &zoomStack() const;
void setZoomStack( const QStack<QRectF> &,
int zoomRectIndex = -1 );

uint zoomRectIndex() const;

public slots:
void moveBy( double x, double y );
virtual void moveTo( const QPointF & );

virtual void zoom( const QRectF & );
virtual void zoom( int up );

signals:







void zoomed( const QRectF &rect );

protected:
virtual void rescale();

virtual QSizeF minZoomSize() const;

virtual void widgetMouseReleaseEvent( QMouseEvent * );
virtual void widgetKeyPressEvent( QKeyEvent * );

virtual void begin();
virtual bool end( bool ok = true );
virtual bool accept( QPolygon & ) const;

private:
void init( bool doReplot );

class PrivateData;
PrivateData *d_data;
};


# 64 "qwt.h"

# 1 "./../src/qwt_plot_magnifier.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_magnifier.h"

# 1 "./../src/qwt_magnifier.h"














































































# 14 "./../src/qwt_plot_magnifier.h"


# 16 "./../src/qwt_plot_magnifier.h"
class QwtPlotCanvas;
class QwtPlot;












class  QwtPlotMagnifier: public QwtMagnifier
{
Q_OBJECT

public:
explicit QwtPlotMagnifier( QwtPlotCanvas * );
virtual ~QwtPlotMagnifier();

void setAxisEnabled( int axis, bool on );
bool isAxisEnabled( int axis ) const;

QwtPlotCanvas *canvas();
const QwtPlotCanvas *canvas() const;

QwtPlot *plot();
const QwtPlot *plot() const;

protected:
virtual void rescale( double factor );

private:
class PrivateData;
PrivateData *d_data;
};


# 65 "qwt.h"

# 1 "./../src/qwt_plot_rescaler.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_rescaler.h"

# 1 "./../src/qwt_interval.h"



































































































































































































































# 14 "./../src/qwt_plot_rescaler.h"

# 1 "./../src/qwt_plot.h"





























































































































































































































# 15 "./../src/qwt_plot_rescaler.h"

# 1 "/usr/share/qt4/include/QtCore/qobject.h"





































































































































































































































































































































































































































































































# 16 "./../src/qwt_plot_rescaler.h"


# 18 "./../src/qwt_plot_rescaler.h"
class QwtPlotCanvas;
class QwtPlot;
class QResizeEvent;








class  QwtPlotRescaler: public QObject
{
public:






enum RescalePolicy
{





Fixed,









Expanding,





Fitting
};





enum ExpandingDirection
{

ExpandUp,


ExpandDown,


ExpandBoth
};

explicit QwtPlotRescaler( QwtPlotCanvas *,
int referenceAxis = QwtPlot::xBottom,
RescalePolicy = Expanding );

virtual ~QwtPlotRescaler();

void setEnabled( bool );
bool isEnabled() const;

void setRescalePolicy( RescalePolicy );
RescalePolicy rescalePolicy() const;

void setExpandingDirection( ExpandingDirection );
void setExpandingDirection( int axis, ExpandingDirection );
ExpandingDirection expandingDirection( int axis ) const;

void setReferenceAxis( int axis );
int referenceAxis() const;

void setAspectRatio( double ratio );
void setAspectRatio( int axis, double ratio );
double aspectRatio( int axis ) const;

void setIntervalHint( int axis, const QwtInterval& );
QwtInterval intervalHint( int axis ) const;

QwtPlotCanvas *canvas();
const QwtPlotCanvas *canvas() const;

QwtPlot *plot();
const QwtPlot *plot() const;

virtual bool eventFilter( QObject *, QEvent * );

void rescale() const;

protected:
virtual void canvasResizeEvent( QResizeEvent * );

virtual void rescale( const QSize &oldSize, const QSize &newSize ) const;
virtual QwtInterval expandScale( 
int axis, const QSize &oldSize, const QSize &newSize ) const;

virtual QwtInterval syncScale(
int axis, const QwtInterval& reference,
const QSize &size ) const;

virtual void updateScales(
QwtInterval intervals[QwtPlot::axisCnt] ) const;

Qt::Orientation orientation( int axis ) const;
QwtInterval interval( int axis ) const;
QwtInterval expandInterval( const QwtInterval &,
double width, ExpandingDirection ) const;

private:
double pixelDist( int axis, const QSize & ) const;

class AxisData;
class PrivateData;
PrivateData *d_data;
};


# 66 "qwt.h"

# 1 "./../src/qwt_raster_data.h"














































































# 67 "qwt.h"

# 1 "./../src/qwt_matrix_raster_data.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_matrix_raster_data.h"

# 1 "./../src/qwt_raster_data.h"














































































# 14 "./../src/qwt_matrix_raster_data.h"

# 1 "/usr/share/qt4/include/QtCore/qvector.h"



























































































































































































































































































































































































































































































































































































































































































































































































































# 15 "./../src/qwt_matrix_raster_data.h"


# 17 "./../src/qwt_matrix_raster_data.h"








class  QwtMatrixRasterData: public QwtRasterData
{
public:




enum ResampleMode
{




NearestNeighbour,





BilinearInterpolation
};

QwtMatrixRasterData();
virtual ~QwtMatrixRasterData();

void setResampleMode(ResampleMode mode);
ResampleMode resampleMode() const;

virtual void setInterval( Qt::Axis, const QwtInterval & );
void setValueMatrix( const QVector<double> &values, size_t numColumns );

const QVector<double> valueMatrix() const;
size_t numColumns() const;
size_t numRows() const;

virtual QRectF pixelHint( const QRectF & ) const;

virtual double value( double x, double y ) const;

private:
void update();

class PrivateData;
PrivateData *d_data;
};


# 68 "qwt.h"




# 1 "./../src/qwt_global.h"














































# 4 "./../src/qwt_sampling_thread.h"

# 1 "/usr/share/qt4/include/QtCore/qthread.h"






































































































































































# 5 "./../src/qwt_sampling_thread.h"


# 7 "./../src/qwt_sampling_thread.h"












class  QwtSamplingThread: public QThread
{
Q_OBJECT

public:
virtual ~QwtSamplingThread();

double interval() const;
double elapsed() const;

public slots:
void setInterval( double interval );
void stop();

protected:
explicit QwtSamplingThread( QObject *parent = 0 );

virtual void run();






virtual void sample( double elapsed ) = 0;

private:
class PrivateData;
PrivateData *d_data;
};


# 69 "qwt.h"

# 1 "./../src/qwt_series_data.h"













































































































































































































































































































































# 70 "qwt.h"

# 1 "./../src/qwt_scale_widget.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_scale_widget.h"

# 1 "./../src/qwt_text.h"




























































































































































# 14 "./../src/qwt_scale_widget.h"

# 1 "./../src/qwt_scale_draw.h"




































































































# 15 "./../src/qwt_scale_widget.h"

# 1 "/usr/share/qt4/include/QtGui/qwidget.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 16 "./../src/qwt_scale_widget.h"

# 1 "/usr/share/qt4/include/QtGui/qfont.h"




































































































































































































































































































































































# 17 "./../src/qwt_scale_widget.h"

# 1 "/usr/share/qt4/include/QtGui/qcolor.h"

















































































































































































































































































































# 18 "./../src/qwt_scale_widget.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 19 "./../src/qwt_scale_widget.h"


# 21 "./../src/qwt_scale_widget.h"
class QPainter;
class QwtScaleTransformation;
class QwtScaleDiv;
class QwtColorMap;








class  QwtScaleWidget : public QWidget
{
Q_OBJECT

public:

enum LayoutFlag
{




TitleInverted = 1
};


typedef QFlags<LayoutFlag> LayoutFlags;

explicit QwtScaleWidget( QWidget *parent = 0 );
explicit QwtScaleWidget( QwtScaleDraw::Alignment, QWidget *parent = 0 );
virtual ~QwtScaleWidget();

signals:

void scaleDivChanged();

public:
void setTitle( const QString &title );
void setTitle( const QwtText &title );
QwtText title() const;

void setLayoutFlag( LayoutFlag, bool on );
bool testLayoutFlag( LayoutFlag ) const;

void setBorderDist( int start, int end );
int startBorderDist() const;
int endBorderDist() const;

void getBorderDistHint( int &start, int &end ) const;

void getMinBorderDist( int &start, int &end ) const;
void setMinBorderDist( int start, int end );

void setMargin( int );
int margin() const;

void setSpacing( int td );
int spacing() const;

void setScaleDiv( QwtScaleTransformation *, const QwtScaleDiv &sd );

void setScaleDraw( QwtScaleDraw * );
const QwtScaleDraw *scaleDraw() const;
QwtScaleDraw *scaleDraw();

void setLabelAlignment( Qt::Alignment );
void setLabelRotation( double rotation );

void setColorBarEnabled( bool );
bool isColorBarEnabled() const;

void setColorBarWidth( int );
int colorBarWidth() const;

void setColorMap( const QwtInterval &, QwtColorMap * );

QwtInterval colorBarInterval() const;
const QwtColorMap *colorMap() const;

virtual QSize sizeHint() const;
virtual QSize minimumSizeHint() const;

int titleHeightForWidth( int width ) const;
int dimForLength( int length, const QFont &scaleFont ) const;

void drawColorBar( QPainter *painter, const QRectF & ) const;
void drawTitle( QPainter *painter, QwtScaleDraw::Alignment,
const QRectF &rect ) const;

void setAlignment( QwtScaleDraw::Alignment );
QwtScaleDraw::Alignment alignment() const;

QRectF colorBarRect( const QRectF& ) const;

protected:
virtual void paintEvent( QPaintEvent * );
virtual void resizeEvent( QResizeEvent * );

void draw( QPainter *p ) const;

void scaleChange();
void layoutScale( bool update = true );

private:
void initScale( QwtScaleDraw::Alignment );

class PrivateData;
PrivateData *d_data;
};

inline QFlags<QwtScaleWidget::LayoutFlags ::enum_type> operator|(QwtScaleWidget::LayoutFlags ::enum_type f1, QwtScaleWidget::LayoutFlags ::enum_type f2) { return QFlags<QwtScaleWidget::LayoutFlags ::enum_type>(f1) | f2; } inline QFlags<QwtScaleWidget::LayoutFlags ::enum_type> operator|(QwtScaleWidget::LayoutFlags ::enum_type f1, QFlags<QwtScaleWidget::LayoutFlags ::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QwtScaleWidget::LayoutFlags ::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


# 71 "qwt.h"



# 1 "./../src/qwt_plot_svgitem.h"












# 1 "./../src/qwt_global.h"














































# 13 "./../src/qwt_plot_svgitem.h"

# 1 "./../src/qwt_plot_item.h"










































































































































# 14 "./../src/qwt_plot_svgitem.h"

# 1 "/usr/share/qt4/include/QtCore/qstring.h"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 15 "./../src/qwt_plot_svgitem.h"


# 17 "./../src/qwt_plot_svgitem.h"
class QSvgRenderer;
class QByteArray;








class  QwtPlotSvgItem: public QwtPlotItem
{
public:
explicit QwtPlotSvgItem( const QString& title = QString::null );
explicit QwtPlotSvgItem( const QwtText& title );
virtual ~QwtPlotSvgItem();

bool loadFile( const QRectF&, const QString &fileName );
bool loadData( const QRectF&, const QByteArray & );

virtual QRectF boundingRect() const;

virtual void draw( QPainter *p,
const QwtScaleMap &xMap, const QwtScaleMap &yMap,
const QRectF &rect ) const;

virtual int rtti() const;

protected:
const QSvgRenderer &renderer() const;
QSvgRenderer &renderer();

void render( QPainter *painter,
const QRectF &viewBox, const QRectF &rect ) const;

QRectF viewBox( const QRectF &area ) const;

private:
void init();

class PrivateData;
PrivateData *d_data;
};


# 74 "qwt.h"


# 76 "qwt.h"

















typedef QwtPlotSeriesItem<JObjectWrapper> QwtPlotSeriesItemGeneric;
typedef QwtSeriesData<JObjectWrapper> QwtSeriesDataGeneric;
typedef QwtArraySeriesData<JObjectWrapper> QwtArraySeriesDataGeneric;